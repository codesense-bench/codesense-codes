{"Programming Language": "C", "Source Code": "static void decStatus(decNumber *dn, uInt status, decContext *set) {\n  if (status & DEC_NaNs) {              \n    \n    if (status & DEC_sNaN) status&=~DEC_sNaN;\n     else {\n      decNumberZero(dn);                \n      dn->bits=DECNAN;                  \n      }\n    }\n  decContextSetStatus(set, status);     \n  return;\n  }", "Selected Statement": "      decNumberZero(dn);                // other error: clean throughout\n", "Selected Pointer": "dn", "Compared Statement": "  decContextSetStatus(set, status);     // [may not return]\n", "Compared Pointer": "set", "Aliasing": "No", "Function Input": {"dn": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdb88", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"digits": {"type_category": "unknown", "concrete_type": "int32_t", "value": "1"}, "exponent": {"type_category": "unknown", "concrete_type": "int32_t", "value": "0"}, "bits": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "32 ' '"}, "lsu": {"type_category": "array", "concrete_type": "uint16_t", "value": [{"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}]}}}}, "set": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdb78", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"digits": {"type_category": "unknown", "concrete_type": "int32_t", "value": "6712937"}, "emax": {"type_category": "unknown", "concrete_type": "int32_t", "value": "1701996660"}, "emin": {"type_category": "unknown", "concrete_type": "int32_t", "value": "976905313"}, "round": {"type_category": "unknown", "concrete_type": "rounding", "value": "1635018084"}, "traps": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "1713399907"}, "status": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "1701603681"}, "clamp": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "100 'd'"}}}}, "status": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}, "Program Information": {"Project Name": "tarantool"}}
{"Programming Language": "C", "Source Code": "int\nhttp_parse_header_line(struct http_parser *prsr, const char **bufp,\n\t\t       const char *end_buf, int max_hname_len)\n{\n\tchar c;\n\tunsigned char ch;\n\tconst char *p = *bufp;\n\tconst char *header_name_start = p;\n\tprsr->hdr_name_idx = 0;\n\n\tenum {\n\t\tsw_start = 0,\n\t\tskip_status_line,\n\t\tskipped_status_line_almost_done,\n\t\tsw_name,\n\t\tsw_space_before_value,\n\t\tsw_value,\n\t\tsw_space_after_value,\n\t\tsw_almost_done,\n\t\tsw_header_almost_done\n\t} state = sw_start;\n\n\t\n\tstatic char lowcase[] =\n\t\t\t\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"\n\t\t\t\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0-\\0\\0\" \"0123456789\"\n\t\t\t\"\\0\\0\\0\\0\\0\\0\\0abcdefghijklmnopqrstuvwxyz\\0\\0\\0\\0_\\0\"\n\t\t\t\"abcdefghijklmnopqrstuvwxyz\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"\n\t\t\t\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"\n\t\t\t\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"\n\t\t\t\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"\n\t\t\t\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"\n\t\t\t\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n\n\tfor (; p < end_buf; p++) {\n\t\tch = *p;\n\t\tswitch (state) {\n\t\t\n\t\tcase sw_start:\n\t\t\tswitch (ch) {\n\t\t\tcase CR:\n\t\t\t\tprsr->hdr_value_end = p;\n\t\t\t\tstate = sw_header_almost_done;\n\t\t\t\tbreak;\n\t\t\tcase LF:\n\t\t\t\tprsr->hdr_value_end = p;\n\t\t\t\tgoto header_done;\n\t\t\tdefault:\n\t\t\t\tstate = sw_name;\n\t\t\t\tc = lowcase[ch];\n\t\t\t\tif (c != 0) {\n\t\t\t\t\tprsr->hdr_name[0] = c;\n\t\t\t\t\tprsr->hdr_name_idx = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (ch == '\\0') {\n\t\t\t\t\treturn HTTP_PARSE_INVALID;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase skip_status_line:\n\t\t\tswitch (ch) {\n\t\t\tcase LF:\n\t\t\t\tgoto skipped_status;\n\t\t\tcase CR:\n\t\t\t\tstate = skipped_status_line_almost_done;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase skipped_status_line_almost_done:\n\t\t\tswitch (ch) {\n\t\t\tcase LF:\n\t\t\t\tgoto skipped_status;\n\t\t\tcase CR:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn HTTP_PARSE_INVALID;\n\t\t\t}\n\t\t\tbreak;\n\t\t\n\t\tcase sw_name:\n\t\t\tc = lowcase[ch];\n\t\t\tif (c != 0) {\n\t\t\t\tif (prsr->hdr_name_idx < max_hname_len) {\n\t\t\t\t\tprsr->hdr_name[prsr->hdr_name_idx] = c;\n\t\t\t\t\tprsr->hdr_name_idx++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ch == ':') {\n\t\t\t\tstate = sw_space_before_value;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ch == CR) {\n\t\t\t\tprsr->hdr_value_start = p;\n\t\t\t\tprsr->hdr_value_end = p;\n\t\t\t\tstate = sw_almost_done;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ch == LF) {\n\t\t\t\tprsr->hdr_value_start = p;\n\t\t\t\tprsr->hdr_value_end = p;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\t\n\t\t\tif (ch == '/' && p - header_name_start == 4 &&\n\t\t\t\tstrncmp(header_name_start, \"HTTP\", 4) == 0) {\n\t\t\t\tint rc = http_parse_status_line(prsr,\n\t\t\t\t\t\t\t&header_name_start,\n\t\t\t\t\t\t\tend_buf);\n\t\t\t\tif (rc == HTTP_PARSE_INVALID) {\n\t\t\t\t\tprsr->http_minor = -1;\n\t\t\t\t\tprsr->http_major = -1;\n\t\t\t\t\tstate = sw_start;\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tstate = skip_status_line;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ch == '\\0')\n\t\t\t\treturn HTTP_PARSE_INVALID;\n\t\t\tbreak;\n\t\t\n\t\tcase sw_space_before_value:\n\t\t\tswitch (ch) {\n\t\t\tcase ' ':\n\t\t\t\tbreak;\n\t\t\tcase CR:\n\t\t\t\tprsr->hdr_value_start = p;\n\t\t\t\tprsr->hdr_value_end = p;\n\t\t\t\tstate = sw_almost_done;\n\t\t\t\tbreak;\n\t\t\tcase LF:\n\t\t\t\tprsr->hdr_value_start = p;\n\t\t\t\tprsr->hdr_value_end = p;\n\t\t\t\tgoto done;\n\t\t\tcase '\\0':\n\t\t\t\treturn HTTP_PARSE_INVALID;\n\t\t\tdefault:\n\t\t\t\tprsr->hdr_value_start = p;\n\t\t\t\tstate = sw_value;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\n\t\tcase sw_value:\n\t\t\tswitch (ch) {\n\t\t\tcase ' ':\n\t\t\t\tprsr->hdr_value_end = p;\n\t\t\t\tstate = sw_space_after_value;\n\t\t\t\tbreak;\n\t\t\tcase CR:\n\t\t\t\tprsr->hdr_value_end = p;\n\t\t\t\tstate = sw_almost_done;\n\t\t\t\tbreak;\n\t\t\tcase LF:\n\t\t\t\tprsr->hdr_value_end = p;\n\t\t\t\tgoto done;\n\t\t\tcase '\\0':\n\t\t\t\treturn HTTP_PARSE_INVALID;\n\t\t\t}\n\t\t\tbreak;\n\t\t\n\t\tcase sw_space_after_value:\n\t\t\tswitch (ch) {\n\t\t\tcase ' ':\n\t\t\t\tbreak;\n\t\t\tcase CR:\n\t\t\t\tstate = sw_almost_done;\n\t\t\t\tbreak;\n\t\t\tcase LF:\n\t\t\t\tgoto done;\n\t\t\tcase '\\0':\n\t\t\t\treturn HTTP_PARSE_INVALID;\n\t\t\tdefault:\n\t\t\t\tstate = sw_value;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t\n\t\tcase sw_almost_done:\n\t\t\tswitch (ch) {\n\t\t\tcase LF:\n\t\t\t\tgoto done;\n\t\t\tcase CR:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn HTTP_PARSE_INVALID;\n\t\t\t}\n\t\t\tbreak;\n\t\t\n\t\tcase sw_header_almost_done:\n\t\t\tif (ch == LF)\n\t\t\t\tgoto header_done;\n\t\t\telse\n\t\t\t\treturn HTTP_PARSE_INVALID;\n\t\t}\n\t}\n\nskipped_status:\n\t*bufp = p + 1;\n\treturn HTTP_PARSE_CONTINUE;\n\ndone:\n\t*bufp = p + 1;\n\treturn HTTP_PARSE_OK;\n\nheader_done:\n\t*bufp = p + 1;\n\treturn HTTP_PARSE_DONE;\n}", "Selected Statement": "\t*bufp = p + 1;\n", "Selected Pointer": "p", "Compared Statement": "\tfor (; p < end_buf; p++) {\n", "Compared Pointer": "end_buf", "Aliasing": "No", "Function Input": {"bufp": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddc8", "value": {"type_category": "string", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x5\n", "message": "Cannot access memory at address 0x5"}}, "end_buf": {"type_category": "string", "concrete_type": "string", "value": "0xca05c0 \"\""}, "max_hname_len": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "prsr": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"hdr_value_start": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdea0 \"\\220\\337\\377\\377\\377\\177\""}, "hdr_value_end": {"type_category": "string", "concrete_type": "string", "value": "0x279934 <ExecuteCallback()+292> \"\\306\\005\\335l\\n\""}, "http_major": {"type_category": "int", "concrete_type": "int", "value": "-8240"}, "http_minor": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "hdr_name": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff7ae08f0 \"A\""}, "hdr_name_idx": {"type_category": "int", "concrete_type": "int", "value": "13204208"}}}}}, "Program Information": {"Project Name": "tarantool"}}
{"Programming Language": "C", "Source Code": "static int\nhttp_parse_status_line(struct http_parser *parser, const char **bufp,\n\t\t       const char *end_buf)\n{\n\tchar ch;\n\tconst char *p = *bufp;\n\tenum {\n\t\tsw_start = 0,\n\t\tsw_H,\n\t\tsw_HT,\n\t\tsw_HTT,\n\t\tsw_HTTP,\n\t\tsw_first_major_digit,\n\t\tsw_major_digit,\n\t\tsw_first_minor_digit,\n\t\tsw_minor_digit,\n\t\tsw_status,\n\t\tsw_space_after_status,\n\t\tsw_status_text,\n\t\tsw_almost_done\n\t} state;\n\n\tstate = sw_start;\n\tint status_count = 0;\n\tfor (;p < end_buf; p++) {\n\t\tch = *p;\n\t\tswitch (state) {\n\t\t\n\t\tcase sw_start:\n\t\t\tif (ch == 'H')\n\t\t\t\tstate = sw_H;\n\t\t\telse\n\t\t\t\treturn HTTP_PARSE_INVALID;\n\t\t\tbreak;\n\t\tcase sw_H:\n\t\t\tif (ch == 'T')\n\t\t\t\tstate = sw_HT;\n\t\t\telse\n\t\t\t\treturn HTTP_PARSE_INVALID;\n\t\t\tbreak;\n\t\tcase sw_HT:\n\t\t\tif (ch == 'T')\n\t\t\t\tstate = sw_HTT;\n\t\t\telse\n\t\t\t\treturn HTTP_PARSE_INVALID;\n\t\t\tbreak;\n\t\tcase sw_HTT:\n\t\t\tif (ch == 'P')\n\t\t\t\tstate = sw_HTTP;\n\t\t\telse\n\t\t\t\treturn HTTP_PARSE_INVALID;\n\t\t\tbreak;\n\t\tcase sw_HTTP:\n\t\t\tif (ch == '/')\n\t\t\t\tstate = sw_first_major_digit;\n\t\t\telse\n\t\t\t\treturn HTTP_PARSE_INVALID;\n\t\t\tbreak;\n\t\t\n\t\tcase sw_first_major_digit:\n\t\t\tif (ch < '1' || ch > '9') {\n\t\t\t\treturn HTTP_PARSE_INVALID;\n\t\t\t}\n\t\t\tparser->http_major = ch - '0';\n\t\t\tstate = sw_major_digit;\n\t\t\tbreak;\n\t\t\n\t\tcase sw_major_digit:\n\t\t\tif (ch == '.') {\n\t\t\t\tstate = sw_first_minor_digit;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ch == ' ') {\n\t\t\t\tparser->http_minor = 0;\n\t\t\t\tstate = sw_status;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ch < '0' || ch > '9') {\n\t\t\t\treturn HTTP_PARSE_INVALID;\n\t\t\t}\n\t\t\tif (parser->http_major > 99) {\n\t\t\t\treturn HTTP_PARSE_INVALID;\n\t\t\t}\n\t\t\tparser->http_major = parser->http_major * 10\n\t\t\t\t\t     + (ch - '0');\n\t\t\tbreak;\n\t\t\n\t\tcase sw_first_minor_digit:\n\t\t\tif (ch < '0' || ch > '9') {\n\t\t\t\treturn HTTP_PARSE_INVALID;\n\t\t\t}\n\t\t\tparser->http_minor = ch - '0';\n\t\t\tstate = sw_minor_digit;\n\t\t\tbreak;\n\t\t\n\t\tcase sw_minor_digit:\n\t\t\tif (ch == ' ') {\n\t\t\t\tstate = sw_status;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ch < '0' || ch > '9') {\n\t\t\t\treturn HTTP_PARSE_INVALID;\n\t\t\t}\n\t\t\tif (parser->http_minor > 99) {\n\t\t\t\treturn HTTP_PARSE_INVALID;\n\t\t\t}\n\t\t\tparser->http_minor = parser->http_minor * 10\n\t\t\t\t\t     + (ch - '0');\n\t\t\tbreak;\n\t\t\n\t\tcase sw_status:\n\t\t\tif (ch == ' ') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ch < '0' || ch > '9') {\n\t\t\t\treturn HTTP_PARSE_INVALID;\n\t\t\t}\n\t\t\tif (++status_count == 3) {\n\t\t\t\tstate = sw_space_after_status;\n\t\t\t}\n\t\t\tbreak;\n\t\t\n\t\tcase sw_space_after_status:\n\t\t\tswitch (ch) {\n\t\t\tcase ' ':\n\t\t\t\tstate = sw_status_text;\n\t\t\t\tbreak;\n\t\t\tcase '.':\n\t\t\t\t\n\t\t\t\tstate = sw_status_text;\n\t\t\t\tbreak;\n\t\t\tcase CR:\n\t\t\t\tstate = sw_almost_done;\n\t\t\t\tbreak;\n\t\t\tcase LF:\n\t\t\t\tgoto done;\n\t\t\tdefault:\n\t\t\t\treturn HTTP_PARSE_INVALID;\n\t\t\t}\n\t\t\tbreak;\n\t\t\n\t\tcase sw_status_text:\n\t\t\tswitch (ch) {\n\t\t\tcase CR:\n\t\t\t\tstate = sw_almost_done;\n\t\t\t\tbreak;\n\t\t\tcase LF:\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\n\t\tcase sw_almost_done:\n\t\t\tswitch (ch) {\n\t\t\tcase LF:\n\t\t\t\tgoto done;\n\t\t\tdefault:\n\t\t\t\treturn HTTP_PARSE_INVALID;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\t*bufp = p + 1;\n\treturn HTTP_PARSE_OK;\n}", "Selected Statement": "\t\tch = *p;\n", "Selected Pointer": "p", "Compared Statement": "\tfor (;p < end_buf; p++) {\n", "Compared Pointer": "end_buf", "Aliasing": "Yes", "Function Input": {"bufp": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdca8", "value": {"type_category": "string", "concrete_type": "string", "value": "0x33352f50545448 <error: Cannot access memory at address 0x33352f50545448>"}}, "end_buf": {"type_category": "string", "concrete_type": "string", "value": "0x7 <error: Cannot access memory at address 0x7>"}, "parser": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdcb0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"hdr_value_start": {"type_category": "string", "concrete_type": "string", "value": "0x33352f50545448 <error: Cannot access memory at address 0x33352f50545448>"}, "hdr_value_end": {"type_category": "string", "concrete_type": "NULL"}, "http_major": {"type_category": "int", "concrete_type": "int", "value": "0"}, "http_minor": {"type_category": "int", "concrete_type": "int", "value": "0"}, "hdr_name": {"type_category": "string", "concrete_type": "string", "value": "0x31 <error: Cannot access memory at address 0x31>"}, "hdr_name_idx": {"type_category": "int", "concrete_type": "int", "value": "0"}}}}}, "Program Information": {"Project Name": "tarantool"}}
{"Programming Language": "C", "Source Code": "ssize_t\ndatetime_parse_full(struct datetime *date, const char *str, size_t len,\n\t\t    const char *tzsuffix, int32_t offset)\n{\n\tsize_t n;\n\tdt_t dt;\n\tconst char *svp = str;\n\tchar c;\n\tint sec_of_day = 0, nanosecond = 0;\n\tint16_t tzindex = 0;\n\n\tn = dt_parse_iso_date(str, len, &dt);\n\tif (n == 0)\n\t\treturn 0;\n\n\tstr += n;\n\tlen -= n;\n\tif (len <= 0)\n\t\tgoto exit;\n\n\tc = *str++;\n\tif (c != 'T' && c != 't' && c != ' ')\n\t\treturn 0;\n\tlen--;\n\tif (len <= 0)\n\t\tgoto exit;\n\n\tn = dt_parse_iso_time(str, len, &sec_of_day, &nanosecond);\n\tif (n == 0)\n\t\treturn 0;\n\n\tstr += n;\n\tlen -= n;\n\tif (len <= 0)\n\t\tgoto exit;\n\n\t\n\ttime_t base = dt_epoch(dt) + sec_of_day - offset * 60;\n\tssize_t l;\n\tif (tzsuffix != NULL) {\n\t\tl = parse_tz_suffix(tzsuffix, strlen(tzsuffix), base,\n\t\t\t\t    &tzindex, &offset);\n\t\tif (l < 0)\n\t\t\treturn l;\n\t\tgoto exit;\n\t}\n\n\tif (*str == ' ') {\n\t\tstr++;\n\t\tlen--;\n\t}\n\tif (len <= 0)\n\t\tgoto exit;\n\n\tl = parse_tz_suffix(str, len, base, &tzindex, &offset);\n\tif (l < 0)\n\t\treturn l;\n\tstr += l;\n\nexit:\n\tdate->epoch = dt_epoch(dt) + sec_of_day - offset * 60;\n\tdate->nsec = nanosecond;\n\tdate->tzoffset = offset;\n\tdate->tzindex = tzindex;\n\n\treturn str - svp;\n}", "Selected Statement": "\tif (n == 0)\n", "Selected Pointer": "str", "Compared Statement": "\treturn str - svp;\n", "Compared Pointer": "svp", "Aliasing": "Yes", "Function Input": {"date": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffde90", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"epoch": {"type_category": "float", "concrete_type": "double", "value": "6.9533558074215702e-310"}, "nsec": {"type_category": "unknown", "concrete_type": "int32_t", "value": "2837716"}, "tzoffset": {"type_category": "unknown", "concrete_type": "int16_t", "value": "0"}, "tzindex": {"type_category": "unknown", "concrete_type": "int16_t", "value": "0"}}}}, "len": {"type_category": "unknown", "concrete_type": "size_t", "value": "4096"}, "offset": {"type_category": "unknown", "concrete_type": "int32_t", "value": "0"}, "str": {"type_category": "string", "concrete_type": "NULL"}, "tzsuffix": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff7963b95 <calloc+133> \"I\\211\\300H\\205\\300t\\fH\\213@\\370\\250\\002\\017\\204\\247\""}}, "Program Information": {"Project Name": "tarantool"}}
{"Programming Language": "C", "Source Code": "bool\ntm_to_datetime(struct tnt_tm *tm, struct datetime *date)\n{\n\tassert(tm != NULL);\n\tassert(date != NULL);\n\tint year = tm->tm_year;\n\tint mon = tm->tm_mon;\n\tint mday = tm->tm_mday;\n\tint yday = tm->tm_yday;\n\tint wday = tm->tm_wday;\n\tdt_t dt = 0;\n\n\tif ((year | mon | mday) == 0) {\n\t\tif (yday != 0) {\n\t\t\tdt = yday - 1 + DT_EPOCH_1970_OFFSET;\n\t\t} else if (wday != 0) {\n\t\t\t\n\t\t\tdt = ((wday - 4) % 7) + DT_EPOCH_1970_OFFSET;\n\t\t}\n\t} else {\n\t\tif (mday == 0)\n\t\t\tmday = 1;\n\t\tassert(mday >= 1 && mday <= 31);\n\t\tassert(mon >= 0 && mon <= 11);\n\t\tif (dt_from_ymd_checked(year + 1900, mon + 1, mday, &dt) == false)\n\t\t\treturn false;\n\t}\n\tint64_t local_secs =\n\t\t(int64_t)dt * SECS_PER_DAY - SECS_EPOCH_1970_OFFSET;\n\tlocal_secs += tm->tm_hour * 3600 + tm->tm_min * 60 + tm->tm_sec;\n\tdate->epoch = local_secs - tm->tm_gmtoff;\n\tdate->nsec = tm->tm_nsec;\n\tdate->tzindex = tm->tm_tzindex;\n\tdate->tzoffset = tm->tm_gmtoff / 60;\n\treturn true;\n}", "Selected Statement": "\tassert(tm != NULL);\n", "Selected Pointer": "tm", "Compared Statement": "\tassert(date != NULL);\n", "Compared Pointer": "date", "Aliasing": "No", "Function Input": {"date": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddc8", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"epoch": {"type_category": "float", "concrete_type": "double", "value": "0"}, "nsec": {"type_category": "unknown", "concrete_type": "int32_t", "value": "0"}, "tzoffset": {"type_category": "unknown", "concrete_type": "int16_t", "value": "0"}, "tzindex": {"type_category": "unknown", "concrete_type": "int16_t", "value": "0"}}}}, "tm": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"tm_sec": {"type_category": "int", "concrete_type": "int", "value": "0"}, "tm_min": {"type_category": "int", "concrete_type": "int", "value": "0"}, "tm_hour": {"type_category": "int", "concrete_type": "int", "value": "0"}, "tm_mday": {"type_category": "int", "concrete_type": "int", "value": "0"}, "tm_mon": {"type_category": "int", "concrete_type": "int", "value": "0"}, "tm_year": {"type_category": "int", "concrete_type": "int", "value": "-1610612736"}, "tm_wday": {"type_category": "int", "concrete_type": "int", "value": "60033"}, "tm_yday": {"type_category": "int", "concrete_type": "int", "value": "0"}, "tm_isdst": {"type_category": "int", "concrete_type": "int", "value": "0"}, "tm_gmtoff": {"type_category": "int", "concrete_type": "long", "value": "-6917529027641081856"}, "tm_epoch": {"type_category": "unknown", "concrete_type": "int64_t", "value": "8070450532247988865"}, "tm_nsec": {"type_category": "int", "concrete_type": "int", "value": "-33"}, "tm_tzindex": {"type_category": "unknown", "concrete_type": "int16_t", "value": "127"}}}}}, "Program Information": {"Project Name": "tarantool"}}
{"Programming Language": "C", "Source Code": "static void\nuri_create_params(struct uri *uri, const char *query)\n{\n\tchar *copy = xstrdup(query);\n\tchar *saveptr, *optstr = strtok_r(copy, \"&\", &saveptr);\n\twhile (optstr != NULL) {\n\t\tchar *value = NULL, *name = optstr;\n\t\tchar *delim = strchr(optstr, '=');\n\t\tif (delim != NULL) {\n\t\t\t*delim = '\\0';\n\t\t\tvalue = delim + 1;\n\t\t}\n\t\toptstr = strtok_r(NULL, \"&\", &saveptr);\n\t\t\n\t\tif (*name == 0)\n\t\t\tcontinue;\n\t\turi_add_param(uri, name, value);\n\t}\n\tfree(copy);\n}", "Selected Statement": "\tfree(copy);\n", "Selected Pointer": "copy", "Compared Statement": "\tchar *copy = xstrdup(query);\n", "Compared Pointer": "query", "Aliasing": "No", "Function Input": {"query": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdd40 \"\""}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdc08", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffde80 \"\\300\\336\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x33a01e <LLVMFuzzerTestOneInput+222> \"H\\215}\\210\\350i\\\"\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0xd0b580 \".?\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "service": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffde80 \"\\300\\336\\377\\377\\377\\177\""}, "path": {"type_category": "string", "concrete_type": "NULL"}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "NULL"}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "13676992"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "0"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "0"}, "params": {"type_category": "pointer", "concrete_type": "NULL"}}}}}, "Program Information": {"Project Name": "tarantool"}}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;\n}", "Selected Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Selected Pointer": "str", "Compared Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Compared Pointer": "uri", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \" \\001\\321\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8dd0 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd10120 \"1\\n\\321\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}}
{"Programming Language": "C", "Source Code": "static void\nuri_param_create(struct uri_param *param, const char *name)\n{\n\tparam->name = xstrdup(name);\n\tparam->values = NULL;\n\tparam->value_count = 0;\n\tparam->values_capacity = 0;\n}", "Selected Statement": "\tparam->name = xstrdup(name);\n", "Selected Pointer": "name", "Compared Statement": "uri_param_create(struct uri_param *param, const char *name)\n", "Compared Pointer": "param", "Aliasing": "No", "Function Input": {"name": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "param": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdaf8", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"name": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdc10 \"\\340\\335\\377\\377\\377\\177\""}, "values_capacity": {"type_category": "int", "concrete_type": "int", "value": "3393049"}, "value_count": {"type_category": "int", "concrete_type": "int", "value": "0"}, "values": {"type_category": "pointer", "concrete_type": "NULL"}}}}}, "Program Information": {"Project Name": "tarantool"}}
{"Programming Language": "C", "Source Code": "size_t\ndatetime_strptime(struct datetime *date, const char *buf, const char *fmt)\n{\n\tassert(date != NULL);\n\tassert(fmt != NULL);\n\tassert(buf != NULL);\n\tstruct tnt_tm t = { .tm_epoch = 0 };\n\tchar *ret = tnt_strptime(buf, fmt, &t);\n\tif (ret == NULL)\n\t\treturn 0;\n\tif (tm_to_datetime(&t, date) == false)\n\t\treturn 0;\n\treturn ret - buf;\n}", "Selected Statement": "\tassert(date != NULL);\n", "Selected Pointer": "date", "Compared Statement": "\treturn ret - buf;\n", "Compared Pointer": "buf", "Aliasing": "No", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdde0 \"\\004%b\""}, "date": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdd70", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"epoch": {"type_category": "float", "concrete_type": "double", "value": "6.9533558074073411e-310"}, "nsec": {"type_category": "unknown", "concrete_type": "int32_t", "value": "3749370"}, "tzoffset": {"type_category": "unknown", "concrete_type": "int16_t", "value": "0"}, "tzindex": {"type_category": "unknown", "concrete_type": "int16_t", "value": "0"}}}}, "fmt": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdde0 \"\\004%b\""}}, "Program Information": {"Project Name": "tarantool"}}
{"Programming Language": "C", "Source Code": "CIVETWEB_API int\nmg_get_response(struct mg_connection *conn,\n                char *ebuf,\n                size_t ebuf_len,\n                int timeout)\n{\n\tint err, ret;\n\tchar txt[32]; \n\tchar *save_timeout;\n\tchar *new_timeout;\n\n\tif (ebuf_len > 0) {\n\t\tebuf[0] = '\\0';\n\t}\n\n\tif (!conn) {\n\t\tmg_snprintf(conn,\n\t\t            NULL, \n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"Parameter error\");\n\t\treturn -1;\n\t}\n\n\t\n\tconn->data_len = 0;\n\n\t\n\tsave_timeout = conn->dom_ctx->config[REQUEST_TIMEOUT];\n\n\tif (timeout >= 0) {\n\t\tmg_snprintf(conn, NULL, txt, sizeof(txt), \"%i\", timeout);\n\t\tnew_timeout = txt;\n\t} else {\n\t\tnew_timeout = NULL;\n\t}\n\n\tconn->dom_ctx->config[REQUEST_TIMEOUT] = new_timeout;\n\tret = get_response(conn, ebuf, ebuf_len, &err);\n\tconn->dom_ctx->config[REQUEST_TIMEOUT] = save_timeout;\n\n\t\n\tconn->request_info.local_uri_raw = conn->request_info.request_uri;\n\tconn->request_info.local_uri = conn->request_info.local_uri_raw;\n\n\t\n\treturn (ret == 0) ? -1 : +1;\n}", "Selected Statement": "\tconn->dom_ctx->config[REQUEST_TIMEOUT] = new_timeout;\n", "Selected Pointer": "new_timeout", "Compared Statement": "\t\tmg_snprintf(conn, NULL, txt, sizeof(txt), \"%i\", timeout);\n", "Compared Pointer": "txt", "Aliasing": "No", "Function Input": {"ebuf": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdd00 \"\""}, "ebuf_len": {"type_category": "unknown", "concrete_type": "size_t", "value": "140737488346048"}, "timeout": {"type_category": "int", "concrete_type": "int", "value": "32767"}}, "Program Information": {"Project Name": "civetweb"}}
{"Programming Language": "C", "Source Code": "static int\nparse_port_string(const struct vec *vec, struct socket *so, int *ip_version)\n{\n\tunsigned int a, b, c, d;\n\tunsigned port;\n\tunsigned long portUL;\n\tint len;\n\tconst char *cb;\n\tchar *endptr;\n#if defined(USE_IPV6)\n\tchar buf[100] = {0};\n#endif\n\n\t\n\tmemset(so, 0, sizeof(*so));\n\tso->lsa.sin.sin_family = AF_INET;\n\t*ip_version = 0;\n\n\t\n\tport = 0;\n\tlen = 0;\n\n\t\n\tif (sscanf(vec->ptr,\n\t           \"%u.%u.%u.%u:%u%n\",\n\t           &a,\n\t           &b,\n\t           &c,\n\t           &d,\n\t           &port,\n\t           &len) \n\t                 \n\t                 \n\t    == 5) {\n\t\t\n\t\tso->lsa.sin.sin_addr.s_addr =\n\t\t    htonl((a << 24) | (b << 16) | (c << 8) | d);\n\t\tso->lsa.sin.sin_port = htons((uint16_t)port);\n\t\t*ip_version = 4;\n\n#if defined(USE_IPV6)\n\t} else if (sscanf(vec->ptr, \"[%49[^]]]:%u%n\", buf, &port, &len) == 2\n\t           && ((size_t)len <= vec->len)\n\t           && mg_inet_pton(\n\t                  AF_INET6, buf, &so->lsa.sin6, sizeof(so->lsa.sin6), 0)) {\n\t\t\n\t\t\n\t\tso->lsa.sin6.sin6_port = htons((uint16_t)port);\n\t\t*ip_version = 6;\n#endif\n\n\t} else if ((vec->ptr[0] == '+')\n\t           && (sscanf(vec->ptr + 1, \"%u%n\", &port, &len)\n\t               == 1)) { \n\t\t                    \n\t\t                    \n\t\t                    \n\n\t\t\n\t\t\n\t\tlen++;\n\n#if defined(USE_IPV6)\n\t\t\n\t\tso->lsa.sin6.sin6_family = AF_INET6;\n\t\tso->lsa.sin6.sin6_port = htons((uint16_t)port);\n\t\t*ip_version = 4 + 6;\n#else\n\t\t\n\t\tso->lsa.sin.sin_port = htons((uint16_t)port);\n\t\t*ip_version = 4;\n#endif\n\n\t} else if (is_valid_port(portUL = strtoul(vec->ptr, &endptr, 0))\n\t           && (vec->ptr != endptr)) {\n\t\tlen = (int)(endptr - vec->ptr);\n\t\tport = (uint16_t)portUL;\n\t\t\n\t\tso->lsa.sin.sin_port = htons((uint16_t)port);\n\t\t*ip_version = 4;\n\n\t} else if ((cb = strchr(vec->ptr, ':')) != NULL) {\n\t\t\n\n\t\t\n\t\tchar hostname[256];\n\t\tsize_t hostnlen = (size_t)(cb - vec->ptr);\n\n\t\tif ((hostnlen >= vec->len) || (hostnlen >= sizeof(hostname))) {\n\t\t\t\n\t\t\t*ip_version = 0;\n\t\t\treturn 0;\n\t\t}\n\n\t\tmg_strlcpy(hostname, vec->ptr, hostnlen + 1);\n\n\t\tif (mg_inet_pton(\n\t\t        AF_INET, hostname, &so->lsa.sin, sizeof(so->lsa.sin), 1)) {\n\t\t\tif (sscanf(cb + 1, \"%u%n\", &port, &len)\n\t\t\t    == 1) { \n\t\t\t\t        \n\t\t\t\t        \n\t\t\t\t        \n\t\t\t\t*ip_version = 4;\n\t\t\t\tso->lsa.sin.sin_port = htons((uint16_t)port);\n\t\t\t\tlen += (int)(hostnlen + 1);\n\t\t\t} else {\n\t\t\t\tlen = 0;\n\t\t\t}\n#if defined(USE_IPV6)\n\t\t} else if (mg_inet_pton(AF_INET6,\n\t\t                        hostname,\n\t\t                        &so->lsa.sin6,\n\t\t                        sizeof(so->lsa.sin6),\n\t\t                        1)) {\n\t\t\tif (sscanf(cb + 1, \"%u%n\", &port, &len) == 1) {\n\t\t\t\t*ip_version = 6;\n\t\t\t\tso->lsa.sin6.sin6_port = htons((uint16_t)port);\n\t\t\t\tlen += (int)(hostnlen + 1);\n\t\t\t} else {\n\t\t\t\tlen = 0;\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tlen = 0;\n\t\t}\n\n#if defined(USE_X_DOM_SOCKET)\n\n\t} else if (vec->ptr[0] == 'x') {\n\t\t\n\t\tif (vec->len < sizeof(so->lsa.sun.sun_path)) {\n\t\t\tlen = vec->len;\n\t\t\tso->lsa.sun.sun_family = AF_UNIX;\n\t\t\tmemset(so->lsa.sun.sun_path, 0, sizeof(so->lsa.sun.sun_path));\n\t\t\tmemcpy(so->lsa.sun.sun_path, (char *)vec->ptr + 1, vec->len - 1);\n\t\t\tport = 0;\n\t\t\t*ip_version = 99;\n\t\t} else {\n\t\t\t\n\t\t\tlen = 0;\n\t\t}\n#endif\n\n\t} else {\n\t\t\n\t\tlen = 0;\n\t}\n\n\t\n\tif ((len > 0) && (is_valid_port(port))) {\n\t\tint bad_suffix = 0;\n\t\tsize_t i;\n\n\t\t\n\t\tfor (i = len; i < vec->len; i++) {\n\t\t\tunsigned char *opt = NULL;\n\t\t\tswitch (vec->ptr[i]) {\n\t\t\tcase 'o':\n\t\t\t\topt = &so->is_optional;\n\t\t\t\tbreak;\n\t\t\tcase 'r':\n\t\t\t\topt = &so->ssl_redir;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\topt = &so->is_ssl;\n\t\t\t\tbreak;\n\t\t\tdefault: \n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif ((opt) && (*opt == 0))\n\t\t\t\t*opt = 1;\n\t\t\telse {\n\t\t\t\tbad_suffix = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif ((bad_suffix == 0) && ((so->is_ssl == 0) || (so->ssl_redir == 0))) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t\n\t*ip_version = 0;\n\treturn 0;\n}", "Selected Statement": "\t           && (vec->ptr != endptr)) {\n", "Selected Pointer": "endptr", "Compared Statement": "\tmemset(so, 0, sizeof(*so));\n", "Compared Pointer": "so", "Aliasing": "No", "Function Input": {"ip_version": {"type_category": "pointer", "concrete_type": "NULL"}, "so": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd968", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"sock": {"type_category": "unknown", "concrete_type": "SOCKET", "value": "15781072"}, "lsa": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"sa": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"sa_family": {"type_category": "unknown", "concrete_type": "sa_family_t", "value": "0"}, "sa_data": {"type_category": "string", "concrete_type": "string", "value": "\"\\000\\000\\001\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\""}}}, "sin": {"type_category": "struct", "concrete_type": "sockaddr_in", "value": "{sin_family = 0, sin_port = 0, sin_addr = {s_addr = 1}, sin_zero = \"\\000\\000\\000\\000\\000\\000\\000\"}"}}}, "rsa": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"sa": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"sa_family": {"type_category": "unknown", "concrete_type": "sa_family_t", "value": "1"}, "sa_data": {"type_category": "string", "concrete_type": "string", "value": "\"\\000\\000\\321\\314\\360\\000\\000\\000\\000\\000\\020\\000\\241\\367\""}}}, "sin": {"type_category": "struct", "concrete_type": "sockaddr_in", "value": "{sin_family = 1, sin_port = 0, sin_addr = {s_addr = 15781073}, sin_zero = \"\\000\\000\\000\\000\\020\\000\\241\\367\"}"}}}, "is_ssl": {"type_category": "int", "concrete_type": "unsigned char", "value": "255 '\\377'"}, "ssl_redir": {"type_category": "int", "concrete_type": "unsigned char", "value": "127 '\\177'"}, "is_optional": {"type_category": "int", "concrete_type": "unsigned char", "value": "0 '\\000'"}, "in_use": {"type_category": "int", "concrete_type": "unsigned char", "value": "0 '\\000'"}}}}, "vec": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd970", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"ptr": {"type_category": "string", "concrete_type": "NULL"}, "len": {"type_category": "unknown", "concrete_type": "size_t", "value": "0"}}}}}, "Program Information": {"Project Name": "civetweb"}}
{"Programming Language": "C", "Source Code": "static void\ndostr(const char *str, int slen, PrintfTarget *target)\n{\n\t\n\tif (slen == 1)\n\t{\n\t\tdopr_outch(*str, target);\n\t\treturn;\n\t}\n\n\twhile (slen > 0)\n\t{\n\t\tint\t\t\tavail;\n\n\t\tif (target->bufend != NULL)\n\t\t\tavail = target->bufend - target->bufptr;\n\t\telse\n\t\t\tavail = slen;\n\t\tif (avail <= 0)\n\t\t{\n\t\t\t\n\t\t\tif (target->stream == NULL)\n\t\t\t{\n\t\t\t\ttarget->nchars += slen; \n\t\t\t\treturn;\n\t\t\t}\n\t\t\tflushbuffer(target);\n\t\t\tcontinue;\n\t\t}\n\t\tavail = Min(avail, slen);\n\t\tmemmove(target->bufptr, str, avail);\n\t\ttarget->bufptr += avail;\n\t\tstr += avail;\n\t\tslen -= avail;\n\t}\n}", "Selected Statement": "\t\tstr += avail;\n", "Selected Pointer": "str", "Compared Statement": "\t\t\tdostr(format, next_pct - format, target);\n", "Compared Pointer": "next_pct", "Aliasing": "No", "Function Input": {"slen": {"type_category": "int", "concrete_type": "int", "value": "<optimized out>"}, "str": {"type_category": "string", "concrete_type": "string", "value": "<optimized out>"}}, "Program Information": {"Project Name": "libpg_query"}}
{"Programming Language": "C", "Source Code": "static int time_formatter(int fmt, char *dst, size_t dlen, time_t *when)\n{\n\tint ret = 0;\n\n\tswitch (fmt) {\n\tcase LAST_TIMEFTM_NONE:\n\t\t*dst = 0;\n\t\tbreak;\n\tcase LAST_TIMEFTM_HHMM:\n\t{\n\t\tstruct tm tm;\n\n\t\tlocaltime_r(when, &tm);\n\t\tif (!snprintf(dst, dlen, \"%02d:%02d\", tm.tm_hour, tm.tm_min))\n\t\t\tret = -1;\n\t\tbreak;\n\t}\n\tcase LAST_TIMEFTM_CTIME:\n\t{\n\t\tchar buf[CTIME_BUFSIZ];\n\n\t\tif (!ctime_r(when, buf)) {\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\t\tsnprintf(dst, dlen, \"%s\", buf);\n\t\tret = rtrim_whitespace((unsigned char *) dst);\n\t\tbreak;\n\t}\n\tcase LAST_TIMEFTM_ISO8601:\n\t\tret = strtime_iso(when, ISO_TIMESTAMP_T, dst, dlen);\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t}\n\treturn ret;\n}", "Selected Statement": "\t\tsnprintf(dst, dlen, \"%s\", buf);\n", "Selected Pointer": "buf", "Compared Statement": "\t\tfmt = &timefmts[ctl->time_fmt];\n", "Compared Pointer": "fmt", "Aliasing": "No", "Function Input": {"dlen": {"type_category": "unknown", "concrete_type": "size_t", "value": "140737488345856"}, "dst": {"type_category": "string", "concrete_type": "string", "value": "0xf5ec40 \"/tmp/test-last-fuzz.7KRk1M\""}, "fmt": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "when": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdae0", "value": {"type_category": "unknown", "concrete_type": "time_t", "value": "8315180034107995183"}}}, "Program Information": {"Project Name": "util-linux"}}
{"Programming Language": "C", "Source Code": "static int mnt_parse_table_line(struct libmnt_fs *fs, const char *s)\n{\n\tint rc = 0;\n\tchar *p = NULL;\n\n\tfs->passno = fs->freq = 0;\n\n\t\n\tp = unmangle(s, &s);\n\tif (!p || (rc = __mnt_fs_set_source_ptr(fs, p))) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [source]\"));\n\t\tfree(p);\n\t\tgoto fail;\n\t}\n\n\ts = skip_separator(s);\n\n\t\n\tfs->target = unmangle(s, &s);\n\tif (!fs->target) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [target]\"));\n\t\tgoto fail;\n\t}\n\n\ts = skip_separator(s);\n\n\t\n\tp = unmangle(s, &s);\n\tif (!p || (rc = __mnt_fs_set_fstype_ptr(fs, p))) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [fstype]\"));\n\t\tfree(p);\n\t\tgoto fail;\n\t}\n\n\ts = skip_separator(s);\n\n\t\n\tp = unmangle(s, &s);\n\tif (p && (rc = mnt_fs_set_options(fs, p))) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [options]\"));\n\t\tfree(p);\n\t\tgoto fail;\n\t}\n\tif (!p)\n\t\tgoto done;\n\tfree(p);\n\n\ts = skip_separator(s);\n\tif (!s || !*s)\n\t\tgoto done;\n\n\t\n\ts = next_s32(s, &fs->freq, &rc);\n\tif (s && *s && rc) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [freq]\"));\n\t\tgoto fail;\n\t}\n\n\ts = skip_separator(s);\n\tif (!s || !*s)\n\t\tgoto done;\n\n\t\n\ts = next_s32(s, &fs->passno, &rc);\n\tif (s && *s && rc) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [passno]\"));\n\t\tgoto fail;\n\t}\n\ndone:\n\treturn 0;\nfail:\n\tif (rc == 0)\n\t\trc = -EINVAL;\n\tDBG(TAB, ul_debug(\"tab parse error on: '%s' [rc=%d]\", s, rc));\n\treturn rc;\n}", "Selected Statement": "\tDBG(TAB, ul_debug(\"tab parse error on: '%s' [rc=%d]\", s, rc));\n", "Selected Pointer": "s", "Compared Statement": "\tp = unmangle(s, &s);\n", "Compared Pointer": "p", "Aliasing": "No", "Function Input": {"fs": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdb40", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"ents": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"next": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x1056ca0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x5e\n", "message": "Cannot access memory at address 0x5e"}}, "prev": {"type_category": "pointer", "concrete_type": "NULL"}}}, "tab": {"type_category": "pointer", "concrete_type": "NULL"}, "refcount": {"type_category": "int", "concrete_type": "int", "value": "0"}, "opts_age": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}, "optlist": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x1056cc0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x6131646564643438\n", "message": "Cannot access memory at address 0x6131646564643438"}}, "id": {"type_category": "int", "concrete_type": "int", "value": "1647719989"}, "parent": {"type_category": "int", "concrete_type": "int", "value": "892875106"}, "devno": {"type_category": "unknown", "concrete_type": "dev_t", "value": "13624"}, "bindsrc": {"type_category": "string", "concrete_type": "NULL"}, "source": {"type_category": "string", "concrete_type": "string", "value": "0x660 <error: Cannot access memory at address 0x660>"}, "tagname": {"type_category": "string", "concrete_type": "string", "value": "0x50 <error: Cannot access memory at address 0x50>"}, "tagval": {"type_category": "string", "concrete_type": "string", "value": "0x1056d30 \"\\001\\026\""}, "root": {"type_category": "string", "concrete_type": "string", "value": "0x3239316235322f65 <error: Cannot access memory at address 0x3239316235322f65>"}, "target": {"type_category": "string", "concrete_type": "string", "value": "0x3665626536383334 <error: Cannot access memory at address 0x3665626536383334>"}, "fstype": {"type_category": "string", "concrete_type": "string", "value": "0x3837653732643961 <error: Cannot access memory at address 0x3837653732643961>"}, "optstr": {"type_category": "string", "concrete_type": "string", "value": "0x3232336236396435 <error: Cannot access memory at address 0x3232336236396435>"}, "vfs_optstr": {"type_category": "string", "concrete_type": "string", "value": "0x111 <error: Cannot access memory at address 0x111>"}, "opt_fields": {"type_category": "string", "concrete_type": "string", "value": "0x1bf900005549 <error: Cannot access memory at address 0x1bf900005549>"}, "fs_optstr": {"type_category": "string", "concrete_type": "string", "value": "0x15a900001ca0 <error: Cannot access memory at address 0x15a900001ca0>"}, "user_optstr": {"type_category": "string", "concrete_type": "string", "value": "0x166800001601 <error: Cannot access memory at address 0x166800001601>"}, "attrs": {"type_category": "string", "concrete_type": "string", "value": "0x84d900001c10 <error: Cannot access memory at address 0x84d900001c10>"}, "freq": {"type_category": "int", "concrete_type": "int", "value": "34025"}, "passno": {"type_category": "int", "concrete_type": "int", "value": "34041"}, "swaptype": {"type_category": "string", "concrete_type": "string", "value": "0x853100008521 <error: Cannot access memory at address 0x853100008521>"}, "size": {"type_category": "unknown", "concrete_type": "off_t", "value": "146548579140929"}, "usedsize": {"type_category": "unknown", "concrete_type": "off_t", "value": "146651658356057"}, "priority": {"type_category": "int", "concrete_type": "int", "value": "34177"}, "flags": {"type_category": "int", "concrete_type": "int", "value": "34201"}, "tid": {"type_category": "unknown", "concrete_type": "pid_t", "value": "37905"}, "comment": {"type_category": "string", "concrete_type": "string", "value": "0x1c4100009761 <error: Cannot access memory at address 0x1c4100009761>"}, "userdata": {"type_category": "pointer", "concrete_type": "VOID"}}}}, "s": {"type_category": "string", "concrete_type": "string", "value": "0x1056ca0 \"^\""}}, "Program Information": {"Project Name": "util-linux"}}
{"Programming Language": "C", "Source Code": "static int mnt_table_parse_next(struct libmnt_parser *pa,\n\t\t\t\tstruct libmnt_table *tb,\n\t\t\t\tstruct libmnt_fs *fs)\n{\n\tchar *s;\n\tint rc;\n\n\tassert(tb);\n\tassert(pa);\n\tassert(fs);\n\n\t\nnext_line:\n\tdo {\n\t\tif (getline(&pa->buf, &pa->bufsiz, pa->f) < 0)\n\t\t\treturn -EINVAL;\n\t\tpa->line++;\n\t\ts = strchr(pa->buf, '\\n');\n\t\tif (!s) {\n\t\t\tDBG(TAB, ul_debugobj(tb, \"%s:%zu: no final newline\",\n\t\t\t\t\t\tpa->filename, pa->line));\n\n\t\t\t\n\t\t\t\n\t\t\tif (feof(pa->f))\n\t\t\t\ts = memchr(pa->buf, '\\0', pa->bufsiz);\n\n\t\t\n\t\t} else if (tb->comms\n\t\t    && (tb->fmt == MNT_FMT_GUESS || tb->fmt == MNT_FMT_FSTAB)\n\t\t    && is_comment_line(pa->buf)) {\n\t\t\tdo {\n\t\t\t\trc = append_comment(tb, fs, pa->buf, feof(pa->f));\n\t\t\t\tif (!rc)\n\t\t\t\t\trc = next_comment_line(pa, &s);\n\t\t\t} while (rc == 0);\n\n\t\t\tif (rc == 1 && feof(pa->f))\n\t\t\t\trc = append_comment(tb, fs, NULL, 1);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\n\t\t}\n\n\t\tif (!s)\n\t\t\tgoto err;\n\t\t*s = '\\0';\n\t\tif (s > pa->buf && *(s - 1)  == '\\r')\n\t\t\t*(--s) = '\\0';\n\t\ts = (char *) skip_blank(pa->buf);\n\t} while (*s == '\\0' || *s == '#');\n\n\tif (tb->fmt == MNT_FMT_GUESS) {\n\t\ttb->fmt = guess_table_format(s);\n\t\tif (tb->fmt == MNT_FMT_SWAPS)\n\t\t\tgoto next_line;\t\t\t\n\t}\n\n\tswitch (tb->fmt) {\n\tcase MNT_FMT_FSTAB:\n\t\trc = mnt_parse_table_line(fs, s);\n\t\tbreak;\n\tcase MNT_FMT_MOUNTINFO:\n\t\trc = mnt_parse_mountinfo_line(fs, s);\n\t\tbreak;\n\tcase MNT_FMT_UTAB:\n\t\trc = mnt_parse_utab_line(fs, s);\n\t\tbreak;\n\tcase MNT_FMT_SWAPS:\n\t\tif (strncmp(s, \"Filename\\t\", 9) == 0)\n\t\t\tgoto next_line;\t\t\t\n\t\trc = mnt_parse_swaps_line(fs, s);\n\t\tbreak;\n\tdefault:\n\t\trc = -1;\t\n\t\tbreak;\n\t}\n\n\tif (rc == 0)\n\t\treturn 0;\nerr:\n\tDBG(TAB, ul_debugobj(tb, \"%s:%zu: %s parse error\", pa->filename, pa->line,\n\t\t\t\ttb->fmt == MNT_FMT_MOUNTINFO ? \"mountinfo\" :\n\t\t\t\ttb->fmt == MNT_FMT_SWAPS ? \"swaps\" :\n\t\t\t\ttb->fmt == MNT_FMT_FSTAB ? \"tab\" : \"utab\"));\n\n\t\n\treturn tb->errcb ? tb->errcb(tb, pa->filename, pa->line) : 1;\n}", "Selected Statement": "\treturn tb->errcb ? tb->errcb(tb, pa->filename, pa->line) : 1;\n", "Selected Pointer": "tb", "Compared Statement": "\t\ts = (char *) skip_blank(pa->buf);\n", "Compared Pointer": "s", "Aliasing": "No", "Function Input": {"fs": {"type_category": "pointer", "concrete_type": "NULL"}, "pa": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdc80", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"f": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x105ada0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"_flags": {"type_category": "int", "concrete_type": "int", "value": "17149344"}, "_IO_read_ptr": {"type_category": "string", "concrete_type": "string", "value": "0x105ada0 \"\\240\\255\\005\\001\""}, "_IO_read_end": {"type_category": "string", "concrete_type": "NULL"}, "_IO_read_base": {"type_category": "string", "concrete_type": "string", "value": "0x1 <error: Cannot access memory at address 0x1>"}, "_IO_write_base": {"type_category": "string", "concrete_type": "NULL"}, "_IO_write_ptr": {"type_category": "string", "concrete_type": "NULL"}, "_IO_write_end": {"type_category": "string", "concrete_type": "NULL"}, "_IO_buf_base": {"type_category": "string", "concrete_type": "NULL"}, "_IO_buf_end": {"type_category": "string", "concrete_type": "NULL"}, "_IO_save_base": {"type_category": "string", "concrete_type": "NULL"}, "_IO_backup_base": {"type_category": "string", "concrete_type": "NULL"}, "_IO_save_end": {"type_category": "string", "concrete_type": "NULL"}, "_markers": {"type_category": "pointer", "concrete_type": "NULL"}, "_chain": {"type_category": "pointer", "concrete_type": "NULL"}, "_fileno": {"type_category": "int", "concrete_type": "int", "value": "0"}, "_flags2": {"type_category": "int", "concrete_type": "int", "value": "0"}, "_old_offset": {"type_category": "unknown", "concrete_type": "__off_t", "value": "0"}, "_cur_column": {"type_category": "int", "concrete_type": "unsigned short", "value": "0"}, "_vtable_offset": {"type_category": "int", "concrete_type": "signed char", "value": "0 '\\000'"}, "_shortbuf": {"type_category": "string", "concrete_type": "string", "value": "\"\""}, "_lock": {"type_category": "pointer", "concrete_type": "NULL"}, "_offset": {"type_category": "unknown", "concrete_type": "__off64_t", "value": "0"}, "_codecvt": {"type_category": "pointer", "concrete_type": "NULL"}, "_wide_data": {"type_category": "pointer", "concrete_type": "NULL"}, "_freeres_list": {"type_category": "pointer", "concrete_type": "NULL"}, "_freeres_buf": {"type_category": "pointer", "concrete_type": "NULL"}, "__pad5": {"type_category": "unknown", "concrete_type": "size_t", "value": "0"}, "_mode": {"type_category": "int", "concrete_type": "int", "value": "0"}, "_unused2": {"type_category": "string", "concrete_type": "string", "value": "\"\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\""}}}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0x105ada0 \"\\240\\255\\005\\001\""}, "buf": {"type_category": "string", "concrete_type": "NULL"}, "bufsiz": {"type_category": "unknown", "concrete_type": "size_t", "value": "1"}, "line": {"type_category": "unknown", "concrete_type": "size_t", "value": "0"}, "sysroot_rc": {"type_category": "int", "concrete_type": "int", "value": "0"}, "sysroot": {"type_category": "string", "concrete_type": "NULL"}}}}, "tb": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdc78", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"fmt": {"type_category": "int", "concrete_type": "int", "value": "-8688"}, "nents": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "refcount": {"type_category": "int", "concrete_type": "int", "value": "5027995"}, "comms": {"type_category": "int", "concrete_type": "int", "value": "0"}, "comm_intro": {"type_category": "string", "concrete_type": "string", "value": "0x1 <error: Cannot access memory at address 0x1>"}, "comm_tail": {"type_category": "string", "concrete_type": "string", "value": "0x1055610 \"\""}, "cache": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdcb0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x2\n", "message": "Cannot access memory at address 0x2"}}, "errcb": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdcb8", "value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xffe\n", "message": "Cannot access memory at address 0xffe"}}, "fltrcb": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdcc0", "value": {"type_category": "unknown", "concrete_type": "unknown", "value": "{int (struct libmnt_fs *, void *)} 0x105ad32"}}, "fltrcb_data": {"type_category": "pointer", "concrete_type": "VOID"}, "noautofs": {"type_category": "int", "concrete_type": "int", "value": "-137605200"}, "ents": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"next": {"type_category": "pointer", "concrete_type": "NULL"}, "prev": {"type_category": "pointer", "concrete_type": "NULL"}}}, "userdata": {"type_category": "pointer", "concrete_type": "NULL"}}}}}, "Program Information": {"Project Name": "util-linux"}}
{"Programming Language": "C", "Source Code": "static int is_terminated_by_blank(const char *str)\n{\n\tsize_t sz = str ? strlen(str) : 0;\n\tconst char *p = sz ? str + (sz - 1) : NULL;\n\n\tif (!sz || !p || *p != '\\n')\n\t\treturn 0;\t\t\n\tif (p == str)\n\t\treturn 1;\t\t\n\tp--;\n\twhile (p > str && (*p == ' ' || *p == '\\t'))\n\t\tp--;\n\treturn *p == '\\n' ? 1 : 0;\n}", "Selected Statement": "\t\treturn 1;\t\t/* only '\\n' */\n", "Selected Pointer": "p", "Compared Statement": "\tif (p == str)\n", "Compared Pointer": "str", "Aliasing": "Yes", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x10550d0 \"\\n\""}}, "Program Information": {"Project Name": "util-linux"}}
{"Programming Language": "C", "Source Code": "int blkid_parse_tag_string(const char *token, char **ret_type, char **ret_val)\n{\n\tchar *name, *value, *cp;\n\n\tDBG(TAG, ul_debug(\"trying to parse '%s' as a tag\", token));\n\n\tif (!token || !(cp = strchr(token, '=')))\n\t\treturn -1;\n\n\tname = strdup(token);\n\tif (!name)\n\t\treturn -1;\n\tvalue = name + (cp - token);\n\t*value++ = '\\0';\n\tif (*value == '\"' || *value == '\\'') {\n\t\tchar c = *value++;\n\t\tif (!(cp = strrchr(value, c)))\n\t\t\tgoto errout; \n\t\t*cp = '\\0';\n\t}\n\n\tif (ret_val) {\n\t\tvalue = *value ? strdup(value) : NULL;\n\t\tif (!value)\n\t\t\tgoto errout;\n\t\t*ret_val = value;\n\t}\n\n\tif (ret_type)\n\t\t*ret_type = name;\n\telse\n\t\tfree(name);\n\n\treturn 0;\n\nerrout:\n\tDBG(TAG, ul_debug(\"parse error: '%s'\", token));\n\tfree(name);\n\treturn -1;\n}", "Selected Statement": "\tif (!name)\n", "Selected Pointer": "token", "Compared Statement": "\tvalue = name + (cp - token);\n", "Compared Pointer": "cp", "Aliasing": "Yes", "Function Input": {"ret_type": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffda18", "value": {"type_category": "string", "concrete_type": "NULL"}}, "ret_val": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffda10", "value": {"type_category": "string", "concrete_type": "NULL"}}, "token": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffda80 \"P\\333\\377\\377\\377\\177\""}}, "Program Information": {"Project Name": "util-linux"}}
{"Programming Language": "C", "Source Code": "static void\nyydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, ap_expr_parse_ctx_t *ctx)\n{\n  YYUSE (yyvaluep);\n  YYUSE (ctx);\n  if (!yymsg)\n    yymsg = \"Deleting\";\n  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  YYUSE (yytype);\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n}", "Selected Statement": "  YYUSE (ctx);\n", "Selected Pointer": "ctx", "Compared Statement": "yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, ap_expr_parse_ctx_t *ctx)\n", "Compared Pointer": "yyvaluep", "Aliasing": "No", "Function Input": {"ctx": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd3b0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"inputbuf": {"type_category": "string", "concrete_type": "string", "value": "0x65207861746e7973 <error: Cannot access memory at address 0x65207861746e7973>"}, "inputlen": {"type_category": "int", "concrete_type": "int", "value": "1919906418"}, "inputptr": {"type_category": "string", "concrete_type": "string", "value": "0x6465746365707865 <error: Cannot access memory at address 0x6465746365707865>"}, "scanner": {"type_category": "pointer", "concrete_type": "VOID"}, "current": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd520", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x72616c2073747570\n", "message": "Cannot access memory at address 0x72616c2073747570"}}, "spares": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd528", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x6e61687420726567\n", "message": "Cannot access memory at address 0x6e61687420726567"}}, "at_start": {"type_category": "int", "concrete_type": "int", "value": "0"}, "pool": {"type_category": "pointer", "concrete_type": "NULL"}, "ptemp": {"type_category": "pointer", "concrete_type": "NULL"}, "expr": {"type_category": "pointer", "concrete_type": "NULL"}, "error": {"type_category": "string", "concrete_type": "NULL"}, "error2": {"type_category": "string", "concrete_type": "NULL"}, "flags": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}, "lookup_fn": {"type_category": "pointer", "concrete_type": "NULL"}}}}, "yymsg": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffde20 \"\\240\\020\\032\\001\""}, "yytype": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "yyvaluep": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd3b8", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"cpVal": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffddc0 \"\\300\\336\\377\\377\\377\\177\""}, "exVal": {"type_category": "pointer", "concrete_type": "RECURSIVE", "value": "0x7fffffffddc0"}, "num": {"type_category": "int", "concrete_type": "int", "value": "-8768"}}}}}, "Program Information": {"Project Name": "apache-httpd"}}
{"Programming Language": "C", "Source Code": "APR_DECLARE(void *) apr_pmemdup(apr_pool_t *a, const void *m, apr_size_t n)\n{\n    void *res;\n\n    if (m == NULL)\n\treturn NULL;\n    res = apr_palloc(a, n);\n    memcpy(res, m, n);\n    return res;\n}", "Selected Statement": "    res = apr_palloc(a, n);\n", "Selected Pointer": "a", "Compared Statement": "    len = strlen(s) + 1;\n", "Compared Pointer": "s", "Aliasing": "No", "Function Input": {"a": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd240", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"parent": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd42d", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xfff7dacbe0000000\n", "message": "Cannot access memory at address 0xfff7dacbe0000000"}}, "child": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd435", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x7f\n", "message": "Cannot access memory at address 0x7f"}}, "sibling": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd43d", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x656c6f6f62000000\n", "message": "Cannot access memory at address 0x656c6f6f62000000"}}, "ref": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd445", "value": {"type_category": "pointer", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x6572707865206e61\n", "message": "Cannot access memory at address 0x6572707865206e61"}}, "cleanups": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd44d", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x646e6524697373\n", "message": "Cannot access memory at address 0x646e6524697373"}}, "free_cleanups": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd455", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x6e696665646e7524\n", "message": "Cannot access memory at address 0x6e696665646e7524"}}, "allocator": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd45d", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x6465\n", "message": "Cannot access memory at address 0x6465"}}, "subprocesses": {"type_category": "pointer", "concrete_type": "NULL"}, "abort_fn": {"type_category": "unknown", "concrete_type": "apr_abortfunc_t"}, "user_data": {"type_category": "pointer", "concrete_type": "NULL"}, "tag": {"type_category": "string", "concrete_type": "NULL"}, "joined": {"type_category": "pointer", "concrete_type": "NULL"}, "nodes": {"type_category": "pointer", "concrete_type": "NULL"}, "file_line": {"type_category": "string", "concrete_type": "NULL"}, "creation_flags": {"type_category": "unknown", "concrete_type": "apr_uint32_t", "value": "1879048192"}, "stat_alloc": {"type_category": "int", "concrete_type": "unsigned int", "value": "7566453"}, "stat_total_alloc": {"type_category": "int", "concrete_type": "unsigned int", "value": "3355443200"}, "stat_clear": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}, "owner": {"type_category": "unknown", "concrete_type": "apr_os_thread_t", "value": "18446743888086433792"}, "mutex": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd4b5", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xffffffd4c000007f\n", "message": "Cannot access memory at address 0xffffffd4c000007f"}}, "pre_cleanups": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd4bd", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x7f\n", "message": "Cannot access memory at address 0x7f"}}}}}, "m": {"type_category": "pointer", "concrete_type": "VOID"}, "n": {"type_category": "unknown", "concrete_type": "apr_size_t", "value": "140737488343776"}}, "Program Information": {"Project Name": "apache-httpd"}}
{"Programming Language": "C", "Source Code": "APR_DECLARE(void) apr_pool_cleanup_register(apr_pool_t *p, const void *data,\n                      apr_status_t (*plain_cleanup_fn)(void *data),\n                      apr_status_t (*child_cleanup_fn)(void *data))\n{\n    cleanup_t *c = NULL;\n\n#if APR_POOL_DEBUG\n    apr_pool_check_integrity(p);\n#endif \n\n    if (p != NULL) {\n        if (p->free_cleanups) {\n            \n            c = p->free_cleanups;\n            p->free_cleanups = c->next;\n        } else {\n            c = apr_palloc(p, sizeof(cleanup_t));\n        }\n        c->data = data;\n        c->plain_cleanup_fn = plain_cleanup_fn;\n        c->child_cleanup_fn = child_cleanup_fn;\n        c->next = p->cleanups;\n        p->cleanups = c;\n    }\n\n#if APR_POOL_DEBUG\n    if (!c || !c->plain_cleanup_fn || !c->child_cleanup_fn) {\n        abort();\n    }\n#endif \n}", "Selected Statement": "        c->child_cleanup_fn = child_cleanup_fn;\n", "Selected Pointer": "child_cleanup_fn", "Compared Statement": "        c->plain_cleanup_fn = plain_cleanup_fn;\n", "Compared Pointer": "plain_cleanup_fn", "Aliasing": "No", "Function Input": {"data": {"type_category": "pointer", "concrete_type": "VOID"}, "p": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"parent": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdfe7", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x7fffffffe4f000\n", "message": "Cannot access memory at address 0x7fffffffe4f000"}}, "child": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdfef", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x7fffffffe02800\n", "message": "Cannot access memory at address 0x7fffffffe02800"}}, "sibling": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdff7", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x119fb7000\n", "message": "Cannot access memory at address 0x119fb7000"}}, "ref": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdfff", "value": {"type_category": "pointer", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x119fd9800\n", "message": "Cannot access memory at address 0x119fd9800"}}, "cleanups": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffe007", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x7a540000\n", "message": "Cannot access memory at address 0x7a540000"}}, "free_cleanups": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffe00f", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x7fffffffe09000\n", "message": "Cannot access memory at address 0x7fffffffe09000"}}, "allocator": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffe017", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x42a39a00\n", "message": "Cannot access memory at address 0x42a39a00"}}, "subprocesses": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffe01f", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x7fffffffdf6000\n", "message": "Cannot access memory at address 0x7fffffffdf6000"}}, "abort_fn": {"type_category": "unknown", "concrete_type": "apr_abortfunc_t"}, "user_data": {"type_category": "pointer", "concrete_type": "NULL"}, "tag": {"type_category": "string", "concrete_type": "NULL"}, "joined": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffe03f", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x7fffffffe2c000\n", "message": "Cannot access memory at address 0x7fffffffe2c000"}}, "nodes": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffe047", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xa0000\n", "message": "Cannot access memory at address 0xa0000"}}, "file_line": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffe09000 <error: Cannot access memory at address 0x7fffffffe09000>"}, "creation_flags": {"type_category": "unknown", "concrete_type": "apr_uint32_t", "value": "1115013120"}, "stat_alloc": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}, "stat_total_alloc": {"type_category": "int", "concrete_type": "unsigned int", "value": "4293212160"}, "stat_clear": {"type_category": "int", "concrete_type": "unsigned int", "value": "8388607"}, "owner": {"type_category": "unknown", "concrete_type": "apr_os_thread_t", "value": "4730523648"}, "mutex": {"type_category": "pointer", "concrete_type": "NULL"}, "pre_cleanups": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffe077", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x7ffff74ff01000\n", "message": "Cannot access memory at address 0x7ffff74ff01000"}}}}}}, "Program Information": {"Project Name": "apache-httpd"}}
{"Programming Language": "C", "Source Code": "APR_DECLARE(char *) apr_cpystrn(char *dst, const char *src, apr_size_t dst_size)\n{\n\n    char *d = dst, *end;\n\n    if (dst_size == 0) {\n        return (dst);\n    }\n\n    if (src) {\n        end = dst + dst_size - 1;\n\n        for (; d < end; ++d, ++src) {\n            if (!(*d = *src)) {\n                return (d);\n            }\n        }\n    }\n\n    *d = '\\0';\t\n\n    return (d);\n}", "Selected Statement": "        for (; d < end; ++d, ++src) {\n", "Selected Pointer": "d", "Compared Statement": "        apr_cpystrn((*argv_out)[argnum], ct, cp - ct);\n", "Compared Pointer": "ct", "Aliasing": "No", "Function Input": {"dst": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "dst_size": {"type_category": "unknown", "concrete_type": "apr_size_t", "value": "18488048"}, "src": {"type_category": "string", "concrete_type": "string", "value": "0x6d1d39 \"strings/apr_cpystrn.c:178\""}}, "Program Information": {"Project Name": "apache-httpd"}}
{"Programming Language": "C", "Source Code": "APR_DECLARE(apr_status_t) apr_parse_addr_port(char **addr,\n                                              char **scope_id,\n                                              apr_port_t *port,\n                                              const char *str,\n                                              apr_pool_t *p)\n{\n    const char *ch, *lastchar;\n    int big_port;\n    apr_size_t addrlen;\n\n    *addr = NULL;         \n    *scope_id = NULL;     \n    *port = 0;            \n\n    \n    ch = lastchar = str + strlen(str) - 1;\n    while (ch >= str && apr_isdigit(*ch)) {\n        --ch;\n    }\n\n    if (ch < str) {       \n        big_port = atoi(str);\n        if (big_port < 1 || big_port > 65535) {\n            return APR_EINVAL;\n        }\n        *port = big_port;\n        return APR_SUCCESS;\n    }\n\n    if (*ch == ':' && ch < lastchar) { \n        if (ch == str) {               \n            return APR_EINVAL;\n        }\n        big_port = atoi(ch + 1);\n        if (big_port < 1 || big_port > 65535) {\n            return APR_EINVAL;\n        }\n        *port = big_port;\n        lastchar = ch - 1;\n    }\n\n    \n    addrlen = lastchar - str + 1;\n\n\n#if APR_HAVE_IPV6\n    if (*str == '[') {\n        const char *end_bracket = memchr(str, ']', addrlen);\n        struct in6_addr ipaddr;\n        const char *scope_delim;\n\n        if (!end_bracket || end_bracket != lastchar) {\n            *port = 0;\n            return APR_EINVAL;\n        }\n\n        \n        scope_delim = memchr(str, '%', addrlen);\n        if (scope_delim) {\n            if (scope_delim == end_bracket - 1) { \n                *port = 0;\n                return APR_EINVAL;\n            }\n            addrlen = scope_delim - str - 1;\n            *scope_id = apr_pstrmemdup(p, scope_delim + 1, end_bracket - scope_delim - 1);\n        }\n        else {\n            addrlen = addrlen - 2; \n        }\n\n        *addr = apr_pstrmemdup(p, str + 1, addrlen);\n        if (apr_inet_pton(AF_INET6, *addr, &ipaddr) != 1) {\n            *addr = NULL;\n            *scope_id = NULL;\n            *port = 0;\n            return APR_EINVAL;\n        }\n    }\n    else\n#endif\n    {\n        \n        *addr = apr_pstrmemdup(p, str, addrlen);\n    }\n    return APR_SUCCESS;\n}", "Selected Statement": "        big_port = atoi(str);\n", "Selected Pointer": "ch", "Compared Statement": "    ch = lastchar = str + strlen(str) - 1;\n", "Compared Pointer": "lastchar", "Aliasing": "Yes", "Function Input": {"addr": {"type_category": "pointer", "concrete_type": "NULL"}, "p": {"type_category": "pointer", "concrete_type": "NULL"}, "port": {"type_category": "pointer", "concrete_type": "NULL"}, "scope_id": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdea8", "value": {"type_category": "string", "concrete_type": "string", "value": "0x4c6421a74c08548 <error: Cannot access memory at address 0x4c6421a74c08548>"}}, "str": {"type_category": "string", "concrete_type": "string", "value": "0x11a10b0 \"\""}}, "Program Information": {"Project Name": "apache-httpd"}}
{"Programming Language": "C", "Source Code": "APR_DECLARE(char *) apr_pstrmemdup(apr_pool_t *a, const char *s, apr_size_t n)\n{\n    char *res;\n\n    if (s == NULL) {\n        return NULL;\n    }\n    res = apr_palloc(a, n + 1);\n    memcpy(res, s, n);\n    res[n] = '\\0';\n    return res;\n}", "Selected Statement": "    res = apr_palloc(a, n + 1);\n", "Selected Pointer": "a", "Compared Statement": "    memcpy(res, s, n);\n", "Compared Pointer": "res", "Aliasing": "No", "Function Input": {"a": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdce0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x1\n", "message": "Cannot access memory at address 0x1"}}, "n": {"type_category": "unknown", "concrete_type": "apr_size_t", "value": "140737488346336"}, "s": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdce0 \"\\001\""}}, "Program Information": {"Project Name": "apache-httpd"}}
{"Programming Language": "C", "Source Code": "void nxt_cdecl\nnxt_log_handler(nxt_uint_t level, nxt_log_t *log, const char *fmt, ...)\n{\n    u_char   *p, *end;\n#if 0\n    u_char   *syslogmsg;\n#endif\n    va_list  args;\n    u_char   msg[NXT_MAX_ERROR_STR];\n\n    p = msg;\n    end = msg + NXT_MAX_ERROR_STR;\n\n    if (nxt_log_prefix != NULL) {\n        p = nxt_cpystrn(p, nxt_log_prefix, end - p);\n        *p++ = ':';\n        *p++ = ' ';\n    }\n\n#if 0\n    syslogmsg = p;\n#endif\n\n    p = nxt_sprintf(p, end, (log->ident != 0) ? \"[%V] *%D \" : \"[%V] \",\n                    &nxt_log_levels[level], log->ident);\n\n    va_start(args, fmt);\n    p = nxt_vsprintf(p, end, fmt, args);\n    va_end(args);\n\n    if (level != NXT_LOG_DEBUG && log->ctx_handler != NULL) {\n        p = log->ctx_handler(log->ctx, p, end);\n    }\n\n    if (p > end - nxt_length(\"\\n\")) {\n        p = end - nxt_length(\"\\n\");\n    }\n\n    *p++ = '\\n';\n\n    (void) nxt_write_console(nxt_stderr, msg, p - msg);\n\n#if 0\n    if (level == NXT_LOG_ALERT) {\n        *(p - nxt_length(\"\\n\")) = '\\0';\n\n        \n        nxt_write_syslog(LOG_ALERT, syslogmsg);\n    }\n#endif\n}", "Selected Statement": "    p = nxt_vsprintf(p, end, fmt, args);\n", "Selected Pointer": "end", "Compared Statement": "nxt_log_handler(nxt_uint_t level, nxt_log_t *log, const char *fmt, ...)\n", "Compared Pointer": "log", "Aliasing": "No", "Function Input": {"fmt": {"type_category": "string", "concrete_type": "string", "value": "0x1074bf0 \"1]\\033\\001\""}, "level": {"type_category": "unknown", "concrete_type": "nxt_uint_t", "value": "0"}, "log": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdcd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"level": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "6477904"}, "ident": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, "handler": {"type_category": "unknown", "concrete_type": "nxt_log_handler_t"}, "ctx_handler": {"type_category": "unknown", "concrete_type": "nxt_log_ctx_handler_t"}, "ctx": {"type_category": "pointer", "concrete_type": "NULL"}}}}}, "Program Information": {"Project Name": "unit"}}
{"Programming Language": "C", "Source Code": "void\nnxt_rbtree_insert(nxt_rbtree_t *tree, nxt_rbtree_part_t *part)\n{\n    nxt_rbtree_node_t     *node, *new_node, *sentinel, **child;\n    nxt_rbtree_compare_t  compare;\n\n    new_node = (nxt_rbtree_node_t *) part;\n\n    node = nxt_rbtree_root(tree);\n    sentinel = nxt_rbtree_sentinel(tree);\n\n    new_node->left = sentinel;\n    new_node->right = sentinel;\n    new_node->color = NXT_RBTREE_RED;\n\n    compare = (nxt_rbtree_compare_t) tree->sentinel.right;\n    child = &nxt_rbtree_root(tree);\n\n    while (*child != sentinel) {\n        node = *child;\n\n        nxt_prefetch(node->left);\n        nxt_prefetch(node->right);\n\n        child = (compare(new_node, node) < 0) ? &node->left : &node->right;\n    }\n\n    *child = new_node;\n    new_node->parent = node;\n\n    nxt_rbtree_insert_fixup(new_node);\n\n    node = nxt_rbtree_root(tree);\n    node->color = NXT_RBTREE_BLACK;\n}", "Selected Statement": "    node = nxt_rbtree_root(tree);\n", "Selected Pointer": "node", "Compared Statement": "nxt_rbtree_insert(nxt_rbtree_t *tree, nxt_rbtree_part_t *part)\n", "Compared Pointer": "part", "Aliasing": "No", "Function Input": {"part": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdb60", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x80\n", "message": "Cannot access memory at address 0x80"}}, "tree": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdb68", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"sentinel": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"left": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x1076780", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xaaaaaaaaaaaaaaaa\n", "message": "Cannot access memory at address 0xaaaaaaaaaaaaaaaa"}}, "right": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x1076788", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xaaaaaaaaaaaaaaaa\n", "message": "Cannot access memory at address 0xaaaaaaaaaaaaaaaa"}}, "parent": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x1076790", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xaaaaaaaaaaaaaaaa\n", "message": "Cannot access memory at address 0xaaaaaaaaaaaaaaaa"}}, "color": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "170 '\\252'"}}}}}}}, "Program Information": {"Project Name": "unit"}}
{"Programming Language": "C", "Source Code": "nxt_int_t\nnxt_http_parse_request(nxt_http_request_parse_t *rp, nxt_buf_mem_t *b)\n{\n    nxt_int_t  rc;\n\n    if (rp->handler == NULL) {\n        rp->handler = &nxt_http_parse_request_line;\n    }\n\n    do {\n        rc = rp->handler(rp, &b->pos, b->free);\n    } while (rc == NXT_OK);\n\n    return rc;\n}", "Selected Statement": "        rc = rp->handler(rp, &b->pos, b->free);\n", "Selected Pointer": "rp", "Compared Statement": "nxt_http_parse_request(nxt_http_request_parse_t *rp, nxt_buf_mem_t *b)\n", "Compared Pointer": "b", "Aliasing": "No", "Function Input": {"b": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdcf0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"pos": {"type_category": "string", "concrete_type": "NULL"}, "free": {"type_category": "string", "concrete_type": "NULL"}, "start": {"type_category": "string", "concrete_type": "NULL"}, "end": {"type_category": "string", "concrete_type": "NULL"}}}}, "rp": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdcf8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x400\n", "message": "Cannot access memory at address 0x400"}}}, "Program Information": {"Project Name": "unit"}}
{"Programming Language": "C", "Source Code": "enum utf8_state\nutf8_open(struct utf8_data *ud, u_char ch)\n{\n\tmemset(ud, 0, sizeof *ud);\n\tif (ch >= 0xc2 && ch <= 0xdf)\n\t\tud->size = 2;\n\telse if (ch >= 0xe0 && ch <= 0xef)\n\t\tud->size = 3;\n\telse if (ch >= 0xf0 && ch <= 0xf4)\n\t\tud->size = 4;\n\telse\n\t\treturn (UTF8_ERROR);\n\tutf8_append(ud, ch);\n\treturn (UTF8_MORE);\n}", "Selected Statement": "\tmemset(ud, 0, sizeof *ud);\n", "Selected Pointer": "ud", "Compared Statement": "\twhile (s < end) {\n", "Compared Pointer": "s", "Aliasing": "No", "Function Input": {"ch": {"type_category": "unknown", "concrete_type": "u_char", "value": "97 'a'"}, "ud": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdcc0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"data": {"type_category": "string", "concrete_type": "string", "value": "\"\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\""}, "have": {"type_category": "unknown", "concrete_type": "u_char", "value": "0 '\\000'"}, "size": {"type_category": "unknown", "concrete_type": "u_char", "value": "0 '\\000'"}, "width": {"type_category": "unknown", "concrete_type": "u_char", "value": "0 '\\000'"}}}}}, "Program Information": {"Project Name": "tmux"}}
{"Programming Language": "C", "Source Code": "stun_attr_ref stun_attr_get_next_str(const uint8_t *buf, size_t len, stun_attr_ref prev) {\n\n  if (!prev) {\n    return stun_attr_get_first_str(buf, len);\n  } else {\n    const uint8_t *end = buf + stun_get_command_message_len_str(buf, len);\n    int attrlen = stun_attr_get_len(prev);\n    uint16_t rem4 = ((uint16_t)attrlen) & 0x0003;\n    if (rem4) {\n      attrlen = attrlen + 4 - (int)rem4;\n    }\n    \n    if (attrlen < end - (const uint8_t *)prev - 4) {\n      const uint8_t *attr_end = (const uint8_t *)prev + 4 + attrlen;\n      return stun_attr_check_valid(attr_end, end - attr_end);\n    }\n    return NULL;\n  }\n}", "Selected Statement": "    const uint8_t *end = buf + stun_get_command_message_len_str(buf, len);\n", "Selected Pointer": "buf", "Compared Statement": "    if (attrlen < end - (const uint8_t *)prev - 4) {\n", "Compared Pointer": "end", "Aliasing": "No", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0xed11d0 \"\""}, "len": {"type_category": "unknown", "concrete_type": "size_t", "value": "140737488345552"}, "prev": {"type_category": "unknown", "concrete_type": "stun_attr_ref", "value": "0xed11d0"}}, "Program Information": {"Project Name": "coturn"}}
{"Programming Language": "C", "Source Code": "int stun_check_message_integrity_by_key_str(turn_credential_type ct, uint8_t *buf, size_t len, hmackey_t key,\n                                            password_t pwd, SHATYPE shatype) {\n  int res = 0;\n  uint8_t new_hmac[MAXSHASIZE] = {0};\n  unsigned int shasize;\n  const uint8_t *old_hmac = NULL;\n\n  stun_attr_ref sar = stun_attr_get_first_by_type_str(buf, len, STUN_ATTRIBUTE_MESSAGE_INTEGRITY);\n  if (!sar) {\n    return -1;\n  }\n\n  int sarlen = stun_attr_get_len(sar);\n\n  switch (sarlen) {\n  case SHA256SIZEBYTES:\n    shasize = SHA256SIZEBYTES;\n    if (shatype != SHATYPE_SHA256) {\n      return -1;\n    }\n    break;\n  case SHA384SIZEBYTES:\n    shasize = SHA384SIZEBYTES;\n    if (shatype != SHATYPE_SHA384) {\n      return -1;\n    }\n    break;\n  case SHA512SIZEBYTES:\n    shasize = SHA512SIZEBYTES;\n    if (shatype != SHATYPE_SHA512) {\n      return -1;\n    }\n    break;\n  case SHA1SIZEBYTES:\n    shasize = SHA1SIZEBYTES;\n    if (shatype != SHATYPE_SHA1) {\n      return -1;\n    }\n    break;\n  default:\n    return -1;\n  };\n\n  int orig_len = stun_get_command_message_len_str(buf, len);\n  if (orig_len < 0) {\n    return -1;\n  }\n\n  int new_len = (int)((const uint8_t *)sar - buf) + 4 + shasize;\n  if (new_len > orig_len) {\n    return -1;\n  }\n\n  if (stun_set_command_message_len_str(buf, new_len) < 0) {\n    return -1;\n  }\n\n  if (ct == TURN_CREDENTIALS_SHORT_TERM) {\n    res =\n        stun_calculate_hmac(buf, (size_t)new_len - 4 - shasize, pwd, strlen((char *)pwd), new_hmac, &shasize, shatype);\n  } else {\n    res = stun_calculate_hmac(buf, (size_t)new_len - 4 - shasize, key, get_hmackey_size(shatype), new_hmac, &shasize,\n                              shatype);\n  }\n\n  stun_set_command_message_len_str(buf, orig_len);\n  if (res < 0) {\n    return -1;\n  }\n\n  old_hmac = stun_attr_get_value(sar);\n  if (!old_hmac) {\n    return -1;\n  }\n\n  if (memcmp(old_hmac, new_hmac, shasize)) {\n    return 0;\n  }\n\n  return +1;\n}", "Selected Statement": "  if (memcmp(old_hmac, new_hmac, shasize)) {\n", "Selected Pointer": "new_hmac", "Compared Statement": "  stun_set_command_message_len_str(buf, orig_len);\n", "Compared Pointer": "buf", "Aliasing": "No", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0xc <error: Cannot access memory at address 0xc>"}, "ct": {"type_category": "unknown", "concrete_type": "turn_credential_type", "value": "4"}, "key": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdc10 \"VOkJxbRl1RmTxUk/WvJxBt\""}, "len": {"type_category": "unknown", "concrete_type": "size_t", "value": "5009782"}, "pwd": {"type_category": "string", "concrete_type": "string", "value": "0x400001000 <error: Cannot access memory at address 0x400001000>"}, "shatype": {"type_category": "unknown", "concrete_type": "SHATYPE", "value": "SHATYPE_DEFAULT"}}, "Program Information": {"Project Name": "coturn"}}
{"Programming Language": "C", "Source Code": "static int\ni_free_callout_name_entry(st_callout_name_key* key, CalloutNameEntry* e,\n                          void* arg ARG_UNUSED)\n{\n  if (IS_NOT_NULL(e)) {\n    xfree(e->name);\n  }\n   \n  xfree(key);\n  xfree(e);\n  return ST_DELETE;\n}", "Selected Statement": "  xfree(e);\n", "Selected Pointer": "e", "Compared Statement": "  xfree(key);\n", "Compared Pointer": "key", "Aliasing": "No", "Function Input": {"e": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd970", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"name": {"type_category": "string", "concrete_type": "string", "value": "0x800000008 <error: Cannot access memory at address 0x800000008>"}, "name_len": {"type_category": "int", "concrete_type": "int", "value": "0"}, "id": {"type_category": "int", "concrete_type": "int", "value": "1"}}}}, "key": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd978", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"enc": {"type_category": "unknown", "concrete_type": "OnigEncoding", "value": "0x5434d0 <mbc_enc_len>"}, "type": {"type_category": "int", "concrete_type": "int", "value": "6147397"}, "s": {"type_category": "string", "concrete_type": "string", "value": "0x100000003 <error: Cannot access memory at address 0x100000003>"}, "end": {"type_category": "string", "concrete_type": "string", "value": "0x532bc0 <onigenc_is_mbc_newline_0x0a> \"UH\\211\\345H\\203\\354 \\212\\004%\\247\\245e\""}}}}}, "Program Information": {"Project Name": "oniguruma"}}
{"Programming Language": "C", "Source Code": "static int\nsearch(regex_t* reg, unsigned char* str, unsigned char* end, OnigOptionType options, int backward, int sl)\n{\n  int r;\n  unsigned char *start, *range;\n  OnigRegion *region;\n  unsigned int retry_limit;\n  size_t len;\n\n  region = onig_region_new();\n\n  len = (size_t )(end - str);\n  retry_limit = calc_retry_limit(sl, len);\n\n  onig_set_retry_limit_in_search(retry_limit);\n  onig_set_match_stack_limit_size(MATCH_STACK_LIMIT);\n  if (sl >= 2)\n    onig_set_subexp_call_limit_in_search(SLOW_SUBEXP_CALL_LIMIT);\n  else\n    onig_set_subexp_call_limit_in_search(SUBEXP_CALL_LIMIT);\n\n#ifdef STANDALONE\n  fprintf(stdout, \"retry limit: %u\\n\", retry_limit);\n  fprintf(stdout, \"end - str: %td\\n\", end - str);\n#endif\n\n  if (backward != 0) {\n    start = end;\n    range = str;\n  }\n  else {\n    start = str;\n    range = end;\n  }\n\n  r = onig_search(reg, str, end, start, range, region, (options & OPTIONS_AT_RUNTIME));\n  if (r >= 0) {\n#ifdef STANDALONE\n    int i;\n\n    fprintf(stdout, \"match at %d  (%s)\\n\", r,\n            ONIGENC_NAME(onig_get_encoding(reg)));\n    for (i = 0; i < region->num_regs; i++) {\n      fprintf(stdout, \"%d: (%d-%d)\\n\", i, region->beg[i], region->end[i]);\n    }\n#endif\n  }\n  else if (r == ONIG_MISMATCH) {\n#ifdef STANDALONE\n    fprintf(stdout, \"search fail (%s)\\n\",\n            ONIGENC_NAME(onig_get_encoding(reg)));\n#endif\n  }\n  else { \n#ifdef STANDALONE\n    char s[ONIG_MAX_ERROR_MESSAGE_LEN];\n\n    onig_error_code_to_str((UChar* )s, r);\n    fprintf(stdout, \"ERROR: %s\\n\", s);\n    fprintf(stdout, \"  (%s)\\n\", ONIGENC_NAME(onig_get_encoding(reg)));\n#endif\n    onig_region_free(region, 1 );\n\n    if (r == ONIGERR_STACK_BUG ||\n        r == ONIGERR_UNDEFINED_BYTECODE ||\n        r == ONIGERR_UNEXPECTED_BYTECODE)\n      return -2;\n\n    return -1;\n  }\n\n  onig_region_free(region, 1 );\n  return 0;\n}", "Selected Statement": "  if (r >= 0) {\n", "Selected Pointer": "end", "Compared Statement": "  r = onig_search(reg, str, end, start, range, region, (options & OPTIONS_AT_RUNTIME));\n", "Compared Pointer": "str", "Aliasing": "Yes", "Function Input": {"backward": {"type_category": "int", "concrete_type": "int", "value": "37761456"}, "end": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdad0 \"\\220\\334\\377\\377\\377\\177\""}, "options": {"type_category": "unknown", "concrete_type": "OnigOptionType", "value": "0"}, "reg": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdac0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"ops": {"type_category": "pointer", "concrete_type": "NULL"}, "ocs": {"type_category": "pointer", "concrete_type": "NULL"}, "ops_curr": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x24031c0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x20\n", "message": "Cannot access memory at address 0x20"}}, "ops_used": {"type_category": "int", "concrete_type": "unsigned int", "value": "81"}, "ops_alloc": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}, "string_pool": {"type_category": "string", "concrete_type": "string", "value": "0x736163747365742f <error: Cannot access memory at address 0x736163747365742f>"}, "string_pool_end": {"type_category": "string", "concrete_type": "string", "value": "0x3563636265642f65 <error: Cannot access memory at address 0x3563636265642f65>"}, "num_mem": {"type_category": "int", "concrete_type": "int", "value": "842019892"}, "num_repeat": {"type_category": "int", "concrete_type": "int", "value": "1684156774"}, "num_empty_check": {"type_category": "int", "concrete_type": "int", "value": "1714512944"}, "num_call": {"type_category": "int", "concrete_type": "int", "value": "929313844"}, "capture_history": {"type_category": "unknown", "concrete_type": "MemStatusType", "value": "859005284"}, "push_mem_start": {"type_category": "unknown", "concrete_type": "MemStatusType", "value": "875574067"}, "push_mem_end": {"type_category": "unknown", "concrete_type": "MemStatusType", "value": "909455673"}, "stack_pop_level": {"type_category": "int", "concrete_type": "int", "value": "1680947298"}, "repeat_range_alloc": {"type_category": "int", "concrete_type": "int", "value": "12642"}, "repeat_range": {"type_category": "pointer", "concrete_type": "NULL"}, "enc": {"type_category": "unknown", "concrete_type": "OnigEncoding"}, "options": {"type_category": "unknown", "concrete_type": "OnigOptionType", "value": "81"}, "syntax": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x2403220", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x736163747365742f\n", "message": "Cannot access memory at address 0x736163747365742f"}}, "case_fold_flag": {"type_category": "unknown", "concrete_type": "OnigCaseFoldType", "value": "1664167781"}, "name_table": {"type_category": "pointer", "concrete_type": "VOID"}, "optimize": {"type_category": "int", "concrete_type": "int", "value": "892547939"}, "threshold_len": {"type_category": "int", "concrete_type": "int", "value": "1717711159"}, "anchor": {"type_category": "int", "concrete_type": "int", "value": "878786872"}, "anc_dist_min": {"type_category": "unknown", "concrete_type": "OnigLen", "value": "859071331"}, "anc_dist_max": {"type_category": "unknown", "concrete_type": "OnigLen", "value": "808609334"}, "sub_anchor": {"type_category": "int", "concrete_type": "int", "value": "1714971448"}, "exact": {"type_category": "string", "concrete_type": "string", "value": "0x3834 <error: Cannot access memory at address 0x3834>"}, "exact_end": {"type_category": "string", "concrete_type": "NULL"}, "map": {"type_category": "string", "concrete_type": "string", "value": "\"\\000\\000\\000\\000\\000\\000\\000\\000Q\\000\\000\\000\\000\\000\\000\\000/testcase/4f09b2b8f37ac6c432a911b42ac14b49386e22d9\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000Q\\000\\000\\000\\000\\000\\000\\000/testcase/d55d1bb83c8c8f86f39cbbe7d20ebc9237a3182a\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000Q\\000\\000\\000\\000\\000\\000\\000/testcase/cb14cb228922242f5328c343bfbf5e215f5f3e00\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000Q\\000\\000\\000\\000\\000\\000\""}, "map_offset": {"type_category": "int", "concrete_type": "int", "value": "1936028719"}, "dist_min": {"type_category": "unknown", "concrete_type": "OnigLen", "value": "1935762292"}, "dist_max": {"type_category": "unknown", "concrete_type": "OnigLen", "value": "1684418405"}, "extp": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x2403370", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x6664383534646334\n", "message": "Cannot access memory at address 0x6664383534646334"}}}}}, "sl": {"type_category": "int", "concrete_type": "int", "value": "0"}, "str": {"type_category": "string", "concrete_type": "string", "value": "0x24031b0 \"\""}}, "Program Information": {"Project Name": "oniguruma"}}
{"Programming Language": "C", "Source Code": "static int\ncompile_string_node(Node* node, regex_t* reg)\n{\n  int r, len, prev_len, slen;\n  UChar *p, *prev, *end;\n  StrNode* sn;\n  OnigEncoding enc = reg->enc;\n\n  sn = STR_(node);\n  if (sn->end <= sn->s)\n    return 0;\n\n  end = sn->end;\n\n  p = prev = sn->s;\n  prev_len = enclen(enc, p);\n  p += prev_len;\n  slen = 1;\n\n  for (; p < end; ) {\n    len = enclen(enc, p);\n    if (len == prev_len) {\n      slen++;\n    }\n    else {\n      r = add_compile_string(prev, prev_len, slen, reg);\n      if (r != 0) return r;\n\n      prev  = p;\n      slen  = 1;\n      prev_len = len;\n    }\n\n    p += len;\n  }\n\n  return add_compile_string(prev, prev_len, slen, reg);\n}", "Selected Statement": "  sn = STR_(node);\n", "Selected Pointer": "sn", "Compared Statement": "  return add_compile_string(prev, prev_len, slen, reg);\n", "Compared Pointer": "reg", "Aliasing": "No", "Function Input": {"node": {"type_category": "pointer", "concrete_type": "NULL"}, "reg": {"type_category": "pointer", "concrete_type": "NULL"}}, "Program Information": {"Project Name": "oniguruma"}}
{"Programming Language": "C", "Source Code": "static void dds_stream_get_ops_info1 (const uint32_t * __restrict ops, uint32_t nestc, struct dds_cdrstream_ops_info *info)\n{\n  uint32_t insn;\n  if (info->nesting_max < nestc)\n    info->nesting_max = nestc;\n  while ((insn = *ops) != DDS_OP_RTS)\n  {\n    switch (DDS_OP (insn))\n    {\n      case DDS_OP_ADR: {\n        if (info->toplevel_op == NULL)\n        {\n          info->toplevel_op = ops;\n          if (DDS_OP_TYPE (insn) != DDS_OP_VAL_UNI)\n            info->data_types |= DDS_DATA_TYPE_CONTAINS_STRUCT;\n        }\n        if ((insn & DDS_OP_FLAG_KEY) && nestc == 0)\n          info->data_types |= DDS_DATA_TYPE_CONTAINS_KEY;\n        if (op_type_optional (insn))\n        {\n          info->min_xcdrv = DDSI_RTPS_CDR_ENC_VERSION_2;\n          info->data_types |= DDS_DATA_TYPE_CONTAINS_OPTIONAL;\n        }\n        if (op_type_external (insn) && DDS_OP_TYPE (insn) != DDS_OP_VAL_STR)\n          info->data_types |= DDS_DATA_TYPE_CONTAINS_EXTERNAL;\n        switch (DDS_OP_TYPE (insn))\n        {\n          case DDS_OP_VAL_BLN: case DDS_OP_VAL_1BY: case DDS_OP_VAL_2BY: case DDS_OP_VAL_4BY: case DDS_OP_VAL_8BY:\n            ops += 2;\n            break;\n          case DDS_OP_VAL_STR:\n            ops += 2;\n            info->data_types |= DDS_DATA_TYPE_CONTAINS_STRING;\n            break;\n          case DDS_OP_VAL_BST:\n            ops += 3;\n            info->data_types |= DDS_DATA_TYPE_CONTAINS_BSTRING;\n            break;\n          case DDS_OP_VAL_ENU:\n            ops += 3;\n            info->data_types |= DDS_DATA_TYPE_CONTAINS_ENUM;\n            break;\n          case DDS_OP_VAL_BMK:\n            ops += 4;\n            info->data_types |= DDS_DATA_TYPE_CONTAINS_BITMASK;\n            break;\n          case DDS_OP_VAL_SEQ:\n            ops = dds_stream_get_ops_info_seq (ops, insn, nestc, info);\n            info->data_types |= DDS_DATA_TYPE_CONTAINS_SEQUENCE;\n            break;\n          case DDS_OP_VAL_BSQ:\n            ops = dds_stream_get_ops_info_seq (ops, insn, nestc, info);\n            info->data_types |= DDS_DATA_TYPE_CONTAINS_BSEQUENCE;\n            break;\n          case DDS_OP_VAL_ARR:\n            ops = dds_stream_get_ops_info_arr (ops, insn, nestc, info);\n            info->data_types |= DDS_DATA_TYPE_CONTAINS_ARRAY;\n            break;\n          case DDS_OP_VAL_UNI:\n            ops = dds_stream_get_ops_info_uni (ops, nestc, info);\n            info->data_types |= DDS_DATA_TYPE_CONTAINS_UNION;\n            break;\n          case DDS_OP_VAL_EXT: {\n            const uint32_t *jsr_ops = ops + DDS_OP_ADR_JSR (ops[2]);\n            const uint32_t jmp = DDS_OP_ADR_JMP (ops[2]);\n            if (DDS_OP_ADR_JSR (ops[2]) > 0)\n              dds_stream_get_ops_info1 (jsr_ops, nestc + 1, info);\n            ops += jmp ? jmp : 3;\n            break;\n          }\n          case DDS_OP_VAL_STU:\n            abort (); \n            break;\n        }\n        break;\n      }\n      case DDS_OP_JSR: {\n        if (DDS_OP_JUMP (insn) > 0)\n          dds_stream_get_ops_info1 (ops + DDS_OP_JUMP (insn), nestc, info);\n        ops++;\n        break;\n      }\n      case DDS_OP_RTS: case DDS_OP_JEQ: case DDS_OP_JEQ4: case DDS_OP_KOF: case DDS_OP_PLM: {\n        abort ();\n        break;\n      }\n      case DDS_OP_DLC: {\n        info->min_xcdrv = DDSI_RTPS_CDR_ENC_VERSION_2;\n        ops++;\n        break;\n      }\n      case DDS_OP_PLC: {\n        info->min_xcdrv = DDSI_RTPS_CDR_ENC_VERSION_2;\n        ops = dds_stream_get_ops_info_pl (ops, nestc, info);\n        break;\n      }\n    }\n  }\n  ++ops; \n  if (ops > info->ops_end)\n    info->ops_end = ops;\n}", "Selected Statement": "            info->data_types |= DDS_DATA_TYPE_CONTAINS_STRING;\n", "Selected Pointer": "ops", "Compared Statement": "  desc->flagset |= dds_stream_key_flags (desc, NULL, NULL);\n", "Compared Pointer": "desc", "Aliasing": "Yes", "Function Input": {"nestc": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "<optimized out>"}}, "Program Information": {"Project Name": "cyclonedds"}}
{"Programming Language": "C", "Source Code": "static bool\nucl_parse_key (struct ucl_parser *parser, struct ucl_chunk *chunk,\n\t\tbool *next_key, bool *end_of_object)\n{\n\tconst unsigned char *p, *c = NULL, *end, *t;\n\tconst char *key = NULL;\n\tbool got_quote = false, got_eq = false, got_semicolon = false,\n\t\t\tneed_unescape = false, ucl_escape = false, var_expand = false,\n\t\t\tgot_content = false, got_sep = false;\n\tucl_object_t *nobj;\n\tssize_t keylen;\n\n\tp = chunk->pos;\n\n\tif (*p == '.') {\n\t\t\n\t\tif (!(parser->flags & UCL_PARSER_DISABLE_MACRO)) {\n\t\t\tucl_chunk_skipc (chunk, p);\n\t\t}\n\n\t\tparser->prev_state = parser->state;\n\t\tparser->state = UCL_STATE_MACRO_NAME;\n\t\t*end_of_object = false;\n\t\treturn true;\n\t}\n\twhile (p < chunk->end) {\n\t\t\n\t\tif (c == NULL) {\n\t\t\tif (chunk->remain >= 2 && ucl_lex_is_comment (p[0], p[1])) {\n\t\t\t\tif (!ucl_skip_comments (parser)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tp = chunk->pos;\n\t\t\t}\n\t\t\telse if (ucl_test_character (*p, UCL_CHARACTER_WHITESPACE_UNSAFE)) {\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t}\n\t\t\telse if (ucl_test_character (*p, UCL_CHARACTER_KEY_START)) {\n\t\t\t\t\n\t\t\t\tc = p;\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\tgot_content = true;\n\t\t\t}\n\t\t\telse if (*p == '\"') {\n\t\t\t\t\n\t\t\t\tc = p + 1;\n\t\t\t\tgot_quote = true;\n\t\t\t\tgot_content = true;\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t}\n\t\t\telse if (*p == '}') {\n\t\t\t\t\n\t\t\t\t*end_of_object = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (*p == '.') {\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_MACRO_NAME;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t\n\t\t\t\tucl_set_err (parser, UCL_ESYNTAX, \"key must begin with a letter\",\n\t\t\t\t\t\t&parser->err);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\tif (!got_quote) {\n\t\t\t\tif (ucl_test_character (*p, UCL_CHARACTER_KEY)) {\n\t\t\t\t\tgot_content = true;\n\t\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\t}\n\t\t\t\telse if (ucl_test_character (*p, UCL_CHARACTER_KEY_SEP)) {\n\t\t\t\t\tend = p;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tucl_set_err (parser, UCL_ESYNTAX, \"invalid character in a key\",\n\t\t\t\t\t\t\t&parser->err);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t\n\t\t\t\tif (!ucl_lex_json_string (parser, chunk, &need_unescape, &ucl_escape, &var_expand)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tend = chunk->pos - 1;\n\t\t\t\tp = chunk->pos;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (p >= chunk->end && got_content) {\n\t\tucl_set_err (parser, UCL_ESYNTAX, \"unfinished key\", &parser->err);\n\t\treturn false;\n\t}\n\telse if (!got_content) {\n\t\treturn true;\n\t}\n\t*end_of_object = false;\n\t\n\twhile (p < chunk->end) {\n\t\tif (ucl_test_character (*p, UCL_CHARACTER_WHITESPACE)) {\n\t\t\tucl_chunk_skipc (chunk, p);\n\t\t}\n\t\telse if (*p == '=') {\n\t\t\tif (!got_eq && !got_semicolon) {\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\tgot_eq = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tucl_set_err (parser, UCL_ESYNTAX, \"unexpected '=' character\",\n\t\t\t\t\t\t&parser->err);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse if (*p == ':') {\n\t\t\tif (!got_eq && !got_semicolon) {\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\tgot_semicolon = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tucl_set_err (parser, UCL_ESYNTAX, \"unexpected ':' character\",\n\t\t\t\t\t\t&parser->err);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse if (chunk->remain >= 2 && ucl_lex_is_comment (p[0], p[1])) {\n\t\t\t\n\t\t\tif (!ucl_skip_comments (parser)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tp = chunk->pos;\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (p >= chunk->end && got_content) {\n\t\tucl_set_err (parser, UCL_ESYNTAX, \"unfinished key\", &parser->err);\n\t\treturn false;\n\t}\n\n\tgot_sep = got_semicolon || got_eq;\n\n\tif (!got_sep) {\n\t\t\n\t\tt = p;\n\t\t*next_key = false;\n\t\twhile (ucl_test_character (*t, UCL_CHARACTER_WHITESPACE)) {\n\t\t\tt ++;\n\t\t}\n\t\t\n\t\tif (*t != '{' && *t != '[') {\n\t\t\twhile (t < chunk->end) {\n\t\t\t\tif (*t == ',' || *t == ';' || *t == '\\n' || *t == '\\r') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (*t == '{' || *t == '[') {\n\t\t\t\t\t*next_key = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tt ++;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tnobj = ucl_object_new_full (UCL_NULL, parser->chunks->priority);\n\tif (nobj == NULL) {\n\t\treturn false;\n\t}\n\tkeylen = ucl_copy_or_store_ptr (parser, c, &nobj->trash_stack[UCL_TRASH_KEY],\n\t\t\t&key, end - c, need_unescape, parser->flags & UCL_PARSER_KEY_LOWERCASE,\n\t\t\tfalse, false);\n\tif (keylen == -1) {\n\t\tucl_object_unref (nobj);\n\t\treturn false;\n\t}\n\telse if (keylen == 0) {\n\t\tucl_set_err (parser, UCL_ESYNTAX, \"empty keys are not allowed\", &parser->err);\n\t\tucl_object_unref (nobj);\n\t\treturn false;\n\t}\n\n\tnobj->key = key;\n\tnobj->keylen = keylen;\n\n\tif (!ucl_parser_process_object_element (parser, nobj)) {\n\t\treturn false;\n\t}\n\n\tif (ucl_escape) {\n\t\tnobj->flags |= UCL_OBJECT_NEED_KEY_ESCAPE;\n\t}\n\n\n\treturn true;\n}", "Selected Statement": "\t\t\t\tc = p;\n", "Selected Pointer": "c", "Compared Statement": "\t\t\t\tucl_chunk_skipc (chunk, p);\n", "Compared Pointer": "chunk", "Aliasing": "No", "Function Input": {"chunk": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd928", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"begin": {"type_category": "string", "concrete_type": "string", "value": "0x950f00f883f4458b <error: Cannot access memory at address 0x950f00f883f4458b>"}, "end": {"type_category": "string", "concrete_type": "string", "value": "0x8348c0b60f0124c0 <error: Cannot access memory at address 0x8348c0b60f0124c0>"}, "pos": {"type_category": "string", "concrete_type": "string", "value": "0x48559066c35d10c4 <error: Cannot access memory at address 0x48559066c35d10c4>"}, "fname": {"type_category": "string", "concrete_type": "string", "value": "0x1a0ec8148e589 <error: Cannot access memory at address 0x1a0ec8148e589>"}, "remain": {"type_category": "unknown", "concrete_type": "size_t", "value": "18446742633780430848"}, "line": {"type_category": "int", "concrete_type": "unsigned int", "value": "3098904904"}, "column": {"type_category": "int", "concrete_type": "unsigned int", "value": "2332033022"}, "priority": {"type_category": "int", "concrete_type": "unsigned int", "value": "219072261"}, "strategy": {"type_category": "unknown", "concrete_type": "ucl_duplicate_strategy", "value": "2294349312"}, "parse_type": {"type_category": "unknown", "concrete_type": "ucl_parse_type", "value": "219070213"}, "special_handlers": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x4c20aa <ucl_parser_process_object_element+42>", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x48fffffec0858948\n", "message": "Cannot access memory at address 0x48fffffec0858948"}}, "next": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x4c20b2 <ucl_parser_process_object_element+50>", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x4864ffffffd8c1c7\n", "message": "Cannot access memory at address 0x4864ffffffd8c1c7"}}}}}, "end_of_object": {"type_category": "pointer", "concrete_type": "NULL"}, "next_key": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd920", "value": {"type_category": "unknown", "concrete_type": "_Bool", "value": "160"}}, "parser": {"type_category": "pointer", "concrete_type": "NULL"}}, "Program Information": {"Project Name": "libucl"}}
{"Programming Language": "C", "Source Code": "static bool\nucl_state_machine (struct ucl_parser *parser)\n{\n\tucl_object_t *obj, *macro_args;\n\tstruct ucl_chunk *chunk = parser->chunks;\n\tconst unsigned char *p, *c = NULL, *macro_start = NULL;\n\tunsigned char *macro_escaped;\n\tsize_t macro_len = 0;\n\tstruct ucl_macro *macro = NULL;\n\tbool next_key = false, end_of_object = false, ret;\n\n\tif (parser->top_obj == NULL) {\n\t\tparser->state = UCL_STATE_INIT;\n\t}\n\n\tp = chunk->pos;\n\twhile (chunk->pos < chunk->end) {\n\t\tswitch (parser->state) {\n\t\tcase UCL_STATE_INIT:\n\t\t\t\n\t\t\tif (!ucl_skip_comments (parser)) {\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbool seen_obrace = false;\n\n\t\t\t\t\n\t\t\t\twhile (p < chunk->end && ucl_test_character (*p,\n\t\t\t\t\t\tUCL_CHARACTER_WHITESPACE_UNSAFE)) {\n\t\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\t}\n\n\t\t\t\tp = chunk->pos;\n\n\t\t\t\tif (p < chunk->end) {\n\t\t\t\t\tif (*p == '[') {\n\t\t\t\t\t\tparser->state = UCL_STATE_VALUE;\n\t\t\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\t\t\tseen_obrace = true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\n\t\t\t\t\t\tif (*p == '{') {\n\t\t\t\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\t\t\t\tparser->state = UCL_STATE_KEY_OBRACE;\n\t\t\t\t\t\t\tseen_obrace = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tparser->state = UCL_STATE_KEY;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (parser->top_obj == NULL) {\n\t\t\t\t\tif (parser->state == UCL_STATE_VALUE) {\n\t\t\t\t\t\tobj = ucl_parser_add_container (NULL, parser, true, 0,\n\t\t\t\t\t\t\t\tseen_obrace);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tobj = ucl_parser_add_container (NULL, parser, false, 0,\n\t\t\t\t\t\t\t\tseen_obrace);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (obj == NULL) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tparser->top_obj = obj;\n\t\t\t\t\tparser->cur_obj = obj;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tbreak;\n\t\tcase UCL_STATE_KEY:\n\t\tcase UCL_STATE_KEY_OBRACE:\n\t\t\t\n\t\t\twhile (p < chunk->end && ucl_test_character (*p, UCL_CHARACTER_WHITESPACE_UNSAFE)) {\n\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t}\n\t\t\tif (p == chunk->end || *p == '}') {\n\t\t\t\t\n\t\t\t\tparser->state = UCL_STATE_AFTER_VALUE;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (parser->stack == NULL) {\n\t\t\t\t\n\t\t\t\tucl_set_err (parser, UCL_ESYNTAX, \"top object is finished but the parser \"\n\t\t\t\t\t\t\"expects a key\", &parser->err);\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!ucl_parse_key (parser, chunk, &next_key, &end_of_object)) {\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (end_of_object) {\n\t\t\t\tp = chunk->pos;\n\t\t\t\tparser->state = UCL_STATE_AFTER_VALUE;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (parser->state != UCL_STATE_MACRO_NAME) {\n\t\t\t\tif (next_key && parser->stack->obj->type == UCL_OBJECT) {\n\t\t\t\t\t\n\t\t\t\t\tobj = ucl_parser_add_container (parser->cur_obj,\n\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tparser->stack->e.params.level + 1,\n\t\t\t\t\t\t\tparser->state == UCL_STATE_KEY_OBRACE);\n\t\t\t\t\tif (obj == NULL) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparser->state = UCL_STATE_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc = chunk->pos;\n\t\t\t}\n\t\t\tp = chunk->pos;\n\t\t\tbreak;\n\t\tcase UCL_STATE_VALUE:\n\t\t\t\n\t\t\tif (!parser->cur_obj || !ucl_parse_value (parser, chunk)) {\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tp = chunk->pos;\n\t\t\tbreak;\n\t\tcase UCL_STATE_AFTER_VALUE:\n\t\t\tif (!ucl_parse_after_value (parser, chunk)) {\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (parser->stack != NULL) {\n\t\t\t\tif (parser->stack->obj->type == UCL_OBJECT) {\n\t\t\t\t\tparser->state = UCL_STATE_KEY;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t\n\t\t\t\t\tparser->state = UCL_STATE_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tp = chunk->pos;\n\t\t\tbreak;\n\t\tcase UCL_STATE_MACRO_NAME:\n\t\t\tif (parser->flags & UCL_PARSER_DISABLE_MACRO) {\n\t\t\t\tif (!ucl_skip_macro_as_comment (parser, chunk)) {\n\t\t\t\t\t\n\t\t\t\t\tucl_create_err (&parser->err,\n\t\t\t\t\t\t\t\"error at %s:%d at column %d: invalid macro\",\n\t\t\t\t\t\t\tchunk->fname ? chunk->fname : \"memory\",\n\t\t\t\t\t\t\tchunk->line,\n\t\t\t\t\t\t\tchunk->column);\n\t\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tp = chunk->pos;\n\t\t\t\t\tparser->state = parser->prev_state;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!ucl_test_character (*p, UCL_CHARACTER_WHITESPACE_UNSAFE) &&\n\t\t\t\t\t\t*p != '(') {\n\t\t\t\t\tucl_chunk_skipc (chunk, p);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (c != NULL && p - c > 0) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tmacro_len = (size_t) (p - c);\n\t\t\t\t\t\tHASH_FIND (hh, parser->macroes, c, macro_len, macro);\n\t\t\t\t\t\tif (macro == NULL) {\n\t\t\t\t\t\t\tucl_create_err (&parser->err,\n\t\t\t\t\t\t\t\t\t\"error at %s:%d at column %d: \"\n\t\t\t\t\t\t\t\t\t\"unknown macro: '%.*s', character: '%c'\",\n\t\t\t\t\t\t\t\t\tchunk->fname ? chunk->fname : \"memory\",\n\t\t\t\t\t\t\t\t\tchunk->line,\n\t\t\t\t\t\t\t\t\tchunk->column,\n\t\t\t\t\t\t\t\t\t(int) (p - c),\n\t\t\t\t\t\t\t\t\tc,\n\t\t\t\t\t\t\t\t\t*chunk->pos);\n\t\t\t\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tSKIP_SPACES_COMMENTS(parser, chunk, p);\n\t\t\t\t\t\tparser->state = UCL_STATE_MACRO;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t\n\t\t\t\t\t\tucl_create_err (&parser->err,\n\t\t\t\t\t\t\t\t\"error at %s:%d at column %d: invalid macro name\",\n\t\t\t\t\t\t\t\tchunk->fname ? chunk->fname : \"memory\",\n\t\t\t\t\t\t\t\tchunk->line,\n\t\t\t\t\t\t\t\tchunk->column);\n\t\t\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase UCL_STATE_MACRO:\n\t\t\tif (*chunk->pos == '(') {\n\t\t\t\tmacro_args = ucl_parse_macro_arguments (parser, chunk);\n\t\t\t\tp = chunk->pos;\n\t\t\t\tif (macro_args) {\n\t\t\t\t\tSKIP_SPACES_COMMENTS(parser, chunk, p);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmacro_args = NULL;\n\t\t\t}\n\t\t\tif (!ucl_parse_macro_value (parser, chunk, macro,\n\t\t\t\t\t&macro_start, &macro_len)) {\n\t\t\t\tparser->prev_state = parser->state;\n\t\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tmacro_len = ucl_expand_variable (parser, &macro_escaped,\n\t\t\t\t\tmacro_start, macro_len);\n\t\t\tparser->state = parser->prev_state;\n\n\t\t\tif (macro_escaped == NULL && macro != NULL) {\n\t\t\t\tif (macro->is_context) {\n\t\t\t\t\tret = macro->h.context_handler (macro_start, macro_len,\n\t\t\t\t\t\t\tmacro_args,\n\t\t\t\t\t\t\tparser->top_obj,\n\t\t\t\t\t\t\tmacro->ud);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret = macro->h.handler (macro_start, macro_len, macro_args,\n\t\t\t\t\t\t\tmacro->ud);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (macro != NULL) {\n\t\t\t\tif (macro->is_context) {\n\t\t\t\t\tret = macro->h.context_handler (macro_escaped, macro_len,\n\t\t\t\t\t\t\tmacro_args,\n\t\t\t\t\t\t\tparser->top_obj,\n\t\t\t\t\t\t\tmacro->ud);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret = macro->h.handler (macro_escaped, macro_len, macro_args,\n\t\t\t\t\t\tmacro->ud);\n\t\t\t\t}\n\n\t\t\t\tUCL_FREE (macro_len + 1, macro_escaped);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret = false;\n\t\t\t\tucl_set_err (parser, UCL_EINTERNAL,\n\t\t\t\t\t\t\"internal error: parser has macro undefined\", &parser->err);\n\t\t\t}\n\n\t\t\t\n\t\t\tchunk = parser->chunks;\n\t\t\tp = chunk->pos;\n\n\t\t\tif (macro_args) {\n\t\t\t\tucl_object_unref (macro_args);\n\t\t\t}\n\n\t\t\tif (!ret) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tucl_set_err (parser, UCL_EINTERNAL,\n\t\t\t\t\t\"internal error: parser is in an unknown state\", &parser->err);\n\t\t\tparser->state = UCL_STATE_ERROR;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (parser->last_comment) {\n\t\tif (parser->cur_obj) {\n\t\t\tucl_attach_comment (parser, parser->cur_obj, true);\n\t\t}\n\t\telse if (parser->stack && parser->stack->obj) {\n\t\t\tucl_attach_comment (parser, parser->stack->obj, true);\n\t\t}\n\t\telse if (parser->top_obj) {\n\t\t\tucl_attach_comment (parser, parser->top_obj, true);\n\t\t}\n\t\telse {\n\t\t\tucl_object_unref (parser->last_comment);\n\t\t}\n\t}\n\n\tif (parser->stack != NULL && parser->state != UCL_STATE_ERROR) {\n\t\tstruct ucl_stack *st;\n\t\tbool has_error = false;\n\n\t\tLL_FOREACH (parser->stack, st) {\n\t\t\tif (st->chunk != parser->chunks) {\n\t\t\t\tbreak; \n\t\t\t}\n\t\t\tif (st->e.params.flags & UCL_STACK_HAS_OBRACE) {\n\t\t\t\tif (parser->err == NULL) {\n\t\t\t\t\tutstring_new (parser->err);\n\t\t\t\t}\n\n\t\t\t\tutstring_printf (parser->err, \"%s:%d unmatched open brace at %d; \",\n\t\t\t\t\t\tchunk->fname ? chunk->fname : \"memory\",\n\t\t\t\t\t\tparser->chunks->line,\n\t\t\t\t\t\tst->e.params.line);\n\n\t\t\t\thas_error = true;\n\t\t\t}\n\t\t}\n\n\t\tif (has_error) {\n\t\t\tparser->err_code = UCL_EUNPAIRED;\n\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}", "Selected Statement": "\t\t\t\t\tparser->top_obj = obj;\n", "Selected Pointer": "obj", "Compared Statement": "\t\t\tif (!ucl_parse_key (parser, chunk, &next_key, &end_of_object)) {\n", "Compared Pointer": "chunk", "Aliasing": "No", "Function Input": {"parser": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdb90", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x1\n", "message": "Cannot access memory at address 0x1"}}}, "Program Information": {"Project Name": "libucl"}}
{"Programming Language": "C", "Source Code": "void\nucl_parser_free (struct ucl_parser *parser)\n{\n\tstruct ucl_stack *stack, *stmp;\n\tstruct ucl_macro *macro, *mtmp;\n\tstruct ucl_chunk *chunk, *ctmp;\n\tstruct ucl_pubkey *key, *ktmp;\n\tstruct ucl_variable *var, *vtmp;\n\tucl_object_t *tr, *trtmp;\n\n\tif (parser == NULL) {\n\t\treturn;\n\t}\n\n\tif (parser->top_obj != NULL) {\n\t\tucl_object_unref (parser->top_obj);\n\t}\n\n\tif (parser->includepaths != NULL) {\n\t\tucl_object_unref (parser->includepaths);\n\t}\n\n\tLL_FOREACH_SAFE (parser->stack, stack, stmp) {\n\t\tfree (stack);\n\t}\n\tHASH_ITER (hh, parser->macroes, macro, mtmp) {\n\t\tfree (macro->name);\n\t\tHASH_DEL (parser->macroes, macro);\n\t\tUCL_FREE (sizeof (struct ucl_macro), macro);\n\t}\n\tLL_FOREACH_SAFE (parser->chunks, chunk, ctmp) {\n\t\tucl_chunk_free (chunk);\n\t}\n\tLL_FOREACH_SAFE (parser->keys, key, ktmp) {\n\t\tUCL_FREE (sizeof (struct ucl_pubkey), key);\n\t}\n\tLL_FOREACH_SAFE (parser->variables, var, vtmp) {\n\t\tfree (var->value);\n\t\tfree (var->var);\n\t\tUCL_FREE (sizeof (struct ucl_variable), var);\n\t}\n\tLL_FOREACH_SAFE (parser->trash_objs, tr, trtmp) {\n\t\tucl_object_free_internal (tr, false, ucl_object_dtor_free);\n\t}\n\n\tif (parser->err != NULL) {\n\t\tutstring_free (parser->err);\n\t}\n\n\tif (parser->cur_file) {\n\t\tfree (parser->cur_file);\n\t}\n\n\tif (parser->comments) {\n\t\tucl_object_unref (parser->comments);\n\t}\n\n\tUCL_FREE (sizeof (struct ucl_parser), parser);\n}", "Selected Statement": "\tLL_FOREACH_SAFE (parser->stack, stack, stmp) {\n", "Selected Pointer": "stack", "Compared Statement": "\tUCL_FREE (sizeof (struct ucl_parser), parser);\n", "Compared Pointer": "parser", "Aliasing": "No", "Function Input": {"parser": {"type_category": "pointer", "concrete_type": "NULL"}}, "Program Information": {"Project Name": "libucl"}}
{"Programming Language": "C", "Source Code": "static void\nws_alloc_free(struct ws_emu *we, struct ws_alloc **wap)\n{\n\tstruct ws_alloc *wa;\n\n\tTAKE_OBJ_NOTNULL(wa, wap, WS_ALLOC_MAGIC);\n\tAZ(VTAILQ_NEXT(wa, list));\n\tVTAILQ_REMOVE(&we->head, wa, list);\n\tfree(wa->ptr);\n\tFREE_OBJ(wa);\n}", "Selected Statement": "\tVTAILQ_REMOVE(&we->head, wa, list);\n", "Selected Pointer": "wa", "Compared Statement": "\twe = ws_emu(ws);\n", "Compared Pointer": "we", "Aliasing": "No", "Function Input": {"wap": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffcfb0", "value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd0e0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3f81c89b6ab\n", "message": "Cannot access memory at address 0x3f81c89b6ab"}}}, "we": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffcfb8", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"magic": {"type_category": "int", "concrete_type": "unsigned int", "value": "905626964"}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "7431538"}, "ws": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd518", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"magic": {"type_category": "int", "concrete_type": "unsigned int", "value": "478787243"}, "id": {"type_category": "string", "concrete_type": "string", "value": "\"\\370\\003\\000\""}, "s": {"type_category": "string", "concrete_type": "NULL"}, "f": {"type_category": "string", "concrete_type": "string", "value": "0xec7bf0 \"\\005\\375\\347\\\"\""}, "r": {"type_category": "string", "concrete_type": "string", "value": "0xec7c08 \"\""}, "e": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff7a535a8 \"F\\001u\\017\\337\\216\\226b\\244\\255+\\005\\222\\216\\204~{\\307d\\363\\251]\\017\\375Xf\\363\\224\\206K\\205\\346\\001\\323J3\\343\\017\\224\\037]\\b\\262\\343\\\\\\361\\017\\365\\244\\355K\\224\\222\\002}\\033\\034\\304,\\031\\234\\256\\336>GX7\\017\\246RO\\020\\252\\255+\\005\\272\\2622\\250\\241_2\\005\\344\\340\\366\\376\\002\\341G\\250\\333\\0303\\272\\252,:\\202\\272\\312\\366\\243^\\366a\\353m0X1.\\306\\306#\\216\\365\\343\\263B\\243\\001\\361\\371\\031sBh\\t\\232\\367\\344\\2614\\360\\370\\031sB\\215\\210k\\340\\236J\\\\e\\336\\210\\240^\\006%\\367\\f\\220\\251\\375\\364\\372\\031sBI\\3600\\206\\004&)\\005\\360\\024\\214\\357%\\211\\242\\202\\354\\222s\\360\\326\\204\\364\\245\\202\\034\\333\\370[\\213\\212\\034\\252\\201e\\216\\202\\337\\263\\224\\210y\\305A\\b\\260g3\\343W\\304\\030xR.\\251\\023\\243v\\376\\fK\\356o\\177\\213\\b\\224\\v&)\\005\\316\\205\\032\\021\\0348\\203\\333(f\\213\\222bD\\230\\376n<\\224|\\237\\353~\\206\\\\Z\\0221\\352A\\274\\376~U\\335q\\\"\\222$\\017\\366\\001\\331\\177~U\\335qI@\\204\\026\\355\\206\\205e~x\\265$s<\\224|n\\003M\\027\\332\\004\\320\\002\\017\\362@\\216&ka\\020\\t\\345k\\255Bw)\\221R\\266O\\361\\020\\247Z\\331^\\330\\204\\323u<\\224|\\374U\\217z#\\366\\305't\\376t\\227\\\"g>N\\n\\256\\235g#g>NV\\323\\003\\266\\340`v\\017\\240\\270C\\302\\371\\033\\236|\\016B\\025\\2634\\223M\\215Z\\232;\\017+-$\\202\\336\\306as\\272\\036\\265\\003\\2457\\202\\325\\220\\3236\\263\\220\\256@\\034\\341F\\336\\017\\036h\\200\\332\\315\\313\\374\\266\\362'i\\036\\367\\346\\230\\030\\263\\332\\024uv\\327\\233|\\251\\006u\\020\\251J.\\251\\236\\243\\316f\\363\\241\\311\\2006t\\210\\vY\\212\\230||\\350\\211h\\270\\332\\024uc~0\\312\\222\\207\\267\\026\\305\\250U_[s\\350\\317\\360\\022\\365\\253\\334\\024\\276\\343\\376\\177\\311x\\273U\\242\\n\\\"%\\250\\215\\277'\\0256\\344\\211\\240\\226\\374\\304\\300\\034\\254\\343\\275 \\242Z\\357\\220\\312\\356\\351\\035h\\351R\\030\\255\\271rM\\262\\224\\323g\\272\\225\\223\\034\\004e\\350\\365\\237\\372\\335\\016\\333\\f\\026\\211\\367\\vO]\\314&\\b\\203\\340\\237\\251\\304%\\257\\305'\\3664\\322\\356f3\\335\\305f3\\335\\305f3\\335\\305g3\\335\\305ho\\0037\\202\\216l\\023T\\024Gn\\355\\316%\\\"(\\262\\377\\023\\362\\234%\\311\\201n3i\\372\\217\\360\\023z2\\377=\\243\\3679\\276n\\317\\351\\225\\266\\270\\245\\357S\\200\\210\\203?\\371\\377\\2747\\025\\025e\\262-.\\326)\\234\\205\\020\\342Y\\004]\\202\\263\\253#\\026\\353Gij\\201\\362\\031\\271\\237\\016>?:,i@:,i\\232\\\\\\210\\vs\\372\\201\\033\\354\\016\\351\\312\\205k\\004w&l\\\"6v\\367\\263>z%\\223\\250%:\\375\\031\\214d\\2338\\214!\\220\\020\\3571u\\031h\\2328#Ni\\332\\260$\\331\\224V\\326A<\\n\\367\\316\\327\\342\\242S\\320\\016fY/\\345\\332\""}}}}, "head": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"vtqh_first": {"type_category": "pointer", "concrete_type": "NULL"}, "vtqh_last": {"type_category": "pointer", "concrete_type": "NULL"}}}}}}}, "Program Information": {"Project Name": "varnish"}}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;\n}", "Selected Statement": "\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\rs\\n\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "16"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}}
{"Programming Language": "C", "Source Code": "int parse_headers_aux(struct sip_msg* msg, hdr_flags_t flags, int next, int sip_well_known_parse)\n{\n\tstruct hdr_field *hf;\n\tstruct hdr_field *itr;\n\tchar* tmp;\n\tchar* rest;\n\tchar* end;\n\thdr_flags_t orig_flag;\n\n#define link_sibling_hdr(_hook, _hdr) \\\n\tdo{ \\\n\t\tif (msg->_hook==0) msg->_hook=_hdr;\\\n\t\t\telse {\\\n\t\t\t\tfor(itr=msg->_hook;itr->sibling;itr=itr->sibling);\\\n\t\t\t\titr->sibling = _hdr;\\\n\t\t\t}\\\n\t}while(0)\n\n\tend=msg->buf+msg->len;\n\ttmp=msg->unparsed;\n\n\tif (next) {\n\t\torig_flag = msg->parsed_flag;\n\t\tmsg->parsed_flag &= ~flags;\n\t}else\n\t\torig_flag=0;\n\n\tLM_DBG(\"flags=%llx\\n\", (unsigned long long)flags);\n\twhile( tmp<end && (flags & msg->parsed_flag) != flags){\n\t\thf=pkg_malloc(sizeof(struct hdr_field));\n\t\tif (hf==0){\n\t\t\tser_error=E_OUT_OF_MEM;\n\t\t\tLM_ERR(\"pkg memory allocation failed\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemset(hf,0, sizeof(struct hdr_field));\n\t\thf->type=HDR_ERROR_T;\n\t\trest=get_hdr_field_aux(tmp, msg->buf+msg->len, hf,sip_well_known_parse);\n\t\tswitch (hf->type){\n\t\t\tcase HDR_ERROR_T:\n\t\t\t\tLM_INFO(\"bad header field\\n\");\n\t\t\t\tgoto  error;\n\t\t\tcase HDR_EOH_T:\n\t\t\t\tmsg->eoh=tmp; \n\t\t\t\tmsg->parsed_flag|=HDR_EOH_F;\n\t\t\t\tpkg_free(hf);\n\t\t\t\tgoto skip;\n\t\t\tcase HDR_OTHER_T: \n\t\t\tcase HDR_TO_PATH_T:\n\t\t\tcase HDR_FROM_PATH_T:\n\t\t\tcase HDR_MESSAGE_ID_T:\n\t\t\tcase HDR_BYTE_RANGE_T:\n\t\t\tcase HDR_FAILURE_REPORT_T:\n\t\t\tcase HDR_SUCCESS_REPORT_T:\n\t\t\tcase HDR_STATUS_T:\n\t\t\tcase HDR_USE_PATH_T:\n\t\t\t\tbreak;\n\t\t\tcase HDR_CALLID_T:\n\t\t\t\tif (msg->callid==0) msg->callid=hf;\n\t\t\t\tmsg->parsed_flag|=HDR_CALLID_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_TO_T:\n\t\t\t\tif (msg->to==0) msg->to=hf;\n\t\t\t\tmsg->parsed_flag|=HDR_TO_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_CSEQ_T:\n\t\t\t\tif (msg->cseq==0) msg->cseq=hf;\n\t\t\t\tmsg->parsed_flag|=HDR_CSEQ_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_FROM_T:\n\t\t\t\tif (msg->from==0) msg->from=hf;\n\t\t\t\tmsg->parsed_flag|=HDR_FROM_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_CONTACT_T:\n\t\t\t\tlink_sibling_hdr(contact,hf);\n\t\t\t\tmsg->parsed_flag|=HDR_CONTACT_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_MAXFORWARDS_T:\n\t\t\t\tif(msg->maxforwards==0) msg->maxforwards=hf;\n\t\t\t\tmsg->parsed_flag|=HDR_MAXFORWARDS_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_ROUTE_T:\n\t\t\t\tlink_sibling_hdr(route,hf);\n\t\t\t\tmsg->parsed_flag|=HDR_ROUTE_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_RECORDROUTE_T:\n\t\t\t\tlink_sibling_hdr(record_route,hf);\n\t\t\t\tmsg->parsed_flag|=HDR_RECORDROUTE_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_PATH_T:\n\t\t\t\tlink_sibling_hdr(path,hf);\n\t\t\t\tmsg->parsed_flag|=HDR_PATH_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_CONTENTTYPE_T:\n\t\t\t\tif (msg->content_type==0) msg->content_type = hf;\n\t\t\t\tmsg->parsed_flag|=HDR_CONTENTTYPE_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_CONTENTLENGTH_T:\n\t\t\t\tif (msg->content_length==0) msg->content_length = hf;\n\t\t\t\tmsg->parsed_flag|=HDR_CONTENTLENGTH_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_AUTHORIZATION_T:\n\t\t\t\tlink_sibling_hdr(authorization,hf);\n\t\t\t\tmsg->parsed_flag|=HDR_AUTHORIZATION_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_EXPIRES_T:\n\t\t\t\tif (msg->expires==0) msg->expires = hf;\n\t\t\t\tmsg->parsed_flag|=HDR_EXPIRES_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_PROXYAUTH_T:\n\t\t\t\tlink_sibling_hdr(proxy_auth,hf);\n\t\t\t\tmsg->parsed_flag|=HDR_PROXYAUTH_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_PROXYREQUIRE_T:\n\t\t\t\tlink_sibling_hdr(proxy_require,hf);\n\t\t\t\tmsg->parsed_flag|=HDR_PROXYREQUIRE_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_SUPPORTED_T:\n\t\t\t\tlink_sibling_hdr(supported,hf);\n\t\t\t\tmsg->parsed_flag|=HDR_SUPPORTED_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_UNSUPPORTED_T:\n\t\t\t\tlink_sibling_hdr(unsupported,hf);\n\t\t\t\tmsg->parsed_flag|=HDR_UNSUPPORTED_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_ALLOW_T:\n\t\t\t\tlink_sibling_hdr(allow,hf);\n\t\t\t\tmsg->parsed_flag|=HDR_ALLOW_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_EVENT_T:\n\t\t\t\tlink_sibling_hdr(event,hf);\n\t\t\t\tmsg->parsed_flag|=HDR_EVENT_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_ACCEPT_T:\n\t\t\t\tlink_sibling_hdr(accept,hf);\n\t\t\t\tmsg->parsed_flag|=HDR_ACCEPT_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_ACCEPTLANGUAGE_T:\n\t\t\t\tlink_sibling_hdr(accept_language,hf);\n\t\t\t\tmsg->parsed_flag|=HDR_ACCEPTLANGUAGE_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_ORGANIZATION_T:\n\t\t\t\tif (msg->organization==0) msg->organization = hf;\n\t\t\t\tmsg->parsed_flag|=HDR_ORGANIZATION_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_PRIORITY_T:\n\t\t\t\tif (msg->priority==0) msg->priority = hf;\n\t\t\t\tmsg->parsed_flag|=HDR_PRIORITY_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_SUBJECT_T:\n\t\t\t\tif (msg->subject==0) msg->subject = hf;\n\t\t\t\tmsg->parsed_flag|=HDR_SUBJECT_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_USERAGENT_T:\n\t\t\t\tif (msg->user_agent==0) msg->user_agent = hf;\n\t\t\t\tmsg->parsed_flag|=HDR_USERAGENT_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_CONTENTDISPOSITION_T:\n\t\t\t\tif (msg->content_disposition==0) msg->content_disposition = hf;\n\t\t\t\tmsg->parsed_flag|=HDR_CONTENTDISPOSITION_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_ACCEPTDISPOSITION_T:\n\t\t\t\tlink_sibling_hdr(accept_disposition,hf);\n\t\t\t\tmsg->parsed_flag|=HDR_ACCEPTDISPOSITION_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_DIVERSION_T:\n\t\t\t\tlink_sibling_hdr(diversion,hf);\n\t\t\t\tmsg->parsed_flag|=HDR_DIVERSION_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_RPID_T:\n\t\t\t\tif (msg->rpid==0) msg->rpid = hf;\n\t\t\t\tmsg->parsed_flag|=HDR_RPID_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_CALL_INFO_T:\n\t\t\t\tlink_sibling_hdr(call_info,hf);\n\t\t\t\tmsg->parsed_flag|=HDR_CALL_INFO_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_WWW_AUTHENTICATE_T:\n\t\t\t\tlink_sibling_hdr(www_authenticate,hf);\n\t\t\t\tmsg->parsed_flag|=HDR_WWW_AUTHENTICATE_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_PROXY_AUTHENTICATE_T:\n\t\t\t\tlink_sibling_hdr(proxy_authenticate,hf);\n\t\t\t\tmsg->parsed_flag|=HDR_PROXY_AUTHENTICATE_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_REFER_TO_T:\n\t\t\t\tif (msg->refer_to==0) msg->refer_to = hf;\n\t\t\t\tmsg->parsed_flag|=HDR_REFER_TO_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_SESSION_EXPIRES_T:\n\t\t\t\tif ( msg->session_expires == 0 ) msg->session_expires = hf;\n\t\t\t\tmsg->parsed_flag |= HDR_SESSION_EXPIRES_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_MIN_SE_T:\n\t\t\t\tif ( msg->min_se == 0 ) msg->min_se = hf;\n\t\t\t\tmsg->parsed_flag |= HDR_MIN_SE_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_MIN_EXPIRES_T:\n\t\t\t\tif ( msg->min_expires == 0 ) msg->min_expires = hf;\n\t\t\t\tmsg->parsed_flag |= HDR_MIN_EXPIRES_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_PPI_T:\n\t\t\t\tlink_sibling_hdr(ppi,hf);\n\t\t\t\tmsg->parsed_flag|=HDR_PPI_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_PAI_T:\n\t\t\t\tlink_sibling_hdr(pai,hf);\n\t\t\t\tmsg->parsed_flag|=HDR_PAI_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_PRIVACY_T:\n\t\t\t\tif (msg->privacy==0) msg->privacy = hf;\n\t\t\t\tmsg->parsed_flag|=HDR_PRIVACY_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_RETRY_AFTER_T:\n\t\t\t\tbreak;\n\t\t\tcase HDR_VIA_T:\n\t\t\t\tlink_sibling_hdr(h_via1,hf);\n\t\t\t\tmsg->parsed_flag|=HDR_VIA_F;\n\t\t\t\tLM_DBG(\"via found, flags=%llx\\n\", (unsigned long long)flags);\n\t\t\t\tif (sip_well_known_parse) {\n\t\t\t\t\tif (msg->via1==0) {\n\t\t\t\t\t\tLM_DBG(\"this is the first via\\n\");\n\t\t\t\t\t\tmsg->h_via1=hf;\n\t\t\t\t\t\tmsg->via1=hf->parsed;\n\t\t\t\t\t\tif (msg->via1->next){\n\t\t\t\t\t\t\tmsg->via2=msg->via1->next;\n\t\t\t\t\t\t\tmsg->parsed_flag|=HDR_VIA2_F;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if (msg->via2==0){\n\t\t\t\t\t\tmsg->h_via2=hf;\n\t\t\t\t\t\tmsg->via2=hf->parsed;\n\t\t\t\t\t\tmsg->parsed_flag|=HDR_VIA2_F;\n\t\t\t\t\t\tLM_DBG(\"parse_headers: this is the second via\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase HDR_FEATURE_CAPS_T:\n\t\t\t\tlink_sibling_hdr(feature_caps, hf);\n\t\t\t\tmsg->parsed_flag |= HDR_FEATURE_CAPS_F;\n\t\t\t\tbreak;\n\t\t\tcase HDR_REPLACES_T:\n\t\t\t\tlink_sibling_hdr(replaces, hf);\n\t\t\t\tmsg->parsed_flag |= HDR_REPLACES_F;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tLM_CRIT(\"unknown header type %d\\n\",\thf->type);\n\t\t\t\tgoto error;\n\t\t}\n\t\t\n\t\tif (msg->last_header==0){\n\t\t\tmsg->headers=hf;\n\t\t\tmsg->last_header=hf;\n\t\t}else{\n\t\t\tmsg->last_header->next=hf;\n\t\t\tmsg->last_header=hf;\n\t\t}\n#ifdef EXTRA_DEBUG\n\t\tLM_DBG(\"header field type %d, name=<%.*s>, body=<%.*s>\\n\",\n\t\t\thf->type,\n\t\t\thf->name.len, ZSW(hf->name.s),\n\t\t\thf->body.len, ZSW(hf->body.s));\n#endif\n\t\ttmp=rest;\n\t}\nskip:\n\tmsg->unparsed=tmp;\n\treturn 0;\n\nerror:\n\tser_error=E_BAD_REQ;\n\tif (hf) pkg_free(hf);\n\tif (next) msg->parsed_flag |= orig_flag;\n\treturn -1;\n}", "Selected Statement": "\twhile( tmp<end && (flags & msg->parsed_flag) != flags){\n", "Selected Pointer": "end", "Compared Statement": "\t\trest=get_hdr_field_aux(tmp, msg->buf+msg->len, hf,sip_well_known_parse);\n", "Compared Pointer": "tmp", "Aliasing": "No", "Function Input": {"flags": {"type_category": "unknown", "concrete_type": "hdr_flags_t", "value": "124593616"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x76d25dc"}, "next": {"type_category": "int", "concrete_type": "int", "value": "17"}, "sip_well_known_parse": {"type_category": "int", "concrete_type": "int", "value": "1"}}, "Program Information": {"Project Name": "opensips"}}
{"Programming Language": "C", "Source Code": "inline static int is_empty_end(const char* p, const char* pend )\n{\n\tp=eat_space_end(p, pend );\n\treturn ((p<(pend )) && (*p=='\\r' || *p=='\\n'));\n}", "Selected Statement": "\treturn ((p<(pend )) && (*p=='\\r' || *p=='\\n'));\n", "Selected Pointer": "p", "Compared Statement": "\tp=eat_space_end(p, pend );\n", "Compared Pointer": "pend", "Aliasing": "Yes", "Function Input": {"p": {"type_category": "string", "concrete_type": "string", "value": "0x76d25e0 \" A\""}, "pend": {"type_category": "string", "concrete_type": "string", "value": "0x76d25e1 \"A\""}}, "Program Information": {"Project Name": "opensips"}}
{"Programming Language": "C", "Source Code": "static int\nBerDecoder_decodeLengthRecursive(uint8_t* buffer, int* length, int bufPos, int maxBufPos, int depth, int maxDepth)\n{\n    if (bufPos >= maxBufPos)\n        return -1;\n\n    uint8_t len1 = buffer[bufPos++];\n\n    if (len1 & 0x80) {\n        int lenLength = len1 & 0x7f;\n\n        if (lenLength == 0) { \n            *length = getIndefiniteLength(buffer, bufPos, maxBufPos, depth, maxDepth);\n        }\n        else {\n            *length = 0;\n\n            int i;\n            for (i = 0; i < lenLength; i++) {\n                if (bufPos >= maxBufPos)\n                    return -1;\n\n                if (bufPos + (*length) > maxBufPos)\n                    return -1;\n\n                *length <<= 8;\n                *length += buffer[bufPos++];\n            }\n        }\n\n    }\n    else {\n        *length = len1;\n    }\n\n    if (*length < 0)\n        return -1;\n\n    if (*length > maxBufPos)\n        return -1;\n\n    if (bufPos + (*length) > maxBufPos)\n        return -1;\n\n    return bufPos;\n}", "Selected Statement": "            *length = getIndefiniteLength(buffer, bufPos, maxBufPos, depth, maxDepth);\n", "Selected Pointer": "buffer", "Compared Statement": "BerDecoder_decodeLengthRecursive(uint8_t* buffer, int* length, int bufPos, int maxBufPos, int depth, int maxDepth)\n", "Compared Pointer": "length", "Aliasing": "No", "Function Input": {"bufPos": {"type_category": "int", "concrete_type": "int", "value": "128"}, "buffer": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffff0000 \"\""}, "depth": {"type_category": "int", "concrete_type": "int", "value": "0"}, "length": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffda38", "value": {"type_category": "int", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3200000000\n", "message": "Cannot access memory at address 0x3200000000"}}, "maxBufPos": {"type_category": "int", "concrete_type": "int", "value": "7"}, "maxDepth": {"type_category": "int", "concrete_type": "int", "value": "0"}}, "Program Information": {"Project Name": "libiec61850"}}
{"Programming Language": "C", "Source Code": "void\nMmsValue_setElement(MmsValue* complexValue, int index, MmsValue* elementValue)\n{\n    if ((complexValue->type != MMS_ARRAY) && (complexValue->type != MMS_STRUCTURE))\n        return;\n\n    if ((index < 0) || (index >= complexValue->value.structure.size))\n        return;\n\n    complexValue->value.structure.components[index] = elementValue;\n}", "Selected Statement": "    complexValue->value.structure.components[index] = elementValue;\n", "Selected Pointer": "elementValue", "Compared Statement": "MmsValue_setElement(MmsValue* complexValue, int index, MmsValue* elementValue)\n", "Compared Pointer": "complexValue", "Aliasing": "No", "Function Input": {"complexValue": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdd18", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"type": {"type_category": "unknown", "concrete_type": "MmsType", "value": "MMS_BOOLEAN"}, "deleteValue": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "0 '\\000'"}, "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"dataAccessError": {"type_category": "unknown", "concrete_type": "MmsDataAccessError", "value": "DATA_ACCESS_ERROR_HARDWARE_FAULT"}, "structure": {"type_category": "struct", "concrete_type": "RECURSIVE", "value": "{size = 1, components = 0x0}"}, "boolean": {"type_category": "unknown", "concrete_type": "_Bool", "value": "true"}, "integer": {"type_category": "pointer", "concrete_type": "RECURSIVE", "value": "0x1"}, "floatingPoint": {"type_category": "struct", "concrete_type": "RECURSIVE", "value": "{exponentWidth = 1 '\\001', formatWidth = 0 '\\000', buf = \"\\000\\000\\000\\000\\000\\000\\000\"}"}, "octetString": {"type_category": "struct", "concrete_type": "RECURSIVE", "value": "{size = 1, maxSize = 0, buf = 0x0}"}, "bitString": {"type_category": "struct", "concrete_type": "RECURSIVE", "value": "{size = 1, buf = 0x0}"}, "visibleString": {"type_category": "struct", "concrete_type": "RECURSIVE", "value": "{buf = 0x1 &lt;error: Cannot access memory at address 0x1&gt;, size = 0}"}, "utcTime": {"type_category": "string", "concrete_type": "string", "value": "\"\\001\\000\\000\\000\\000\\000\\000\""}, "binaryTime": {"type_category": "struct", "concrete_type": "RECURSIVE", "value": "{size = 1 '\\001', buf = \"\\000\\000\\000\\000\\000\"}"}}}}}}, "elementValue": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdd08", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x500000005\n", "message": "Cannot access memory at address 0x500000005"}}, "index": {"type_category": "int", "concrete_type": "int", "value": "0"}}, "Program Information": {"Project Name": "libiec61850"}}
{"Programming Language": "C", "Source Code": "static void\nvlog(int pri, const char *token, const char *fmt, va_list ap)\n{\n\tif (logh) {\n\t\tchar *result = NULL;\n\t\tif (vasprintf(&result, fmt, ap) != -1) {\n\t\t\tlogh(pri, result);\n\t\t\tfree(result);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\treturn;\n\t}\n\n\t\n\tif (use_syslog) {\n\t\tva_list ap2;\n\t\tva_copy(ap2, ap);\n\t\tvsyslog(pri, fmt, ap2);\n\t\tva_end(ap2);\n\t}\n\n\t\n\tchar *nfmt;\n\t\n\tif (asprintf(&nfmt, \"%s %s%s%s]%s %s\\n\", date(), translate(STDERR_FILENO, pri),\n\t\ttoken ? \"/\" : \"\", token ? token : \"\",\n\t\tisatty(STDERR_FILENO) ? \"\\033[0m\" : \"\", fmt) == -1) {\n\t\tvfprintf(stderr, fmt, ap);\n\t\tfprintf(stderr, \"\\n\");\n\t} else {\n\t\tvfprintf(stderr, nfmt, ap);\n\t\tfree(nfmt);\n\t}\n\tfflush(stderr);\n}", "Selected Statement": "\t\t\tlogh(pri, result);\n", "Selected Pointer": "fmt", "Compared Statement": "\t\tvlog(LOG_DEBUG, token, emsg, ap);\n", "Compared Pointer": "emsg", "Aliasing": "Yes", "Function Input": {"ap": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd9d0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"gp_offset": {"type_category": "int", "concrete_type": "unsigned int", "value": "16"}, "fp_offset": {"type_category": "int", "concrete_type": "unsigned int", "value": "48"}, "overflow_arg_area": {"type_category": "pointer", "concrete_type": "VOID"}, "reg_save_area": {"type_category": "pointer", "concrete_type": "VOID"}}}}, "fmt": {"type_category": "string", "concrete_type": "string", "value": "0x5555556fdb3d \"cleanup chassis %s\""}, "pri": {"type_category": "int", "concrete_type": "int", "value": "7"}, "token": {"type_category": "string", "concrete_type": "string", "value": "0x5555556cef8e \"alloc\""}}, "Program Information": {"Project Name": "lldpd"}}
{"Programming Language": "C", "Source Code": "hashtab_t hashtab_create(unsigned int (*hash_value) (hashtab_t h,\n\t\t\t\t\t\t     const_hashtab_key_t key),\n\t\t\t int (*keycmp) (hashtab_t h,\n\t\t\t\t\tconst_hashtab_key_t key1,\n\t\t\t\t\tconst_hashtab_key_t key2),\n\t\t\t unsigned int size)\n{\n\n\thashtab_t p;\n\n\tp = (hashtab_t) malloc(sizeof(hashtab_val_t));\n\tif (p == NULL)\n\t\treturn p;\n\n\tmemset(p, 0, sizeof(hashtab_val_t));\n\tp->size = size;\n\tp->nel = 0;\n\tp->hash_value = hash_value;\n\tp->keycmp = keycmp;\n\tp->htable = (hashtab_ptr_t *) calloc(size, sizeof(hashtab_ptr_t));\n\tif (p->htable == NULL) {\n\t\tfree(p);\n\t\treturn NULL;\n\t}\n\n\treturn p;\n}", "Selected Statement": "\tp->hash_value = hash_value;\n", "Selected Pointer": "hash_value", "Compared Statement": "\tp->keycmp = keycmp;\n", "Compared Pointer": "keycmp", "Aliasing": "No", "Function Input": {"size": {"type_category": "int", "concrete_type": "unsigned int", "value": "64"}}, "Program Information": {"Project Name": "selinux"}}
{"Programming Language": "C", "Source Code": "void avrule_decl_destroy(avrule_decl_t * x)\n{\n\tif (x == NULL) {\n\t\treturn;\n\t}\n\tcond_list_destroy(x->cond_list);\n\tavrule_list_destroy(x->avrules);\n\trole_trans_rule_list_destroy(x->role_tr_rules);\n\tfilename_trans_rule_list_destroy(x->filename_trans_rules);\n\trole_allow_rule_list_destroy(x->role_allow_rules);\n\trange_trans_rule_list_destroy(x->range_tr_rules);\n\tscope_index_destroy(&x->required);\n\tscope_index_destroy(&x->declared);\n\tsymtabs_destroy(x->symtab);\n\tfree(x->module_name);\n\tfree(x);\n}", "Selected Statement": "\tfree(x);\n", "Selected Pointer": "x", "Compared Statement": "\t\tavrule_decl_destroy(decl);\n", "Compared Pointer": "decl", "Aliasing": "No", "Function Input": {"x": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd6e8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}}, "Program Information": {"Project Name": "selinux"}}
{"Programming Language": "C", "Source Code": "int parse_msg(\n\t\tchar *const buf, const unsigned int len, struct sip_msg *const msg)\n{\n\n\tchar *tmp;\n\tchar *rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor(tmp = buf; (tmp - buf < len)\n\t\t\t\t   && (*tmp == '\\n' || *tmp == '\\r' || *tmp == '\\0'\n\t\t\t\t\t\t   || *tmp == '\\t' || *tmp == ' ');\n\t\t\ttmp++)\n\t\t;\n\toffset = tmp - buf;\n\tfl = &(msg->first_line);\n\trest = parse_first_line(tmp, len - offset, fl);\n\toffset += rest - tmp;\n\ttmp = rest;\n\tswitch(fl->type) {\n\t\tcase SIP_INVALID:\n\t\t\tDBG(\"invalid message\\n\");\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tDBG(\"SIP Request:\\n\");\n\t\t\tDBG(\" method:  <%.*s>\\n\", fl->u.request.method.len,\n\t\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tDBG(\" uri:     <%.*s>\\n\", fl->u.request.uri.len,\n\t\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tDBG(\" version: <%.*s>\\n\", fl->u.request.version.len,\n\t\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags = HDR_VIA_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tDBG(\"SIP Reply  (status):\\n\");\n\t\t\tDBG(\" version: <%.*s>\\n\", fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tDBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tDBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\t\n\t\t\t\n\t\t\tflags = HDR_VIA_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDBG(\"unknown type %d\\n\", fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed = tmp;\n\t\n\tif(parse_headers(msg, flags, 0) == -1)\n\t\tgoto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif(msg->via1) {\n\t\tDBG(\"first via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\", msg->via1->name.len,\n\t\t\t\tZSW(msg->via1->name.s), msg->via1->version.len,\n\t\t\t\tZSW(msg->via1->version.s), msg->via1->transport.len,\n\t\t\t\tZSW(msg->via1->transport.s), msg->via1->host.len,\n\t\t\t\tZSW(msg->via1->host.s), msg->via1->port_str.len,\n\t\t\t\tZSW(msg->via1->port_str.s), msg->via1->port);\n\t\tif(msg->via1->params.s)\n\t\t\tDBG(\";<%.*s>\", msg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif(msg->via1->comment.s)\n\t\t\tDBG(\" <%.*s>\", msg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tDBG(\"\\n\");\n\t}\n\tif(msg->via2) {\n\t\tDBG(\"second via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\", msg->via2->name.len,\n\t\t\t\tZSW(msg->via2->name.s), msg->via2->version.len,\n\t\t\t\tZSW(msg->via2->version.s), msg->via2->transport.len,\n\t\t\t\tZSW(msg->via2->transport.s), msg->via2->host.len,\n\t\t\t\tZSW(msg->via2->host.s), msg->via2->port_str.len,\n\t\t\t\tZSW(msg->via2->port_str.s), msg->via2->port);\n\t\tif(msg->via2->params.s)\n\t\t\tDBG(\";<%.*s>\", msg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif(msg->via2->comment.s)\n\t\t\tDBG(\" <%.*s>\", msg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tDBG(\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tDBG(\"exiting parse_msg\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLOG(cfg_get(core, core_cfg, sip_parser_log),\n\t\t\t\"ERROR: parse_msg: message=<%.*s>\\n\", (int)msg->len,\n\t\t\tZSW(ksr_buf_oneline(msg->buf, (int)msg->len)));\n\treturn -1;\n}", "Selected Statement": "\tswitch(fl->type) {\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp = rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "NULL"}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}, "msg": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd6d8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xffff00001f80\n", "message": "Cannot access memory at address 0xffff00001f80"}}}, "Program Information": {"Project Name": "kamailio"}}
{"Programming Language": "C", "Source Code": "static void RC4(RC4_KEY *key, int buffer_len, unsigned char * buff)\n{\n\tunsigned char t;\n\tunsigned char x;\n\tunsigned char y;\n\tunsigned char* state;\n\tunsigned char xorIndex;\n\tshort counter;\n\n\tx = key->x;\n\ty = key->y;\n\tstate = &key->state[0];\n\tfor(counter = 0; counter < buffer_len; counter++) {\n\t\tx = (x + 1) % 256;\n\t\ty = (state[x] + y) % 256;\n\t\tswap_byte(&state[x], &state[y]);\n\t\txorIndex = (state[x] + state[y]) % 256;\n\t\tbuff[counter] ^= state[xorIndex];\n\t}\n\tkey->x = x;\n\tkey->y = y;\n}", "Selected Statement": "\tstate = &key->state[0];\n", "Selected Pointer": "state", "Compared Statement": "    RC4(&rc4_key, buf_len, buf);\n", "Compared Pointer": "buf", "Aliasing": "No", "Function Input": {"buff": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffde7c \"\\307\\3329kP\""}, "buffer_len": {"type_category": "int", "concrete_type": "int", "value": "4"}, "key": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdca8", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"state": {"type_category": "string", "concrete_type": "string", "value": "\"N\\242\\335C\\026\\3204\\276&`\\233\\021V\\256\\022\\214\\366\\\"|\\313M\\315\\215\\361^'R\\035$>r<\\343\\375\\310\\000\\252F\\2558\\211]m\\205xq\\346\\200w\\202\\314S\\t\\333yiosP\\236IZB#LU\\362\\353\\324\\025\\230G3\\036\\037\\304\\3605\\032\\250J{\\030\\020\\356}\\344@\\nka\\232fp\\223\\342X\\001\\031\\270\\203\\275\\277\\004\\364,\\332Y:\\357\\227\\253_\\003\\204H\\3167\\372\\312\\216\\234\\351\\317\\217\\002\\370[ \\243\\325\\373\\340\\345\\244\\027+\\322\\006h\\\\\\261l\\374-\\341%?\\365*\\210(\\267\\271\\v\\0342~)\\377\\222\\334\\a\\305\\220\\306\\260\\303\\212\\265\\b\\262\\350u1\\241W\\3010\\311\\221\\323\\272\\fj6\\263Tnc\\246D\\033\\300.E\\177\\231zO9\\302\\257\\240\\355\\331=\\352\\024!\\347\\254\\264\\363Q\\237\\321\\327\\213\\376v\\247\\273\\235\\016\\245\\201d\\225\\371/b\\224\\005\\017\\207K\\326\\307\\251t\\226A\\023\\330\\367e\\266\\274\\354\\206\\337;\\336g\\r\""}, "x": {"type_category": "int", "concrete_type": "unsigned char", "value": "0 '\\000'"}, "y": {"type_category": "int", "concrete_type": "unsigned char", "value": "0 '\\000'"}}}}}, "Program Information": {"Project Name": "mdbtools"}}
{"Programming Language": "C", "Source Code": "int libbfio_handle_initialize(\n      libbfio_handle_t **handle,\n      intptr_t *io_handle,\n      int (*free_io_handle)(\n             intptr_t **io_handle,\n             libcerror_error_t **error ),\n      int (*clone_io_handle)(\n             intptr_t **destination_io_handle,\n             intptr_t *source_io_handle,\n             libcerror_error_t **error ),\n      int (*open)(\n             intptr_t *io_handle,\n             int access_flags,\n             libcerror_error_t **error ),\n      int (*close)(\n             intptr_t *io_handle,\n             libcerror_error_t **error ),\n      ssize_t (*read)(\n                 intptr_t *io_handle,\n                 uint8_t *buffer,\n                 size_t size,\n                 libcerror_error_t **error ),\n      ssize_t (*write)(\n                 intptr_t *io_handle,\n                 const uint8_t *buffer,\n                 size_t size,\n                 libcerror_error_t **error ),\n      off64_t (*seek_offset)(\n                 intptr_t *io_handle,\n                 off64_t offset,\n                 int whence,\n                 libcerror_error_t **error ),\n      int (*exists)(\n             intptr_t *io_handle,\n             libcerror_error_t **error ),\n      int (*is_open)(\n             intptr_t *io_handle,\n             libcerror_error_t **error ),\n      int (*get_size)(\n             intptr_t *io_handle,\n             size64_t *size,\n             libcerror_error_t **error ),\n      uint8_t flags,\n      libcerror_error_t **error )\n{\n\tlibbfio_internal_handle_t *internal_handle = NULL;\n\tstatic char *function                      = \"libbfio_handle_initialize\";\n\n\tif( handle == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid handle.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *handle != NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\n\t\t \"%s: invalid handle value already set.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tinternal_handle = memory_allocate_structure(\n\t                   libbfio_internal_handle_t );\n\n\tif( internal_handle == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create handle.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     internal_handle,\n\t     0,\n\t     sizeof( libbfio_internal_handle_t ) ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear handle.\",\n\t\t function );\n\n\t\tmemory_free(\n\t\t internal_handle );\n\n\t\treturn( -1 );\n\t}\n\tif( libcdata_range_list_initialize(\n\t     &( internal_handle->offsets_read ),\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create read offsets list.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n#if defined( HAVE_MULTI_THREAD_SUPPORT ) && !defined( HAVE_LOCAL_LIBBFIO )\n\tif( libcthreads_read_write_lock_initialize(\n\t     &( internal_handle->read_write_lock ),\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to intialize read/write lock.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n#endif\n\tinternal_handle->io_handle       = io_handle;\n\tinternal_handle->flags           = flags;\n\tinternal_handle->free_io_handle  = free_io_handle;\n\tinternal_handle->clone_io_handle = clone_io_handle;\n\tinternal_handle->open            = open;\n\tinternal_handle->close           = close;\n\tinternal_handle->read            = read;\n\tinternal_handle->write           = write;\n\tinternal_handle->seek_offset     = seek_offset;\n\tinternal_handle->exists          = exists;\n\tinternal_handle->is_open         = is_open;\n\tinternal_handle->get_size        = get_size;\n\n\t*handle = (libbfio_handle_t *) internal_handle;\n\n\treturn( 1 );\n\non_error:\n\tif( internal_handle != NULL )\n\t{\n\t\tif( internal_handle->offsets_read != NULL )\n\t\t{\n\t\t\tlibcdata_range_list_free(\n\t\t\t &( internal_handle->offsets_read ),\n\t\t\t NULL,\n\t\t\t NULL );\n\t\t}\n\t\tmemory_free(\n\t\t internal_handle );\n\t}\n\treturn( -1 );\n}", "Selected Statement": "\tinternal_handle->clone_io_handle = clone_io_handle;\n", "Selected Pointer": "clone_io_handle", "Compared Statement": "\tinternal_handle->exists          = exists;\n", "Compared Pointer": "exists", "Aliasing": "No", "Function Input": {"error": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdbc0", "value": {"type_category": "pointer", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x1060fe1a\n", "message": "Cannot access memory at address 0x1060fe1a"}}, "flags": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "0 '\\000'"}, "handle": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdc28", "value": {"type_category": "pointer", "concrete_type": "NULL"}}, "io_handle": {"type_category": "pointer", "concrete_type": "NULL"}}, "Program Information": {"Project Name": "libyal"}}
{"Programming Language": "C", "Source Code": "int libfdata_list_initialize(\n     libfdata_list_t **list,\n     intptr_t *data_handle,\n     int (*free_data_handle)(\n            intptr_t **data_handle,\n            libcerror_error_t **error ),\n     int (*clone_data_handle)(\n            intptr_t **destination_data_handle,\n            intptr_t *source_data_handle,\n            libcerror_error_t **error ),\n     int (*read_element_data)(\n            intptr_t *data_handle,\n            intptr_t *file_io_handle,\n            libfdata_list_element_t *list_element,\n            libfdata_cache_t *cache,\n            int element_data_file_index,\n            off64_t element_data_offset,\n            size64_t element_data_size,\n            uint32_t element_data_flags,\n            uint8_t read_flags,\n            libcerror_error_t **error ),\n     int (*write_element_data)(\n            intptr_t *data_handle,\n            intptr_t *file_io_handle,\n            libfdata_list_element_t *list_element,\n            libfdata_cache_t *cache,\n            int element_data_file_index,\n            off64_t element_data_offset,\n            size64_t element_data_size,\n            uint32_t element_data_flags,\n            uint8_t write_flags,\n            libcerror_error_t **error ),\n     uint8_t flags,\n     libcerror_error_t **error )\n{\n\tlibfdata_internal_list_t *internal_list = NULL;\n\tstatic char *function                   = \"libfdata_list_initialize\";\n\n\tif( list == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid list.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *list != NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\n\t\t \"%s: invalid list value already set.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( ( flags & 0xfe ) != 0 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\n\t\t \"%s: unsupported flags: 0x%02\" PRIx8 \".\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tinternal_list = memory_allocate_structure(\n\t                 libfdata_internal_list_t );\n\n\tif( internal_list == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create list.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     internal_list,\n\t     0,\n\t     sizeof( libfdata_internal_list_t ) ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear list.\",\n\t\t function );\n\n\t\tmemory_free(\n\t\t internal_list );\n\n\t\treturn( -1 );\n\t}\n\tif( libcdata_array_initialize(\n\t     &( internal_list->elements_array ),\n\t     0,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create elements array.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( libcdata_array_initialize(\n\t     &( internal_list->mapped_ranges_array ),\n\t     0,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create mapped ranges array.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tinternal_list->flags             |= flags;\n\tinternal_list->data_handle        = data_handle;\n\tinternal_list->free_data_handle   = free_data_handle;\n\tinternal_list->clone_data_handle  = clone_data_handle;\n\tinternal_list->read_element_data  = read_element_data;\n\tinternal_list->write_element_data = write_element_data;\n\n\t*list = (libfdata_list_t *) internal_list;\n\n\treturn( 1 );\n\non_error:\n\tif( internal_list != NULL )\n\t{\n\t\tif( internal_list->elements_array != NULL )\n\t\t{\n\t\t\tlibcdata_array_free(\n\t\t\t &( internal_list->elements_array ),\n\t\t\t NULL,\n\t\t\t NULL );\n\t\t}\n\t\tmemory_free(\n\t\t internal_list );\n\t}\n\treturn( -1 );\n}", "Selected Statement": "\tinternal_list->read_element_data  = read_element_data;\n", "Selected Pointer": "read_element_data", "Compared Statement": "\tinternal_list->data_handle        = data_handle;\n", "Compared Pointer": "data_handle", "Aliasing": "No", "Function Input": {"data_handle": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdd48", "value": {"type_category": "unknown", "concrete_type": "intptr_t", "value": "0"}}, "error": {"type_category": "pointer", "concrete_type": "NULL"}, "flags": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "0 '\\000'"}, "list": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdd50", "value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x12ea8c0", "value": {"type_category": "unknown", "concrete_type": "libfdata_list_t", "value": "0"}}}}, "Program Information": {"Project Name": "libyal"}}
