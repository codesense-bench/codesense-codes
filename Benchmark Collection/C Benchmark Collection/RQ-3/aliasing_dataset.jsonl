{"Programming Language": "C", "Source Code": "const char *\ncsv_parse_impl(struct csv *csv, const char *s, const char *end, bool firstonly)\n{\n\tif (end - s == 0)\n\t\treturn NULL;\n\tassert(end - s > 0);\n\tassert(csv->emit_field);\n\tassert(csv->emit_row);\n\tfor (const char *p = s; p != end; p++) {\n\t\tbool is_line_end = (*p == '\\n' || *p == '\\r');\n\t\t\n\t\tif (csv->buf == NULL ||\n\t\t   (csv->bufp && csv->buf_len < (size_t)(csv->bufp - csv->buf + 1))) {\n\t\t\tsize_t new_size = csv->buf_len * 2;\n\t\t\tif (csv->buf_len == 0 || csv->buf == NULL)\n\t\t\t\tnew_size = 256;\n\t\t\tchar *new_buf = (char *)csv->realloc(csv->buf, new_size);\n\t\t\tif (new_buf == NULL) {\n\t\t\t\tcsv->error_status = CSV_ER_MEMORY_ERROR;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcsv->buf_len = new_size;\n\t\t\tcsv->bufp = csv->bufp - csv->buf + new_buf;\n\t\t\tcsv->buf = new_buf;\n\t\t}\n\t\t\n\t\tif (is_line_end && csv->state != CSV_IN_QUOTES &&\n\t\t   *p != csv->prev_symbol &&\n\t\t   (csv->prev_symbol  == '\\n' || csv->prev_symbol == '\\r')) {\n\t\t\tcsv->prev_symbol = '\\0';\n\t\t\tcontinue;\n\t\t}\n\t\tcsv->prev_symbol = *p;\n\t\t\n\t\tswitch (csv->state) {\n\t\tcase CSV_LEADING_SPACES:\n\t\t\tcsv->bufp = csv->buf;\n\t\t\tif (*p == ' ') \n\t\t\t\tcontinue;\n\t\t\tcsv->state = CSV_OUT_OF_QUOTES;\n\t\t\t\n\t\t\tbreak;\n\t\tcase CSV_QUOTE_OPENING:\n\t\t\tif (*p == csv->quote_char && csv->bufp) {\n\t\t\t\t\n\t\t\t\t*csv->bufp++ = csv->quote_char;\n\t\t\t\tcsv->state = CSV_OUT_OF_QUOTES;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcsv->state = CSV_IN_QUOTES;\n\t\t\t\n\t\t\tbreak;\n\t\tcase CSV_QUOTE_CLOSING:\n\t\t\tif (*p == csv->quote_char) {\n\t\t\t\t\n\t\t\t\t*csv->bufp++ = csv->quote_char;\n\t\t\t\tcsv->state = CSV_IN_QUOTES;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcsv->state = CSV_OUT_OF_QUOTES;\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (csv->state) {\n\t\tcase CSV_OUT_OF_QUOTES:\n\t\t\tif (is_line_end || *p == csv->delimiter) {\n\t\t\t\t\n\t\t\t\tcsv->state = CSV_LEADING_SPACES;\n\t\t\t\tcsv->bufp -= csv->ending_spaces;\n\t\t\t\tcsv->ending_spaces = 0;\n\t\t\t\tif (firstonly) {\n\t\t\t\t\tcsv->state = CSV_NEWFIELD;\n\t\t\t\t\treturn p;\n\t\t\t\t} else {\n\t\t\t\t\tcsv->emit_field(csv->emit_ctx,\n\t\t\t\t\t\t\tcsv->buf, csv->bufp);\n\t\t\t\t}\n\n\t\t\t\tcsv->bufp = csv->buf;\n\n\t\t\t} else if (*p == csv->quote_char) {\n\t\t\t\tcsv->state = CSV_QUOTE_OPENING;\n\t\t\t} else {\n\t\t\t\t*csv->bufp++ = *p;\n\t\t\t}\n\n\t\t\tif (*p == ' ') {\n\t\t\t\tcsv->ending_spaces++;\n\t\t\t} else {\n\t\t\t\tcsv->ending_spaces = 0;\n\t\t\t}\n\t\t\tif (is_line_end) {\n\t\t\t\t\n\t\t\t\tcsv->bufp = 0;\n\t\t\t\tcsv->emit_row(csv->emit_ctx);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CSV_IN_QUOTES:\n\t\t\t\n\t\t\tassert(csv->bufp != NULL);\n\t\t\tif (*p == csv->quote_char) {\n\t\t\t\tcsv->state = CSV_QUOTE_CLOSING;\n\t\t\t} else {\n\t\t\t\t*csv->bufp++ = *p;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CSV_NEWFIELD:\n\t\t\tcsv->bufp = csv->buf;\n\t\t\tcsv->state = CSV_LEADING_SPACES;\n\t\t\tif (is_line_end) {\n\t\t\t\tcsv->bufp = 0;\n\t\t\t\tif (p + 1 == end)\n\t\t\t\t\treturn NULL;\n\t\t\t\telse\n\t\t\t\t\treturn p + 1;\n\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn end;\n}\n\n\nvoid\ncsv_parse_chunk(struct csv *csv, const char *s, const char *end) {\n\tcsv_parse_impl(csv, s, end, false);", "Selected Statement": "\tcsv_parse_impl(csv, s, end, false);\n", "Selected Pointer": "s", "Compared Statement": "\tcsv_parse_impl(csv, s, end, false);\n", "Compared Pointer": "end", "Aliasing": "Yes", "Function Input": {"csv": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffde60", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"emit_ctx": {"type_category": "pointer", "concrete_type": "VOID"}, "emit_row": {"type_category": "unknown", "concrete_type": "csv_emit_row_t"}, "emit_field": {"type_category": "unknown", "concrete_type": "csv_emit_field_t", "value": "0x7fffffffdf60"}, "delimiter": {"type_category": "int", "concrete_type": "char", "value": "16 '\\020'"}, "quote_char": {"type_category": "int", "concrete_type": "char", "value": "-112 '\\220'"}, "prev_symbol": {"type_category": "int", "concrete_type": "char", "value": "-55 '\\311'"}, "error_status": {"type_category": "int", "concrete_type": "int", "value": "0"}, "ending_spaces": {"type_category": "int", "concrete_type": "int", "value": "13209616"}, "realloc": {"type_category": "pointer", "concrete_type": "NULL"}, "state": {"type_category": "int", "concrete_type": "int", "value": "3222944"}, "buf": {"type_category": "string", "concrete_type": "string", "value": "0x312d70 <csv_emit_field_empty> \"UH\\211\\345\\212\\004%\\254\\0062\""}, "bufp": {"type_category": "string", "concrete_type": "string", "value": "0x222c <error: Cannot access memory at address 0x222c>"}, "buf_len": {"type_category": "unknown", "concrete_type": "size_t", "value": "0"}}}}, "end": {"type_category": "string", "concrete_type": "string", "value": "0x5b0000006e <error: Cannot access memory at address 0x5b0000006e>"}, "s": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffde81 \"\\220\\311\""}}, "Program Information": {"Project Name": "tarantool"}, "idx": 0}
{"Programming Language": "C", "Source Code": "const char *\ncsv_parse_impl(struct csv *csv, const char *s, const char *end, bool firstonly)\n{\n\tif (end - s == 0)\n\t\treturn NULL;\n\tassert(end - s > 0);\n\tassert(csv->emit_field);\n\tassert(csv->emit_row);\n\tfor (const char *p = s; p != end; p++) {\n\t\tbool is_line_end = (*p == '\\n' || *p == '\\r');\n\t\t\n\t\tif (csv->buf == NULL ||\n\t\t   (csv->bufp && csv->buf_len < (size_t)(csv->bufp - csv->buf + 1))) {\n\t\t\tsize_t new_size = csv->buf_len * 2;\n\t\t\tif (csv->buf_len == 0 || csv->buf == NULL)\n\t\t\t\tnew_size = 256;\n\t\t\tchar *new_buf = (char *)csv->realloc(csv->buf, new_size);\n\t\t\tif (new_buf == NULL) {\n\t\t\t\tcsv->error_status = CSV_ER_MEMORY_ERROR;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcsv->buf_len = new_size;\n\t\t\tcsv->bufp = csv->bufp - csv->buf + new_buf;\n\t\t\tcsv->buf = new_buf;\n\t\t}\n\t\t\n\t\tif (is_line_end && csv->state != CSV_IN_QUOTES &&\n\t\t   *p != csv->prev_symbol &&\n\t\t   (csv->prev_symbol  == '\\n' || csv->prev_symbol == '\\r')) {\n\t\t\tcsv->prev_symbol = '\\0';\n\t\t\tcontinue;\n\t\t}\n\t\tcsv->prev_symbol = *p;\n\t\t\n\t\tswitch (csv->state) {\n\t\tcase CSV_LEADING_SPACES:\n\t\t\tcsv->bufp = csv->buf;\n\t\t\tif (*p == ' ') \n\t\t\t\tcontinue;\n\t\t\tcsv->state = CSV_OUT_OF_QUOTES;\n\t\t\t\n\t\t\tbreak;\n\t\tcase CSV_QUOTE_OPENING:\n\t\t\tif (*p == csv->quote_char && csv->bufp) {\n\t\t\t\t\n\t\t\t\t*csv->bufp++ = csv->quote_char;\n\t\t\t\tcsv->state = CSV_OUT_OF_QUOTES;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcsv->state = CSV_IN_QUOTES;\n\t\t\t\n\t\t\tbreak;\n\t\tcase CSV_QUOTE_CLOSING:\n\t\t\tif (*p == csv->quote_char) {\n\t\t\t\t\n\t\t\t\t*csv->bufp++ = csv->quote_char;\n\t\t\t\tcsv->state = CSV_IN_QUOTES;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcsv->state = CSV_OUT_OF_QUOTES;\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (csv->state) {\n\t\tcase CSV_OUT_OF_QUOTES:\n\t\t\tif (is_line_end || *p == csv->delimiter) {\n\t\t\t\t\n\t\t\t\tcsv->state = CSV_LEADING_SPACES;\n\t\t\t\tcsv->bufp -= csv->ending_spaces;\n\t\t\t\tcsv->ending_spaces = 0;\n\t\t\t\tif (firstonly) {\n\t\t\t\t\tcsv->state = CSV_NEWFIELD;\n\t\t\t\t\treturn p;\n\t\t\t\t} else {\n\t\t\t\t\tcsv->emit_field(csv->emit_ctx,\n\t\t\t\t\t\t\tcsv->buf, csv->bufp);\n\t\t\t\t}\n\n\t\t\t\tcsv->bufp = csv->buf;\n\n\t\t\t} else if (*p == csv->quote_char) {\n\t\t\t\tcsv->state = CSV_QUOTE_OPENING;\n\t\t\t} else {\n\t\t\t\t*csv->bufp++ = *p;\n\t\t\t}\n\n\t\t\tif (*p == ' ') {\n\t\t\t\tcsv->ending_spaces++;\n\t\t\t} else {\n\t\t\t\tcsv->ending_spaces = 0;\n\t\t\t}\n\t\t\tif (is_line_end) {\n\t\t\t\t\n\t\t\t\tcsv->bufp = 0;\n\t\t\t\tcsv->emit_row(csv->emit_ctx);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CSV_IN_QUOTES:\n\t\t\t\n\t\t\tassert(csv->bufp != NULL);\n\t\t\tif (*p == csv->quote_char) {\n\t\t\t\tcsv->state = CSV_QUOTE_CLOSING;\n\t\t\t} else {\n\t\t\t\t*csv->bufp++ = *p;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CSV_NEWFIELD:\n\t\t\tcsv->bufp = csv->buf;\n\t\t\tcsv->state = CSV_LEADING_SPACES;\n\t\t\tif (is_line_end) {\n\t\t\t\tcsv->bufp = 0;\n\t\t\t\tif (p + 1 == end)\n\t\t\t\t\treturn NULL;\n\t\t\t\telse\n\t\t\t\t\treturn p + 1;\n\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn end;\n}\n\n\nvoid\ncsv_parse_chunk(struct csv *csv, const char *s, const char *end) {\n\tcsv_parse_impl(csv, s, end, false);", "Selected Statement": "\tfor (const char *p = s; p != end; p++) {\n", "Selected Pointer": "p", "Compared Statement": "\tcsv_parse_impl(csv, s, end, false);\n", "Compared Pointer": "s", "Aliasing": "Yes", "Function Input": {"csv": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdd70", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x201\n", "message": "Cannot access memory at address 0x201"}}, "end": {"type_category": "string", "concrete_type": "string", "value": "0x5b0000006e <error: Cannot access memory at address 0x5b0000006e>"}, "s": {"type_category": "string", "concrete_type": "NULL"}}, "Program Information": {"Project Name": "tarantool"}, "idx": 1}
{"Programming Language": "C", "Source Code": "static decimal_t *\ndecimal_check_status(decimal_t *dec, decContext *context)\n{\n\tuint32_t status = decContextGetStatus(context);\n\tdecContextZeroStatus(context);\n\t\n\tstatus &= ~(uint32_t)(DEC_Inexact | DEC_Rounded | DEC_Underflow |\n\t\t\t      DEC_Subnormal | DEC_Clamped);\n\treturn status || !decNumberIsFinite(dec) ? NULL : dec;\n}\n\nint decimal_precision(const decimal_t *dec) {\n\treturn dec->exponent <= 0 ? MAX(dec->digits, -dec->exponent) :\n\t\t\t\t    dec->digits + dec->exponent;\n}\n\nint  decimal_scale(const decimal_t *dec) {\n\treturn dec->exponent < 0 ? -dec->exponent : 0;\n}\n\ndecimal_t *\ndecimal_zero(decimal_t *dec)\n{\n\tdecNumberZero(dec);\n\treturn dec;\n}\n\nbool\ndecimal_is_int(const decimal_t *dec)\n{\n\treturn decNumberIsInt(dec);\n}\n\nbool\ndecimal_is_neg(const decimal_t *dec)\n{\n\treturn decNumberIsNegative(dec) && !decNumberIsZero(dec);\n}\n\ndecimal_t *\ndecimal_from_string(decimal_t *dec, const char *str)\n{\n\tconst char *end = decNumberFromString(dec, str, &decimal_context);\n\tif (*end != '\\0') {\n\t\tdecContextZeroStatus(&decimal_context);\n\t\treturn NULL;\n\t}", "Selected Statement": "\tuint32_t status = decContextGetStatus(context);\n", "Selected Pointer": "context", "Compared Statement": "decimal_check_status(decimal_t *dec, decContext *context)\n", "Compared Pointer": "dec", "Aliasing": "No", "Function Input": {"dec": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffde58", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"digits": {"type_category": "unknown", "concrete_type": "int32_t", "value": "1"}, "exponent": {"type_category": "unknown", "concrete_type": "int32_t", "value": "0"}, "bits": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "32 ' '"}, "lsu": {"type_category": "array", "concrete_type": "uint16_t", "value": [{"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "47936"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "216"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "30780"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "42"}]}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 2}
{"Programming Language": "C", "Source Code": "static decimal_t *\ndecimal_check_status(decimal_t *dec, decContext *context)\n{\n\tuint32_t status = decContextGetStatus(context);\n\tdecContextZeroStatus(context);\n\t\n\tstatus &= ~(uint32_t)(DEC_Inexact | DEC_Rounded | DEC_Underflow |\n\t\t\t      DEC_Subnormal | DEC_Clamped);\n\treturn status || !decNumberIsFinite(dec) ? NULL : dec;\n}\n\nint decimal_precision(const decimal_t *dec) {\n\treturn dec->exponent <= 0 ? MAX(dec->digits, -dec->exponent) :\n\t\t\t\t    dec->digits + dec->exponent;\n}\n\nint  decimal_scale(const decimal_t *dec) {\n\treturn dec->exponent < 0 ? -dec->exponent : 0;\n}\n\ndecimal_t *\ndecimal_zero(decimal_t *dec)\n{\n\tdecNumberZero(dec);\n\treturn dec;\n}\n\nbool\ndecimal_is_int(const decimal_t *dec)\n{\n\treturn decNumberIsInt(dec);\n}\n\nbool\ndecimal_is_neg(const decimal_t *dec)\n{\n\treturn decNumberIsNegative(dec) && !decNumberIsZero(dec);\n}\n\ndecimal_t *\ndecimal_from_string(decimal_t *dec, const char *str)\n{\n\tconst char *end = decNumberFromString(dec, str, &decimal_context);\n\tif (*end != '\\0') {\n\t\tdecContextZeroStatus(&decimal_context);\n\t\treturn NULL;\n\t}", "Selected Statement": "decimal_check_status(decimal_t *dec, decContext *context)\n", "Selected Pointer": "dec", "Compared Statement": "\tuint32_t status = decContextGetStatus(context);\n", "Compared Pointer": "context", "Aliasing": "No", "Function Input": {"dec": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdd68", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"digits": {"type_category": "unknown", "concrete_type": "int32_t", "value": "1"}, "exponent": {"type_category": "unknown", "concrete_type": "int32_t", "value": "0"}, "bits": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "0 '\\000'"}, "lsu": {"type_category": "array", "concrete_type": "uint16_t", "value": [{"type_category": "unknown", "concrete_type": "uint16_t", "value": "9"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "47936"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "216"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "30780"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "42"}]}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 3}
{"Programming Language": "C", "Source Code": "static decimal_t *\ndecimal_check_status(decimal_t *dec, decContext *context)\n{\n\tuint32_t status = decContextGetStatus(context);\n\tdecContextZeroStatus(context);\n\t\n\tstatus &= ~(uint32_t)(DEC_Inexact | DEC_Rounded | DEC_Underflow |\n\t\t\t      DEC_Subnormal | DEC_Clamped);\n\treturn status || !decNumberIsFinite(dec) ? NULL : dec;\n}\n\nint decimal_precision(const decimal_t *dec) {\n\treturn dec->exponent <= 0 ? MAX(dec->digits, -dec->exponent) :\n\t\t\t\t    dec->digits + dec->exponent;\n}\n\nint  decimal_scale(const decimal_t *dec) {\n\treturn dec->exponent < 0 ? -dec->exponent : 0;\n}\n\ndecimal_t *\ndecimal_zero(decimal_t *dec)\n{\n\tdecNumberZero(dec);\n\treturn dec;\n}\n\nbool\ndecimal_is_int(const decimal_t *dec)\n{\n\treturn decNumberIsInt(dec);\n}\n\nbool\ndecimal_is_neg(const decimal_t *dec)\n{\n\treturn decNumberIsNegative(dec) && !decNumberIsZero(dec);\n}\n\ndecimal_t *\ndecimal_from_string(decimal_t *dec, const char *str)\n{\n\tconst char *end = decNumberFromString(dec, str, &decimal_context);\n\tif (*end != '\\0') {\n\t\tdecContextZeroStatus(&decimal_context);\n\t\treturn NULL;\n\t}", "Selected Statement": "\tuint32_t status = decContextGetStatus(context);\n", "Selected Pointer": "context", "Compared Statement": "decimal_check_status(decimal_t *dec, decContext *context)\n", "Compared Pointer": "dec", "Aliasing": "No", "Function Input": {"dec": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdd68", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"digits": {"type_category": "unknown", "concrete_type": "int32_t", "value": "1"}, "exponent": {"type_category": "unknown", "concrete_type": "int32_t", "value": "0"}, "bits": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "0 '\\000'"}, "lsu": {"type_category": "array", "concrete_type": "uint16_t", "value": [{"type_category": "unknown", "concrete_type": "uint16_t", "value": "2"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "47936"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "216"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "30780"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "42"}]}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 4}
{"Programming Language": "C", "Source Code": "static decimal_t *\ndecimal_check_status(decimal_t *dec, decContext *context)\n{\n\tuint32_t status = decContextGetStatus(context);\n\tdecContextZeroStatus(context);\n\t\n\tstatus &= ~(uint32_t)(DEC_Inexact | DEC_Rounded | DEC_Underflow |\n\t\t\t      DEC_Subnormal | DEC_Clamped);\n\treturn status || !decNumberIsFinite(dec) ? NULL : dec;\n}\n\nint decimal_precision(const decimal_t *dec) {\n\treturn dec->exponent <= 0 ? MAX(dec->digits, -dec->exponent) :\n\t\t\t\t    dec->digits + dec->exponent;\n}\n\nint  decimal_scale(const decimal_t *dec) {\n\treturn dec->exponent < 0 ? -dec->exponent : 0;\n}\n\ndecimal_t *\ndecimal_zero(decimal_t *dec)\n{\n\tdecNumberZero(dec);\n\treturn dec;\n}\n\nbool\ndecimal_is_int(const decimal_t *dec)\n{\n\treturn decNumberIsInt(dec);\n}\n\nbool\ndecimal_is_neg(const decimal_t *dec)\n{\n\treturn decNumberIsNegative(dec) && !decNumberIsZero(dec);\n}\n\ndecimal_t *\ndecimal_from_string(decimal_t *dec, const char *str)\n{\n\tconst char *end = decNumberFromString(dec, str, &decimal_context);\n\tif (*end != '\\0') {\n\t\tdecContextZeroStatus(&decimal_context);\n\t\treturn NULL;\n\t}", "Selected Statement": "\tuint32_t status = decContextGetStatus(context);\n", "Selected Pointer": "context", "Compared Statement": "decimal_check_status(decimal_t *dec, decContext *context)\n", "Compared Pointer": "dec", "Aliasing": "No", "Function Input": {"dec": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdd68", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"digits": {"type_category": "unknown", "concrete_type": "int32_t", "value": "1"}, "exponent": {"type_category": "unknown", "concrete_type": "int32_t", "value": "-1"}, "bits": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "0 '\\000'"}, "lsu": {"type_category": "array", "concrete_type": "uint16_t", "value": [{"type_category": "unknown", "concrete_type": "uint16_t", "value": "1"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "47936"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "216"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "30780"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "42"}]}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 5}
{"Programming Language": "C", "Source Code": "static decimal_t *\ndecimal_check_status(decimal_t *dec, decContext *context)\n{\n\tuint32_t status = decContextGetStatus(context);\n\tdecContextZeroStatus(context);\n\t\n\tstatus &= ~(uint32_t)(DEC_Inexact | DEC_Rounded | DEC_Underflow |\n\t\t\t      DEC_Subnormal | DEC_Clamped);\n\treturn status || !decNumberIsFinite(dec) ? NULL : dec;\n}\n\nint decimal_precision(const decimal_t *dec) {\n\treturn dec->exponent <= 0 ? MAX(dec->digits, -dec->exponent) :\n\t\t\t\t    dec->digits + dec->exponent;\n}\n\nint  decimal_scale(const decimal_t *dec) {\n\treturn dec->exponent < 0 ? -dec->exponent : 0;\n}\n\ndecimal_t *\ndecimal_zero(decimal_t *dec)\n{\n\tdecNumberZero(dec);\n\treturn dec;\n}\n\nbool\ndecimal_is_int(const decimal_t *dec)\n{\n\treturn decNumberIsInt(dec);\n}\n\nbool\ndecimal_is_neg(const decimal_t *dec)\n{\n\treturn decNumberIsNegative(dec) && !decNumberIsZero(dec);\n}\n\ndecimal_t *\ndecimal_from_string(decimal_t *dec, const char *str)\n{\n\tconst char *end = decNumberFromString(dec, str, &decimal_context);\n\tif (*end != '\\0') {\n\t\tdecContextZeroStatus(&decimal_context);\n\t\treturn NULL;\n\t}", "Selected Statement": "\tuint32_t status = decContextGetStatus(context);\n", "Selected Pointer": "context", "Compared Statement": "decimal_check_status(decimal_t *dec, decContext *context)\n", "Compared Pointer": "dec", "Aliasing": "No", "Function Input": {"dec": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdd68", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"digits": {"type_category": "unknown", "concrete_type": "int32_t", "value": "1"}, "exponent": {"type_category": "unknown", "concrete_type": "int32_t", "value": "0"}, "bits": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "0 '\\000'"}, "lsu": {"type_category": "array", "concrete_type": "uint16_t", "value": [{"type_category": "unknown", "concrete_type": "uint16_t", "value": "7"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "47936"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "216"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "30780"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "42"}]}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 6}
{"Programming Language": "C", "Source Code": "static decimal_t *\ndecimal_check_status(decimal_t *dec, decContext *context)\n{\n\tuint32_t status = decContextGetStatus(context);\n\tdecContextZeroStatus(context);\n\t\n\tstatus &= ~(uint32_t)(DEC_Inexact | DEC_Rounded | DEC_Underflow |\n\t\t\t      DEC_Subnormal | DEC_Clamped);\n\treturn status || !decNumberIsFinite(dec) ? NULL : dec;\n}\n\nint decimal_precision(const decimal_t *dec) {\n\treturn dec->exponent <= 0 ? MAX(dec->digits, -dec->exponent) :\n\t\t\t\t    dec->digits + dec->exponent;\n}\n\nint  decimal_scale(const decimal_t *dec) {\n\treturn dec->exponent < 0 ? -dec->exponent : 0;\n}\n\ndecimal_t *\ndecimal_zero(decimal_t *dec)\n{\n\tdecNumberZero(dec);\n\treturn dec;\n}\n\nbool\ndecimal_is_int(const decimal_t *dec)\n{\n\treturn decNumberIsInt(dec);\n}\n\nbool\ndecimal_is_neg(const decimal_t *dec)\n{\n\treturn decNumberIsNegative(dec) && !decNumberIsZero(dec);\n}\n\ndecimal_t *\ndecimal_from_string(decimal_t *dec, const char *str)\n{\n\tconst char *end = decNumberFromString(dec, str, &decimal_context);\n\tif (*end != '\\0') {\n\t\tdecContextZeroStatus(&decimal_context);\n\t\treturn NULL;\n\t}", "Selected Statement": "decimal_check_status(decimal_t *dec, decContext *context)\n", "Selected Pointer": "dec", "Compared Statement": "\tuint32_t status = decContextGetStatus(context);\n", "Compared Pointer": "context", "Aliasing": "No", "Function Input": {"dec": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdd68", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"digits": {"type_category": "unknown", "concrete_type": "int32_t", "value": "1"}, "exponent": {"type_category": "unknown", "concrete_type": "int32_t", "value": "0"}, "bits": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "0 '\\000'"}, "lsu": {"type_category": "array", "concrete_type": "uint16_t", "value": [{"type_category": "unknown", "concrete_type": "uint16_t", "value": "8"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "47936"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "216"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "30780"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "42"}]}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 7}
{"Programming Language": "C", "Source Code": "static decimal_t *\ndecimal_check_status(decimal_t *dec, decContext *context)\n{\n\tuint32_t status = decContextGetStatus(context);\n\tdecContextZeroStatus(context);\n\t\n\tstatus &= ~(uint32_t)(DEC_Inexact | DEC_Rounded | DEC_Underflow |\n\t\t\t      DEC_Subnormal | DEC_Clamped);\n\treturn status || !decNumberIsFinite(dec) ? NULL : dec;\n}\n\nint decimal_precision(const decimal_t *dec) {\n\treturn dec->exponent <= 0 ? MAX(dec->digits, -dec->exponent) :\n\t\t\t\t    dec->digits + dec->exponent;\n}\n\nint  decimal_scale(const decimal_t *dec) {\n\treturn dec->exponent < 0 ? -dec->exponent : 0;\n}\n\ndecimal_t *\ndecimal_zero(decimal_t *dec)\n{\n\tdecNumberZero(dec);\n\treturn dec;\n}\n\nbool\ndecimal_is_int(const decimal_t *dec)\n{\n\treturn decNumberIsInt(dec);\n}\n\nbool\ndecimal_is_neg(const decimal_t *dec)\n{\n\treturn decNumberIsNegative(dec) && !decNumberIsZero(dec);\n}\n\ndecimal_t *\ndecimal_from_string(decimal_t *dec, const char *str)\n{\n\tconst char *end = decNumberFromString(dec, str, &decimal_context);\n\tif (*end != '\\0') {\n\t\tdecContextZeroStatus(&decimal_context);\n\t\treturn NULL;\n\t}", "Selected Statement": "\tuint32_t status = decContextGetStatus(context);\n", "Selected Pointer": "context", "Compared Statement": "decimal_check_status(decimal_t *dec, decContext *context)\n", "Compared Pointer": "dec", "Aliasing": "No", "Function Input": {"dec": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdd68", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"digits": {"type_category": "unknown", "concrete_type": "int32_t", "value": "1"}, "exponent": {"type_category": "unknown", "concrete_type": "int32_t", "value": "0"}, "bits": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "32 ' '"}, "lsu": {"type_category": "array", "concrete_type": "uint16_t", "value": [{"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "47936"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "216"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "30780"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "42"}]}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 8}
{"Programming Language": "C", "Source Code": "static decimal_t *\ndecimal_check_status(decimal_t *dec, decContext *context)\n{\n\tuint32_t status = decContextGetStatus(context);\n\tdecContextZeroStatus(context);\n\t\n\tstatus &= ~(uint32_t)(DEC_Inexact | DEC_Rounded | DEC_Underflow |\n\t\t\t      DEC_Subnormal | DEC_Clamped);\n\treturn status || !decNumberIsFinite(dec) ? NULL : dec;\n}\n\nint decimal_precision(const decimal_t *dec) {\n\treturn dec->exponent <= 0 ? MAX(dec->digits, -dec->exponent) :\n\t\t\t\t    dec->digits + dec->exponent;\n}\n\nint  decimal_scale(const decimal_t *dec) {\n\treturn dec->exponent < 0 ? -dec->exponent : 0;\n}\n\ndecimal_t *\ndecimal_zero(decimal_t *dec)\n{\n\tdecNumberZero(dec);\n\treturn dec;\n}\n\nbool\ndecimal_is_int(const decimal_t *dec)\n{\n\treturn decNumberIsInt(dec);\n}\n\nbool\ndecimal_is_neg(const decimal_t *dec)\n{\n\treturn decNumberIsNegative(dec) && !decNumberIsZero(dec);\n}\n\ndecimal_t *\ndecimal_from_string(decimal_t *dec, const char *str)\n{\n\tconst char *end = decNumberFromString(dec, str, &decimal_context);\n\tif (*end != '\\0') {\n\t\tdecContextZeroStatus(&decimal_context);\n\t\treturn NULL;\n\t}", "Selected Statement": "decimal_check_status(decimal_t *dec, decContext *context)\n", "Selected Pointer": "dec", "Compared Statement": "\tuint32_t status = decContextGetStatus(context);\n", "Compared Pointer": "context", "Aliasing": "No", "Function Input": {"dec": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdd68", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"digits": {"type_category": "unknown", "concrete_type": "int32_t", "value": "1"}, "exponent": {"type_category": "unknown", "concrete_type": "int32_t", "value": "0"}, "bits": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "0 '\\000'"}, "lsu": {"type_category": "array", "concrete_type": "uint16_t", "value": [{"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "47936"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "216"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "30780"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "42"}]}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 9}
{"Programming Language": "C", "Source Code": "static decimal_t *\ndecimal_check_status(decimal_t *dec, decContext *context)\n{\n\tuint32_t status = decContextGetStatus(context);\n\tdecContextZeroStatus(context);\n\t\n\tstatus &= ~(uint32_t)(DEC_Inexact | DEC_Rounded | DEC_Underflow |\n\t\t\t      DEC_Subnormal | DEC_Clamped);\n\treturn status || !decNumberIsFinite(dec) ? NULL : dec;\n}\n\nint decimal_precision(const decimal_t *dec) {\n\treturn dec->exponent <= 0 ? MAX(dec->digits, -dec->exponent) :\n\t\t\t\t    dec->digits + dec->exponent;\n}\n\nint  decimal_scale(const decimal_t *dec) {\n\treturn dec->exponent < 0 ? -dec->exponent : 0;\n}\n\ndecimal_t *\ndecimal_zero(decimal_t *dec)\n{\n\tdecNumberZero(dec);\n\treturn dec;\n}\n\nbool\ndecimal_is_int(const decimal_t *dec)\n{\n\treturn decNumberIsInt(dec);\n}\n\nbool\ndecimal_is_neg(const decimal_t *dec)\n{\n\treturn decNumberIsNegative(dec) && !decNumberIsZero(dec);\n}\n\ndecimal_t *\ndecimal_from_string(decimal_t *dec, const char *str)\n{\n\tconst char *end = decNumberFromString(dec, str, &decimal_context);\n\tif (*end != '\\0') {\n\t\tdecContextZeroStatus(&decimal_context);\n\t\treturn NULL;\n\t}", "Selected Statement": "\tuint32_t status = decContextGetStatus(context);\n", "Selected Pointer": "context", "Compared Statement": "decimal_check_status(decimal_t *dec, decContext *context)\n", "Compared Pointer": "dec", "Aliasing": "No", "Function Input": {"dec": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdd68", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"digits": {"type_category": "unknown", "concrete_type": "int32_t", "value": "1"}, "exponent": {"type_category": "unknown", "concrete_type": "int32_t", "value": "0"}, "bits": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "0 '\\000'"}, "lsu": {"type_category": "array", "concrete_type": "uint16_t", "value": [{"type_category": "unknown", "concrete_type": "uint16_t", "value": "1"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "47936"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "216"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "30780"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "42"}]}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 10}
{"Programming Language": "C", "Source Code": "static decimal_t *\ndecimal_check_status(decimal_t *dec, decContext *context)\n{\n\tuint32_t status = decContextGetStatus(context);\n\tdecContextZeroStatus(context);\n\t\n\tstatus &= ~(uint32_t)(DEC_Inexact | DEC_Rounded | DEC_Underflow |\n\t\t\t      DEC_Subnormal | DEC_Clamped);\n\treturn status || !decNumberIsFinite(dec) ? NULL : dec;\n}\n\nint decimal_precision(const decimal_t *dec) {\n\treturn dec->exponent <= 0 ? MAX(dec->digits, -dec->exponent) :\n\t\t\t\t    dec->digits + dec->exponent;\n}\n\nint  decimal_scale(const decimal_t *dec) {\n\treturn dec->exponent < 0 ? -dec->exponent : 0;\n}\n\ndecimal_t *\ndecimal_zero(decimal_t *dec)\n{\n\tdecNumberZero(dec);\n\treturn dec;\n}\n\nbool\ndecimal_is_int(const decimal_t *dec)\n{\n\treturn decNumberIsInt(dec);\n}\n\nbool\ndecimal_is_neg(const decimal_t *dec)\n{\n\treturn decNumberIsNegative(dec) && !decNumberIsZero(dec);\n}\n\ndecimal_t *\ndecimal_from_string(decimal_t *dec, const char *str)\n{\n\tconst char *end = decNumberFromString(dec, str, &decimal_context);\n\tif (*end != '\\0') {\n\t\tdecContextZeroStatus(&decimal_context);\n\t\treturn NULL;\n\t}", "Selected Statement": "decimal_check_status(decimal_t *dec, decContext *context)\n", "Selected Pointer": "dec", "Compared Statement": "\tuint32_t status = decContextGetStatus(context);\n", "Compared Pointer": "context", "Aliasing": "No", "Function Input": {"dec": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdd68", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"digits": {"type_category": "unknown", "concrete_type": "int32_t", "value": "1"}, "exponent": {"type_category": "unknown", "concrete_type": "int32_t", "value": "0"}, "bits": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "0 '\\000'"}, "lsu": {"type_category": "array", "concrete_type": "uint16_t", "value": [{"type_category": "unknown", "concrete_type": "uint16_t", "value": "6"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "47936"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "216"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "30780"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "42"}]}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 11}
{"Programming Language": "C", "Source Code": "static decimal_t *\ndecimal_check_status(decimal_t *dec, decContext *context)\n{\n\tuint32_t status = decContextGetStatus(context);\n\tdecContextZeroStatus(context);\n\t\n\tstatus &= ~(uint32_t)(DEC_Inexact | DEC_Rounded | DEC_Underflow |\n\t\t\t      DEC_Subnormal | DEC_Clamped);\n\treturn status || !decNumberIsFinite(dec) ? NULL : dec;\n}\n\nint decimal_precision(const decimal_t *dec) {\n\treturn dec->exponent <= 0 ? MAX(dec->digits, -dec->exponent) :\n\t\t\t\t    dec->digits + dec->exponent;\n}\n\nint  decimal_scale(const decimal_t *dec) {\n\treturn dec->exponent < 0 ? -dec->exponent : 0;\n}\n\ndecimal_t *\ndecimal_zero(decimal_t *dec)\n{\n\tdecNumberZero(dec);\n\treturn dec;\n}\n\nbool\ndecimal_is_int(const decimal_t *dec)\n{\n\treturn decNumberIsInt(dec);\n}\n\nbool\ndecimal_is_neg(const decimal_t *dec)\n{\n\treturn decNumberIsNegative(dec) && !decNumberIsZero(dec);\n}\n\ndecimal_t *\ndecimal_from_string(decimal_t *dec, const char *str)\n{\n\tconst char *end = decNumberFromString(dec, str, &decimal_context);\n\tif (*end != '\\0') {\n\t\tdecContextZeroStatus(&decimal_context);\n\t\treturn NULL;\n\t}", "Selected Statement": "\tuint32_t status = decContextGetStatus(context);\n", "Selected Pointer": "context", "Compared Statement": "decimal_check_status(decimal_t *dec, decContext *context)\n", "Compared Pointer": "dec", "Aliasing": "No", "Function Input": {"dec": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdd68", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"digits": {"type_category": "unknown", "concrete_type": "int32_t", "value": "1"}, "exponent": {"type_category": "unknown", "concrete_type": "int32_t", "value": "0"}, "bits": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "0 '\\000'"}, "lsu": {"type_category": "array", "concrete_type": "uint16_t", "value": [{"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "47936"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "216"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "30780"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "42"}]}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 12}
{"Programming Language": "C", "Source Code": "static decimal_t *\ndecimal_check_status(decimal_t *dec, decContext *context)\n{\n\tuint32_t status = decContextGetStatus(context);\n\tdecContextZeroStatus(context);\n\t\n\tstatus &= ~(uint32_t)(DEC_Inexact | DEC_Rounded | DEC_Underflow |\n\t\t\t      DEC_Subnormal | DEC_Clamped);\n\treturn status || !decNumberIsFinite(dec) ? NULL : dec;\n}\n\nint decimal_precision(const decimal_t *dec) {\n\treturn dec->exponent <= 0 ? MAX(dec->digits, -dec->exponent) :\n\t\t\t\t    dec->digits + dec->exponent;\n}\n\nint  decimal_scale(const decimal_t *dec) {\n\treturn dec->exponent < 0 ? -dec->exponent : 0;\n}\n\ndecimal_t *\ndecimal_zero(decimal_t *dec)\n{\n\tdecNumberZero(dec);\n\treturn dec;\n}\n\nbool\ndecimal_is_int(const decimal_t *dec)\n{\n\treturn decNumberIsInt(dec);\n}\n\nbool\ndecimal_is_neg(const decimal_t *dec)\n{\n\treturn decNumberIsNegative(dec) && !decNumberIsZero(dec);\n}\n\ndecimal_t *\ndecimal_from_string(decimal_t *dec, const char *str)\n{\n\tconst char *end = decNumberFromString(dec, str, &decimal_context);\n\tif (*end != '\\0') {\n\t\tdecContextZeroStatus(&decimal_context);\n\t\treturn NULL;\n\t}", "Selected Statement": "\tuint32_t status = decContextGetStatus(context);\n", "Selected Pointer": "context", "Compared Statement": "decimal_check_status(decimal_t *dec, decContext *context)\n", "Compared Pointer": "dec", "Aliasing": "No", "Function Input": {"dec": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdd68", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"digits": {"type_category": "unknown", "concrete_type": "int32_t", "value": "1"}, "exponent": {"type_category": "unknown", "concrete_type": "int32_t", "value": "0"}, "bits": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "0 '\\000'"}, "lsu": {"type_category": "array", "concrete_type": "uint16_t", "value": [{"type_category": "unknown", "concrete_type": "uint16_t", "value": "2"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "47936"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "216"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "30780"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "42"}]}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 13}
{"Programming Language": "C", "Source Code": "bool\ntm_to_datetime(struct tnt_tm *tm, struct datetime *date)\n{\n\tassert(tm != NULL);\n\tassert(date != NULL);\n\tint year = tm->tm_year;\n\tint mon = tm->tm_mon;\n\tint mday = tm->tm_mday;\n\tint yday = tm->tm_yday;\n\tint wday = tm->tm_wday;\n\tdt_t dt = 0;\n\n\tif ((year | mon | mday) == 0) {\n\t\tif (yday != 0) {\n\t\t\tdt = yday - 1 + DT_EPOCH_1970_OFFSET;\n\t\t} else if (wday != 0) {\n\t\t\t\n\t\t\tdt = ((wday - 4) % 7) + DT_EPOCH_1970_OFFSET;\n\t\t}\n\t} else {\n\t\tif (mday == 0)\n\t\t\tmday = 1;\n\t\tassert(mday >= 1 && mday <= 31);\n\t\tassert(mon >= 0 && mon <= 11);\n\t\tif (dt_from_ymd_checked(year + 1900, mon + 1, mday, &dt) == false)\n\t\t\treturn false;\n\t}\n\tint64_t local_secs =\n\t\t(int64_t)dt * SECS_PER_DAY - SECS_EPOCH_1970_OFFSET;\n\tlocal_secs += tm->tm_hour * 3600 + tm->tm_min * 60 + tm->tm_sec;\n\tdate->epoch = local_secs - tm->tm_gmtoff;\n\tdate->nsec = tm->tm_nsec;\n\tdate->tzindex = tm->tm_tzindex;\n\tdate->tzoffset = tm->tm_gmtoff / 60;\n\treturn true;\n}\n\nsize_t\ndatetime_strptime(struct datetime *date, const char *buf, const char *fmt)\n{\n\tassert(date != NULL);\n\tassert(fmt != NULL);\n\tassert(buf != NULL);\n\tstruct tnt_tm t = { .tm_epoch = 0 };\n\tchar *ret = tnt_strptime(buf, fmt, &t);\n\tif (ret == NULL)\n\t\treturn 0;", "Selected Statement": "\tassert(tm != NULL);\n", "Selected Pointer": "tm", "Compared Statement": "\tassert(date != NULL);\n", "Compared Pointer": "date", "Aliasing": "No", "Function Input": {"date": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddc8", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"epoch": {"type_category": "float", "concrete_type": "double", "value": "0"}, "nsec": {"type_category": "unknown", "concrete_type": "int32_t", "value": "0"}, "tzoffset": {"type_category": "unknown", "concrete_type": "int16_t", "value": "0"}, "tzindex": {"type_category": "unknown", "concrete_type": "int16_t", "value": "0"}}}}, "tm": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"tm_sec": {"type_category": "int", "concrete_type": "int", "value": "0"}, "tm_min": {"type_category": "int", "concrete_type": "int", "value": "0"}, "tm_hour": {"type_category": "int", "concrete_type": "int", "value": "0"}, "tm_mday": {"type_category": "int", "concrete_type": "int", "value": "0"}, "tm_mon": {"type_category": "int", "concrete_type": "int", "value": "0"}, "tm_year": {"type_category": "int", "concrete_type": "int", "value": "-1610612736"}, "tm_wday": {"type_category": "int", "concrete_type": "int", "value": "60033"}, "tm_yday": {"type_category": "int", "concrete_type": "int", "value": "0"}, "tm_isdst": {"type_category": "int", "concrete_type": "int", "value": "0"}, "tm_gmtoff": {"type_category": "int", "concrete_type": "long", "value": "-6917529027641081856"}, "tm_epoch": {"type_category": "unknown", "concrete_type": "int64_t", "value": "8070450532247988865"}, "tm_nsec": {"type_category": "int", "concrete_type": "int", "value": "-33"}, "tm_tzindex": {"type_category": "unknown", "concrete_type": "int16_t", "value": "127"}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 14}
{"Programming Language": "C", "Source Code": "bool\ntm_to_datetime(struct tnt_tm *tm, struct datetime *date)\n{\n\tassert(tm != NULL);\n\tassert(date != NULL);\n\tint year = tm->tm_year;\n\tint mon = tm->tm_mon;\n\tint mday = tm->tm_mday;\n\tint yday = tm->tm_yday;\n\tint wday = tm->tm_wday;\n\tdt_t dt = 0;\n\n\tif ((year | mon | mday) == 0) {\n\t\tif (yday != 0) {\n\t\t\tdt = yday - 1 + DT_EPOCH_1970_OFFSET;\n\t\t} else if (wday != 0) {\n\t\t\t\n\t\t\tdt = ((wday - 4) % 7) + DT_EPOCH_1970_OFFSET;\n\t\t}\n\t} else {\n\t\tif (mday == 0)\n\t\t\tmday = 1;\n\t\tassert(mday >= 1 && mday <= 31);\n\t\tassert(mon >= 0 && mon <= 11);\n\t\tif (dt_from_ymd_checked(year + 1900, mon + 1, mday, &dt) == false)\n\t\t\treturn false;\n\t}\n\tint64_t local_secs =\n\t\t(int64_t)dt * SECS_PER_DAY - SECS_EPOCH_1970_OFFSET;\n\tlocal_secs += tm->tm_hour * 3600 + tm->tm_min * 60 + tm->tm_sec;\n\tdate->epoch = local_secs - tm->tm_gmtoff;\n\tdate->nsec = tm->tm_nsec;\n\tdate->tzindex = tm->tm_tzindex;\n\tdate->tzoffset = tm->tm_gmtoff / 60;\n\treturn true;\n}\n\nsize_t\ndatetime_strptime(struct datetime *date, const char *buf, const char *fmt)\n{\n\tassert(date != NULL);\n\tassert(fmt != NULL);\n\tassert(buf != NULL);\n\tstruct tnt_tm t = { .tm_epoch = 0 };\n\tchar *ret = tnt_strptime(buf, fmt, &t);\n\tif (ret == NULL)\n\t\treturn 0;", "Selected Statement": "\tassert(tm != NULL);\n", "Selected Pointer": "tm", "Compared Statement": "\tassert(date != NULL);\n", "Compared Pointer": "date", "Aliasing": "No", "Function Input": {"date": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdcd8", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"epoch": {"type_category": "float", "concrete_type": "double", "value": "0"}, "nsec": {"type_category": "unknown", "concrete_type": "int32_t", "value": "0"}, "tzoffset": {"type_category": "unknown", "concrete_type": "int16_t", "value": "0"}, "tzindex": {"type_category": "unknown", "concrete_type": "int16_t", "value": "0"}}}}, "tm": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdce0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"tm_sec": {"type_category": "int", "concrete_type": "int", "value": "10"}, "tm_min": {"type_category": "int", "concrete_type": "int", "value": "0"}, "tm_hour": {"type_category": "int", "concrete_type": "int", "value": "0"}, "tm_mday": {"type_category": "int", "concrete_type": "int", "value": "0"}, "tm_mon": {"type_category": "int", "concrete_type": "int", "value": "0"}, "tm_year": {"type_category": "int", "concrete_type": "int", "value": "-1056964608"}, "tm_wday": {"type_category": "int", "concrete_type": "int", "value": "60033"}, "tm_yday": {"type_category": "int", "concrete_type": "int", "value": "0"}, "tm_isdst": {"type_category": "int", "concrete_type": "int", "value": "0"}, "tm_gmtoff": {"type_category": "int", "concrete_type": "long", "value": "-4611686018427387904"}, "tm_epoch": {"type_category": "unknown", "concrete_type": "int64_t", "value": "-9223372036854715775"}, "tm_nsec": {"type_category": "int", "concrete_type": "int", "value": "-34"}, "tm_tzindex": {"type_category": "unknown", "concrete_type": "int16_t", "value": "127"}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 15}
{"Programming Language": "C", "Source Code": "static void\nuri_create_params(struct uri *uri, const char *query)\n{\n\tchar *copy = xstrdup(query);\n\tchar *saveptr, *optstr = strtok_r(copy, \"&\", &saveptr);\n\twhile (optstr != NULL) {\n\t\tchar *value = NULL, *name = optstr;\n\t\tchar *delim = strchr(optstr, '=');\n\t\tif (delim != NULL) {\n\t\t\t*delim = '\\0';\n\t\t\tvalue = delim + 1;\n\t\t}\n\t\toptstr = strtok_r(NULL, \"&\", &saveptr);\n\t\t\n\t\tif (*name == 0)\n\t\t\tcontinue;\n\t\turi_add_param(uri, name, value);\n\t}\n\tfree(copy);\n}\n\nvoid\nuri_set_credentials(struct uri *uri, const char *login, const char *password)\n{\n\tassert(login != NULL);\n\tfree(uri->login);\n\turi->login = xstrdup(login);\n\n\tfree(uri->password);\n\turi->password = password == NULL ? NULL : xstrdup(password);\n}\n\nvoid\nuri_copy(struct uri *dst, const struct uri *src)\n{\n\tdst->scheme = XSTRDUP(src->scheme);\n\tdst->login = XSTRDUP(src->login);\n\tdst->password = XSTRDUP(src->password);\n\tdst->host = XSTRDUP(src->host);\n\tdst->service = XSTRDUP(src->service);\n\tdst->path = XSTRDUP(src->path);\n\tdst->query = XSTRDUP(src->query);\n\tdst->fragment = XSTRDUP(src->fragment);\n\tdst->host_hint = src->host_hint;\n\tdst->params_capacity = src->params_capacity;\n\tdst->param_count = src->param_count;\n\tdst->params = (src->params_capacity == 0 ? NULL :\n\t\t       xmalloc(src->params_capacity * sizeof(*dst->params)));\n\tfor (int i = 0; i < src->param_count; i++)\n\t\turi_param_copy(&dst->params[i], &src->params[i]);\n}\n\nvoid\nuri_move(struct uri *dst, struct uri *src)\n{\n\t*dst = *src;\n\turi_create(src, NULL);\n}\n\nvoid\nuri_destroy(struct uri *uri)\n{\n\turi_destroy_params(uri);\n\tfree(uri->scheme);\n\tfree(uri->login);\n\tfree(uri->password);\n\tfree(uri->host);\n\tfree(uri->service);\n\tfree(uri->path);\n\tfree(uri->query);\n\tfree(uri->fragment);\n\tTRASH(uri);\n}\n\nint\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);", "Selected Statement": "\t\turi_create_params(uri, uri->query);\n", "Selected Pointer": "uri", "Compared Statement": "\tfree(copy);\n", "Compared Pointer": "copy", "Aliasing": "No", "Function Input": {"query": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdd40 \"\""}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdc08", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffde80 \"\\300\\336\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x33a01e <LLVMFuzzerTestOneInput+222> \"H\\215}\\210\\350i\\\"\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0xd0b580 \".?\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "service": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffde80 \"\\300\\336\\377\\377\\377\\177\""}, "path": {"type_category": "string", "concrete_type": "NULL"}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "NULL"}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "13676992"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "0"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "0"}, "params": {"type_category": "pointer", "concrete_type": "NULL"}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 16}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Selected Pointer": "str", "Compared Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Compared Pointer": "uri", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \" \\001\\321\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8dd0 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd10120 \"1\\n\\321\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 17}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"`+\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b7890 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd02b60 \"c>\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 18}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Selected Pointer": "str", "Compared Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Compared Pointer": "uri", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \" \\001\\321\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8b70 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd10120 \"h@\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 19}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Selected Pointer": "str", "Compared Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Compared Pointer": "uri", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\200\\265\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8470 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0b580 \"$`\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 20}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"`+\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b7c30 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd02b60 \"/<\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 21}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "NULL"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdec0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdfb0 \"@\\340\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "NULL"}, "host": {"type_category": "string", "concrete_type": "string", "value": "0xfc5 <error: Cannot access memory at address 0xfc5>"}, "service": {"type_category": "string", "concrete_type": "string", "value": "0x24120e4 \"1a694a09b7c2381c2a4b973137a8c1\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x1 <error: Cannot access memory at address 0x1>"}, "query": {"type_category": "string", "concrete_type": "string", "value": "0x1000 <error: Cannot access memory at address 0x1000>"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8128"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2761157"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdfc0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x32\n", "message": "Cannot access memory at address 0x32"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 22}
{"Programming Language": "C", "Source Code": "static void\nuri_create_params(struct uri *uri, const char *query)\n{\n\tchar *copy = xstrdup(query);\n\tchar *saveptr, *optstr = strtok_r(copy, \"&\", &saveptr);\n\twhile (optstr != NULL) {\n\t\tchar *value = NULL, *name = optstr;\n\t\tchar *delim = strchr(optstr, '=');\n\t\tif (delim != NULL) {\n\t\t\t*delim = '\\0';\n\t\t\tvalue = delim + 1;\n\t\t}\n\t\toptstr = strtok_r(NULL, \"&\", &saveptr);\n\t\t\n\t\tif (*name == 0)\n\t\t\tcontinue;\n\t\turi_add_param(uri, name, value);\n\t}\n\tfree(copy);\n}\n\nvoid\nuri_set_credentials(struct uri *uri, const char *login, const char *password)\n{\n\tassert(login != NULL);\n\tfree(uri->login);\n\turi->login = xstrdup(login);\n\n\tfree(uri->password);\n\turi->password = password == NULL ? NULL : xstrdup(password);\n}\n\nvoid\nuri_copy(struct uri *dst, const struct uri *src)\n{\n\tdst->scheme = XSTRDUP(src->scheme);\n\tdst->login = XSTRDUP(src->login);\n\tdst->password = XSTRDUP(src->password);\n\tdst->host = XSTRDUP(src->host);\n\tdst->service = XSTRDUP(src->service);\n\tdst->path = XSTRDUP(src->path);\n\tdst->query = XSTRDUP(src->query);\n\tdst->fragment = XSTRDUP(src->fragment);\n\tdst->host_hint = src->host_hint;\n\tdst->params_capacity = src->params_capacity;\n\tdst->param_count = src->param_count;\n\tdst->params = (src->params_capacity == 0 ? NULL :\n\t\t       xmalloc(src->params_capacity * sizeof(*dst->params)));\n\tfor (int i = 0; i < src->param_count; i++)\n\t\turi_param_copy(&dst->params[i], &src->params[i]);\n}\n\nvoid\nuri_move(struct uri *dst, struct uri *src)\n{\n\t*dst = *src;\n\turi_create(src, NULL);\n}\n\nvoid\nuri_destroy(struct uri *uri)\n{\n\turi_destroy_params(uri);\n\tfree(uri->scheme);\n\tfree(uri->login);\n\tfree(uri->password);\n\tfree(uri->host);\n\tfree(uri->service);\n\tfree(uri->path);\n\tfree(uri->query);\n\tfree(uri->fragment);\n\tTRASH(uri);\n}\n\nint\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);", "Selected Statement": "\t\turi_create_params(uri, uri->query);\n", "Selected Pointer": "uri", "Compared Statement": "\tfree(copy);\n", "Compared Pointer": "copy", "Aliasing": "No", "Function Input": {"query": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdd40 \"\""}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdc08", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffde80 \"\\300\\336\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x33a01e <LLVMFuzzerTestOneInput+222> \"H\\215}\\210\\350i\\\"\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0xd02b60 \"?6\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x1 <error: Cannot access memory at address 0x1>"}, "service": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffde80 \"\\300\\336\\377\\377\\377\\177\""}, "path": {"type_category": "string", "concrete_type": "NULL"}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "NULL"}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "0"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "0"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "0"}, "params": {"type_category": "pointer", "concrete_type": "NULL"}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 23}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"@\\v\\321\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8f30 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd10b40 \".|\\321\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 24}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\200\\254\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8010 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0ac80 \"#\\177\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 25}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Selected Pointer": "str", "Compared Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Compared Pointer": "uri", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\200\\254\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b7ff0 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0ac80 \"/{\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 26}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"P\\020\\321\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8fb0 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd11050 \"@o\\321\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 27}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"`+\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b7e70 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd02b60 \"u\\222\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 28}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Selected Pointer": "str", "Compared Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Compared Pointer": "uri", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\200\\265\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8690 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0b580 \"F<\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 29}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\200\\265\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8490 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0b580 \"4%\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 30}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\340\\357\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b87f0 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0efe0 \"3[\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 31}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"`+\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b79b0 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd02b60 \"[g\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 32}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"@\\v\\321\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8ef0 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd10b40 \"']\\321\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 33}
{"Programming Language": "C", "Source Code": "static void\nuri_create_params(struct uri *uri, const char *query)\n{\n\tchar *copy = xstrdup(query);\n\tchar *saveptr, *optstr = strtok_r(copy, \"&\", &saveptr);\n\twhile (optstr != NULL) {\n\t\tchar *value = NULL, *name = optstr;\n\t\tchar *delim = strchr(optstr, '=');\n\t\tif (delim != NULL) {\n\t\t\t*delim = '\\0';\n\t\t\tvalue = delim + 1;\n\t\t}\n\t\toptstr = strtok_r(NULL, \"&\", &saveptr);\n\t\t\n\t\tif (*name == 0)\n\t\t\tcontinue;\n\t\turi_add_param(uri, name, value);\n\t}\n\tfree(copy);\n}\n\nvoid\nuri_set_credentials(struct uri *uri, const char *login, const char *password)\n{\n\tassert(login != NULL);\n\tfree(uri->login);\n\turi->login = xstrdup(login);\n\n\tfree(uri->password);\n\turi->password = password == NULL ? NULL : xstrdup(password);\n}\n\nvoid\nuri_copy(struct uri *dst, const struct uri *src)\n{\n\tdst->scheme = XSTRDUP(src->scheme);\n\tdst->login = XSTRDUP(src->login);\n\tdst->password = XSTRDUP(src->password);\n\tdst->host = XSTRDUP(src->host);\n\tdst->service = XSTRDUP(src->service);\n\tdst->path = XSTRDUP(src->path);\n\tdst->query = XSTRDUP(src->query);\n\tdst->fragment = XSTRDUP(src->fragment);\n\tdst->host_hint = src->host_hint;\n\tdst->params_capacity = src->params_capacity;\n\tdst->param_count = src->param_count;\n\tdst->params = (src->params_capacity == 0 ? NULL :\n\t\t       xmalloc(src->params_capacity * sizeof(*dst->params)));\n\tfor (int i = 0; i < src->param_count; i++)\n\t\turi_param_copy(&dst->params[i], &src->params[i]);\n}\n\nvoid\nuri_move(struct uri *dst, struct uri *src)\n{\n\t*dst = *src;\n\turi_create(src, NULL);\n}\n\nvoid\nuri_destroy(struct uri *uri)\n{\n\turi_destroy_params(uri);\n\tfree(uri->scheme);\n\tfree(uri->login);\n\tfree(uri->password);\n\tfree(uri->host);\n\tfree(uri->service);\n\tfree(uri->path);\n\tfree(uri->query);\n\tfree(uri->fragment);\n\tTRASH(uri);\n}\n\nint\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);", "Selected Statement": "\t\turi_create_params(uri, uri->query);\n", "Selected Pointer": "uri", "Compared Statement": "\tfree(copy);\n", "Compared Pointer": "copy", "Aliasing": "No", "Function Input": {"query": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdd40 \"\""}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdc08", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffde80 \"\\300\\336\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x33a01e <LLVMFuzzerTestOneInput+222> \"H\\215}\\210\\350i\\\"\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0xd10120 \"&?\\321\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "service": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffde80 \"\\300\\336\\377\\377\\377\\177\""}, "path": {"type_category": "string", "concrete_type": "NULL"}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "NULL"}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "13701168"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "0"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "0"}, "params": {"type_category": "pointer", "concrete_type": "NULL"}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 34}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"`+\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b7690 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd02b60 \"%`\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 35}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Selected Pointer": "str", "Compared Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Compared Pointer": "uri", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\200\\265\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8310 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0b580 \"1@\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 36}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\200\\265\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b82b0 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0b580 \"[\\273\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 37}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x1 <error: Cannot access memory at address 0x1>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\260\\377\\317\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b7090 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xcfffb0 \"{3V\\002\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 38}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\220\\t\\321\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8e30 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd10990 \"1]\\321\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 39}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\300\\375\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8d10 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0fdc0 \"%\\357\\321\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 40}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"`+\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b7d90 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd02b60 \"8@\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 41}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x1 <error: Cannot access memory at address 0x1>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\260\\377\\317\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b7190 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xcfffb0 \"\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 42}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x1 <error: Cannot access memory at address 0x1>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\260\\377\\317\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b7170 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xcfffb0 \"\\1773V\\002\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 43}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Selected Pointer": "str", "Compared Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Compared Pointer": "uri", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\200\\265\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8410 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0b580 \",{\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 44}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\200\\265\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b83b0 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0b580 \".\\177\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 45}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x1 <error: Cannot access memory at address 0x1>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\260\\377\\317\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b7270 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xcfffb0 \"\\0323V\\002\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 46}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"@\\v\\321\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8f70 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd10b40 \".]\\321\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 47}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Selected Pointer": "str", "Compared Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Compared Pointer": "uri", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\200\\265\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b84b0 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0b580 \".\\233\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 48}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"`+\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b7770 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd02b60 \"?<\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 49}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"`+\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b7d30 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd02b60 \"u{\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 50}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\200\\265\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8230 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0b580 \"-<\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 51}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \" \\001\\321\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8c70 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd10120 \"/\\345\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 52}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"P\\020\\321\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b90f0 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd11050 \"%\\020\\321\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 53}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"`+\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b7c90 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd02b60 \"%K\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 54}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\020H\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b7ef0 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd04810 \"[C\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 55}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Selected Pointer": "str", "Compared Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Compared Pointer": "uri", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\200\\265\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8970 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0b580 \".>\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 56}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"`+\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b7d50 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd02b60 \"0@\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 57}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Selected Pointer": "str", "Compared Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Compared Pointer": "uri", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\200\\265\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8630 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0b580 \"5`\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 58}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"`+\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b7db0 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd02b60 \"%:\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 59}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \" \\001\\321\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8df0 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd10120 \".`\\321\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 60}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"@\\v\\321\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b9090 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd10b40 \"%]\\321\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 61}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\200\\265\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b88b0 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0b580 \"1%\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 62}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"P\\020\\321\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b9170 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd11050 \"1>\\321\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 63}
{"Programming Language": "C", "Source Code": "static void\nuri_param_create(struct uri_param *param, const char *name)\n{\n\tparam->name = xstrdup(name);\n\tparam->values = NULL;\n\tparam->value_count = 0;\n\tparam->values_capacity = 0;\n}\n\n\nstatic void\nuri_param_copy(struct uri_param *dst, const struct uri_param *src)\n{\n\tdst->name = xstrdup(src->name);\n\tdst->values_capacity = src->values_capacity;\n\tdst->value_count = src->value_count;\n\tdst->values = (src->values_capacity == 0 ? NULL :\n\t\t       xmalloc(src->values_capacity * sizeof(*dst->values)));\n\tfor (int i = 0; i < src->value_count; i++)\n\t\tdst->values[i] = xstrdup(src->values[i]);\n}\n\nvoid\nuri_remove_param(struct uri *uri, const char *name)\n{\n\tstruct uri_param *param = uri_find_param(uri, name);\n\tif (param == NULL)\n\t\treturn;\n\tint idx = param - uri->params;\n\turi_param_destroy(param);\n\tfor (int i = idx; i < uri->param_count - 1; i++)\n\t\turi->params[i] = uri->params[i + 1];\n\turi->param_count--;\n}\n\nvoid\nuri_add_param(struct uri *uri, const char *name, const char *value)\n{\n\tstruct uri_param *param = uri_find_param(uri, name);\n\tif (param == NULL) {\n\t\tassert(uri->param_count <= uri->params_capacity);\n\t\tif (uri->param_count == uri->params_capacity) {\n\t\t\turi->params_capacity = uri->params_capacity == 0 ? 16 :\n\t\t\t\t\t       uri->params_capacity * 2;\n\t\t\tsize_t size =\n\t\t\t\turi->params_capacity * sizeof(struct uri_param);\n\t\t\turi->params = xrealloc(uri->params, size);\n\t\t}\n\t\tparam = &uri->params[uri->param_count++];\n\t\turi_param_create(param, name);\n\t}", "Selected Statement": "uri_param_create(struct uri_param *param, const char *name)\n", "Selected Pointer": "param", "Compared Statement": "\tparam->name = xstrdup(name);\n", "Compared Pointer": "name", "Aliasing": "No", "Function Input": {"name": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "param": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdaf8", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"name": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdc10 \"\\340\\335\\377\\377\\377\\177\""}, "values_capacity": {"type_category": "int", "concrete_type": "int", "value": "3393049"}, "value_count": {"type_category": "int", "concrete_type": "int", "value": "0"}, "values": {"type_category": "pointer", "concrete_type": "NULL"}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 64}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\200\\265\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b80d0 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0b580 \"1`\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 65}
{"Programming Language": "C", "Source Code": "static void\nuri_create_params(struct uri *uri, const char *query)\n{\n\tchar *copy = xstrdup(query);\n\tchar *saveptr, *optstr = strtok_r(copy, \"&\", &saveptr);\n\twhile (optstr != NULL) {\n\t\tchar *value = NULL, *name = optstr;\n\t\tchar *delim = strchr(optstr, '=');\n\t\tif (delim != NULL) {\n\t\t\t*delim = '\\0';\n\t\t\tvalue = delim + 1;\n\t\t}\n\t\toptstr = strtok_r(NULL, \"&\", &saveptr);\n\t\t\n\t\tif (*name == 0)\n\t\t\tcontinue;\n\t\turi_add_param(uri, name, value);\n\t}\n\tfree(copy);\n}\n\nvoid\nuri_set_credentials(struct uri *uri, const char *login, const char *password)\n{\n\tassert(login != NULL);\n\tfree(uri->login);\n\turi->login = xstrdup(login);\n\n\tfree(uri->password);\n\turi->password = password == NULL ? NULL : xstrdup(password);\n}\n\nvoid\nuri_copy(struct uri *dst, const struct uri *src)\n{\n\tdst->scheme = XSTRDUP(src->scheme);\n\tdst->login = XSTRDUP(src->login);\n\tdst->password = XSTRDUP(src->password);\n\tdst->host = XSTRDUP(src->host);\n\tdst->service = XSTRDUP(src->service);\n\tdst->path = XSTRDUP(src->path);\n\tdst->query = XSTRDUP(src->query);\n\tdst->fragment = XSTRDUP(src->fragment);\n\tdst->host_hint = src->host_hint;\n\tdst->params_capacity = src->params_capacity;\n\tdst->param_count = src->param_count;\n\tdst->params = (src->params_capacity == 0 ? NULL :\n\t\t       xmalloc(src->params_capacity * sizeof(*dst->params)));\n\tfor (int i = 0; i < src->param_count; i++)\n\t\turi_param_copy(&dst->params[i], &src->params[i]);\n}\n\nvoid\nuri_move(struct uri *dst, struct uri *src)\n{\n\t*dst = *src;\n\turi_create(src, NULL);\n}\n\nvoid\nuri_destroy(struct uri *uri)\n{\n\turi_destroy_params(uri);\n\tfree(uri->scheme);\n\tfree(uri->login);\n\tfree(uri->password);\n\tfree(uri->host);\n\tfree(uri->service);\n\tfree(uri->path);\n\tfree(uri->query);\n\tfree(uri->fragment);\n\tTRASH(uri);\n}\n\nint\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);", "Selected Statement": "\t\turi_create_params(uri, uri->query);\n", "Selected Pointer": "uri", "Compared Statement": "\tfree(copy);\n", "Compared Pointer": "copy", "Aliasing": "No", "Function Input": {"query": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdd40 \"\""}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdc08", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffde80 \"\\300\\336\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x33a01e <LLVMFuzzerTestOneInput+222> \"H\\215}\\210\\350i\\\"\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0xd0ac80 \"u?\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "service": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffde80 \"\\300\\336\\377\\377\\377\\177\""}, "path": {"type_category": "string", "concrete_type": "NULL"}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "NULL"}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "13677488"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "0"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "0"}, "params": {"type_category": "pointer", "concrete_type": "NULL"}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 66}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"0\\006\\321\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8d90 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd10630 \"[2\\321\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 67}
{"Programming Language": "C", "Source Code": "static void\nuri_param_create(struct uri_param *param, const char *name)\n{\n\tparam->name = xstrdup(name);\n\tparam->values = NULL;\n\tparam->value_count = 0;\n\tparam->values_capacity = 0;\n}\n\n\nstatic void\nuri_param_copy(struct uri_param *dst, const struct uri_param *src)\n{\n\tdst->name = xstrdup(src->name);\n\tdst->values_capacity = src->values_capacity;\n\tdst->value_count = src->value_count;\n\tdst->values = (src->values_capacity == 0 ? NULL :\n\t\t       xmalloc(src->values_capacity * sizeof(*dst->values)));\n\tfor (int i = 0; i < src->value_count; i++)\n\t\tdst->values[i] = xstrdup(src->values[i]);\n}\n\nvoid\nuri_remove_param(struct uri *uri, const char *name)\n{\n\tstruct uri_param *param = uri_find_param(uri, name);\n\tif (param == NULL)\n\t\treturn;\n\tint idx = param - uri->params;\n\turi_param_destroy(param);\n\tfor (int i = idx; i < uri->param_count - 1; i++)\n\t\turi->params[i] = uri->params[i + 1];\n\turi->param_count--;\n}\n\nvoid\nuri_add_param(struct uri *uri, const char *name, const char *value)\n{\n\tstruct uri_param *param = uri_find_param(uri, name);\n\tif (param == NULL) {\n\t\tassert(uri->param_count <= uri->params_capacity);\n\t\tif (uri->param_count == uri->params_capacity) {\n\t\t\turi->params_capacity = uri->params_capacity == 0 ? 16 :\n\t\t\t\t\t       uri->params_capacity * 2;\n\t\t\tsize_t size =\n\t\t\t\turi->params_capacity * sizeof(struct uri_param);\n\t\t\turi->params = xrealloc(uri->params, size);\n\t\t}\n\t\tparam = &uri->params[uri->param_count++];\n\t\turi_param_create(param, name);\n\t}", "Selected Statement": "uri_param_create(struct uri_param *param, const char *name)\n", "Selected Pointer": "param", "Compared Statement": "\tparam->name = xstrdup(name);\n", "Compared Pointer": "name", "Aliasing": "No", "Function Input": {"name": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "param": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdaf8", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"name": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdc10 \"\\340\\335\\377\\377\\377\\177\""}, "values_capacity": {"type_category": "int", "concrete_type": "int", "value": "3393049"}, "value_count": {"type_category": "int", "concrete_type": "int", "value": "0"}, "values": {"type_category": "pointer", "concrete_type": "NULL"}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 68}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Selected Pointer": "str", "Compared Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Compared Pointer": "uri", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\200\\265\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8530 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0b580 \"[Q\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 69}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Selected Pointer": "str", "Compared Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Compared Pointer": "uri", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\200\\265\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8830 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0b580 \"/\\031\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 70}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Selected Pointer": "str", "Compared Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Compared Pointer": "uri", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x1 <error: Cannot access memory at address 0x1>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \" 3V\\002\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b7330 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0x2563320 \"|+\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 71}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"`+\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b7d10 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd02b60 \"0}\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 72}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\200\\265\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b85f0 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0b580 \"i@\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 73}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\200\\265\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b83d0 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0b580 \"?\\276\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 74}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\200\\265\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8670 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0b580 \"h|\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 75}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Selected Pointer": "str", "Compared Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Compared Pointer": "uri", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\300\\375\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8b30 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0fdc0 \"0>\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 76}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Selected Pointer": "str", "Compared Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Compared Pointer": "uri", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\200\\265\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8290 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0b580 \"/>\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 77}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\200\\254\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8070 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0ac80 \"#{\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 78}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"`+\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b76b0 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd02b60 \"'@\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 79}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x1 <error: Cannot access memory at address 0x1>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\260\\377\\317\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b71b0 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xcfffb0 \"\\0013V\\002\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 80}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Selected Pointer": "str", "Compared Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Compared Pointer": "uri", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"`+\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b7910 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd02b60 \".\\020\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 81}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"`+\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b7a10 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd02b60 \"0[\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 82}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \" \\001\\321\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8c30 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd10120 \"t]\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 83}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Selected Pointer": "str", "Compared Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Compared Pointer": "uri", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"`+\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b7970 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd02b60 \"C<\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 84}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\200\\265\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8750 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0b580 \"#%\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 85}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\360\\364\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8950 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0f4f0 \"u\\226\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 86}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\200\\254\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b81d0 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0ac80 \"%*\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 87}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\200\\254\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b80b0 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0ac80 \".\\217\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 88}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \" \\001\\321\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8c50 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd10120 \"?\\f\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 89}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Selected Pointer": "str", "Compared Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Compared Pointer": "uri", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \" \\001\\321\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8f90 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd10120 \".\\\"\\321\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 90}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\300\\375\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8b10 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0fdc0 \"A{\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 91}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Selected Pointer": "str", "Compared Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Compared Pointer": "uri", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\320\\341\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8590 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0e1d0 \"@n\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 92}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x1 <error: Cannot access memory at address 0x1>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \" 3V\\002\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b74b0 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0x2563320 \"\\002+\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 93}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Selected Pointer": "str", "Compared Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Compared Pointer": "uri", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\200\\265\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b89f0 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0b580 \"#<\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 94}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\200\\265\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8250 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0b580 \"/[\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 95}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\200\\265\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b85d0 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0b580 \"/]\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 96}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"`+\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b79f0 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd02b60 \".[\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 97}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Selected Pointer": "str", "Compared Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Compared Pointer": "uri", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\200\\265\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8710 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0b580 \"#\\n\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 98}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x1 <error: Cannot access memory at address 0x1>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \" 3V\\002\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b7470 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0x2563320 \"}+\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 99}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"`+\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b7e50 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd02b60 \"${\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 100}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"`+\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b7df0 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd02b60 \"$[\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 101}
{"Programming Language": "C", "Source Code": "static void\nuri_create_params(struct uri *uri, const char *query)\n{\n\tchar *copy = xstrdup(query);\n\tchar *saveptr, *optstr = strtok_r(copy, \"&\", &saveptr);\n\twhile (optstr != NULL) {\n\t\tchar *value = NULL, *name = optstr;\n\t\tchar *delim = strchr(optstr, '=');\n\t\tif (delim != NULL) {\n\t\t\t*delim = '\\0';\n\t\t\tvalue = delim + 1;\n\t\t}\n\t\toptstr = strtok_r(NULL, \"&\", &saveptr);\n\t\t\n\t\tif (*name == 0)\n\t\t\tcontinue;\n\t\turi_add_param(uri, name, value);\n\t}\n\tfree(copy);\n}\n\nvoid\nuri_set_credentials(struct uri *uri, const char *login, const char *password)\n{\n\tassert(login != NULL);\n\tfree(uri->login);\n\turi->login = xstrdup(login);\n\n\tfree(uri->password);\n\turi->password = password == NULL ? NULL : xstrdup(password);\n}\n\nvoid\nuri_copy(struct uri *dst, const struct uri *src)\n{\n\tdst->scheme = XSTRDUP(src->scheme);\n\tdst->login = XSTRDUP(src->login);\n\tdst->password = XSTRDUP(src->password);\n\tdst->host = XSTRDUP(src->host);\n\tdst->service = XSTRDUP(src->service);\n\tdst->path = XSTRDUP(src->path);\n\tdst->query = XSTRDUP(src->query);\n\tdst->fragment = XSTRDUP(src->fragment);\n\tdst->host_hint = src->host_hint;\n\tdst->params_capacity = src->params_capacity;\n\tdst->param_count = src->param_count;\n\tdst->params = (src->params_capacity == 0 ? NULL :\n\t\t       xmalloc(src->params_capacity * sizeof(*dst->params)));\n\tfor (int i = 0; i < src->param_count; i++)\n\t\turi_param_copy(&dst->params[i], &src->params[i]);\n}\n\nvoid\nuri_move(struct uri *dst, struct uri *src)\n{\n\t*dst = *src;\n\turi_create(src, NULL);\n}\n\nvoid\nuri_destroy(struct uri *uri)\n{\n\turi_destroy_params(uri);\n\tfree(uri->scheme);\n\tfree(uri->login);\n\tfree(uri->password);\n\tfree(uri->host);\n\tfree(uri->service);\n\tfree(uri->path);\n\tfree(uri->query);\n\tfree(uri->fragment);\n\tTRASH(uri);\n}\n\nint\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);", "Selected Statement": "\t\turi_create_params(uri, uri->query);\n", "Selected Pointer": "uri", "Compared Statement": "\tfree(copy);\n", "Compared Pointer": "copy", "Aliasing": "No", "Function Input": {"query": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdd40 \"\""}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdc08", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffde80 \"\\300\\336\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x33a01e <LLVMFuzzerTestOneInput+222> \"H\\215}\\210\\350i\\\"\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0xd0c520 \"(?\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "service": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffde80 \"\\300\\336\\377\\377\\377\\177\""}, "path": {"type_category": "string", "concrete_type": "NULL"}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "NULL"}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "13689264"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "0"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "0"}, "params": {"type_category": "pointer", "concrete_type": "NULL"}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 102}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Selected Pointer": "str", "Compared Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Compared Pointer": "uri", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x1 <error: Cannot access memory at address 0x1>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \" 3V\\002\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b7430 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0x2563320 \"%+\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 103}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Selected Pointer": "str", "Compared Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Compared Pointer": "uri", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\200\\254\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8110 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0ac80 \"[0\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 104}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\200\\265\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8430 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0b580 \"[t\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 105}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \" \\001\\321\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8c90 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd10120 \".{\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 106}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Selected Pointer": "str", "Compared Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Compared Pointer": "uri", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\020H\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b7fd0 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd04810 \"[?\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 107}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Selected Pointer": "str", "Compared Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Compared Pointer": "uri", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\200\\265\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b83f0 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0b580 \"%^\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 108}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"`+\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b75f0 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd02b60 \"[`\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 109}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x1 <error: Cannot access memory at address 0x1>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\260\\377\\317\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b7030 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xcfffb0 \"\\0373V\\002\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 110}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x1 <error: Cannot access memory at address 0x1>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \" 3V\\002\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b7390 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0x2563320 \":+\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 111}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Selected Pointer": "str", "Compared Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Compared Pointer": "uri", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\200\\254\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8150 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0ac80 \"//\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 112}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Selected Pointer": "str", "Compared Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Compared Pointer": "uri", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"`+\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b7870 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd02b60 \"2>\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 113}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\200\\265\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8a30 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0b580 \"t@\\320\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 114}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;", "Selected Statement": "\tmemset(uri, 0, sizeof(struct uri));\n", "Selected Pointer": "uri", "Compared Statement": "\tif (uri_raw_parse(&uri_raw, str) != 0)\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "uri": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffddd0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"scheme": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "login": {"type_category": "string", "concrete_type": "string", "value": "0x2a0e14 <ExecuteCallback()+292> \"\\306\\005\\375\\373\\r\""}, "password": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdff0 \"\\300\\375\\320\""}, "host": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff32b8cb0 \"A\""}, "service": {"type_category": "string", "concrete_type": "string", "value": "0xcf7aa0 \"\\360\\n\\320\""}, "path": {"type_category": "string", "concrete_type": "string", "value": "0x2144f3 <std::nothrow> \"\""}, "query": {"type_category": "string", "concrete_type": "NULL"}, "fragment": {"type_category": "string", "concrete_type": "string", "value": "0xd0fdc0 \"\""}, "host_hint": {"type_category": "int", "concrete_type": "int", "value": "-8272"}, "params_capacity": {"type_category": "int", "concrete_type": "int", "value": "32767"}, "param_count": {"type_category": "int", "concrete_type": "int", "value": "2754043"}, "params": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffded0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xc\n", "message": "Cannot access memory at address 0xc"}}}}}}, "Program Information": {"Project Name": "tarantool"}, "idx": 115}
{"Programming Language": "C", "Source Code": "*/\nstatic int\nparse_port_string(const struct vec *vec, struct socket *so, int *ip_version)\n{\n\tunsigned int a, b, c, d;\n\tunsigned port;\n\tunsigned long portUL;\n\tint len;\n\tconst char *cb;\n\tchar *endptr;\n#if defined(USE_IPV6)\n\tchar buf[100] = {0};\n#endif\n\n\t\n\tmemset(so, 0, sizeof(*so));\n\tso->lsa.sin.sin_family = AF_INET;\n\t*ip_version = 0;\n\n\t\n\tport = 0;\n\tlen = 0;\n\n\t\n\tif (sscanf(vec->ptr,\n\t           \"%u.%u.%u.%u:%u%n\",\n\t           &a,\n\t           &b,\n\t           &c,\n\t           &d,\n\t           &port,\n\t           &len) \n\t                 \n\t                 \n\t    == 5) {\n\t\t\n\t\tso->lsa.sin.sin_addr.s_addr =\n\t\t    htonl((a << 24) | (b << 16) | (c << 8) | d);\n\t\tso->lsa.sin.sin_port = htons((uint16_t)port);\n\t\t*ip_version = 4;\n\n#if defined(USE_IPV6)\n\t} else if (sscanf(vec->ptr, \"[%49[^]]]:%u%n\", buf, &port, &len) == 2\n\t           && ((size_t)len <= vec->len)\n\t           && mg_inet_pton(\n\t                  AF_INET6, buf, &so->lsa.sin6, sizeof(so->lsa.sin6), 0)) {\n\t\t\n\t\t\n\t\tso->lsa.sin6.sin6_port = htons((uint16_t)port);\n\t\t*ip_version = 6;\n#endif\n\n\t} else if ((vec->ptr[0] == '+')\n\t           && (sscanf(vec->ptr + 1, \"%u%n\", &port, &len)\n\t               == 1)) { \n\t\t                    \n\t\t                    \n\t\t                    \n\n\t\t\n\t\t\n\t\tlen++;\n\n#if defined(USE_IPV6)\n\t\t\n\t\tso->lsa.sin6.sin6_family = AF_INET6;\n\t\tso->lsa.sin6.sin6_port = htons((uint16_t)port);\n\t\t*ip_version = 4 + 6;\n#else\n\t\t\n\t\tso->lsa.sin.sin_port = htons((uint16_t)port);\n\t\t*ip_version = 4;\n#endif\n\n\t} else if (is_valid_port(portUL = strtoul(vec->ptr, &endptr, 0))\n\t           && (vec->ptr != endptr)) {\n\t\tlen = (int)(endptr - vec->ptr);\n\t\tport = (uint16_t)portUL;\n\t\t\n\t\tso->lsa.sin.sin_port = htons((uint16_t)port);\n\t\t*ip_version = 4;\n\n\t} else if ((cb = strchr(vec->ptr, ':')) != NULL) {\n\t\t\n\n\t\t\n\t\tchar hostname[256];\n\t\tsize_t hostnlen = (size_t)(cb - vec->ptr);\n\n\t\tif ((hostnlen >= vec->len) || (hostnlen >= sizeof(hostname))) {\n\t\t\t\n\t\t\t*ip_version = 0;\n\t\t\treturn 0;\n\t\t}\n\n\t\tmg_strlcpy(hostname, vec->ptr, hostnlen + 1);\n\n\t\tif (mg_inet_pton(\n\t\t        AF_INET, hostname, &so->lsa.sin, sizeof(so->lsa.sin), 1)) {\n\t\t\tif (sscanf(cb + 1, \"%u%n\", &port, &len)\n\t\t\t    == 1) { \n\t\t\t\t        \n\t\t\t\t        \n\t\t\t\t        \n\t\t\t\t*ip_version = 4;\n\t\t\t\tso->lsa.sin.sin_port = htons((uint16_t)port);\n\t\t\t\tlen += (int)(hostnlen + 1);\n\t\t\t} else {\n\t\t\t\tlen = 0;\n\t\t\t}\n#if defined(USE_IPV6)\n\t\t} else if (mg_inet_pton(AF_INET6,\n\t\t                        hostname,\n\t\t                        &so->lsa.sin6,\n\t\t                        sizeof(so->lsa.sin6),\n\t\t                        1)) {\n\t\t\tif (sscanf(cb + 1, \"%u%n\", &port, &len) == 1) {\n\t\t\t\t*ip_version = 6;\n\t\t\t\tso->lsa.sin6.sin6_port = htons((uint16_t)port);\n\t\t\t\tlen += (int)(hostnlen + 1);\n\t\t\t} else {\n\t\t\t\tlen = 0;\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tlen = 0;\n\t\t}\n\n#if defined(USE_X_DOM_SOCKET)\n\n\t} else if (vec->ptr[0] == 'x') {\n\t\t\n\t\tif (vec->len < sizeof(so->lsa.sun.sun_path)) {\n\t\t\tlen = vec->len;\n\t\t\tso->lsa.sun.sun_family = AF_UNIX;\n\t\t\tmemset(so->lsa.sun.sun_path, 0, sizeof(so->lsa.sun.sun_path));\n\t\t\tmemcpy(so->lsa.sun.sun_path, (char *)vec->ptr + 1, vec->len - 1);\n\t\t\tport = 0;\n\t\t\t*ip_version = 99;\n\t\t} else {\n\t\t\t\n\t\t\tlen = 0;\n\t\t}\n#endif\n\n\t} else {\n\t\t\n\t\tlen = 0;\n\t}\n\n\t\n\tif ((len > 0) && (is_valid_port(port))) {\n\t\tint bad_suffix = 0;\n\t\tsize_t i;\n\n\t\t\n\t\tfor (i = len; i < vec->len; i++) {\n\t\t\tunsigned char *opt = NULL;\n\t\t\tswitch (vec->ptr[i]) {\n\t\t\tcase 'o':\n\t\t\t\topt = &so->is_optional;\n\t\t\t\tbreak;\n\t\t\tcase 'r':\n\t\t\t\topt = &so->ssl_redir;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\topt = &so->is_ssl;\n\t\t\t\tbreak;\n\t\t\tdefault: \n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif ((opt) && (*opt == 0))\n\t\t\t\t*opt = 1;\n\t\t\telse {\n\t\t\t\tbad_suffix = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif ((bad_suffix == 0) && ((so->is_ssl == 0) || (so->ssl_redir == 0))) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t\n\t*ip_version = 0;\n\treturn 0;\n}\n\n\n\nstatic int\nis_ssl_port_used(const char *ports)\n{\n\tif (ports) {\n\t\t\n\t\tint i;\n\t\tint portslen = (int)strlen(ports);\n\t\tchar prevIsNumber = 0;\n\n\t\tfor (i = 0; i < portslen; i++) {\n\t\t\tif (prevIsNumber) {\n\t\t\t\tint suffixCharIdx = (ports[i] == 'o')\n\t\t\t\t                        ? (i + 1)\n\t\t\t\t                        : i; \n\t\t\t\tif (ports[suffixCharIdx] == 's'\n\t\t\t\t    || ports[suffixCharIdx] == 'r') {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ports[i] >= '0' && ports[i] <= '9') {\n\t\t\t\tprevIsNumber = 1;\n\t\t\t} else {\n\t\t\t\tprevIsNumber = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nstatic int\nset_ports_option(struct mg_context *phys_ctx)\n{\n\tconst char *list;\n\tint on = 1;\n#if defined(USE_IPV6)\n\tint off = 0;\n#endif\n\tstruct vec vec;\n\tstruct socket so, *ptr;\n\n\tstruct mg_pollfd *pfd;\n\tunion usa usa;\n\tsocklen_t len;\n\tint ip_version;\n\n\tint portsTotal = 0;\n\tint portsOk = 0;\n\n\tconst char *opt_txt;\n\tlong opt_listen_backlog;\n\n\tif (!phys_ctx) {\n\t\treturn 0;\n\t}\n\n\tmemset(&so, 0, sizeof(so));\n\tmemset(&usa, 0, sizeof(usa));\n\tlen = sizeof(usa);\n\tlist = phys_ctx->dd.config[LISTENING_PORTS];\n\n\twhile ((list = next_option(list, &vec, NULL)) != NULL) {\n\n\t\tportsTotal++;", "Selected Statement": "\t           && (vec->ptr != endptr)) {\n", "Selected Pointer": "endptr", "Compared Statement": "\tmemset(so, 0, sizeof(*so));\n", "Compared Pointer": "so", "Aliasing": "No", "Function Input": {"ip_version": {"type_category": "pointer", "concrete_type": "NULL"}, "so": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd968", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"sock": {"type_category": "unknown", "concrete_type": "SOCKET", "value": "15781072"}, "lsa": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"sa": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"sa_family": {"type_category": "unknown", "concrete_type": "sa_family_t", "value": "0"}, "sa_data": {"type_category": "string", "concrete_type": "string", "value": "\"\\000\\000\\001\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\""}}}, "sin": {"type_category": "struct", "concrete_type": "sockaddr_in", "value": "{sin_family = 0, sin_port = 0, sin_addr = {s_addr = 1}, sin_zero = \"\\000\\000\\000\\000\\000\\000\\000\"}"}}}, "rsa": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"sa": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"sa_family": {"type_category": "unknown", "concrete_type": "sa_family_t", "value": "1"}, "sa_data": {"type_category": "string", "concrete_type": "string", "value": "\"\\000\\000\\321\\314\\360\\000\\000\\000\\000\\000\\020\\000\\241\\367\""}}}, "sin": {"type_category": "struct", "concrete_type": "sockaddr_in", "value": "{sin_family = 1, sin_port = 0, sin_addr = {s_addr = 15781073}, sin_zero = \"\\000\\000\\000\\000\\020\\000\\241\\367\"}"}}}, "is_ssl": {"type_category": "int", "concrete_type": "unsigned char", "value": "255 '\\377'"}, "ssl_redir": {"type_category": "int", "concrete_type": "unsigned char", "value": "127 '\\177'"}, "is_optional": {"type_category": "int", "concrete_type": "unsigned char", "value": "0 '\\000'"}, "in_use": {"type_category": "int", "concrete_type": "unsigned char", "value": "0 '\\000'"}}}}, "vec": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd970", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"ptr": {"type_category": "string", "concrete_type": "NULL"}, "len": {"type_category": "unknown", "concrete_type": "size_t", "value": "0"}}}}}, "Program Information": {"Project Name": "civetweb"}, "idx": 116}
{"Programming Language": "C", "Source Code": "*/\nstatic int\nparse_port_string(const struct vec *vec, struct socket *so, int *ip_version)\n{\n\tunsigned int a, b, c, d;\n\tunsigned port;\n\tunsigned long portUL;\n\tint len;\n\tconst char *cb;\n\tchar *endptr;\n#if defined(USE_IPV6)\n\tchar buf[100] = {0};\n#endif\n\n\t\n\tmemset(so, 0, sizeof(*so));\n\tso->lsa.sin.sin_family = AF_INET;\n\t*ip_version = 0;\n\n\t\n\tport = 0;\n\tlen = 0;\n\n\t\n\tif (sscanf(vec->ptr,\n\t           \"%u.%u.%u.%u:%u%n\",\n\t           &a,\n\t           &b,\n\t           &c,\n\t           &d,\n\t           &port,\n\t           &len) \n\t                 \n\t                 \n\t    == 5) {\n\t\t\n\t\tso->lsa.sin.sin_addr.s_addr =\n\t\t    htonl((a << 24) | (b << 16) | (c << 8) | d);\n\t\tso->lsa.sin.sin_port = htons((uint16_t)port);\n\t\t*ip_version = 4;\n\n#if defined(USE_IPV6)\n\t} else if (sscanf(vec->ptr, \"[%49[^]]]:%u%n\", buf, &port, &len) == 2\n\t           && ((size_t)len <= vec->len)\n\t           && mg_inet_pton(\n\t                  AF_INET6, buf, &so->lsa.sin6, sizeof(so->lsa.sin6), 0)) {\n\t\t\n\t\t\n\t\tso->lsa.sin6.sin6_port = htons((uint16_t)port);\n\t\t*ip_version = 6;\n#endif\n\n\t} else if ((vec->ptr[0] == '+')\n\t           && (sscanf(vec->ptr + 1, \"%u%n\", &port, &len)\n\t               == 1)) { \n\t\t                    \n\t\t                    \n\t\t                    \n\n\t\t\n\t\t\n\t\tlen++;\n\n#if defined(USE_IPV6)\n\t\t\n\t\tso->lsa.sin6.sin6_family = AF_INET6;\n\t\tso->lsa.sin6.sin6_port = htons((uint16_t)port);\n\t\t*ip_version = 4 + 6;\n#else\n\t\t\n\t\tso->lsa.sin.sin_port = htons((uint16_t)port);\n\t\t*ip_version = 4;\n#endif\n\n\t} else if (is_valid_port(portUL = strtoul(vec->ptr, &endptr, 0))\n\t           && (vec->ptr != endptr)) {\n\t\tlen = (int)(endptr - vec->ptr);\n\t\tport = (uint16_t)portUL;\n\t\t\n\t\tso->lsa.sin.sin_port = htons((uint16_t)port);\n\t\t*ip_version = 4;\n\n\t} else if ((cb = strchr(vec->ptr, ':')) != NULL) {\n\t\t\n\n\t\t\n\t\tchar hostname[256];\n\t\tsize_t hostnlen = (size_t)(cb - vec->ptr);\n\n\t\tif ((hostnlen >= vec->len) || (hostnlen >= sizeof(hostname))) {\n\t\t\t\n\t\t\t*ip_version = 0;\n\t\t\treturn 0;\n\t\t}\n\n\t\tmg_strlcpy(hostname, vec->ptr, hostnlen + 1);\n\n\t\tif (mg_inet_pton(\n\t\t        AF_INET, hostname, &so->lsa.sin, sizeof(so->lsa.sin), 1)) {\n\t\t\tif (sscanf(cb + 1, \"%u%n\", &port, &len)\n\t\t\t    == 1) { \n\t\t\t\t        \n\t\t\t\t        \n\t\t\t\t        \n\t\t\t\t*ip_version = 4;\n\t\t\t\tso->lsa.sin.sin_port = htons((uint16_t)port);\n\t\t\t\tlen += (int)(hostnlen + 1);\n\t\t\t} else {\n\t\t\t\tlen = 0;\n\t\t\t}\n#if defined(USE_IPV6)\n\t\t} else if (mg_inet_pton(AF_INET6,\n\t\t                        hostname,\n\t\t                        &so->lsa.sin6,\n\t\t                        sizeof(so->lsa.sin6),\n\t\t                        1)) {\n\t\t\tif (sscanf(cb + 1, \"%u%n\", &port, &len) == 1) {\n\t\t\t\t*ip_version = 6;\n\t\t\t\tso->lsa.sin6.sin6_port = htons((uint16_t)port);\n\t\t\t\tlen += (int)(hostnlen + 1);\n\t\t\t} else {\n\t\t\t\tlen = 0;\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tlen = 0;\n\t\t}\n\n#if defined(USE_X_DOM_SOCKET)\n\n\t} else if (vec->ptr[0] == 'x') {\n\t\t\n\t\tif (vec->len < sizeof(so->lsa.sun.sun_path)) {\n\t\t\tlen = vec->len;\n\t\t\tso->lsa.sun.sun_family = AF_UNIX;\n\t\t\tmemset(so->lsa.sun.sun_path, 0, sizeof(so->lsa.sun.sun_path));\n\t\t\tmemcpy(so->lsa.sun.sun_path, (char *)vec->ptr + 1, vec->len - 1);\n\t\t\tport = 0;\n\t\t\t*ip_version = 99;\n\t\t} else {\n\t\t\t\n\t\t\tlen = 0;\n\t\t}\n#endif\n\n\t} else {\n\t\t\n\t\tlen = 0;\n\t}\n\n\t\n\tif ((len > 0) && (is_valid_port(port))) {\n\t\tint bad_suffix = 0;\n\t\tsize_t i;\n\n\t\t\n\t\tfor (i = len; i < vec->len; i++) {\n\t\t\tunsigned char *opt = NULL;\n\t\t\tswitch (vec->ptr[i]) {\n\t\t\tcase 'o':\n\t\t\t\topt = &so->is_optional;\n\t\t\t\tbreak;\n\t\t\tcase 'r':\n\t\t\t\topt = &so->ssl_redir;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\topt = &so->is_ssl;\n\t\t\t\tbreak;\n\t\t\tdefault: \n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif ((opt) && (*opt == 0))\n\t\t\t\t*opt = 1;\n\t\t\telse {\n\t\t\t\tbad_suffix = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif ((bad_suffix == 0) && ((so->is_ssl == 0) || (so->ssl_redir == 0))) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t\n\t*ip_version = 0;\n\treturn 0;\n}\n\n\n\nstatic int\nis_ssl_port_used(const char *ports)\n{\n\tif (ports) {\n\t\t\n\t\tint i;\n\t\tint portslen = (int)strlen(ports);\n\t\tchar prevIsNumber = 0;\n\n\t\tfor (i = 0; i < portslen; i++) {\n\t\t\tif (prevIsNumber) {\n\t\t\t\tint suffixCharIdx = (ports[i] == 'o')\n\t\t\t\t                        ? (i + 1)\n\t\t\t\t                        : i; \n\t\t\t\tif (ports[suffixCharIdx] == 's'\n\t\t\t\t    || ports[suffixCharIdx] == 'r') {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ports[i] >= '0' && ports[i] <= '9') {\n\t\t\t\tprevIsNumber = 1;\n\t\t\t} else {\n\t\t\t\tprevIsNumber = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nstatic int\nset_ports_option(struct mg_context *phys_ctx)\n{\n\tconst char *list;\n\tint on = 1;\n#if defined(USE_IPV6)\n\tint off = 0;\n#endif\n\tstruct vec vec;\n\tstruct socket so, *ptr;\n\n\tstruct mg_pollfd *pfd;\n\tunion usa usa;\n\tsocklen_t len;\n\tint ip_version;\n\n\tint portsTotal = 0;\n\tint portsOk = 0;\n\n\tconst char *opt_txt;\n\tlong opt_listen_backlog;\n\n\tif (!phys_ctx) {\n\t\treturn 0;\n\t}\n\n\tmemset(&so, 0, sizeof(so));\n\tmemset(&usa, 0, sizeof(usa));\n\tlen = sizeof(usa);\n\tlist = phys_ctx->dd.config[LISTENING_PORTS];\n\n\twhile ((list = next_option(list, &vec, NULL)) != NULL) {\n\n\t\tportsTotal++;", "Selected Statement": "\t           && (vec->ptr != endptr)) {\n", "Selected Pointer": "endptr", "Compared Statement": "\tmemset(so, 0, sizeof(*so));\n", "Compared Pointer": "so", "Aliasing": "No", "Function Input": {"ip_version": {"type_category": "pointer", "concrete_type": "NULL"}, "so": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd968", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"sock": {"type_category": "unknown", "concrete_type": "SOCKET", "value": "15781072"}, "lsa": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"sa": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"sa_family": {"type_category": "unknown", "concrete_type": "sa_family_t", "value": "0"}, "sa_data": {"type_category": "string", "concrete_type": "string", "value": "\"\\000\\000\\001\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\""}}}, "sin": {"type_category": "struct", "concrete_type": "sockaddr_in", "value": "{sin_family = 0, sin_port = 0, sin_addr = {s_addr = 1}, sin_zero = \"\\000\\000\\000\\000\\000\\000\\000\"}"}}}, "rsa": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"sa": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"sa_family": {"type_category": "unknown", "concrete_type": "sa_family_t", "value": "1"}, "sa_data": {"type_category": "string", "concrete_type": "string", "value": "\"\\000\\000\\321\\314\\360\\000\\000\\000\\000\\000\\020\\000\\241\\367\""}}}, "sin": {"type_category": "struct", "concrete_type": "sockaddr_in", "value": "{sin_family = 1, sin_port = 0, sin_addr = {s_addr = 15781073}, sin_zero = \"\\000\\000\\000\\000\\020\\000\\241\\367\"}"}}}, "is_ssl": {"type_category": "int", "concrete_type": "unsigned char", "value": "255 '\\377'"}, "ssl_redir": {"type_category": "int", "concrete_type": "unsigned char", "value": "127 '\\177'"}, "is_optional": {"type_category": "int", "concrete_type": "unsigned char", "value": "0 '\\000'"}, "in_use": {"type_category": "int", "concrete_type": "unsigned char", "value": "0 '\\000'"}}}}, "vec": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd970", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"ptr": {"type_category": "string", "concrete_type": "NULL"}, "len": {"type_category": "unknown", "concrete_type": "size_t", "value": "0"}}}}}, "Program Information": {"Project Name": "civetweb"}, "idx": 117}
{"Programming Language": "C", "Source Code": "int\npg_vsnprintf(char *str, size_t count, const char *fmt, va_list args)\n{\n\tPrintfTarget target;\n\tchar\t\tonebyte[1];\n\n\t\n\tif (count == 0)\n\t{\n\t\tstr = onebyte;\n\t\tcount = 1;\n\t}\n\ttarget.bufstart = target.bufptr = str;\n\ttarget.bufend = str + count - 1;\n\ttarget.stream = NULL;\n\ttarget.nchars = 0;\n\ttarget.failed = false;\n\tdopr(&target, fmt, args);\n\t*(target.bufptr) = '\\0';", "Selected Statement": "\tdopr(&target, fmt, args);\n", "Selected Pointer": "fmt", "Compared Statement": "\ttarget.bufend = str + count - 1;\n", "Compared Pointer": "str", "Aliasing": "No", "Function Input": {"count": {"type_category": "unknown", "concrete_type": "size_t", "value": "<optimized out>"}, "fmt": {"type_category": "string", "concrete_type": "string", "value": "<optimized out>"}, "str": {"type_category": "string", "concrete_type": "string", "value": "<optimized out>"}}, "Program Information": {"Project Name": "libpg_query"}, "idx": 118}
{"Programming Language": "C", "Source Code": "int\npg_vsnprintf(char *str, size_t count, const char *fmt, va_list args)\n{\n\tPrintfTarget target;\n\tchar\t\tonebyte[1];\n\n\t\n\tif (count == 0)\n\t{\n\t\tstr = onebyte;\n\t\tcount = 1;\n\t}\n\ttarget.bufstart = target.bufptr = str;\n\ttarget.bufend = str + count - 1;\n\ttarget.stream = NULL;\n\ttarget.nchars = 0;\n\ttarget.failed = false;\n\tdopr(&target, fmt, args);\n\t*(target.bufptr) = '\\0';", "Selected Statement": "\ttarget.bufend = str + count - 1;\n", "Selected Pointer": "str", "Compared Statement": "\tdopr(&target, fmt, args);\n", "Compared Pointer": "fmt", "Aliasing": "No", "Function Input": {"count": {"type_category": "unknown", "concrete_type": "size_t", "value": "<optimized out>"}, "fmt": {"type_category": "string", "concrete_type": "string", "value": "<optimized out>"}, "str": {"type_category": "string", "concrete_type": "string", "value": "<optimized out>"}}, "Program Information": {"Project Name": "libpg_query"}, "idx": 119}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Selected Pointer": "tmp", "Compared Statement": "\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n", "Compared Pointer": "filename", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffde98", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5c060 \"\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 120}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n", "Selected Pointer": "filename", "Compared Statement": "\t\tfmt = &timefmts[ctl->time_fmt];\n", "Compared Pointer": "fmt", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"\\353\\353\\353d\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 121}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\tfmt = &timefmts[ctl->time_fmt];\n", "Selected Pointer": "fmt", "Compared Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Compared Pointer": "timestr", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"u\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 122}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Selected Pointer": "timestr", "Compared Statement": "\t\tfmt = &timefmts[ctl->time_fmt];\n", "Compared Pointer": "fmt", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"u\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 123}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Selected Pointer": "timestr", "Compared Statement": "\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n", "Compared Pointer": "filename", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 124}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\tfmt = &timefmts[ctl->time_fmt];\n", "Selected Pointer": "fmt", "Compared Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Compared Pointer": "tmp", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"u\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 125}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\tfmt = &timefmts[ctl->time_fmt];\n", "Selected Pointer": "fmt", "Compared Statement": "\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n", "Compared Pointer": "filename", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 126}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n", "Selected Pointer": "filename", "Compared Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Compared Pointer": "timestr", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"\\r\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 127}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n", "Selected Pointer": "filename", "Compared Statement": "\t\tfmt = &timefmts[ctl->time_fmt];\n", "Compared Pointer": "fmt", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"\\r\\304\\365\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 128}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n", "Selected Pointer": "filename", "Compared Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Compared Pointer": "tmp", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"\\364\\020\\365\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 129}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Selected Pointer": "timestr", "Compared Statement": "\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n", "Compared Pointer": "filename", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"\\a\\031\\365\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 130}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n", "Selected Pointer": "filename", "Compared Statement": "\t\tfmt = &timefmts[ctl->time_fmt];\n", "Compared Pointer": "fmt", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"d\\304\\365\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 131}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Selected Pointer": "tmp", "Compared Statement": "\t\tfmt = &timefmts[ctl->time_fmt];\n", "Compared Pointer": "fmt", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"u`\\006t\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 132}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Selected Pointer": "timestr", "Compared Statement": "\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n", "Compared Pointer": "filename", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"dy*\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 133}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n", "Selected Pointer": "filename", "Compared Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Compared Pointer": "tmp", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \",\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 134}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Selected Pointer": "timestr", "Compared Statement": "\t\tfmt = &timefmts[ctl->time_fmt];\n", "Compared Pointer": "fmt", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"ubody*\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 135}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Selected Pointer": "tmp", "Compared Statement": "\t\tfmt = &timefmts[ctl->time_fmt];\n", "Compared Pointer": "fmt", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"=\\r\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 136}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\tfmt = &timefmts[ctl->time_fmt];\n", "Selected Pointer": "fmt", "Compared Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Compared Pointer": "tmp", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 137}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Selected Pointer": "tmp", "Compared Statement": "\t\tfmt = &timefmts[ctl->time_fmt];\n", "Compared Pointer": "fmt", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"\\021\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 138}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n", "Selected Pointer": "filename", "Compared Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Compared Pointer": "tmp", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"\\v\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 139}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n", "Selected Pointer": "filename", "Compared Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Compared Pointer": "timestr", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"u\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 140}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Selected Pointer": "timestr", "Compared Statement": "\t\tfmt = &timefmts[ctl->time_fmt];\n", "Compared Pointer": "fmt", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"uc\\365\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 141}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Selected Pointer": "tmp", "Compared Statement": "\t\tfmt = &timefmts[ctl->time_fmt];\n", "Compared Pointer": "fmt", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"unobody*\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 142}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\tfmt = &timefmts[ctl->time_fmt];\n", "Selected Pointer": "fmt", "Compared Statement": "\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n", "Compared Pointer": "filename", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 143}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n", "Selected Pointer": "filename", "Compared Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Compared Pointer": "tmp", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"mait\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 144}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\tfmt = &timefmts[ctl->time_fmt];\n", "Selected Pointer": "fmt", "Compared Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Compared Pointer": "timestr", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"u\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 145}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Selected Pointer": "tmp", "Compared Statement": "\t\tfmt = &timefmts[ctl->time_fmt];\n", "Compared Pointer": "fmt", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 146}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n", "Selected Pointer": "filename", "Compared Statement": "\t\tfmt = &timefmts[ctl->time_fmt];\n", "Compared Pointer": "fmt", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"ut\\365\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 147}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n", "Selected Pointer": "filename", "Compared Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Compared Pointer": "timestr", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"\\a\\031\\031\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 148}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n", "Selected Pointer": "filename", "Compared Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Compared Pointer": "timestr", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"u\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 149}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\tfmt = &timefmts[ctl->time_fmt];\n", "Selected Pointer": "fmt", "Compared Statement": "\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n", "Compared Pointer": "filename", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 150}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n", "Selected Pointer": "filename", "Compared Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Compared Pointer": "tmp", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"u\\251\\031dat\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 151}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\tfmt = &timefmts[ctl->time_fmt];\n", "Selected Pointer": "fmt", "Compared Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Compared Pointer": "timestr", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"\\353\\353d\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 152}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\tfmt = &timefmts[ctl->time_fmt];\n", "Selected Pointer": "fmt", "Compared Statement": "\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n", "Compared Pointer": "filename", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf59fd0 \"\\353\\f\\342\\367\\377\\177\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 153}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n", "Selected Pointer": "filename", "Compared Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Compared Pointer": "tmp", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"u\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 154}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Selected Pointer": "tmp", "Compared Statement": "\t\tfmt = &timefmts[ctl->time_fmt];\n", "Compared Pointer": "fmt", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 155}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\tfmt = &timefmts[ctl->time_fmt];\n", "Selected Pointer": "fmt", "Compared Statement": "\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n", "Compared Pointer": "filename", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 156}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\tfmt = &timefmts[ctl->time_fmt];\n", "Selected Pointer": "fmt", "Compared Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Compared Pointer": "timestr", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 157}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Selected Pointer": "tmp", "Compared Statement": "\t\tfmt = &timefmts[ctl->time_fmt];\n", "Compared Pointer": "fmt", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"\\006\\304\\365\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 158}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n", "Selected Pointer": "filename", "Compared Statement": "\t\tfmt = &timefmts[ctl->time_fmt];\n", "Compared Pointer": "fmt", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 159}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\tfmt = &timefmts[ctl->time_fmt];\n", "Selected Pointer": "fmt", "Compared Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Compared Pointer": "timestr", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"w\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 160}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\tfmt = &timefmts[ctl->time_fmt];\n", "Selected Pointer": "fmt", "Compared Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Compared Pointer": "tmp", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"\\031\\304\\365\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 161}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Selected Pointer": "tmp", "Compared Statement": "\t\tfmt = &timefmts[ctl->time_fmt];\n", "Compared Pointer": "fmt", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"i\\004\\365\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 162}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Selected Pointer": "tmp", "Compared Statement": "\t\tfmt = &timefmts[ctl->time_fmt];\n", "Compared Pointer": "fmt", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"c\\304\\365\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 163}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\tfmt = &timefmts[ctl->time_fmt];\n", "Selected Pointer": "fmt", "Compared Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Compared Pointer": "timestr", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 164}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n", "Selected Pointer": "filename", "Compared Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Compared Pointer": "timestr", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"i\\304\\365\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 165}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Selected Pointer": "timestr", "Compared Statement": "\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n", "Compared Pointer": "filename", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"\\353\\353\\365\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 166}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Selected Pointer": "tmp", "Compared Statement": "\t\tfmt = &timefmts[ctl->time_fmt];\n", "Compared Pointer": "fmt", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 167}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n", "Selected Pointer": "filename", "Compared Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Compared Pointer": "tmp", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 168}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\tfmt = &timefmts[ctl->time_fmt];\n", "Selected Pointer": "fmt", "Compared Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Compared Pointer": "tmp", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 169}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n", "Selected Pointer": "filename", "Compared Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Compared Pointer": "timestr", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"/\\304\\365\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 170}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\tfmt = &timefmts[ctl->time_fmt];\n", "Selected Pointer": "fmt", "Compared Statement": "\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n", "Compared Pointer": "filename", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"t\\304\\365\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 171}
{"Programming Language": "C", "Source Code": "static void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);", "Selected Statement": "\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n", "Selected Pointer": "tmp", "Compared Statement": "\t\tfmt = &timefmts[ctl->time_fmt];\n", "Compared Pointer": "fmt", "Aliasing": "No", "Function Input": {"ctl": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdda8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}, "filename": {"type_category": "string", "concrete_type": "string", "value": "0xf5bfe0 \"\\364s0\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 172}
{"Programming Language": "C", "Source Code": "static int is_terminated_by_blank(const char *str)\n{\n\tsize_t sz = str ? strlen(str) : 0;\n\tconst char *p = sz ? str + (sz - 1) : NULL;\n\n\tif (!sz || !p || *p != '\\n')\n\t\treturn 0;\t\t\n\tif (p == str)\n\t\treturn 1;\t\t\n\tp--;\n\twhile (p > str && (*p == ' ' || *p == '\\t'))\n\t\tp--;\n\treturn *p == '\\n' ? 1 : 0;\n}\n\n\nstatic int next_comment_line(struct libmnt_parser *pa, char **last)\n{\n\tif (getline(&pa->buf, &pa->bufsiz, pa->f) < 0)\n\t\treturn feof(pa->f) ? 1 : -errno;\n\n\tpa->line++;\n\t*last = strchr(pa->buf, '\\n');\n\n\treturn is_comment_line(pa->buf) ? 0 : 1;\n}\n\nstatic int append_comment(struct libmnt_table *tb,\n\t\t\t  struct libmnt_fs *fs,\n\t\t\t  const char *comm,\n\t\t\t  int eof)\n{\n\tint rc, intro = mnt_table_get_nents(tb) == 0;", "Selected Statement": "\tif (p == str)\n", "Selected Pointer": "p", "Compared Statement": "\tif (p == str)\n", "Compared Pointer": "str", "Aliasing": "Yes", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x10550d0 \"\\n\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 173}
{"Programming Language": "C", "Source Code": "static int is_terminated_by_blank(const char *str)\n{\n\tsize_t sz = str ? strlen(str) : 0;\n\tconst char *p = sz ? str + (sz - 1) : NULL;\n\n\tif (!sz || !p || *p != '\\n')\n\t\treturn 0;\t\t\n\tif (p == str)\n\t\treturn 1;\t\t\n\tp--;\n\twhile (p > str && (*p == ' ' || *p == '\\t'))\n\t\tp--;\n\treturn *p == '\\n' ? 1 : 0;\n}\n\n\nstatic int next_comment_line(struct libmnt_parser *pa, char **last)\n{\n\tif (getline(&pa->buf, &pa->bufsiz, pa->f) < 0)\n\t\treturn feof(pa->f) ? 1 : -errno;\n\n\tpa->line++;\n\t*last = strchr(pa->buf, '\\n');\n\n\treturn is_comment_line(pa->buf) ? 0 : 1;\n}\n\nstatic int append_comment(struct libmnt_table *tb,\n\t\t\t  struct libmnt_fs *fs,\n\t\t\t  const char *comm,\n\t\t\t  int eof)\n{\n\tint rc, intro = mnt_table_get_nents(tb) == 0;", "Selected Statement": "\tif (p == str)\n", "Selected Pointer": "p", "Compared Statement": "\tif (p == str)\n", "Compared Pointer": "str", "Aliasing": "Yes", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x105b6b0 \"\\n\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 174}
{"Programming Language": "C", "Source Code": "static int is_terminated_by_blank(const char *str)\n{\n\tsize_t sz = str ? strlen(str) : 0;\n\tconst char *p = sz ? str + (sz - 1) : NULL;\n\n\tif (!sz || !p || *p != '\\n')\n\t\treturn 0;\t\t\n\tif (p == str)\n\t\treturn 1;\t\t\n\tp--;\n\twhile (p > str && (*p == ' ' || *p == '\\t'))\n\t\tp--;\n\treturn *p == '\\n' ? 1 : 0;\n}\n\n\nstatic int next_comment_line(struct libmnt_parser *pa, char **last)\n{\n\tif (getline(&pa->buf, &pa->bufsiz, pa->f) < 0)\n\t\treturn feof(pa->f) ? 1 : -errno;\n\n\tpa->line++;\n\t*last = strchr(pa->buf, '\\n');\n\n\treturn is_comment_line(pa->buf) ? 0 : 1;\n}\n\nstatic int append_comment(struct libmnt_table *tb,\n\t\t\t  struct libmnt_fs *fs,\n\t\t\t  const char *comm,\n\t\t\t  int eof)\n{\n\tint rc, intro = mnt_table_get_nents(tb) == 0;", "Selected Statement": "\tif (p == str)\n", "Selected Pointer": "str", "Compared Statement": "\tif (p == str)\n", "Compared Pointer": "p", "Aliasing": "Yes", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x105b6b0 \"\\n\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 175}
{"Programming Language": "C", "Source Code": "static int is_terminated_by_blank(const char *str)\n{\n\tsize_t sz = str ? strlen(str) : 0;\n\tconst char *p = sz ? str + (sz - 1) : NULL;\n\n\tif (!sz || !p || *p != '\\n')\n\t\treturn 0;\t\t\n\tif (p == str)\n\t\treturn 1;\t\t\n\tp--;\n\twhile (p > str && (*p == ' ' || *p == '\\t'))\n\t\tp--;\n\treturn *p == '\\n' ? 1 : 0;\n}\n\n\nstatic int next_comment_line(struct libmnt_parser *pa, char **last)\n{\n\tif (getline(&pa->buf, &pa->bufsiz, pa->f) < 0)\n\t\treturn feof(pa->f) ? 1 : -errno;\n\n\tpa->line++;\n\t*last = strchr(pa->buf, '\\n');\n\n\treturn is_comment_line(pa->buf) ? 0 : 1;\n}\n\nstatic int append_comment(struct libmnt_table *tb,\n\t\t\t  struct libmnt_fs *fs,\n\t\t\t  const char *comm,\n\t\t\t  int eof)\n{\n\tint rc, intro = mnt_table_get_nents(tb) == 0;", "Selected Statement": "\tif (p == str)\n", "Selected Pointer": "p", "Compared Statement": "\tif (p == str)\n", "Compared Pointer": "str", "Aliasing": "Yes", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x105b6b0 \"\\n\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 176}
{"Programming Language": "C", "Source Code": "static int is_terminated_by_blank(const char *str)\n{\n\tsize_t sz = str ? strlen(str) : 0;\n\tconst char *p = sz ? str + (sz - 1) : NULL;\n\n\tif (!sz || !p || *p != '\\n')\n\t\treturn 0;\t\t\n\tif (p == str)\n\t\treturn 1;\t\t\n\tp--;\n\twhile (p > str && (*p == ' ' || *p == '\\t'))\n\t\tp--;\n\treturn *p == '\\n' ? 1 : 0;\n}\n\n\nstatic int next_comment_line(struct libmnt_parser *pa, char **last)\n{\n\tif (getline(&pa->buf, &pa->bufsiz, pa->f) < 0)\n\t\treturn feof(pa->f) ? 1 : -errno;\n\n\tpa->line++;\n\t*last = strchr(pa->buf, '\\n');\n\n\treturn is_comment_line(pa->buf) ? 0 : 1;\n}\n\nstatic int append_comment(struct libmnt_table *tb,\n\t\t\t  struct libmnt_fs *fs,\n\t\t\t  const char *comm,\n\t\t\t  int eof)\n{\n\tint rc, intro = mnt_table_get_nents(tb) == 0;", "Selected Statement": "\tif (p == str)\n", "Selected Pointer": "str", "Compared Statement": "\tif (p == str)\n", "Compared Pointer": "p", "Aliasing": "Yes", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x105b0e0 \"\\n\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 177}
{"Programming Language": "C", "Source Code": "static int is_terminated_by_blank(const char *str)\n{\n\tsize_t sz = str ? strlen(str) : 0;\n\tconst char *p = sz ? str + (sz - 1) : NULL;\n\n\tif (!sz || !p || *p != '\\n')\n\t\treturn 0;\t\t\n\tif (p == str)\n\t\treturn 1;\t\t\n\tp--;\n\twhile (p > str && (*p == ' ' || *p == '\\t'))\n\t\tp--;\n\treturn *p == '\\n' ? 1 : 0;\n}\n\n\nstatic int next_comment_line(struct libmnt_parser *pa, char **last)\n{\n\tif (getline(&pa->buf, &pa->bufsiz, pa->f) < 0)\n\t\treturn feof(pa->f) ? 1 : -errno;\n\n\tpa->line++;\n\t*last = strchr(pa->buf, '\\n');\n\n\treturn is_comment_line(pa->buf) ? 0 : 1;\n}\n\nstatic int append_comment(struct libmnt_table *tb,\n\t\t\t  struct libmnt_fs *fs,\n\t\t\t  const char *comm,\n\t\t\t  int eof)\n{\n\tint rc, intro = mnt_table_get_nents(tb) == 0;", "Selected Statement": "\tif (p == str)\n", "Selected Pointer": "str", "Compared Statement": "\tif (p == str)\n", "Compared Pointer": "p", "Aliasing": "Yes", "Function Input": {"str": {"type_category": "string", "concrete_type": "string", "value": "0x105b0a0 \"\\n\""}}, "Program Information": {"Project Name": "util-linux"}, "idx": 178}
{"Programming Language": "C", "Source Code": "static YYSIZE_T\nyytnamerr (char *yyres, const char *yystr)\n{\n  if (*yystr == '\"')\n    {\n      YYSIZE_T yyn = 0;\n      char const *yyp = yystr;\n\n      for (;;)\n        switch (*++yyp)\n          {\n          case '\\'':\n          case ',':\n            goto do_not_strip_quotes;\n\n          case '\\\\':\n            if (*++yyp != '\\\\')\n              goto do_not_strip_quotes;\n            \n          default:\n            if (yyres)\n              yyres[yyn] = *yyp;\n            yyn++;\n            break;\n\n          case '\"':\n            if (yyres)\n              yyres[yyn] = '\\0';\n            return yyn;\n          }\n    do_not_strip_quotes: ;\n    }\n\n  if (! yyres)\n    return yystrlen (yystr);\n\n  return yystpcpy (yyres, yystr) - yyres;\n}\n# endif\n\n\nstatic int\nyysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,\n                yytype_int16 *yyssp, int yytoken)\n{", "Selected Statement": "yytnamerr (char *yyres, const char *yystr)\n", "Selected Pointer": "yyres", "Compared Statement": "  return yystpcpy (yyres, yystr) - yyres;\n", "Compared Pointer": "yystr", "Aliasing": "No", "Function Input": {"yyres": {"type_category": "string", "concrete_type": "string", "value": "0xf7dd3a10 <error: Cannot access memory at address 0xf7dd3a10>"}, "yystr": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffd300 \"\\360\\324\\377\\377\\377\\177\""}}, "Program Information": {"Project Name": "apache-httpd"}, "idx": 179}
{"Programming Language": "C", "Source Code": "}\n    len = strlen(s) + 1;\n    res = apr_pmemdup(a, s, len);\n    return res;\n}\n\nAPR_DECLARE(char *) apr_pstrndup(apr_pool_t *a, const char *s, apr_size_t n)\n{\n    char *res;\n    const char *end;\n\n    if (s == NULL) {\n        return NULL;\n    }\n    end = memchr(s, '\\0', n);\n    if (end != NULL)\n        n = end - s;\n    res = apr_palloc(a, n + 1);\n    memcpy(res, s, n);\n    res[n] = '\\0';\n    return res;\n}\n\nAPR_DECLARE(char *) apr_pstrmemdup(apr_pool_t *a, const char *s, apr_size_t n)\n{\n    char *res;\n\n    if (s == NULL) {\n        return NULL;\n    }\n    res = apr_palloc(a, n + 1);\n    memcpy(res, s, n);\n    res[n] = '\\0';\n    return res;\n}\n\nAPR_DECLARE(void *) apr_pmemdup(apr_pool_t *a, const void *m, apr_size_t n)\n{\n    void *res;\n\n    if (m == NULL)\n\treturn NULL;\n    res = apr_palloc(a, n);\n    memcpy(res, m, n);\n    return res;", "Selected Statement": "    len = strlen(s) + 1;\n", "Selected Pointer": "s", "Compared Statement": "    res = apr_palloc(a, n);\n", "Compared Pointer": "a", "Aliasing": "No", "Function Input": {"a": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd240", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"parent": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd42d", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xfff7dacbe0000000\n", "message": "Cannot access memory at address 0xfff7dacbe0000000"}}, "child": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd435", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x7f\n", "message": "Cannot access memory at address 0x7f"}}, "sibling": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd43d", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x656c6f6f62000000\n", "message": "Cannot access memory at address 0x656c6f6f62000000"}}, "ref": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd445", "value": {"type_category": "pointer", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x6572707865206e61\n", "message": "Cannot access memory at address 0x6572707865206e61"}}, "cleanups": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd44d", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x646e6524697373\n", "message": "Cannot access memory at address 0x646e6524697373"}}, "free_cleanups": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd455", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x6e696665646e7524\n", "message": "Cannot access memory at address 0x6e696665646e7524"}}, "allocator": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd45d", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x6465\n", "message": "Cannot access memory at address 0x6465"}}, "subprocesses": {"type_category": "pointer", "concrete_type": "NULL"}, "abort_fn": {"type_category": "unknown", "concrete_type": "apr_abortfunc_t"}, "user_data": {"type_category": "pointer", "concrete_type": "NULL"}, "tag": {"type_category": "string", "concrete_type": "NULL"}, "joined": {"type_category": "pointer", "concrete_type": "NULL"}, "nodes": {"type_category": "pointer", "concrete_type": "NULL"}, "file_line": {"type_category": "string", "concrete_type": "NULL"}, "creation_flags": {"type_category": "unknown", "concrete_type": "apr_uint32_t", "value": "1879048192"}, "stat_alloc": {"type_category": "int", "concrete_type": "unsigned int", "value": "7566453"}, "stat_total_alloc": {"type_category": "int", "concrete_type": "unsigned int", "value": "3355443200"}, "stat_clear": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}, "owner": {"type_category": "unknown", "concrete_type": "apr_os_thread_t", "value": "18446743888086433792"}, "mutex": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd4b5", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xffffffd4c000007f\n", "message": "Cannot access memory at address 0xffffffd4c000007f"}}, "pre_cleanups": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd4bd", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x7f\n", "message": "Cannot access memory at address 0x7f"}}}}}, "n": {"type_category": "unknown", "concrete_type": "apr_size_t", "value": "140737488343776"}}, "Program Information": {"Project Name": "apache-httpd"}, "idx": 180}
{"Programming Language": "C", "Source Code": "APR_DECLARE(char *) apr_cpystrn(char *dst, const char *src, apr_size_t dst_size)\n{\n\n    char *d = dst, *end;\n\n    if (dst_size == 0) {\n        return (dst);\n    }\n\n    if (src) {\n        end = dst + dst_size - 1;\n\n        for (; d < end; ++d, ++src) {\n            if (!(*d = *src)) {\n                return (d);\n            }\n        }\n    }\n\n    *d = '\\0';\t\n\n    return (d);\n}\n\n\n\nAPR_DECLARE(apr_status_t) apr_tokenize_to_argv(const char *arg_str,\n                                            char ***argv_out,\n                                            apr_pool_t *token_context)\n{\n    const char *cp;\n    const char *ct;\n    char *cleaned, *dirty;\n    int escaped;\n    int isquoted, numargs = 0, argnum;\n\n#define SKIP_WHITESPACE(cp) \\\n    for ( ; *cp == ' ' || *cp == '\\t'; ) { \\\n        cp++; \\\n    };\n\n#define CHECK_QUOTATION(cp,isquoted) \\\n    isquoted = 0; \\\n    if (*cp == '\"') { \\\n        isquoted = 1; \\\n        cp++; \\\n    } \\\n    else if (*cp == '\\'') { \\\n        isquoted = 2; \\\n        cp++; \\\n    }\n\n\n#define DETERMINE_NEXTSTRING(cp,isquoted) \\\n    for ( ; *cp != '\\0'; cp++) { \\\n        if (   (*cp == '\\\\' && (*(cp+1) == ' ' || *(cp+1) == '\\t' || \\\n                                *(cp+1) == '\"' || *(cp+1) == '\\''))) { \\\n            cp++; \\\n            continue; \\\n        } \\\n        if (   (!isquoted && (*cp == ' ' || *cp == '\\t')) \\\n            || (isquoted == 1 && *cp == '\"') \\\n            || (isquoted == 2 && *cp == '\\'')                 ) { \\\n            break; \\\n        } \\\n    }\n\n\n#define REMOVE_ESCAPE_CHARS(cleaned, dirty, escaped) \\\n    escaped = 0; \\\n    while(*dirty) { \\\n        if (!escaped && *dirty == '\\\\') { \\\n            escaped = 1; \\\n        } \\\n        else { \\\n            escaped = 0; \\\n            *cleaned++ = *dirty; \\\n        } \\\n        ++dirty; \\\n    } \\\n    *cleaned = 0;        \n\n    cp = arg_str;\n    SKIP_WHITESPACE(cp);\n    ct = cp;\n\n    \n    numargs = 1;\n    while (*ct != '\\0') {\n        CHECK_QUOTATION(ct, isquoted);\n        DETERMINE_NEXTSTRING(ct, isquoted);\n        if (*ct != '\\0') {\n            ct++;\n        }\n        numargs++;\n        SKIP_WHITESPACE(ct);\n    }\n    *argv_out = apr_palloc(token_context, numargs * sizeof(char*));\n\n    \n    for (argnum = 0; argnum < (numargs-1); argnum++) {\n        SKIP_WHITESPACE(cp);\n        CHECK_QUOTATION(cp, isquoted);\n        ct = cp;\n        DETERMINE_NEXTSTRING(cp, isquoted);\n        cp++;\n        (*argv_out)[argnum] = apr_palloc(token_context, cp - ct);\n        apr_cpystrn((*argv_out)[argnum], ct, cp - ct);", "Selected Statement": "        for (; d < end; ++d, ++src) {\n", "Selected Pointer": "end", "Compared Statement": "        apr_cpystrn((*argv_out)[argnum], ct, cp - ct);\n", "Compared Pointer": "ct", "Aliasing": "No", "Function Input": {"dst": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "dst_size": {"type_category": "unknown", "concrete_type": "apr_size_t", "value": "18488048"}, "src": {"type_category": "string", "concrete_type": "string", "value": "0x6d1d39 \"strings/apr_cpystrn.c:178\""}}, "Program Information": {"Project Name": "apache-httpd"}, "idx": 181}
{"Programming Language": "C", "Source Code": "APR_DECLARE(char *) apr_pstrmemdup(apr_pool_t *a, const char *s, apr_size_t n)\n{\n    char *res;\n\n    if (s == NULL) {\n        return NULL;\n    }\n    res = apr_palloc(a, n + 1);\n    memcpy(res, s, n);\n    res[n] = '\\0';\n    return res;", "Selected Statement": "    memcpy(res, s, n);\n", "Selected Pointer": "res", "Compared Statement": "    res = apr_palloc(a, n + 1);\n", "Compared Pointer": "a", "Aliasing": "No", "Function Input": {"a": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdce0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x1\n", "message": "Cannot access memory at address 0x1"}}, "n": {"type_category": "unknown", "concrete_type": "apr_size_t", "value": "140737488346336"}, "s": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdce0 \"\\001\""}}, "Program Information": {"Project Name": "apache-httpd"}, "idx": 182}
{"Programming Language": "C", "Source Code": "}\n    len = strlen(s) + 1;\n    res = apr_pmemdup(a, s, len);\n    return res;\n}\n\nAPR_DECLARE(char *) apr_pstrndup(apr_pool_t *a, const char *s, apr_size_t n)\n{\n    char *res;\n    const char *end;\n\n    if (s == NULL) {\n        return NULL;\n    }\n    end = memchr(s, '\\0', n);\n    if (end != NULL)\n        n = end - s;\n    res = apr_palloc(a, n + 1);\n    memcpy(res, s, n);\n    res[n] = '\\0';\n    return res;\n}\n\nAPR_DECLARE(char *) apr_pstrmemdup(apr_pool_t *a, const char *s, apr_size_t n)\n{\n    char *res;\n\n    if (s == NULL) {\n        return NULL;\n    }\n    res = apr_palloc(a, n + 1);\n    memcpy(res, s, n);\n    res[n] = '\\0';\n    return res;\n}\n\nAPR_DECLARE(void *) apr_pmemdup(apr_pool_t *a, const void *m, apr_size_t n)\n{\n    void *res;\n\n    if (m == NULL)\n\treturn NULL;\n    res = apr_palloc(a, n);\n    memcpy(res, m, n);\n    return res;", "Selected Statement": "    len = strlen(s) + 1;\n", "Selected Pointer": "s", "Compared Statement": "    res = apr_palloc(a, n);\n", "Compared Pointer": "a", "Aliasing": "No", "Function Input": {"a": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd320", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"parent": {"type_category": "pointer", "concrete_type": "NULL"}, "child": {"type_category": "pointer", "concrete_type": "NULL"}, "sibling": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd51d", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x2073747570000000\n", "message": "Cannot access memory at address 0x2073747570000000"}}, "ref": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd525", "value": {"type_category": "pointer", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x742072656772616c\n", "message": "Cannot access memory at address 0x742072656772616c"}}, "cleanups": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd52d", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"next": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x6e6168 <_pcre2_ucd_stage2_8+7192>", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x1aa01aa01aa01aa\n", "message": "Cannot access memory at address 0x1aa01aa01aa01aa"}}, "data": {"type_category": "pointer", "concrete_type": "VOID"}, "plain_cleanup_fn": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x6e6178 <_pcre2_ucd_stage2_8+7208>", "value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x1aa01aa01aa01aa\n", "message": "Cannot access memory at address 0x1aa01aa01aa01aa"}}, "child_cleanup_fn": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x6e6180 <_pcre2_ucd_stage2_8+7216>", "value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x1aa01aa01aa01aa\n", "message": "Cannot access memory at address 0x1aa01aa01aa01aa"}}}}}, "free_cleanups": {"type_category": "pointer", "concrete_type": "NULL"}, "allocator": {"type_category": "pointer", "concrete_type": "NULL"}, "subprocesses": {"type_category": "pointer", "concrete_type": "NULL"}, "abort_fn": {"type_category": "unknown", "concrete_type": "apr_abortfunc_t"}, "user_data": {"type_category": "pointer", "concrete_type": "NULL"}, "tag": {"type_category": "string", "concrete_type": "NULL"}, "joined": {"type_category": "pointer", "concrete_type": "NULL"}, "nodes": {"type_category": "pointer", "concrete_type": "NULL"}, "file_line": {"type_category": "string", "concrete_type": "NULL"}, "creation_flags": {"type_category": "unknown", "concrete_type": "apr_uint32_t", "value": "0"}, "stat_alloc": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}, "stat_total_alloc": {"type_category": "int", "concrete_type": "unsigned int", "value": "3355443200"}, "stat_clear": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}, "owner": {"type_category": "unknown", "concrete_type": "apr_os_thread_t", "value": "18446743891844530176"}, "mutex": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd595", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xffffffd5a000007f\n", "message": "Cannot access memory at address 0xffffffd5a000007f"}}, "pre_cleanups": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd59d", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x207374757000007f\n", "message": "Cannot access memory at address 0x207374757000007f"}}}}}, "n": {"type_category": "unknown", "concrete_type": "apr_size_t", "value": "140737488344000"}}, "Program Information": {"Project Name": "apache-httpd"}, "idx": 183}
{"Programming Language": "C", "Source Code": "}\n    len = strlen(s) + 1;\n    res = apr_pmemdup(a, s, len);\n    return res;\n}\n\nAPR_DECLARE(char *) apr_pstrndup(apr_pool_t *a, const char *s, apr_size_t n)\n{\n    char *res;\n    const char *end;\n\n    if (s == NULL) {\n        return NULL;\n    }\n    end = memchr(s, '\\0', n);\n    if (end != NULL)\n        n = end - s;\n    res = apr_palloc(a, n + 1);\n    memcpy(res, s, n);\n    res[n] = '\\0';\n    return res;\n}\n\nAPR_DECLARE(char *) apr_pstrmemdup(apr_pool_t *a, const char *s, apr_size_t n)\n{\n    char *res;\n\n    if (s == NULL) {\n        return NULL;\n    }\n    res = apr_palloc(a, n + 1);\n    memcpy(res, s, n);\n    res[n] = '\\0';\n    return res;\n}\n\nAPR_DECLARE(void *) apr_pmemdup(apr_pool_t *a, const void *m, apr_size_t n)\n{\n    void *res;\n\n    if (m == NULL)\n\treturn NULL;\n    res = apr_palloc(a, n);\n    memcpy(res, m, n);\n    return res;", "Selected Statement": "    len = strlen(s) + 1;\n", "Selected Pointer": "s", "Compared Statement": "    res = apr_palloc(a, n);\n", "Compared Pointer": "a", "Aliasing": "No", "Function Input": {"a": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd230", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"parent": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd41d", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x6400\n", "message": "Cannot access memory at address 0x6400"}}, "child": {"type_category": "pointer", "concrete_type": "NULL"}, "sibling": {"type_category": "pointer", "concrete_type": "NULL"}, "ref": {"type_category": "pointer", "concrete_type": "NULL"}, "cleanups": {"type_category": "pointer", "concrete_type": "NULL"}, "free_cleanups": {"type_category": "pointer", "concrete_type": "NULL"}, "allocator": {"type_category": "pointer", "concrete_type": "NULL"}, "subprocesses": {"type_category": "pointer", "concrete_type": "NULL"}, "abort_fn": {"type_category": "unknown", "concrete_type": "apr_abortfunc_t", "value": "0x2073747570000000"}, "user_data": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd465", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x742072656772616c\n", "message": "Cannot access memory at address 0x742072656772616c"}}, "tag": {"type_category": "string", "concrete_type": "string", "value": "0x6e6168 <_pcre2_ucd_stage2_8+7192> \"\\252\\001\\252\\001\\252\\001\\252\\001\\252\\001\\252\\001\\252\\001\\252\\001\\252\\001\\252\\001\\252\\001\\252\\001\\252\\001\\252\\001\\252\\001\\252\\001\\252\\001\\252\\001\\252\\001\\252\\001\\252\\001\\252\\001\\252\\001\\252\\001\\252\\001\\252\\001\\252\\001\\252\\001\\252\\001\\252\\001\\252\\001\\252\\001\\252\\001\\252\\001\\252\\001\\252\\001\\252\\001\\253\\001\\252\\001\\254\\001\\253\\001\\253\\001\\253\\001\\253\\001\\253\\001\\253\\001\\255\\001\\243\""}, "joined": {"type_category": "pointer", "concrete_type": "NULL"}, "nodes": {"type_category": "pointer", "concrete_type": "NULL"}, "file_line": {"type_category": "string", "concrete_type": "NULL"}, "creation_flags": {"type_category": "unknown", "concrete_type": "apr_uint32_t", "value": "0"}, "stat_alloc": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}, "stat_total_alloc": {"type_category": "int", "concrete_type": "unsigned int", "value": "3355443200"}, "stat_clear": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}, "owner": {"type_category": "unknown", "concrete_type": "apr_os_thread_t", "value": "18446743887817998336"}, "mutex": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd4a5", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xffffffd4b000007f\n", "message": "Cannot access memory at address 0xffffffd4b000007f"}}, "pre_cleanups": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd4ad", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x7f\n", "message": "Cannot access memory at address 0x7f"}}}}}, "n": {"type_category": "unknown", "concrete_type": "apr_size_t", "value": "140737488343760"}}, "Program Information": {"Project Name": "apache-httpd"}, "idx": 184}
{"Programming Language": "C", "Source Code": "APR_DECLARE(char *) apr_cpystrn(char *dst, const char *src, apr_size_t dst_size)\n{\n\n    char *d = dst, *end;\n\n    if (dst_size == 0) {\n        return (dst);\n    }\n\n    if (src) {\n        end = dst + dst_size - 1;\n\n        for (; d < end; ++d, ++src) {\n            if (!(*d = *src)) {\n                return (d);\n            }\n        }\n    }\n\n    *d = '\\0';\t\n\n    return (d);\n}\n\n\n\nAPR_DECLARE(apr_status_t) apr_tokenize_to_argv(const char *arg_str,\n                                            char ***argv_out,\n                                            apr_pool_t *token_context)\n{\n    const char *cp;\n    const char *ct;\n    char *cleaned, *dirty;\n    int escaped;\n    int isquoted, numargs = 0, argnum;\n\n#define SKIP_WHITESPACE(cp) \\\n    for ( ; *cp == ' ' || *cp == '\\t'; ) { \\\n        cp++; \\\n    };\n\n#define CHECK_QUOTATION(cp,isquoted) \\\n    isquoted = 0; \\\n    if (*cp == '\"') { \\\n        isquoted = 1; \\\n        cp++; \\\n    } \\\n    else if (*cp == '\\'') { \\\n        isquoted = 2; \\\n        cp++; \\\n    }\n\n\n#define DETERMINE_NEXTSTRING(cp,isquoted) \\\n    for ( ; *cp != '\\0'; cp++) { \\\n        if (   (*cp == '\\\\' && (*(cp+1) == ' ' || *(cp+1) == '\\t' || \\\n                                *(cp+1) == '\"' || *(cp+1) == '\\''))) { \\\n            cp++; \\\n            continue; \\\n        } \\\n        if (   (!isquoted && (*cp == ' ' || *cp == '\\t')) \\\n            || (isquoted == 1 && *cp == '\"') \\\n            || (isquoted == 2 && *cp == '\\'')                 ) { \\\n            break; \\\n        } \\\n    }\n\n\n#define REMOVE_ESCAPE_CHARS(cleaned, dirty, escaped) \\\n    escaped = 0; \\\n    while(*dirty) { \\\n        if (!escaped && *dirty == '\\\\') { \\\n            escaped = 1; \\\n        } \\\n        else { \\\n            escaped = 0; \\\n            *cleaned++ = *dirty; \\\n        } \\\n        ++dirty; \\\n    } \\\n    *cleaned = 0;        \n\n    cp = arg_str;\n    SKIP_WHITESPACE(cp);\n    ct = cp;\n\n    \n    numargs = 1;\n    while (*ct != '\\0') {\n        CHECK_QUOTATION(ct, isquoted);\n        DETERMINE_NEXTSTRING(ct, isquoted);\n        if (*ct != '\\0') {\n            ct++;\n        }\n        numargs++;\n        SKIP_WHITESPACE(ct);\n    }\n    *argv_out = apr_palloc(token_context, numargs * sizeof(char*));\n\n    \n    for (argnum = 0; argnum < (numargs-1); argnum++) {\n        SKIP_WHITESPACE(cp);\n        CHECK_QUOTATION(cp, isquoted);\n        ct = cp;\n        DETERMINE_NEXTSTRING(cp, isquoted);\n        cp++;\n        (*argv_out)[argnum] = apr_palloc(token_context, cp - ct);\n        apr_cpystrn((*argv_out)[argnum], ct, cp - ct);", "Selected Statement": "        apr_cpystrn((*argv_out)[argnum], ct, cp - ct);\n", "Selected Pointer": "cp", "Compared Statement": "        for (; d < end; ++d, ++src) {\n", "Compared Pointer": "end", "Aliasing": "No", "Function Input": {"dst": {"type_category": "string", "concrete_type": "string", "value": "0x2 <error: Cannot access memory at address 0x2>"}, "dst_size": {"type_category": "unknown", "concrete_type": "apr_size_t", "value": "18488048"}, "src": {"type_category": "string", "concrete_type": "string", "value": "0x6d1d39 \"strings/apr_cpystrn.c:178\""}}, "Program Information": {"Project Name": "apache-httpd"}, "idx": 185}
{"Programming Language": "C", "Source Code": "APR_DECLARE(char *) apr_pstrmemdup(apr_pool_t *a, const char *s, apr_size_t n)\n{\n    char *res;\n\n    if (s == NULL) {\n        return NULL;\n    }\n    res = apr_palloc(a, n + 1);\n    memcpy(res, s, n);\n    res[n] = '\\0';\n    return res;", "Selected Statement": "    memcpy(res, s, n);\n", "Selected Pointer": "res", "Compared Statement": "    res = apr_palloc(a, n + 1);\n", "Compared Pointer": "a", "Aliasing": "No", "Function Input": {"a": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdcf0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x1\n", "message": "Cannot access memory at address 0x1"}}, "n": {"type_category": "unknown", "concrete_type": "apr_size_t", "value": "140737488346352"}, "s": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdcf0 \"\\001\""}}, "Program Information": {"Project Name": "apache-httpd"}, "idx": 186}
{"Programming Language": "C", "Source Code": "enum utf8_state\nutf8_open(struct utf8_data *ud, u_char ch)\n{\n\tmemset(ud, 0, sizeof *ud);\n\tif (ch >= 0xc2 && ch <= 0xdf)\n\t\tud->size = 2;\n\telse if (ch >= 0xe0 && ch <= 0xef)\n\t\tud->size = 3;\n\telse if (ch >= 0xf0 && ch <= 0xf4)\n\t\tud->size = 4;\n\telse\n\t\treturn (UTF8_ERROR);\n\tutf8_append(ud, ch);\n\treturn (UTF8_MORE);\n}\n\n\nenum utf8_state\nutf8_append(struct utf8_data *ud, u_char ch)\n{\n\tint\twidth;\n\n\tif (ud->have >= ud->size)\n\t\tfatalx(\"UTF-8 character overflow\");\n\tif (ud->size > sizeof ud->data)\n\t\tfatalx(\"UTF-8 character size too large\");\n\n\tif (ud->have != 0 && (ch & 0xc0) != 0x80)\n\t\tud->width = 0xff;\n\n\tud->data[ud->have++] = ch;\n\tif (ud->have != ud->size)\n\t\treturn (UTF8_MORE);\n\n\tif (ud->width == 0xff)\n\t\treturn (UTF8_ERROR);\n\tif (utf8_width(ud, &width) != UTF8_DONE)\n\t\treturn (UTF8_ERROR);\n\tud->width = width;\n\n\treturn (UTF8_DONE);\n}\n\n\nint\nutf8_strvis(char *dst, const char *src, size_t len, int flag)\n{\n\tstruct utf8_data\t ud;\n\tconst char\t\t*start = dst, *end = src + len;\n\tenum utf8_state\t\t more;\n\tsize_t\t\t\t i;\n\n\twhile (src < end) {\n\t\tif ((more = utf8_open(&ud, *src)) == UTF8_MORE) {\n\t\t\twhile (++src < end && more == UTF8_MORE)\n\t\t\t\tmore = utf8_append(&ud, *src);\n\t\t\tif (more == UTF8_DONE) {\n\t\t\t\t\n\t\t\t\tfor (i = 0; i < ud.size; i++)\n\t\t\t\t\t*dst++ = ud.data[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tsrc -= ud.have;\n\t\t}\n\t\tif (src[0] == '$' && src < end - 1) {\n\t\t\tif (isalpha((u_char)src[1]) ||\n\t\t\t    src[1] == '_' ||\n\t\t\t    src[1] == '{')\n\t\t\t\t*dst++ = '\\\\';\n\t\t\t*dst++ = '$';\n\t\t} else if (src < end - 1)\n\t\t\tdst = vis(dst, src[0], flag, src[1]);\n\t\telse if (src < end)\n\t\t\tdst = vis(dst, src[0], flag, '\\0');\n\t\tsrc++;\n\t}\n\t*dst = '\\0';\n\treturn (dst - start);\n}\n\n\nint\nutf8_stravis(char **dst, const char *src, int flag)\n{\n\tchar\t*buf;\n\tint\t len;\n\n\tbuf = xreallocarray(NULL, 4, strlen(src) + 1);\n\tlen = utf8_strvis(buf, src, strlen(src), flag);\n\n\t*dst = xrealloc(buf, len + 1);\n\treturn (len);\n}\n\n\nint\nutf8_stravisx(char **dst, const char *src, size_t srclen, int flag)\n{\n\tchar\t*buf;\n\tint\t len;\n\n\tbuf = xreallocarray(NULL, 4, srclen + 1);\n\tlen = utf8_strvis(buf, src, srclen, flag);\n\n\t*dst = xrealloc(buf, len + 1);\n\treturn (len);\n}\n\n\nint\nutf8_isvalid(const char *s)\n{\n\tstruct utf8_data ud;\n\tconst char\t*end;\n\tenum utf8_state\t more;\n\n\tend = s + strlen(s);\n\twhile (s < end) {", "Selected Statement": "\twhile (s < end) {\n", "Selected Pointer": "s", "Compared Statement": "\tmemset(ud, 0, sizeof *ud);\n", "Compared Pointer": "ud", "Aliasing": "No", "Function Input": {"ch": {"type_category": "unknown", "concrete_type": "u_char", "value": "97 'a'"}, "ud": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdcc0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"data": {"type_category": "string", "concrete_type": "string", "value": "\"\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\""}, "have": {"type_category": "unknown", "concrete_type": "u_char", "value": "0 '\\000'"}, "size": {"type_category": "unknown", "concrete_type": "u_char", "value": "0 '\\000'"}, "width": {"type_category": "unknown", "concrete_type": "u_char", "value": "0 '\\000'"}}}}}, "Program Information": {"Project Name": "tmux"}, "idx": 187}
{"Programming Language": "C", "Source Code": "*/\nint stun_check_message_integrity_by_key_str(turn_credential_type ct, uint8_t *buf, size_t len, hmackey_t key,\n                                            password_t pwd, SHATYPE shatype) {\n  int res = 0;\n  uint8_t new_hmac[MAXSHASIZE] = {0};\n  unsigned int shasize;\n  const uint8_t *old_hmac = NULL;\n\n  stun_attr_ref sar = stun_attr_get_first_by_type_str(buf, len, STUN_ATTRIBUTE_MESSAGE_INTEGRITY);\n  if (!sar) {\n    return -1;\n  }\n\n  int sarlen = stun_attr_get_len(sar);\n\n  switch (sarlen) {\n  case SHA256SIZEBYTES:\n    shasize = SHA256SIZEBYTES;\n    if (shatype != SHATYPE_SHA256) {\n      return -1;\n    }\n    break;\n  case SHA384SIZEBYTES:\n    shasize = SHA384SIZEBYTES;\n    if (shatype != SHATYPE_SHA384) {\n      return -1;\n    }\n    break;\n  case SHA512SIZEBYTES:\n    shasize = SHA512SIZEBYTES;\n    if (shatype != SHATYPE_SHA512) {\n      return -1;\n    }\n    break;\n  case SHA1SIZEBYTES:\n    shasize = SHA1SIZEBYTES;\n    if (shatype != SHATYPE_SHA1) {\n      return -1;\n    }\n    break;\n  default:\n    return -1;\n  };\n\n  int orig_len = stun_get_command_message_len_str(buf, len);\n  if (orig_len < 0) {\n    return -1;\n  }\n\n  int new_len = (int)((const uint8_t *)sar - buf) + 4 + shasize;\n  if (new_len > orig_len) {\n    return -1;\n  }\n\n  if (stun_set_command_message_len_str(buf, new_len) < 0) {\n    return -1;\n  }\n\n  if (ct == TURN_CREDENTIALS_SHORT_TERM) {\n    res =\n        stun_calculate_hmac(buf, (size_t)new_len - 4 - shasize, pwd, strlen((char *)pwd), new_hmac, &shasize, shatype);\n  } else {\n    res = stun_calculate_hmac(buf, (size_t)new_len - 4 - shasize, key, get_hmackey_size(shatype), new_hmac, &shasize,\n                              shatype);\n  }\n\n  stun_set_command_message_len_str(buf, orig_len);\n  if (res < 0) {\n    return -1;\n  }\n\n  old_hmac = stun_attr_get_value(sar);\n  if (!old_hmac) {\n    return -1;\n  }\n\n  if (memcmp(old_hmac, new_hmac, shasize)) {\n    return 0;\n  }\n\n  return +1;\n}\n\n\nint stun_check_message_integrity_str(turn_credential_type ct, uint8_t *buf, size_t len, const uint8_t *uname,\n                                     const uint8_t *realm, const uint8_t *upwd, SHATYPE shatype) {\n  hmackey_t key;\n  password_t pwd;\n\n  if (ct == TURN_CREDENTIALS_SHORT_TERM) {\n    strncpy((char *)pwd, (const char *)upwd, sizeof(password_t) - 1);\n    pwd[sizeof(password_t) - 1] = 0;\n  } else if (stun_produce_integrity_key_str(uname, realm, upwd, key, shatype) < 0) {\n    return -1;\n  }", "Selected Statement": "  stun_set_command_message_len_str(buf, orig_len);\n", "Selected Pointer": "buf", "Compared Statement": "  if (memcmp(old_hmac, new_hmac, shasize)) {\n", "Compared Pointer": "old_hmac", "Aliasing": "No", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0xc <error: Cannot access memory at address 0xc>"}, "ct": {"type_category": "unknown", "concrete_type": "turn_credential_type", "value": "4"}, "key": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdc10 \"VOkJxbRl1RmTxUk/WvJxBt\""}, "len": {"type_category": "unknown", "concrete_type": "size_t", "value": "5009782"}, "pwd": {"type_category": "string", "concrete_type": "string", "value": "0x400001000 <error: Cannot access memory at address 0x400001000>"}, "shatype": {"type_category": "unknown", "concrete_type": "SHATYPE", "value": "SHATYPE_DEFAULT"}}, "Program Information": {"Project Name": "coturn"}, "idx": 188}
{"Programming Language": "C", "Source Code": "*/\nint stun_check_message_integrity_by_key_str(turn_credential_type ct, uint8_t *buf, size_t len, hmackey_t key,\n                                            password_t pwd, SHATYPE shatype) {\n  int res = 0;\n  uint8_t new_hmac[MAXSHASIZE] = {0};\n  unsigned int shasize;\n  const uint8_t *old_hmac = NULL;\n\n  stun_attr_ref sar = stun_attr_get_first_by_type_str(buf, len, STUN_ATTRIBUTE_MESSAGE_INTEGRITY);\n  if (!sar) {\n    return -1;\n  }\n\n  int sarlen = stun_attr_get_len(sar);\n\n  switch (sarlen) {\n  case SHA256SIZEBYTES:\n    shasize = SHA256SIZEBYTES;\n    if (shatype != SHATYPE_SHA256) {\n      return -1;\n    }\n    break;\n  case SHA384SIZEBYTES:\n    shasize = SHA384SIZEBYTES;\n    if (shatype != SHATYPE_SHA384) {\n      return -1;\n    }\n    break;\n  case SHA512SIZEBYTES:\n    shasize = SHA512SIZEBYTES;\n    if (shatype != SHATYPE_SHA512) {\n      return -1;\n    }\n    break;\n  case SHA1SIZEBYTES:\n    shasize = SHA1SIZEBYTES;\n    if (shatype != SHATYPE_SHA1) {\n      return -1;\n    }\n    break;\n  default:\n    return -1;\n  };\n\n  int orig_len = stun_get_command_message_len_str(buf, len);\n  if (orig_len < 0) {\n    return -1;\n  }\n\n  int new_len = (int)((const uint8_t *)sar - buf) + 4 + shasize;\n  if (new_len > orig_len) {\n    return -1;\n  }\n\n  if (stun_set_command_message_len_str(buf, new_len) < 0) {\n    return -1;\n  }\n\n  if (ct == TURN_CREDENTIALS_SHORT_TERM) {\n    res =\n        stun_calculate_hmac(buf, (size_t)new_len - 4 - shasize, pwd, strlen((char *)pwd), new_hmac, &shasize, shatype);\n  } else {\n    res = stun_calculate_hmac(buf, (size_t)new_len - 4 - shasize, key, get_hmackey_size(shatype), new_hmac, &shasize,\n                              shatype);\n  }\n\n  stun_set_command_message_len_str(buf, orig_len);\n  if (res < 0) {\n    return -1;\n  }\n\n  old_hmac = stun_attr_get_value(sar);\n  if (!old_hmac) {\n    return -1;\n  }\n\n  if (memcmp(old_hmac, new_hmac, shasize)) {\n    return 0;\n  }\n\n  return +1;\n}\n\n\nint stun_check_message_integrity_str(turn_credential_type ct, uint8_t *buf, size_t len, const uint8_t *uname,\n                                     const uint8_t *realm, const uint8_t *upwd, SHATYPE shatype) {\n  hmackey_t key;\n  password_t pwd;\n\n  if (ct == TURN_CREDENTIALS_SHORT_TERM) {\n    strncpy((char *)pwd, (const char *)upwd, sizeof(password_t) - 1);\n    pwd[sizeof(password_t) - 1] = 0;\n  } else if (stun_produce_integrity_key_str(uname, realm, upwd, key, shatype) < 0) {\n    return -1;\n  }", "Selected Statement": "  stun_set_command_message_len_str(buf, orig_len);\n", "Selected Pointer": "buf", "Compared Statement": "  if (memcmp(old_hmac, new_hmac, shasize)) {\n", "Compared Pointer": "old_hmac", "Aliasing": "No", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x14 <error: Cannot access memory at address 0x14>"}, "ct": {"type_category": "unknown", "concrete_type": "turn_credential_type", "value": "4"}, "key": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdc10 \"VOkJxbRl1RmTxUk/WvJxBt\""}, "len": {"type_category": "unknown", "concrete_type": "size_t", "value": "5009782"}, "pwd": {"type_category": "string", "concrete_type": "string", "value": "0x400001000 <error: Cannot access memory at address 0x400001000>"}, "shatype": {"type_category": "unknown", "concrete_type": "SHATYPE", "value": "SHATYPE_DEFAULT"}}, "Program Information": {"Project Name": "coturn"}, "idx": 189}
{"Programming Language": "C", "Source Code": "size_t len, unsigned priority, enum ucl_duplicate_strategy strat,\n\t\tenum ucl_parse_type parse_type)\n{\n\tstruct ucl_chunk *chunk;\n\tstruct ucl_parser_special_handler *special_handler;\n\n\tif (parser == NULL) {\n\t\treturn false;\n\t}\n\n\tif (data == NULL && len != 0) {\n\t\tucl_create_err (&parser->err, \"invalid chunk added\");\n\t\treturn false;\n\t}\n\n\tif (parser->state != UCL_STATE_ERROR) {\n\t\tchunk = UCL_ALLOC (sizeof (struct ucl_chunk));\n\t\tif (chunk == NULL) {\n\t\t\tucl_create_err (&parser->err, \"cannot allocate chunk structure\");\n\t\t\treturn false;\n\t\t}\n\n\t\tmemset (chunk, 0, sizeof (*chunk));\n\n\t\t\n\t\tLL_FOREACH (parser->special_handlers, special_handler) {\n\t\t\tif ((special_handler->flags & UCL_SPECIAL_HANDLER_PREPROCESS_ALL) ||\n\t\t\t\t\t(len >= special_handler->magic_len &&\n\t\t\t\t\t memcmp (data, special_handler->magic, special_handler->magic_len) == 0)) {\n\t\t\t\tunsigned char *ndata = NULL;\n\t\t\t\tsize_t nlen = 0;\n\n\t\t\t\tif (!special_handler->handler (parser, data, len, &ndata, &nlen,\n\t\t\t\t\t\tspecial_handler->user_data)) {\n\t\t\t\t\tUCL_FREE(sizeof (struct ucl_chunk), chunk);\n\t\t\t\t\tucl_create_err (&parser->err, \"call for external handler failed\");\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tstruct ucl_parser_special_handler_chain *nchain;\n\t\t\t\tnchain = UCL_ALLOC (sizeof (*nchain));\n\t\t\t\tnchain->begin = ndata;\n\t\t\t\tnchain->len = nlen;\n\t\t\t\tnchain->special_handler = special_handler;\n\n\t\t\t\t\n\t\t\t\tLL_PREPEND (chunk->special_handlers, nchain);\n\n\t\t\t\tdata = ndata;\n\t\t\t\tlen = nlen;\n\t\t\t}\n\t\t}\n\n\t\tif (parse_type == UCL_PARSE_AUTO && len > 0) {\n\t\t\t\n\t\t\tif ((*data & 0x80) == 0x80 && (*data >= 0xdc && *data <= 0xdf)) {\n\t\t\t\tparse_type = UCL_PARSE_MSGPACK;\n\t\t\t}\n\t\t\telse if (*data == '(') {\n\t\t\t\tparse_type = UCL_PARSE_CSEXP;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparse_type = UCL_PARSE_UCL;\n\t\t\t}\n\t\t}\n\n\t\tchunk->begin = data;\n\t\tchunk->remain = len;\n\t\tchunk->pos = chunk->begin;\n\t\tchunk->end = chunk->begin + len;\n\t\tchunk->line = 1;\n\t\tchunk->column = 0;\n\t\tchunk->priority = priority;\n\t\tchunk->strategy = strat;\n\t\tchunk->parse_type = parse_type;\n\n\t\tif (parser->cur_file) {\n\t\t\tchunk->fname = strdup (parser->cur_file);\n\t\t}\n\n\t\tLL_PREPEND (parser->chunks, chunk);\n\t\tparser->recursion ++;\n\n\t\tif (parser->recursion > UCL_MAX_RECURSION) {\n\t\t\tucl_create_err (&parser->err, \"maximum include nesting limit is reached: %d\",\n\t\t\t\t\tparser->recursion);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (len > 0) {\n\t\t\t\n\t\t\tswitch (parse_type) {\n\t\t\tdefault:\n\t\t\tcase UCL_PARSE_UCL:\n\t\t\t\treturn ucl_state_machine (parser);\n\t\t\tcase UCL_PARSE_MSGPACK:\n\t\t\t\treturn ucl_parse_msgpack (parser);\n\t\t\tcase UCL_PARSE_CSEXP:\n\t\t\t\treturn ucl_parse_csexp (parser);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\tif (parser->top_obj == NULL) {\n\t\t\t\t\n\t\t\t\tparser->top_obj = ucl_object_new_full (UCL_OBJECT, priority);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tucl_create_err (&parser->err, \"a parser is in an invalid state\");\n\n\treturn false;\n}\n\nbool\nucl_parser_add_chunk_priority (struct ucl_parser *parser,\n\t\tconst unsigned char *data, size_t len, unsigned priority)\n{\n\t\n\tif (parser == NULL) {\n\t\treturn false;\n\t}", "Selected Statement": "\t\tLL_PREPEND (parser->chunks, chunk);\n", "Selected Pointer": "chunk", "Compared Statement": "\t\tchunk->begin = data;\n", "Compared Pointer": "data", "Aliasing": "No", "Function Input": {"data": {"type_category": "string", "concrete_type": "string", "value": "0x9e3779b1 <error: Cannot access memory at address 0x9e3779b1>"}, "len": {"type_category": "unknown", "concrete_type": "size_t", "value": "140737488346320"}, "parser": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdcc0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x7\n", "message": "Cannot access memory at address 0x7"}}, "priority": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}}, "Program Information": {"Project Name": "libucl"}, "idx": 190}
{"Programming Language": "C", "Source Code": "size_t len, unsigned priority, enum ucl_duplicate_strategy strat,\n\t\tenum ucl_parse_type parse_type)\n{\n\tstruct ucl_chunk *chunk;\n\tstruct ucl_parser_special_handler *special_handler;\n\n\tif (parser == NULL) {\n\t\treturn false;\n\t}\n\n\tif (data == NULL && len != 0) {\n\t\tucl_create_err (&parser->err, \"invalid chunk added\");\n\t\treturn false;\n\t}\n\n\tif (parser->state != UCL_STATE_ERROR) {\n\t\tchunk = UCL_ALLOC (sizeof (struct ucl_chunk));\n\t\tif (chunk == NULL) {\n\t\t\tucl_create_err (&parser->err, \"cannot allocate chunk structure\");\n\t\t\treturn false;\n\t\t}\n\n\t\tmemset (chunk, 0, sizeof (*chunk));\n\n\t\t\n\t\tLL_FOREACH (parser->special_handlers, special_handler) {\n\t\t\tif ((special_handler->flags & UCL_SPECIAL_HANDLER_PREPROCESS_ALL) ||\n\t\t\t\t\t(len >= special_handler->magic_len &&\n\t\t\t\t\t memcmp (data, special_handler->magic, special_handler->magic_len) == 0)) {\n\t\t\t\tunsigned char *ndata = NULL;\n\t\t\t\tsize_t nlen = 0;\n\n\t\t\t\tif (!special_handler->handler (parser, data, len, &ndata, &nlen,\n\t\t\t\t\t\tspecial_handler->user_data)) {\n\t\t\t\t\tUCL_FREE(sizeof (struct ucl_chunk), chunk);\n\t\t\t\t\tucl_create_err (&parser->err, \"call for external handler failed\");\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tstruct ucl_parser_special_handler_chain *nchain;\n\t\t\t\tnchain = UCL_ALLOC (sizeof (*nchain));\n\t\t\t\tnchain->begin = ndata;\n\t\t\t\tnchain->len = nlen;\n\t\t\t\tnchain->special_handler = special_handler;\n\n\t\t\t\t\n\t\t\t\tLL_PREPEND (chunk->special_handlers, nchain);\n\n\t\t\t\tdata = ndata;\n\t\t\t\tlen = nlen;\n\t\t\t}\n\t\t}\n\n\t\tif (parse_type == UCL_PARSE_AUTO && len > 0) {\n\t\t\t\n\t\t\tif ((*data & 0x80) == 0x80 && (*data >= 0xdc && *data <= 0xdf)) {\n\t\t\t\tparse_type = UCL_PARSE_MSGPACK;\n\t\t\t}\n\t\t\telse if (*data == '(') {\n\t\t\t\tparse_type = UCL_PARSE_CSEXP;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparse_type = UCL_PARSE_UCL;\n\t\t\t}\n\t\t}\n\n\t\tchunk->begin = data;\n\t\tchunk->remain = len;\n\t\tchunk->pos = chunk->begin;\n\t\tchunk->end = chunk->begin + len;\n\t\tchunk->line = 1;\n\t\tchunk->column = 0;\n\t\tchunk->priority = priority;\n\t\tchunk->strategy = strat;\n\t\tchunk->parse_type = parse_type;\n\n\t\tif (parser->cur_file) {\n\t\t\tchunk->fname = strdup (parser->cur_file);\n\t\t}\n\n\t\tLL_PREPEND (parser->chunks, chunk);\n\t\tparser->recursion ++;\n\n\t\tif (parser->recursion > UCL_MAX_RECURSION) {\n\t\t\tucl_create_err (&parser->err, \"maximum include nesting limit is reached: %d\",\n\t\t\t\t\tparser->recursion);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (len > 0) {\n\t\t\t\n\t\t\tswitch (parse_type) {\n\t\t\tdefault:\n\t\t\tcase UCL_PARSE_UCL:\n\t\t\t\treturn ucl_state_machine (parser);\n\t\t\tcase UCL_PARSE_MSGPACK:\n\t\t\t\treturn ucl_parse_msgpack (parser);\n\t\t\tcase UCL_PARSE_CSEXP:\n\t\t\t\treturn ucl_parse_csexp (parser);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\tif (parser->top_obj == NULL) {\n\t\t\t\t\n\t\t\t\tparser->top_obj = ucl_object_new_full (UCL_OBJECT, priority);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tucl_create_err (&parser->err, \"a parser is in an invalid state\");\n\n\treturn false;\n}\n\nbool\nucl_parser_add_chunk_priority (struct ucl_parser *parser,\n\t\tconst unsigned char *data, size_t len, unsigned priority)\n{\n\t\n\tif (parser == NULL) {\n\t\treturn false;\n\t}", "Selected Statement": "\t\tchunk->begin = data;\n", "Selected Pointer": "data", "Compared Statement": "\t\tLL_PREPEND (parser->chunks, chunk);\n", "Compared Pointer": "chunk", "Aliasing": "No", "Function Input": {"data": {"type_category": "string", "concrete_type": "string", "value": "0x9e3779b1 <error: Cannot access memory at address 0x9e3779b1>"}, "len": {"type_category": "unknown", "concrete_type": "size_t", "value": "140737488346320"}, "parser": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdcc0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x7\n", "message": "Cannot access memory at address 0x7"}}, "priority": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}}, "Program Information": {"Project Name": "libucl"}, "idx": 191}
{"Programming Language": "C", "Source Code": "size_t len, unsigned priority, enum ucl_duplicate_strategy strat,\n\t\tenum ucl_parse_type parse_type)\n{\n\tstruct ucl_chunk *chunk;\n\tstruct ucl_parser_special_handler *special_handler;\n\n\tif (parser == NULL) {\n\t\treturn false;\n\t}\n\n\tif (data == NULL && len != 0) {\n\t\tucl_create_err (&parser->err, \"invalid chunk added\");\n\t\treturn false;\n\t}\n\n\tif (parser->state != UCL_STATE_ERROR) {\n\t\tchunk = UCL_ALLOC (sizeof (struct ucl_chunk));\n\t\tif (chunk == NULL) {\n\t\t\tucl_create_err (&parser->err, \"cannot allocate chunk structure\");\n\t\t\treturn false;\n\t\t}\n\n\t\tmemset (chunk, 0, sizeof (*chunk));\n\n\t\t\n\t\tLL_FOREACH (parser->special_handlers, special_handler) {\n\t\t\tif ((special_handler->flags & UCL_SPECIAL_HANDLER_PREPROCESS_ALL) ||\n\t\t\t\t\t(len >= special_handler->magic_len &&\n\t\t\t\t\t memcmp (data, special_handler->magic, special_handler->magic_len) == 0)) {\n\t\t\t\tunsigned char *ndata = NULL;\n\t\t\t\tsize_t nlen = 0;\n\n\t\t\t\tif (!special_handler->handler (parser, data, len, &ndata, &nlen,\n\t\t\t\t\t\tspecial_handler->user_data)) {\n\t\t\t\t\tUCL_FREE(sizeof (struct ucl_chunk), chunk);\n\t\t\t\t\tucl_create_err (&parser->err, \"call for external handler failed\");\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tstruct ucl_parser_special_handler_chain *nchain;\n\t\t\t\tnchain = UCL_ALLOC (sizeof (*nchain));\n\t\t\t\tnchain->begin = ndata;\n\t\t\t\tnchain->len = nlen;\n\t\t\t\tnchain->special_handler = special_handler;\n\n\t\t\t\t\n\t\t\t\tLL_PREPEND (chunk->special_handlers, nchain);\n\n\t\t\t\tdata = ndata;\n\t\t\t\tlen = nlen;\n\t\t\t}\n\t\t}\n\n\t\tif (parse_type == UCL_PARSE_AUTO && len > 0) {\n\t\t\t\n\t\t\tif ((*data & 0x80) == 0x80 && (*data >= 0xdc && *data <= 0xdf)) {\n\t\t\t\tparse_type = UCL_PARSE_MSGPACK;\n\t\t\t}\n\t\t\telse if (*data == '(') {\n\t\t\t\tparse_type = UCL_PARSE_CSEXP;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparse_type = UCL_PARSE_UCL;\n\t\t\t}\n\t\t}\n\n\t\tchunk->begin = data;\n\t\tchunk->remain = len;\n\t\tchunk->pos = chunk->begin;\n\t\tchunk->end = chunk->begin + len;\n\t\tchunk->line = 1;\n\t\tchunk->column = 0;\n\t\tchunk->priority = priority;\n\t\tchunk->strategy = strat;\n\t\tchunk->parse_type = parse_type;\n\n\t\tif (parser->cur_file) {\n\t\t\tchunk->fname = strdup (parser->cur_file);\n\t\t}\n\n\t\tLL_PREPEND (parser->chunks, chunk);\n\t\tparser->recursion ++;\n\n\t\tif (parser->recursion > UCL_MAX_RECURSION) {\n\t\t\tucl_create_err (&parser->err, \"maximum include nesting limit is reached: %d\",\n\t\t\t\t\tparser->recursion);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (len > 0) {\n\t\t\t\n\t\t\tswitch (parse_type) {\n\t\t\tdefault:\n\t\t\tcase UCL_PARSE_UCL:\n\t\t\t\treturn ucl_state_machine (parser);\n\t\t\tcase UCL_PARSE_MSGPACK:\n\t\t\t\treturn ucl_parse_msgpack (parser);\n\t\t\tcase UCL_PARSE_CSEXP:\n\t\t\t\treturn ucl_parse_csexp (parser);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\tif (parser->top_obj == NULL) {\n\t\t\t\t\n\t\t\t\tparser->top_obj = ucl_object_new_full (UCL_OBJECT, priority);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tucl_create_err (&parser->err, \"a parser is in an invalid state\");\n\n\treturn false;\n}\n\nbool\nucl_parser_add_chunk_priority (struct ucl_parser *parser,\n\t\tconst unsigned char *data, size_t len, unsigned priority)\n{\n\t\n\tif (parser == NULL) {\n\t\treturn false;\n\t}", "Selected Statement": "\t\tLL_PREPEND (parser->chunks, chunk);\n", "Selected Pointer": "chunk", "Compared Statement": "\t\tchunk->begin = data;\n", "Compared Pointer": "data", "Aliasing": "No", "Function Input": {"data": {"type_category": "string", "concrete_type": "string", "value": "0x9e3779b1 <error: Cannot access memory at address 0x9e3779b1>"}, "len": {"type_category": "unknown", "concrete_type": "size_t", "value": "140737488346320"}, "parser": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdcc0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x7\n", "message": "Cannot access memory at address 0x7"}}, "priority": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}}, "Program Information": {"Project Name": "libucl"}, "idx": 192}
{"Programming Language": "C", "Source Code": "void\nucl_parser_free (struct ucl_parser *parser)\n{\n\tstruct ucl_stack *stack, *stmp;\n\tstruct ucl_macro *macro, *mtmp;\n\tstruct ucl_chunk *chunk, *ctmp;\n\tstruct ucl_pubkey *key, *ktmp;\n\tstruct ucl_variable *var, *vtmp;\n\tucl_object_t *tr, *trtmp;\n\n\tif (parser == NULL) {\n\t\treturn;\n\t}\n\n\tif (parser->top_obj != NULL) {\n\t\tucl_object_unref (parser->top_obj);\n\t}\n\n\tif (parser->includepaths != NULL) {\n\t\tucl_object_unref (parser->includepaths);\n\t}\n\n\tLL_FOREACH_SAFE (parser->stack, stack, stmp) {\n\t\tfree (stack);\n\t}\n\tHASH_ITER (hh, parser->macroes, macro, mtmp) {\n\t\tfree (macro->name);\n\t\tHASH_DEL (parser->macroes, macro);\n\t\tUCL_FREE (sizeof (struct ucl_macro), macro);\n\t}\n\tLL_FOREACH_SAFE (parser->chunks, chunk, ctmp) {\n\t\tucl_chunk_free (chunk);\n\t}\n\tLL_FOREACH_SAFE (parser->keys, key, ktmp) {\n\t\tUCL_FREE (sizeof (struct ucl_pubkey), key);\n\t}\n\tLL_FOREACH_SAFE (parser->variables, var, vtmp) {\n\t\tfree (var->value);\n\t\tfree (var->var);\n\t\tUCL_FREE (sizeof (struct ucl_variable), var);\n\t}\n\tLL_FOREACH_SAFE (parser->trash_objs, tr, trtmp) {\n\t\tucl_object_free_internal (tr, false, ucl_object_dtor_free);\n\t}\n\n\tif (parser->err != NULL) {\n\t\tutstring_free (parser->err);\n\t}\n\n\tif (parser->cur_file) {\n\t\tfree (parser->cur_file);\n\t}\n\n\tif (parser->comments) {\n\t\tucl_object_unref (parser->comments);\n\t}\n\n\tUCL_FREE (sizeof (struct ucl_parser), parser);", "Selected Statement": "\tLL_FOREACH_SAFE (parser->stack, stack, stmp) {\n", "Selected Pointer": "stack", "Compared Statement": "\tUCL_FREE (sizeof (struct ucl_parser), parser);\n", "Compared Pointer": "parser", "Aliasing": "No", "Function Input": {"parser": {"type_category": "pointer", "concrete_type": "NULL"}}, "Program Information": {"Project Name": "libucl"}, "idx": 193}
{"Programming Language": "C", "Source Code": "size_t len, unsigned priority, enum ucl_duplicate_strategy strat,\n\t\tenum ucl_parse_type parse_type)\n{\n\tstruct ucl_chunk *chunk;\n\tstruct ucl_parser_special_handler *special_handler;\n\n\tif (parser == NULL) {\n\t\treturn false;\n\t}\n\n\tif (data == NULL && len != 0) {\n\t\tucl_create_err (&parser->err, \"invalid chunk added\");\n\t\treturn false;\n\t}\n\n\tif (parser->state != UCL_STATE_ERROR) {\n\t\tchunk = UCL_ALLOC (sizeof (struct ucl_chunk));\n\t\tif (chunk == NULL) {\n\t\t\tucl_create_err (&parser->err, \"cannot allocate chunk structure\");\n\t\t\treturn false;\n\t\t}\n\n\t\tmemset (chunk, 0, sizeof (*chunk));\n\n\t\t\n\t\tLL_FOREACH (parser->special_handlers, special_handler) {\n\t\t\tif ((special_handler->flags & UCL_SPECIAL_HANDLER_PREPROCESS_ALL) ||\n\t\t\t\t\t(len >= special_handler->magic_len &&\n\t\t\t\t\t memcmp (data, special_handler->magic, special_handler->magic_len) == 0)) {\n\t\t\t\tunsigned char *ndata = NULL;\n\t\t\t\tsize_t nlen = 0;\n\n\t\t\t\tif (!special_handler->handler (parser, data, len, &ndata, &nlen,\n\t\t\t\t\t\tspecial_handler->user_data)) {\n\t\t\t\t\tUCL_FREE(sizeof (struct ucl_chunk), chunk);\n\t\t\t\t\tucl_create_err (&parser->err, \"call for external handler failed\");\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tstruct ucl_parser_special_handler_chain *nchain;\n\t\t\t\tnchain = UCL_ALLOC (sizeof (*nchain));\n\t\t\t\tnchain->begin = ndata;\n\t\t\t\tnchain->len = nlen;\n\t\t\t\tnchain->special_handler = special_handler;\n\n\t\t\t\t\n\t\t\t\tLL_PREPEND (chunk->special_handlers, nchain);\n\n\t\t\t\tdata = ndata;\n\t\t\t\tlen = nlen;\n\t\t\t}\n\t\t}\n\n\t\tif (parse_type == UCL_PARSE_AUTO && len > 0) {\n\t\t\t\n\t\t\tif ((*data & 0x80) == 0x80 && (*data >= 0xdc && *data <= 0xdf)) {\n\t\t\t\tparse_type = UCL_PARSE_MSGPACK;\n\t\t\t}\n\t\t\telse if (*data == '(') {\n\t\t\t\tparse_type = UCL_PARSE_CSEXP;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparse_type = UCL_PARSE_UCL;\n\t\t\t}\n\t\t}\n\n\t\tchunk->begin = data;\n\t\tchunk->remain = len;\n\t\tchunk->pos = chunk->begin;\n\t\tchunk->end = chunk->begin + len;\n\t\tchunk->line = 1;\n\t\tchunk->column = 0;\n\t\tchunk->priority = priority;\n\t\tchunk->strategy = strat;\n\t\tchunk->parse_type = parse_type;\n\n\t\tif (parser->cur_file) {\n\t\t\tchunk->fname = strdup (parser->cur_file);\n\t\t}\n\n\t\tLL_PREPEND (parser->chunks, chunk);\n\t\tparser->recursion ++;\n\n\t\tif (parser->recursion > UCL_MAX_RECURSION) {\n\t\t\tucl_create_err (&parser->err, \"maximum include nesting limit is reached: %d\",\n\t\t\t\t\tparser->recursion);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (len > 0) {\n\t\t\t\n\t\t\tswitch (parse_type) {\n\t\t\tdefault:\n\t\t\tcase UCL_PARSE_UCL:\n\t\t\t\treturn ucl_state_machine (parser);\n\t\t\tcase UCL_PARSE_MSGPACK:\n\t\t\t\treturn ucl_parse_msgpack (parser);\n\t\t\tcase UCL_PARSE_CSEXP:\n\t\t\t\treturn ucl_parse_csexp (parser);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\tif (parser->top_obj == NULL) {\n\t\t\t\t\n\t\t\t\tparser->top_obj = ucl_object_new_full (UCL_OBJECT, priority);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tucl_create_err (&parser->err, \"a parser is in an invalid state\");\n\n\treturn false;\n}\n\nbool\nucl_parser_add_chunk_priority (struct ucl_parser *parser,\n\t\tconst unsigned char *data, size_t len, unsigned priority)\n{\n\t\n\tif (parser == NULL) {\n\t\treturn false;\n\t}", "Selected Statement": "\t\tLL_PREPEND (parser->chunks, chunk);\n", "Selected Pointer": "chunk", "Compared Statement": "\t\tchunk->begin = data;\n", "Compared Pointer": "data", "Aliasing": "No", "Function Input": {"data": {"type_category": "string", "concrete_type": "string", "value": "0x9e3779b1 <error: Cannot access memory at address 0x9e3779b1>"}, "len": {"type_category": "unknown", "concrete_type": "size_t", "value": "140737488346320"}, "parser": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdcc0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x7\n", "message": "Cannot access memory at address 0x7"}}, "priority": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}}, "Program Information": {"Project Name": "libucl"}, "idx": 194}
{"Programming Language": "C", "Source Code": "size_t len, unsigned priority, enum ucl_duplicate_strategy strat,\n\t\tenum ucl_parse_type parse_type)\n{\n\tstruct ucl_chunk *chunk;\n\tstruct ucl_parser_special_handler *special_handler;\n\n\tif (parser == NULL) {\n\t\treturn false;\n\t}\n\n\tif (data == NULL && len != 0) {\n\t\tucl_create_err (&parser->err, \"invalid chunk added\");\n\t\treturn false;\n\t}\n\n\tif (parser->state != UCL_STATE_ERROR) {\n\t\tchunk = UCL_ALLOC (sizeof (struct ucl_chunk));\n\t\tif (chunk == NULL) {\n\t\t\tucl_create_err (&parser->err, \"cannot allocate chunk structure\");\n\t\t\treturn false;\n\t\t}\n\n\t\tmemset (chunk, 0, sizeof (*chunk));\n\n\t\t\n\t\tLL_FOREACH (parser->special_handlers, special_handler) {\n\t\t\tif ((special_handler->flags & UCL_SPECIAL_HANDLER_PREPROCESS_ALL) ||\n\t\t\t\t\t(len >= special_handler->magic_len &&\n\t\t\t\t\t memcmp (data, special_handler->magic, special_handler->magic_len) == 0)) {\n\t\t\t\tunsigned char *ndata = NULL;\n\t\t\t\tsize_t nlen = 0;\n\n\t\t\t\tif (!special_handler->handler (parser, data, len, &ndata, &nlen,\n\t\t\t\t\t\tspecial_handler->user_data)) {\n\t\t\t\t\tUCL_FREE(sizeof (struct ucl_chunk), chunk);\n\t\t\t\t\tucl_create_err (&parser->err, \"call for external handler failed\");\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tstruct ucl_parser_special_handler_chain *nchain;\n\t\t\t\tnchain = UCL_ALLOC (sizeof (*nchain));\n\t\t\t\tnchain->begin = ndata;\n\t\t\t\tnchain->len = nlen;\n\t\t\t\tnchain->special_handler = special_handler;\n\n\t\t\t\t\n\t\t\t\tLL_PREPEND (chunk->special_handlers, nchain);\n\n\t\t\t\tdata = ndata;\n\t\t\t\tlen = nlen;\n\t\t\t}\n\t\t}\n\n\t\tif (parse_type == UCL_PARSE_AUTO && len > 0) {\n\t\t\t\n\t\t\tif ((*data & 0x80) == 0x80 && (*data >= 0xdc && *data <= 0xdf)) {\n\t\t\t\tparse_type = UCL_PARSE_MSGPACK;\n\t\t\t}\n\t\t\telse if (*data == '(') {\n\t\t\t\tparse_type = UCL_PARSE_CSEXP;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparse_type = UCL_PARSE_UCL;\n\t\t\t}\n\t\t}\n\n\t\tchunk->begin = data;\n\t\tchunk->remain = len;\n\t\tchunk->pos = chunk->begin;\n\t\tchunk->end = chunk->begin + len;\n\t\tchunk->line = 1;\n\t\tchunk->column = 0;\n\t\tchunk->priority = priority;\n\t\tchunk->strategy = strat;\n\t\tchunk->parse_type = parse_type;\n\n\t\tif (parser->cur_file) {\n\t\t\tchunk->fname = strdup (parser->cur_file);\n\t\t}\n\n\t\tLL_PREPEND (parser->chunks, chunk);\n\t\tparser->recursion ++;\n\n\t\tif (parser->recursion > UCL_MAX_RECURSION) {\n\t\t\tucl_create_err (&parser->err, \"maximum include nesting limit is reached: %d\",\n\t\t\t\t\tparser->recursion);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (len > 0) {\n\t\t\t\n\t\t\tswitch (parse_type) {\n\t\t\tdefault:\n\t\t\tcase UCL_PARSE_UCL:\n\t\t\t\treturn ucl_state_machine (parser);\n\t\t\tcase UCL_PARSE_MSGPACK:\n\t\t\t\treturn ucl_parse_msgpack (parser);\n\t\t\tcase UCL_PARSE_CSEXP:\n\t\t\t\treturn ucl_parse_csexp (parser);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\tif (parser->top_obj == NULL) {\n\t\t\t\t\n\t\t\t\tparser->top_obj = ucl_object_new_full (UCL_OBJECT, priority);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tucl_create_err (&parser->err, \"a parser is in an invalid state\");\n\n\treturn false;\n}\n\nbool\nucl_parser_add_chunk_priority (struct ucl_parser *parser,\n\t\tconst unsigned char *data, size_t len, unsigned priority)\n{\n\t\n\tif (parser == NULL) {\n\t\treturn false;\n\t}", "Selected Statement": "\t\tLL_PREPEND (parser->chunks, chunk);\n", "Selected Pointer": "chunk", "Compared Statement": "\t\tchunk->begin = data;\n", "Compared Pointer": "data", "Aliasing": "No", "Function Input": {"data": {"type_category": "string", "concrete_type": "string", "value": "0x9e3779b1 <error: Cannot access memory at address 0x9e3779b1>"}, "len": {"type_category": "unknown", "concrete_type": "size_t", "value": "140737488346320"}, "parser": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdcc0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x7\n", "message": "Cannot access memory at address 0x7"}}, "priority": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}}, "Program Information": {"Project Name": "libucl"}, "idx": 195}
{"Programming Language": "C", "Source Code": "void\nucl_parser_free (struct ucl_parser *parser)\n{\n\tstruct ucl_stack *stack, *stmp;\n\tstruct ucl_macro *macro, *mtmp;\n\tstruct ucl_chunk *chunk, *ctmp;\n\tstruct ucl_pubkey *key, *ktmp;\n\tstruct ucl_variable *var, *vtmp;\n\tucl_object_t *tr, *trtmp;\n\n\tif (parser == NULL) {\n\t\treturn;\n\t}\n\n\tif (parser->top_obj != NULL) {\n\t\tucl_object_unref (parser->top_obj);\n\t}\n\n\tif (parser->includepaths != NULL) {\n\t\tucl_object_unref (parser->includepaths);\n\t}\n\n\tLL_FOREACH_SAFE (parser->stack, stack, stmp) {\n\t\tfree (stack);\n\t}\n\tHASH_ITER (hh, parser->macroes, macro, mtmp) {\n\t\tfree (macro->name);\n\t\tHASH_DEL (parser->macroes, macro);\n\t\tUCL_FREE (sizeof (struct ucl_macro), macro);\n\t}\n\tLL_FOREACH_SAFE (parser->chunks, chunk, ctmp) {\n\t\tucl_chunk_free (chunk);\n\t}\n\tLL_FOREACH_SAFE (parser->keys, key, ktmp) {\n\t\tUCL_FREE (sizeof (struct ucl_pubkey), key);\n\t}\n\tLL_FOREACH_SAFE (parser->variables, var, vtmp) {\n\t\tfree (var->value);\n\t\tfree (var->var);\n\t\tUCL_FREE (sizeof (struct ucl_variable), var);\n\t}\n\tLL_FOREACH_SAFE (parser->trash_objs, tr, trtmp) {\n\t\tucl_object_free_internal (tr, false, ucl_object_dtor_free);\n\t}\n\n\tif (parser->err != NULL) {\n\t\tutstring_free (parser->err);\n\t}\n\n\tif (parser->cur_file) {\n\t\tfree (parser->cur_file);\n\t}\n\n\tif (parser->comments) {\n\t\tucl_object_unref (parser->comments);\n\t}\n\n\tUCL_FREE (sizeof (struct ucl_parser), parser);", "Selected Statement": "\tLL_FOREACH_SAFE (parser->stack, stack, stmp) {\n", "Selected Pointer": "stack", "Compared Statement": "\tLL_FOREACH_SAFE (parser->chunks, chunk, ctmp) {\n", "Compared Pointer": "chunk", "Aliasing": "No", "Function Input": {"parser": {"type_category": "pointer", "concrete_type": "NULL"}}, "Program Information": {"Project Name": "libucl"}, "idx": 196}
{"Programming Language": "C", "Source Code": "size_t len, unsigned priority, enum ucl_duplicate_strategy strat,\n\t\tenum ucl_parse_type parse_type)\n{\n\tstruct ucl_chunk *chunk;\n\tstruct ucl_parser_special_handler *special_handler;\n\n\tif (parser == NULL) {\n\t\treturn false;\n\t}\n\n\tif (data == NULL && len != 0) {\n\t\tucl_create_err (&parser->err, \"invalid chunk added\");\n\t\treturn false;\n\t}\n\n\tif (parser->state != UCL_STATE_ERROR) {\n\t\tchunk = UCL_ALLOC (sizeof (struct ucl_chunk));\n\t\tif (chunk == NULL) {\n\t\t\tucl_create_err (&parser->err, \"cannot allocate chunk structure\");\n\t\t\treturn false;\n\t\t}\n\n\t\tmemset (chunk, 0, sizeof (*chunk));\n\n\t\t\n\t\tLL_FOREACH (parser->special_handlers, special_handler) {\n\t\t\tif ((special_handler->flags & UCL_SPECIAL_HANDLER_PREPROCESS_ALL) ||\n\t\t\t\t\t(len >= special_handler->magic_len &&\n\t\t\t\t\t memcmp (data, special_handler->magic, special_handler->magic_len) == 0)) {\n\t\t\t\tunsigned char *ndata = NULL;\n\t\t\t\tsize_t nlen = 0;\n\n\t\t\t\tif (!special_handler->handler (parser, data, len, &ndata, &nlen,\n\t\t\t\t\t\tspecial_handler->user_data)) {\n\t\t\t\t\tUCL_FREE(sizeof (struct ucl_chunk), chunk);\n\t\t\t\t\tucl_create_err (&parser->err, \"call for external handler failed\");\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tstruct ucl_parser_special_handler_chain *nchain;\n\t\t\t\tnchain = UCL_ALLOC (sizeof (*nchain));\n\t\t\t\tnchain->begin = ndata;\n\t\t\t\tnchain->len = nlen;\n\t\t\t\tnchain->special_handler = special_handler;\n\n\t\t\t\t\n\t\t\t\tLL_PREPEND (chunk->special_handlers, nchain);\n\n\t\t\t\tdata = ndata;\n\t\t\t\tlen = nlen;\n\t\t\t}\n\t\t}\n\n\t\tif (parse_type == UCL_PARSE_AUTO && len > 0) {\n\t\t\t\n\t\t\tif ((*data & 0x80) == 0x80 && (*data >= 0xdc && *data <= 0xdf)) {\n\t\t\t\tparse_type = UCL_PARSE_MSGPACK;\n\t\t\t}\n\t\t\telse if (*data == '(') {\n\t\t\t\tparse_type = UCL_PARSE_CSEXP;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparse_type = UCL_PARSE_UCL;\n\t\t\t}\n\t\t}\n\n\t\tchunk->begin = data;\n\t\tchunk->remain = len;\n\t\tchunk->pos = chunk->begin;\n\t\tchunk->end = chunk->begin + len;\n\t\tchunk->line = 1;\n\t\tchunk->column = 0;\n\t\tchunk->priority = priority;\n\t\tchunk->strategy = strat;\n\t\tchunk->parse_type = parse_type;\n\n\t\tif (parser->cur_file) {\n\t\t\tchunk->fname = strdup (parser->cur_file);\n\t\t}\n\n\t\tLL_PREPEND (parser->chunks, chunk);\n\t\tparser->recursion ++;\n\n\t\tif (parser->recursion > UCL_MAX_RECURSION) {\n\t\t\tucl_create_err (&parser->err, \"maximum include nesting limit is reached: %d\",\n\t\t\t\t\tparser->recursion);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (len > 0) {\n\t\t\t\n\t\t\tswitch (parse_type) {\n\t\t\tdefault:\n\t\t\tcase UCL_PARSE_UCL:\n\t\t\t\treturn ucl_state_machine (parser);\n\t\t\tcase UCL_PARSE_MSGPACK:\n\t\t\t\treturn ucl_parse_msgpack (parser);\n\t\t\tcase UCL_PARSE_CSEXP:\n\t\t\t\treturn ucl_parse_csexp (parser);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\tif (parser->top_obj == NULL) {\n\t\t\t\t\n\t\t\t\tparser->top_obj = ucl_object_new_full (UCL_OBJECT, priority);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tucl_create_err (&parser->err, \"a parser is in an invalid state\");\n\n\treturn false;\n}\n\nbool\nucl_parser_add_chunk_priority (struct ucl_parser *parser,\n\t\tconst unsigned char *data, size_t len, unsigned priority)\n{\n\t\n\tif (parser == NULL) {\n\t\treturn false;\n\t}", "Selected Statement": "\t\tLL_PREPEND (parser->chunks, chunk);\n", "Selected Pointer": "chunk", "Compared Statement": "\t\tchunk->begin = data;\n", "Compared Pointer": "data", "Aliasing": "No", "Function Input": {"data": {"type_category": "string", "concrete_type": "string", "value": "0x9e3779b1 <error: Cannot access memory at address 0x9e3779b1>"}, "len": {"type_category": "unknown", "concrete_type": "size_t", "value": "140737488346320"}, "parser": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdcc0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x7\n", "message": "Cannot access memory at address 0x7"}}, "priority": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}}, "Program Information": {"Project Name": "libucl"}, "idx": 197}
{"Programming Language": "C", "Source Code": "size_t len, unsigned priority, enum ucl_duplicate_strategy strat,\n\t\tenum ucl_parse_type parse_type)\n{\n\tstruct ucl_chunk *chunk;\n\tstruct ucl_parser_special_handler *special_handler;\n\n\tif (parser == NULL) {\n\t\treturn false;\n\t}\n\n\tif (data == NULL && len != 0) {\n\t\tucl_create_err (&parser->err, \"invalid chunk added\");\n\t\treturn false;\n\t}\n\n\tif (parser->state != UCL_STATE_ERROR) {\n\t\tchunk = UCL_ALLOC (sizeof (struct ucl_chunk));\n\t\tif (chunk == NULL) {\n\t\t\tucl_create_err (&parser->err, \"cannot allocate chunk structure\");\n\t\t\treturn false;\n\t\t}\n\n\t\tmemset (chunk, 0, sizeof (*chunk));\n\n\t\t\n\t\tLL_FOREACH (parser->special_handlers, special_handler) {\n\t\t\tif ((special_handler->flags & UCL_SPECIAL_HANDLER_PREPROCESS_ALL) ||\n\t\t\t\t\t(len >= special_handler->magic_len &&\n\t\t\t\t\t memcmp (data, special_handler->magic, special_handler->magic_len) == 0)) {\n\t\t\t\tunsigned char *ndata = NULL;\n\t\t\t\tsize_t nlen = 0;\n\n\t\t\t\tif (!special_handler->handler (parser, data, len, &ndata, &nlen,\n\t\t\t\t\t\tspecial_handler->user_data)) {\n\t\t\t\t\tUCL_FREE(sizeof (struct ucl_chunk), chunk);\n\t\t\t\t\tucl_create_err (&parser->err, \"call for external handler failed\");\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tstruct ucl_parser_special_handler_chain *nchain;\n\t\t\t\tnchain = UCL_ALLOC (sizeof (*nchain));\n\t\t\t\tnchain->begin = ndata;\n\t\t\t\tnchain->len = nlen;\n\t\t\t\tnchain->special_handler = special_handler;\n\n\t\t\t\t\n\t\t\t\tLL_PREPEND (chunk->special_handlers, nchain);\n\n\t\t\t\tdata = ndata;\n\t\t\t\tlen = nlen;\n\t\t\t}\n\t\t}\n\n\t\tif (parse_type == UCL_PARSE_AUTO && len > 0) {\n\t\t\t\n\t\t\tif ((*data & 0x80) == 0x80 && (*data >= 0xdc && *data <= 0xdf)) {\n\t\t\t\tparse_type = UCL_PARSE_MSGPACK;\n\t\t\t}\n\t\t\telse if (*data == '(') {\n\t\t\t\tparse_type = UCL_PARSE_CSEXP;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparse_type = UCL_PARSE_UCL;\n\t\t\t}\n\t\t}\n\n\t\tchunk->begin = data;\n\t\tchunk->remain = len;\n\t\tchunk->pos = chunk->begin;\n\t\tchunk->end = chunk->begin + len;\n\t\tchunk->line = 1;\n\t\tchunk->column = 0;\n\t\tchunk->priority = priority;\n\t\tchunk->strategy = strat;\n\t\tchunk->parse_type = parse_type;\n\n\t\tif (parser->cur_file) {\n\t\t\tchunk->fname = strdup (parser->cur_file);\n\t\t}\n\n\t\tLL_PREPEND (parser->chunks, chunk);\n\t\tparser->recursion ++;\n\n\t\tif (parser->recursion > UCL_MAX_RECURSION) {\n\t\t\tucl_create_err (&parser->err, \"maximum include nesting limit is reached: %d\",\n\t\t\t\t\tparser->recursion);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (len > 0) {\n\t\t\t\n\t\t\tswitch (parse_type) {\n\t\t\tdefault:\n\t\t\tcase UCL_PARSE_UCL:\n\t\t\t\treturn ucl_state_machine (parser);\n\t\t\tcase UCL_PARSE_MSGPACK:\n\t\t\t\treturn ucl_parse_msgpack (parser);\n\t\t\tcase UCL_PARSE_CSEXP:\n\t\t\t\treturn ucl_parse_csexp (parser);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\tif (parser->top_obj == NULL) {\n\t\t\t\t\n\t\t\t\tparser->top_obj = ucl_object_new_full (UCL_OBJECT, priority);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tucl_create_err (&parser->err, \"a parser is in an invalid state\");\n\n\treturn false;\n}\n\nbool\nucl_parser_add_chunk_priority (struct ucl_parser *parser,\n\t\tconst unsigned char *data, size_t len, unsigned priority)\n{\n\t\n\tif (parser == NULL) {\n\t\treturn false;\n\t}", "Selected Statement": "\t\tLL_PREPEND (parser->chunks, chunk);\n", "Selected Pointer": "chunk", "Compared Statement": "\t\tchunk->begin = data;\n", "Compared Pointer": "data", "Aliasing": "No", "Function Input": {"data": {"type_category": "string", "concrete_type": "string", "value": "0x9e3779b1 <error: Cannot access memory at address 0x9e3779b1>"}, "len": {"type_category": "unknown", "concrete_type": "size_t", "value": "140737488346320"}, "parser": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdcc0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x7\n", "message": "Cannot access memory at address 0x7"}}, "priority": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}}, "Program Information": {"Project Name": "libucl"}, "idx": 198}
{"Programming Language": "C", "Source Code": "size_t len, unsigned priority, enum ucl_duplicate_strategy strat,\n\t\tenum ucl_parse_type parse_type)\n{\n\tstruct ucl_chunk *chunk;\n\tstruct ucl_parser_special_handler *special_handler;\n\n\tif (parser == NULL) {\n\t\treturn false;\n\t}\n\n\tif (data == NULL && len != 0) {\n\t\tucl_create_err (&parser->err, \"invalid chunk added\");\n\t\treturn false;\n\t}\n\n\tif (parser->state != UCL_STATE_ERROR) {\n\t\tchunk = UCL_ALLOC (sizeof (struct ucl_chunk));\n\t\tif (chunk == NULL) {\n\t\t\tucl_create_err (&parser->err, \"cannot allocate chunk structure\");\n\t\t\treturn false;\n\t\t}\n\n\t\tmemset (chunk, 0, sizeof (*chunk));\n\n\t\t\n\t\tLL_FOREACH (parser->special_handlers, special_handler) {\n\t\t\tif ((special_handler->flags & UCL_SPECIAL_HANDLER_PREPROCESS_ALL) ||\n\t\t\t\t\t(len >= special_handler->magic_len &&\n\t\t\t\t\t memcmp (data, special_handler->magic, special_handler->magic_len) == 0)) {\n\t\t\t\tunsigned char *ndata = NULL;\n\t\t\t\tsize_t nlen = 0;\n\n\t\t\t\tif (!special_handler->handler (parser, data, len, &ndata, &nlen,\n\t\t\t\t\t\tspecial_handler->user_data)) {\n\t\t\t\t\tUCL_FREE(sizeof (struct ucl_chunk), chunk);\n\t\t\t\t\tucl_create_err (&parser->err, \"call for external handler failed\");\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tstruct ucl_parser_special_handler_chain *nchain;\n\t\t\t\tnchain = UCL_ALLOC (sizeof (*nchain));\n\t\t\t\tnchain->begin = ndata;\n\t\t\t\tnchain->len = nlen;\n\t\t\t\tnchain->special_handler = special_handler;\n\n\t\t\t\t\n\t\t\t\tLL_PREPEND (chunk->special_handlers, nchain);\n\n\t\t\t\tdata = ndata;\n\t\t\t\tlen = nlen;\n\t\t\t}\n\t\t}\n\n\t\tif (parse_type == UCL_PARSE_AUTO && len > 0) {\n\t\t\t\n\t\t\tif ((*data & 0x80) == 0x80 && (*data >= 0xdc && *data <= 0xdf)) {\n\t\t\t\tparse_type = UCL_PARSE_MSGPACK;\n\t\t\t}\n\t\t\telse if (*data == '(') {\n\t\t\t\tparse_type = UCL_PARSE_CSEXP;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparse_type = UCL_PARSE_UCL;\n\t\t\t}\n\t\t}\n\n\t\tchunk->begin = data;\n\t\tchunk->remain = len;\n\t\tchunk->pos = chunk->begin;\n\t\tchunk->end = chunk->begin + len;\n\t\tchunk->line = 1;\n\t\tchunk->column = 0;\n\t\tchunk->priority = priority;\n\t\tchunk->strategy = strat;\n\t\tchunk->parse_type = parse_type;\n\n\t\tif (parser->cur_file) {\n\t\t\tchunk->fname = strdup (parser->cur_file);\n\t\t}\n\n\t\tLL_PREPEND (parser->chunks, chunk);\n\t\tparser->recursion ++;\n\n\t\tif (parser->recursion > UCL_MAX_RECURSION) {\n\t\t\tucl_create_err (&parser->err, \"maximum include nesting limit is reached: %d\",\n\t\t\t\t\tparser->recursion);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (len > 0) {\n\t\t\t\n\t\t\tswitch (parse_type) {\n\t\t\tdefault:\n\t\t\tcase UCL_PARSE_UCL:\n\t\t\t\treturn ucl_state_machine (parser);\n\t\t\tcase UCL_PARSE_MSGPACK:\n\t\t\t\treturn ucl_parse_msgpack (parser);\n\t\t\tcase UCL_PARSE_CSEXP:\n\t\t\t\treturn ucl_parse_csexp (parser);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\tif (parser->top_obj == NULL) {\n\t\t\t\t\n\t\t\t\tparser->top_obj = ucl_object_new_full (UCL_OBJECT, priority);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tucl_create_err (&parser->err, \"a parser is in an invalid state\");\n\n\treturn false;\n}\n\nbool\nucl_parser_add_chunk_priority (struct ucl_parser *parser,\n\t\tconst unsigned char *data, size_t len, unsigned priority)\n{\n\t\n\tif (parser == NULL) {\n\t\treturn false;\n\t}", "Selected Statement": "\t\tchunk->begin = data;\n", "Selected Pointer": "data", "Compared Statement": "\t\tLL_PREPEND (parser->chunks, chunk);\n", "Compared Pointer": "chunk", "Aliasing": "No", "Function Input": {"data": {"type_category": "string", "concrete_type": "string", "value": "0x9e3779b1 <error: Cannot access memory at address 0x9e3779b1>"}, "len": {"type_category": "unknown", "concrete_type": "size_t", "value": "140737488346320"}, "parser": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdcc0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x7\n", "message": "Cannot access memory at address 0x7"}}, "priority": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}}, "Program Information": {"Project Name": "libucl"}, "idx": 199}
{"Programming Language": "C", "Source Code": "size_t len, unsigned priority, enum ucl_duplicate_strategy strat,\n\t\tenum ucl_parse_type parse_type)\n{\n\tstruct ucl_chunk *chunk;\n\tstruct ucl_parser_special_handler *special_handler;\n\n\tif (parser == NULL) {\n\t\treturn false;\n\t}\n\n\tif (data == NULL && len != 0) {\n\t\tucl_create_err (&parser->err, \"invalid chunk added\");\n\t\treturn false;\n\t}\n\n\tif (parser->state != UCL_STATE_ERROR) {\n\t\tchunk = UCL_ALLOC (sizeof (struct ucl_chunk));\n\t\tif (chunk == NULL) {\n\t\t\tucl_create_err (&parser->err, \"cannot allocate chunk structure\");\n\t\t\treturn false;\n\t\t}\n\n\t\tmemset (chunk, 0, sizeof (*chunk));\n\n\t\t\n\t\tLL_FOREACH (parser->special_handlers, special_handler) {\n\t\t\tif ((special_handler->flags & UCL_SPECIAL_HANDLER_PREPROCESS_ALL) ||\n\t\t\t\t\t(len >= special_handler->magic_len &&\n\t\t\t\t\t memcmp (data, special_handler->magic, special_handler->magic_len) == 0)) {\n\t\t\t\tunsigned char *ndata = NULL;\n\t\t\t\tsize_t nlen = 0;\n\n\t\t\t\tif (!special_handler->handler (parser, data, len, &ndata, &nlen,\n\t\t\t\t\t\tspecial_handler->user_data)) {\n\t\t\t\t\tUCL_FREE(sizeof (struct ucl_chunk), chunk);\n\t\t\t\t\tucl_create_err (&parser->err, \"call for external handler failed\");\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tstruct ucl_parser_special_handler_chain *nchain;\n\t\t\t\tnchain = UCL_ALLOC (sizeof (*nchain));\n\t\t\t\tnchain->begin = ndata;\n\t\t\t\tnchain->len = nlen;\n\t\t\t\tnchain->special_handler = special_handler;\n\n\t\t\t\t\n\t\t\t\tLL_PREPEND (chunk->special_handlers, nchain);\n\n\t\t\t\tdata = ndata;\n\t\t\t\tlen = nlen;\n\t\t\t}\n\t\t}\n\n\t\tif (parse_type == UCL_PARSE_AUTO && len > 0) {\n\t\t\t\n\t\t\tif ((*data & 0x80) == 0x80 && (*data >= 0xdc && *data <= 0xdf)) {\n\t\t\t\tparse_type = UCL_PARSE_MSGPACK;\n\t\t\t}\n\t\t\telse if (*data == '(') {\n\t\t\t\tparse_type = UCL_PARSE_CSEXP;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparse_type = UCL_PARSE_UCL;\n\t\t\t}\n\t\t}\n\n\t\tchunk->begin = data;\n\t\tchunk->remain = len;\n\t\tchunk->pos = chunk->begin;\n\t\tchunk->end = chunk->begin + len;\n\t\tchunk->line = 1;\n\t\tchunk->column = 0;\n\t\tchunk->priority = priority;\n\t\tchunk->strategy = strat;\n\t\tchunk->parse_type = parse_type;\n\n\t\tif (parser->cur_file) {\n\t\t\tchunk->fname = strdup (parser->cur_file);\n\t\t}\n\n\t\tLL_PREPEND (parser->chunks, chunk);\n\t\tparser->recursion ++;\n\n\t\tif (parser->recursion > UCL_MAX_RECURSION) {\n\t\t\tucl_create_err (&parser->err, \"maximum include nesting limit is reached: %d\",\n\t\t\t\t\tparser->recursion);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (len > 0) {\n\t\t\t\n\t\t\tswitch (parse_type) {\n\t\t\tdefault:\n\t\t\tcase UCL_PARSE_UCL:\n\t\t\t\treturn ucl_state_machine (parser);\n\t\t\tcase UCL_PARSE_MSGPACK:\n\t\t\t\treturn ucl_parse_msgpack (parser);\n\t\t\tcase UCL_PARSE_CSEXP:\n\t\t\t\treturn ucl_parse_csexp (parser);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\tif (parser->top_obj == NULL) {\n\t\t\t\t\n\t\t\t\tparser->top_obj = ucl_object_new_full (UCL_OBJECT, priority);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tucl_create_err (&parser->err, \"a parser is in an invalid state\");\n\n\treturn false;\n}\n\nbool\nucl_parser_add_chunk_priority (struct ucl_parser *parser,\n\t\tconst unsigned char *data, size_t len, unsigned priority)\n{\n\t\n\tif (parser == NULL) {\n\t\treturn false;\n\t}", "Selected Statement": "\t\tLL_PREPEND (parser->chunks, chunk);\n", "Selected Pointer": "chunk", "Compared Statement": "\t\tchunk->begin = data;\n", "Compared Pointer": "data", "Aliasing": "No", "Function Input": {"data": {"type_category": "string", "concrete_type": "string", "value": "0x9e3779b1 <error: Cannot access memory at address 0x9e3779b1>"}, "len": {"type_category": "unknown", "concrete_type": "size_t", "value": "140737488346320"}, "parser": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdcc0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x7\n", "message": "Cannot access memory at address 0x7"}}, "priority": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}}, "Program Information": {"Project Name": "libucl"}, "idx": 200}
{"Programming Language": "C", "Source Code": "size_t len, unsigned priority, enum ucl_duplicate_strategy strat,\n\t\tenum ucl_parse_type parse_type)\n{\n\tstruct ucl_chunk *chunk;\n\tstruct ucl_parser_special_handler *special_handler;\n\n\tif (parser == NULL) {\n\t\treturn false;\n\t}\n\n\tif (data == NULL && len != 0) {\n\t\tucl_create_err (&parser->err, \"invalid chunk added\");\n\t\treturn false;\n\t}\n\n\tif (parser->state != UCL_STATE_ERROR) {\n\t\tchunk = UCL_ALLOC (sizeof (struct ucl_chunk));\n\t\tif (chunk == NULL) {\n\t\t\tucl_create_err (&parser->err, \"cannot allocate chunk structure\");\n\t\t\treturn false;\n\t\t}\n\n\t\tmemset (chunk, 0, sizeof (*chunk));\n\n\t\t\n\t\tLL_FOREACH (parser->special_handlers, special_handler) {\n\t\t\tif ((special_handler->flags & UCL_SPECIAL_HANDLER_PREPROCESS_ALL) ||\n\t\t\t\t\t(len >= special_handler->magic_len &&\n\t\t\t\t\t memcmp (data, special_handler->magic, special_handler->magic_len) == 0)) {\n\t\t\t\tunsigned char *ndata = NULL;\n\t\t\t\tsize_t nlen = 0;\n\n\t\t\t\tif (!special_handler->handler (parser, data, len, &ndata, &nlen,\n\t\t\t\t\t\tspecial_handler->user_data)) {\n\t\t\t\t\tUCL_FREE(sizeof (struct ucl_chunk), chunk);\n\t\t\t\t\tucl_create_err (&parser->err, \"call for external handler failed\");\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tstruct ucl_parser_special_handler_chain *nchain;\n\t\t\t\tnchain = UCL_ALLOC (sizeof (*nchain));\n\t\t\t\tnchain->begin = ndata;\n\t\t\t\tnchain->len = nlen;\n\t\t\t\tnchain->special_handler = special_handler;\n\n\t\t\t\t\n\t\t\t\tLL_PREPEND (chunk->special_handlers, nchain);\n\n\t\t\t\tdata = ndata;\n\t\t\t\tlen = nlen;\n\t\t\t}\n\t\t}\n\n\t\tif (parse_type == UCL_PARSE_AUTO && len > 0) {\n\t\t\t\n\t\t\tif ((*data & 0x80) == 0x80 && (*data >= 0xdc && *data <= 0xdf)) {\n\t\t\t\tparse_type = UCL_PARSE_MSGPACK;\n\t\t\t}\n\t\t\telse if (*data == '(') {\n\t\t\t\tparse_type = UCL_PARSE_CSEXP;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparse_type = UCL_PARSE_UCL;\n\t\t\t}\n\t\t}\n\n\t\tchunk->begin = data;\n\t\tchunk->remain = len;\n\t\tchunk->pos = chunk->begin;\n\t\tchunk->end = chunk->begin + len;\n\t\tchunk->line = 1;\n\t\tchunk->column = 0;\n\t\tchunk->priority = priority;\n\t\tchunk->strategy = strat;\n\t\tchunk->parse_type = parse_type;\n\n\t\tif (parser->cur_file) {\n\t\t\tchunk->fname = strdup (parser->cur_file);\n\t\t}\n\n\t\tLL_PREPEND (parser->chunks, chunk);\n\t\tparser->recursion ++;\n\n\t\tif (parser->recursion > UCL_MAX_RECURSION) {\n\t\t\tucl_create_err (&parser->err, \"maximum include nesting limit is reached: %d\",\n\t\t\t\t\tparser->recursion);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (len > 0) {\n\t\t\t\n\t\t\tswitch (parse_type) {\n\t\t\tdefault:\n\t\t\tcase UCL_PARSE_UCL:\n\t\t\t\treturn ucl_state_machine (parser);\n\t\t\tcase UCL_PARSE_MSGPACK:\n\t\t\t\treturn ucl_parse_msgpack (parser);\n\t\t\tcase UCL_PARSE_CSEXP:\n\t\t\t\treturn ucl_parse_csexp (parser);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\tif (parser->top_obj == NULL) {\n\t\t\t\t\n\t\t\t\tparser->top_obj = ucl_object_new_full (UCL_OBJECT, priority);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tucl_create_err (&parser->err, \"a parser is in an invalid state\");\n\n\treturn false;\n}\n\nbool\nucl_parser_add_chunk_priority (struct ucl_parser *parser,\n\t\tconst unsigned char *data, size_t len, unsigned priority)\n{\n\t\n\tif (parser == NULL) {\n\t\treturn false;\n\t}", "Selected Statement": "\t\tLL_PREPEND (parser->chunks, chunk);\n", "Selected Pointer": "chunk", "Compared Statement": "\t\tchunk->begin = data;\n", "Compared Pointer": "data", "Aliasing": "No", "Function Input": {"data": {"type_category": "string", "concrete_type": "string", "value": "0x9e3779b1 <error: Cannot access memory at address 0x9e3779b1>"}, "len": {"type_category": "unknown", "concrete_type": "size_t", "value": "140737488346320"}, "parser": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdcc0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x7\n", "message": "Cannot access memory at address 0x7"}}, "priority": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}}, "Program Information": {"Project Name": "libucl"}, "idx": 201}
{"Programming Language": "C", "Source Code": "size_t len, unsigned priority, enum ucl_duplicate_strategy strat,\n\t\tenum ucl_parse_type parse_type)\n{\n\tstruct ucl_chunk *chunk;\n\tstruct ucl_parser_special_handler *special_handler;\n\n\tif (parser == NULL) {\n\t\treturn false;\n\t}\n\n\tif (data == NULL && len != 0) {\n\t\tucl_create_err (&parser->err, \"invalid chunk added\");\n\t\treturn false;\n\t}\n\n\tif (parser->state != UCL_STATE_ERROR) {\n\t\tchunk = UCL_ALLOC (sizeof (struct ucl_chunk));\n\t\tif (chunk == NULL) {\n\t\t\tucl_create_err (&parser->err, \"cannot allocate chunk structure\");\n\t\t\treturn false;\n\t\t}\n\n\t\tmemset (chunk, 0, sizeof (*chunk));\n\n\t\t\n\t\tLL_FOREACH (parser->special_handlers, special_handler) {\n\t\t\tif ((special_handler->flags & UCL_SPECIAL_HANDLER_PREPROCESS_ALL) ||\n\t\t\t\t\t(len >= special_handler->magic_len &&\n\t\t\t\t\t memcmp (data, special_handler->magic, special_handler->magic_len) == 0)) {\n\t\t\t\tunsigned char *ndata = NULL;\n\t\t\t\tsize_t nlen = 0;\n\n\t\t\t\tif (!special_handler->handler (parser, data, len, &ndata, &nlen,\n\t\t\t\t\t\tspecial_handler->user_data)) {\n\t\t\t\t\tUCL_FREE(sizeof (struct ucl_chunk), chunk);\n\t\t\t\t\tucl_create_err (&parser->err, \"call for external handler failed\");\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tstruct ucl_parser_special_handler_chain *nchain;\n\t\t\t\tnchain = UCL_ALLOC (sizeof (*nchain));\n\t\t\t\tnchain->begin = ndata;\n\t\t\t\tnchain->len = nlen;\n\t\t\t\tnchain->special_handler = special_handler;\n\n\t\t\t\t\n\t\t\t\tLL_PREPEND (chunk->special_handlers, nchain);\n\n\t\t\t\tdata = ndata;\n\t\t\t\tlen = nlen;\n\t\t\t}\n\t\t}\n\n\t\tif (parse_type == UCL_PARSE_AUTO && len > 0) {\n\t\t\t\n\t\t\tif ((*data & 0x80) == 0x80 && (*data >= 0xdc && *data <= 0xdf)) {\n\t\t\t\tparse_type = UCL_PARSE_MSGPACK;\n\t\t\t}\n\t\t\telse if (*data == '(') {\n\t\t\t\tparse_type = UCL_PARSE_CSEXP;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparse_type = UCL_PARSE_UCL;\n\t\t\t}\n\t\t}\n\n\t\tchunk->begin = data;\n\t\tchunk->remain = len;\n\t\tchunk->pos = chunk->begin;\n\t\tchunk->end = chunk->begin + len;\n\t\tchunk->line = 1;\n\t\tchunk->column = 0;\n\t\tchunk->priority = priority;\n\t\tchunk->strategy = strat;\n\t\tchunk->parse_type = parse_type;\n\n\t\tif (parser->cur_file) {\n\t\t\tchunk->fname = strdup (parser->cur_file);\n\t\t}\n\n\t\tLL_PREPEND (parser->chunks, chunk);\n\t\tparser->recursion ++;\n\n\t\tif (parser->recursion > UCL_MAX_RECURSION) {\n\t\t\tucl_create_err (&parser->err, \"maximum include nesting limit is reached: %d\",\n\t\t\t\t\tparser->recursion);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (len > 0) {\n\t\t\t\n\t\t\tswitch (parse_type) {\n\t\t\tdefault:\n\t\t\tcase UCL_PARSE_UCL:\n\t\t\t\treturn ucl_state_machine (parser);\n\t\t\tcase UCL_PARSE_MSGPACK:\n\t\t\t\treturn ucl_parse_msgpack (parser);\n\t\t\tcase UCL_PARSE_CSEXP:\n\t\t\t\treturn ucl_parse_csexp (parser);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\tif (parser->top_obj == NULL) {\n\t\t\t\t\n\t\t\t\tparser->top_obj = ucl_object_new_full (UCL_OBJECT, priority);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tucl_create_err (&parser->err, \"a parser is in an invalid state\");\n\n\treturn false;\n}\n\nbool\nucl_parser_add_chunk_priority (struct ucl_parser *parser,\n\t\tconst unsigned char *data, size_t len, unsigned priority)\n{\n\t\n\tif (parser == NULL) {\n\t\treturn false;\n\t}", "Selected Statement": "\t\tchunk->begin = data;\n", "Selected Pointer": "data", "Compared Statement": "\t\tLL_PREPEND (parser->chunks, chunk);\n", "Compared Pointer": "chunk", "Aliasing": "No", "Function Input": {"data": {"type_category": "string", "concrete_type": "string", "value": "0x9e3779b1 <error: Cannot access memory at address 0x9e3779b1>"}, "len": {"type_category": "unknown", "concrete_type": "size_t", "value": "140737488346320"}, "parser": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdcc0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x7\n", "message": "Cannot access memory at address 0x7"}}, "priority": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}}, "Program Information": {"Project Name": "libucl"}, "idx": 202}
{"Programming Language": "C", "Source Code": "size_t len, unsigned priority, enum ucl_duplicate_strategy strat,\n\t\tenum ucl_parse_type parse_type)\n{\n\tstruct ucl_chunk *chunk;\n\tstruct ucl_parser_special_handler *special_handler;\n\n\tif (parser == NULL) {\n\t\treturn false;\n\t}\n\n\tif (data == NULL && len != 0) {\n\t\tucl_create_err (&parser->err, \"invalid chunk added\");\n\t\treturn false;\n\t}\n\n\tif (parser->state != UCL_STATE_ERROR) {\n\t\tchunk = UCL_ALLOC (sizeof (struct ucl_chunk));\n\t\tif (chunk == NULL) {\n\t\t\tucl_create_err (&parser->err, \"cannot allocate chunk structure\");\n\t\t\treturn false;\n\t\t}\n\n\t\tmemset (chunk, 0, sizeof (*chunk));\n\n\t\t\n\t\tLL_FOREACH (parser->special_handlers, special_handler) {\n\t\t\tif ((special_handler->flags & UCL_SPECIAL_HANDLER_PREPROCESS_ALL) ||\n\t\t\t\t\t(len >= special_handler->magic_len &&\n\t\t\t\t\t memcmp (data, special_handler->magic, special_handler->magic_len) == 0)) {\n\t\t\t\tunsigned char *ndata = NULL;\n\t\t\t\tsize_t nlen = 0;\n\n\t\t\t\tif (!special_handler->handler (parser, data, len, &ndata, &nlen,\n\t\t\t\t\t\tspecial_handler->user_data)) {\n\t\t\t\t\tUCL_FREE(sizeof (struct ucl_chunk), chunk);\n\t\t\t\t\tucl_create_err (&parser->err, \"call for external handler failed\");\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tstruct ucl_parser_special_handler_chain *nchain;\n\t\t\t\tnchain = UCL_ALLOC (sizeof (*nchain));\n\t\t\t\tnchain->begin = ndata;\n\t\t\t\tnchain->len = nlen;\n\t\t\t\tnchain->special_handler = special_handler;\n\n\t\t\t\t\n\t\t\t\tLL_PREPEND (chunk->special_handlers, nchain);\n\n\t\t\t\tdata = ndata;\n\t\t\t\tlen = nlen;\n\t\t\t}\n\t\t}\n\n\t\tif (parse_type == UCL_PARSE_AUTO && len > 0) {\n\t\t\t\n\t\t\tif ((*data & 0x80) == 0x80 && (*data >= 0xdc && *data <= 0xdf)) {\n\t\t\t\tparse_type = UCL_PARSE_MSGPACK;\n\t\t\t}\n\t\t\telse if (*data == '(') {\n\t\t\t\tparse_type = UCL_PARSE_CSEXP;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparse_type = UCL_PARSE_UCL;\n\t\t\t}\n\t\t}\n\n\t\tchunk->begin = data;\n\t\tchunk->remain = len;\n\t\tchunk->pos = chunk->begin;\n\t\tchunk->end = chunk->begin + len;\n\t\tchunk->line = 1;\n\t\tchunk->column = 0;\n\t\tchunk->priority = priority;\n\t\tchunk->strategy = strat;\n\t\tchunk->parse_type = parse_type;\n\n\t\tif (parser->cur_file) {\n\t\t\tchunk->fname = strdup (parser->cur_file);\n\t\t}\n\n\t\tLL_PREPEND (parser->chunks, chunk);\n\t\tparser->recursion ++;\n\n\t\tif (parser->recursion > UCL_MAX_RECURSION) {\n\t\t\tucl_create_err (&parser->err, \"maximum include nesting limit is reached: %d\",\n\t\t\t\t\tparser->recursion);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (len > 0) {\n\t\t\t\n\t\t\tswitch (parse_type) {\n\t\t\tdefault:\n\t\t\tcase UCL_PARSE_UCL:\n\t\t\t\treturn ucl_state_machine (parser);\n\t\t\tcase UCL_PARSE_MSGPACK:\n\t\t\t\treturn ucl_parse_msgpack (parser);\n\t\t\tcase UCL_PARSE_CSEXP:\n\t\t\t\treturn ucl_parse_csexp (parser);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\tif (parser->top_obj == NULL) {\n\t\t\t\t\n\t\t\t\tparser->top_obj = ucl_object_new_full (UCL_OBJECT, priority);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tucl_create_err (&parser->err, \"a parser is in an invalid state\");\n\n\treturn false;\n}\n\nbool\nucl_parser_add_chunk_priority (struct ucl_parser *parser,\n\t\tconst unsigned char *data, size_t len, unsigned priority)\n{\n\t\n\tif (parser == NULL) {\n\t\treturn false;\n\t}", "Selected Statement": "\t\tLL_PREPEND (parser->chunks, chunk);\n", "Selected Pointer": "chunk", "Compared Statement": "\t\tchunk->begin = data;\n", "Compared Pointer": "data", "Aliasing": "No", "Function Input": {"data": {"type_category": "string", "concrete_type": "string", "value": "0x9e3779b1 <error: Cannot access memory at address 0x9e3779b1>"}, "len": {"type_category": "unknown", "concrete_type": "size_t", "value": "140737488346320"}, "parser": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdcc0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x7\n", "message": "Cannot access memory at address 0x7"}}, "priority": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}}, "Program Information": {"Project Name": "libucl"}, "idx": 203}
{"Programming Language": "C", "Source Code": "size_t len, unsigned priority, enum ucl_duplicate_strategy strat,\n\t\tenum ucl_parse_type parse_type)\n{\n\tstruct ucl_chunk *chunk;\n\tstruct ucl_parser_special_handler *special_handler;\n\n\tif (parser == NULL) {\n\t\treturn false;\n\t}\n\n\tif (data == NULL && len != 0) {\n\t\tucl_create_err (&parser->err, \"invalid chunk added\");\n\t\treturn false;\n\t}\n\n\tif (parser->state != UCL_STATE_ERROR) {\n\t\tchunk = UCL_ALLOC (sizeof (struct ucl_chunk));\n\t\tif (chunk == NULL) {\n\t\t\tucl_create_err (&parser->err, \"cannot allocate chunk structure\");\n\t\t\treturn false;\n\t\t}\n\n\t\tmemset (chunk, 0, sizeof (*chunk));\n\n\t\t\n\t\tLL_FOREACH (parser->special_handlers, special_handler) {\n\t\t\tif ((special_handler->flags & UCL_SPECIAL_HANDLER_PREPROCESS_ALL) ||\n\t\t\t\t\t(len >= special_handler->magic_len &&\n\t\t\t\t\t memcmp (data, special_handler->magic, special_handler->magic_len) == 0)) {\n\t\t\t\tunsigned char *ndata = NULL;\n\t\t\t\tsize_t nlen = 0;\n\n\t\t\t\tif (!special_handler->handler (parser, data, len, &ndata, &nlen,\n\t\t\t\t\t\tspecial_handler->user_data)) {\n\t\t\t\t\tUCL_FREE(sizeof (struct ucl_chunk), chunk);\n\t\t\t\t\tucl_create_err (&parser->err, \"call for external handler failed\");\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tstruct ucl_parser_special_handler_chain *nchain;\n\t\t\t\tnchain = UCL_ALLOC (sizeof (*nchain));\n\t\t\t\tnchain->begin = ndata;\n\t\t\t\tnchain->len = nlen;\n\t\t\t\tnchain->special_handler = special_handler;\n\n\t\t\t\t\n\t\t\t\tLL_PREPEND (chunk->special_handlers, nchain);\n\n\t\t\t\tdata = ndata;\n\t\t\t\tlen = nlen;\n\t\t\t}\n\t\t}\n\n\t\tif (parse_type == UCL_PARSE_AUTO && len > 0) {\n\t\t\t\n\t\t\tif ((*data & 0x80) == 0x80 && (*data >= 0xdc && *data <= 0xdf)) {\n\t\t\t\tparse_type = UCL_PARSE_MSGPACK;\n\t\t\t}\n\t\t\telse if (*data == '(') {\n\t\t\t\tparse_type = UCL_PARSE_CSEXP;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparse_type = UCL_PARSE_UCL;\n\t\t\t}\n\t\t}\n\n\t\tchunk->begin = data;\n\t\tchunk->remain = len;\n\t\tchunk->pos = chunk->begin;\n\t\tchunk->end = chunk->begin + len;\n\t\tchunk->line = 1;\n\t\tchunk->column = 0;\n\t\tchunk->priority = priority;\n\t\tchunk->strategy = strat;\n\t\tchunk->parse_type = parse_type;\n\n\t\tif (parser->cur_file) {\n\t\t\tchunk->fname = strdup (parser->cur_file);\n\t\t}\n\n\t\tLL_PREPEND (parser->chunks, chunk);\n\t\tparser->recursion ++;\n\n\t\tif (parser->recursion > UCL_MAX_RECURSION) {\n\t\t\tucl_create_err (&parser->err, \"maximum include nesting limit is reached: %d\",\n\t\t\t\t\tparser->recursion);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (len > 0) {\n\t\t\t\n\t\t\tswitch (parse_type) {\n\t\t\tdefault:\n\t\t\tcase UCL_PARSE_UCL:\n\t\t\t\treturn ucl_state_machine (parser);\n\t\t\tcase UCL_PARSE_MSGPACK:\n\t\t\t\treturn ucl_parse_msgpack (parser);\n\t\t\tcase UCL_PARSE_CSEXP:\n\t\t\t\treturn ucl_parse_csexp (parser);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\tif (parser->top_obj == NULL) {\n\t\t\t\t\n\t\t\t\tparser->top_obj = ucl_object_new_full (UCL_OBJECT, priority);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tucl_create_err (&parser->err, \"a parser is in an invalid state\");\n\n\treturn false;\n}\n\nbool\nucl_parser_add_chunk_priority (struct ucl_parser *parser,\n\t\tconst unsigned char *data, size_t len, unsigned priority)\n{\n\t\n\tif (parser == NULL) {\n\t\treturn false;\n\t}", "Selected Statement": "\t\tLL_PREPEND (parser->chunks, chunk);\n", "Selected Pointer": "chunk", "Compared Statement": "\t\tchunk->begin = data;\n", "Compared Pointer": "data", "Aliasing": "No", "Function Input": {"data": {"type_category": "string", "concrete_type": "string", "value": "0x9e3779b1 <error: Cannot access memory at address 0x9e3779b1>"}, "len": {"type_category": "unknown", "concrete_type": "size_t", "value": "140737488346320"}, "parser": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdcc0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x7\n", "message": "Cannot access memory at address 0x7"}}, "priority": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}}, "Program Information": {"Project Name": "libucl"}, "idx": 204}
{"Programming Language": "C", "Source Code": "void\nucl_parser_free (struct ucl_parser *parser)\n{\n\tstruct ucl_stack *stack, *stmp;\n\tstruct ucl_macro *macro, *mtmp;\n\tstruct ucl_chunk *chunk, *ctmp;\n\tstruct ucl_pubkey *key, *ktmp;\n\tstruct ucl_variable *var, *vtmp;\n\tucl_object_t *tr, *trtmp;\n\n\tif (parser == NULL) {\n\t\treturn;\n\t}\n\n\tif (parser->top_obj != NULL) {\n\t\tucl_object_unref (parser->top_obj);\n\t}\n\n\tif (parser->includepaths != NULL) {\n\t\tucl_object_unref (parser->includepaths);\n\t}\n\n\tLL_FOREACH_SAFE (parser->stack, stack, stmp) {\n\t\tfree (stack);\n\t}\n\tHASH_ITER (hh, parser->macroes, macro, mtmp) {\n\t\tfree (macro->name);\n\t\tHASH_DEL (parser->macroes, macro);\n\t\tUCL_FREE (sizeof (struct ucl_macro), macro);\n\t}\n\tLL_FOREACH_SAFE (parser->chunks, chunk, ctmp) {\n\t\tucl_chunk_free (chunk);\n\t}\n\tLL_FOREACH_SAFE (parser->keys, key, ktmp) {\n\t\tUCL_FREE (sizeof (struct ucl_pubkey), key);\n\t}\n\tLL_FOREACH_SAFE (parser->variables, var, vtmp) {\n\t\tfree (var->value);\n\t\tfree (var->var);\n\t\tUCL_FREE (sizeof (struct ucl_variable), var);\n\t}\n\tLL_FOREACH_SAFE (parser->trash_objs, tr, trtmp) {\n\t\tucl_object_free_internal (tr, false, ucl_object_dtor_free);\n\t}\n\n\tif (parser->err != NULL) {\n\t\tutstring_free (parser->err);\n\t}\n\n\tif (parser->cur_file) {\n\t\tfree (parser->cur_file);\n\t}\n\n\tif (parser->comments) {\n\t\tucl_object_unref (parser->comments);\n\t}\n\n\tUCL_FREE (sizeof (struct ucl_parser), parser);", "Selected Statement": "\t\tHASH_DEL (parser->macroes, macro);\n", "Selected Pointer": "macro", "Compared Statement": "\tLL_FOREACH_SAFE (parser->stack, stack, stmp) {\n", "Compared Pointer": "stack", "Aliasing": "No", "Function Input": {"parser": {"type_category": "pointer", "concrete_type": "NULL"}}, "Program Information": {"Project Name": "libucl"}, "idx": 205}
{"Programming Language": "C", "Source Code": "size_t len, unsigned priority, enum ucl_duplicate_strategy strat,\n\t\tenum ucl_parse_type parse_type)\n{\n\tstruct ucl_chunk *chunk;\n\tstruct ucl_parser_special_handler *special_handler;\n\n\tif (parser == NULL) {\n\t\treturn false;\n\t}\n\n\tif (data == NULL && len != 0) {\n\t\tucl_create_err (&parser->err, \"invalid chunk added\");\n\t\treturn false;\n\t}\n\n\tif (parser->state != UCL_STATE_ERROR) {\n\t\tchunk = UCL_ALLOC (sizeof (struct ucl_chunk));\n\t\tif (chunk == NULL) {\n\t\t\tucl_create_err (&parser->err, \"cannot allocate chunk structure\");\n\t\t\treturn false;\n\t\t}\n\n\t\tmemset (chunk, 0, sizeof (*chunk));\n\n\t\t\n\t\tLL_FOREACH (parser->special_handlers, special_handler) {\n\t\t\tif ((special_handler->flags & UCL_SPECIAL_HANDLER_PREPROCESS_ALL) ||\n\t\t\t\t\t(len >= special_handler->magic_len &&\n\t\t\t\t\t memcmp (data, special_handler->magic, special_handler->magic_len) == 0)) {\n\t\t\t\tunsigned char *ndata = NULL;\n\t\t\t\tsize_t nlen = 0;\n\n\t\t\t\tif (!special_handler->handler (parser, data, len, &ndata, &nlen,\n\t\t\t\t\t\tspecial_handler->user_data)) {\n\t\t\t\t\tUCL_FREE(sizeof (struct ucl_chunk), chunk);\n\t\t\t\t\tucl_create_err (&parser->err, \"call for external handler failed\");\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tstruct ucl_parser_special_handler_chain *nchain;\n\t\t\t\tnchain = UCL_ALLOC (sizeof (*nchain));\n\t\t\t\tnchain->begin = ndata;\n\t\t\t\tnchain->len = nlen;\n\t\t\t\tnchain->special_handler = special_handler;\n\n\t\t\t\t\n\t\t\t\tLL_PREPEND (chunk->special_handlers, nchain);\n\n\t\t\t\tdata = ndata;\n\t\t\t\tlen = nlen;\n\t\t\t}\n\t\t}\n\n\t\tif (parse_type == UCL_PARSE_AUTO && len > 0) {\n\t\t\t\n\t\t\tif ((*data & 0x80) == 0x80 && (*data >= 0xdc && *data <= 0xdf)) {\n\t\t\t\tparse_type = UCL_PARSE_MSGPACK;\n\t\t\t}\n\t\t\telse if (*data == '(') {\n\t\t\t\tparse_type = UCL_PARSE_CSEXP;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparse_type = UCL_PARSE_UCL;\n\t\t\t}\n\t\t}\n\n\t\tchunk->begin = data;\n\t\tchunk->remain = len;\n\t\tchunk->pos = chunk->begin;\n\t\tchunk->end = chunk->begin + len;\n\t\tchunk->line = 1;\n\t\tchunk->column = 0;\n\t\tchunk->priority = priority;\n\t\tchunk->strategy = strat;\n\t\tchunk->parse_type = parse_type;\n\n\t\tif (parser->cur_file) {\n\t\t\tchunk->fname = strdup (parser->cur_file);\n\t\t}\n\n\t\tLL_PREPEND (parser->chunks, chunk);\n\t\tparser->recursion ++;\n\n\t\tif (parser->recursion > UCL_MAX_RECURSION) {\n\t\t\tucl_create_err (&parser->err, \"maximum include nesting limit is reached: %d\",\n\t\t\t\t\tparser->recursion);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (len > 0) {\n\t\t\t\n\t\t\tswitch (parse_type) {\n\t\t\tdefault:\n\t\t\tcase UCL_PARSE_UCL:\n\t\t\t\treturn ucl_state_machine (parser);\n\t\t\tcase UCL_PARSE_MSGPACK:\n\t\t\t\treturn ucl_parse_msgpack (parser);\n\t\t\tcase UCL_PARSE_CSEXP:\n\t\t\t\treturn ucl_parse_csexp (parser);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\tif (parser->top_obj == NULL) {\n\t\t\t\t\n\t\t\t\tparser->top_obj = ucl_object_new_full (UCL_OBJECT, priority);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tucl_create_err (&parser->err, \"a parser is in an invalid state\");\n\n\treturn false;\n}\n\nbool\nucl_parser_add_chunk_priority (struct ucl_parser *parser,\n\t\tconst unsigned char *data, size_t len, unsigned priority)\n{\n\t\n\tif (parser == NULL) {\n\t\treturn false;\n\t}", "Selected Statement": "\t\tchunk->begin = data;\n", "Selected Pointer": "data", "Compared Statement": "\t\tLL_PREPEND (parser->chunks, chunk);\n", "Compared Pointer": "chunk", "Aliasing": "No", "Function Input": {"data": {"type_category": "string", "concrete_type": "string", "value": "0x9e3779b1 <error: Cannot access memory at address 0x9e3779b1>"}, "len": {"type_category": "unknown", "concrete_type": "size_t", "value": "140737488346320"}, "parser": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdcc0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x7\n", "message": "Cannot access memory at address 0x7"}}, "priority": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}}, "Program Information": {"Project Name": "libucl"}, "idx": 206}
{"Programming Language": "C", "Source Code": "size_t len, unsigned priority, enum ucl_duplicate_strategy strat,\n\t\tenum ucl_parse_type parse_type)\n{\n\tstruct ucl_chunk *chunk;\n\tstruct ucl_parser_special_handler *special_handler;\n\n\tif (parser == NULL) {\n\t\treturn false;\n\t}\n\n\tif (data == NULL && len != 0) {\n\t\tucl_create_err (&parser->err, \"invalid chunk added\");\n\t\treturn false;\n\t}\n\n\tif (parser->state != UCL_STATE_ERROR) {\n\t\tchunk = UCL_ALLOC (sizeof (struct ucl_chunk));\n\t\tif (chunk == NULL) {\n\t\t\tucl_create_err (&parser->err, \"cannot allocate chunk structure\");\n\t\t\treturn false;\n\t\t}\n\n\t\tmemset (chunk, 0, sizeof (*chunk));\n\n\t\t\n\t\tLL_FOREACH (parser->special_handlers, special_handler) {\n\t\t\tif ((special_handler->flags & UCL_SPECIAL_HANDLER_PREPROCESS_ALL) ||\n\t\t\t\t\t(len >= special_handler->magic_len &&\n\t\t\t\t\t memcmp (data, special_handler->magic, special_handler->magic_len) == 0)) {\n\t\t\t\tunsigned char *ndata = NULL;\n\t\t\t\tsize_t nlen = 0;\n\n\t\t\t\tif (!special_handler->handler (parser, data, len, &ndata, &nlen,\n\t\t\t\t\t\tspecial_handler->user_data)) {\n\t\t\t\t\tUCL_FREE(sizeof (struct ucl_chunk), chunk);\n\t\t\t\t\tucl_create_err (&parser->err, \"call for external handler failed\");\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tstruct ucl_parser_special_handler_chain *nchain;\n\t\t\t\tnchain = UCL_ALLOC (sizeof (*nchain));\n\t\t\t\tnchain->begin = ndata;\n\t\t\t\tnchain->len = nlen;\n\t\t\t\tnchain->special_handler = special_handler;\n\n\t\t\t\t\n\t\t\t\tLL_PREPEND (chunk->special_handlers, nchain);\n\n\t\t\t\tdata = ndata;\n\t\t\t\tlen = nlen;\n\t\t\t}\n\t\t}\n\n\t\tif (parse_type == UCL_PARSE_AUTO && len > 0) {\n\t\t\t\n\t\t\tif ((*data & 0x80) == 0x80 && (*data >= 0xdc && *data <= 0xdf)) {\n\t\t\t\tparse_type = UCL_PARSE_MSGPACK;\n\t\t\t}\n\t\t\telse if (*data == '(') {\n\t\t\t\tparse_type = UCL_PARSE_CSEXP;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparse_type = UCL_PARSE_UCL;\n\t\t\t}\n\t\t}\n\n\t\tchunk->begin = data;\n\t\tchunk->remain = len;\n\t\tchunk->pos = chunk->begin;\n\t\tchunk->end = chunk->begin + len;\n\t\tchunk->line = 1;\n\t\tchunk->column = 0;\n\t\tchunk->priority = priority;\n\t\tchunk->strategy = strat;\n\t\tchunk->parse_type = parse_type;\n\n\t\tif (parser->cur_file) {\n\t\t\tchunk->fname = strdup (parser->cur_file);\n\t\t}\n\n\t\tLL_PREPEND (parser->chunks, chunk);\n\t\tparser->recursion ++;\n\n\t\tif (parser->recursion > UCL_MAX_RECURSION) {\n\t\t\tucl_create_err (&parser->err, \"maximum include nesting limit is reached: %d\",\n\t\t\t\t\tparser->recursion);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (len > 0) {\n\t\t\t\n\t\t\tswitch (parse_type) {\n\t\t\tdefault:\n\t\t\tcase UCL_PARSE_UCL:\n\t\t\t\treturn ucl_state_machine (parser);\n\t\t\tcase UCL_PARSE_MSGPACK:\n\t\t\t\treturn ucl_parse_msgpack (parser);\n\t\t\tcase UCL_PARSE_CSEXP:\n\t\t\t\treturn ucl_parse_csexp (parser);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\tif (parser->top_obj == NULL) {\n\t\t\t\t\n\t\t\t\tparser->top_obj = ucl_object_new_full (UCL_OBJECT, priority);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tucl_create_err (&parser->err, \"a parser is in an invalid state\");\n\n\treturn false;\n}\n\nbool\nucl_parser_add_chunk_priority (struct ucl_parser *parser,\n\t\tconst unsigned char *data, size_t len, unsigned priority)\n{\n\t\n\tif (parser == NULL) {\n\t\treturn false;\n\t}", "Selected Statement": "\t\tLL_PREPEND (parser->chunks, chunk);\n", "Selected Pointer": "chunk", "Compared Statement": "\t\tchunk->begin = data;\n", "Compared Pointer": "data", "Aliasing": "No", "Function Input": {"data": {"type_category": "string", "concrete_type": "string", "value": "0x9e3779b1 <error: Cannot access memory at address 0x9e3779b1>"}, "len": {"type_category": "unknown", "concrete_type": "size_t", "value": "140737488346320"}, "parser": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdcc0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x7\n", "message": "Cannot access memory at address 0x7"}}, "priority": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}}, "Program Information": {"Project Name": "libucl"}, "idx": 207}
{"Programming Language": "C", "Source Code": "size_t len, unsigned priority, enum ucl_duplicate_strategy strat,\n\t\tenum ucl_parse_type parse_type)\n{\n\tstruct ucl_chunk *chunk;\n\tstruct ucl_parser_special_handler *special_handler;\n\n\tif (parser == NULL) {\n\t\treturn false;\n\t}\n\n\tif (data == NULL && len != 0) {\n\t\tucl_create_err (&parser->err, \"invalid chunk added\");\n\t\treturn false;\n\t}\n\n\tif (parser->state != UCL_STATE_ERROR) {\n\t\tchunk = UCL_ALLOC (sizeof (struct ucl_chunk));\n\t\tif (chunk == NULL) {\n\t\t\tucl_create_err (&parser->err, \"cannot allocate chunk structure\");\n\t\t\treturn false;\n\t\t}\n\n\t\tmemset (chunk, 0, sizeof (*chunk));\n\n\t\t\n\t\tLL_FOREACH (parser->special_handlers, special_handler) {\n\t\t\tif ((special_handler->flags & UCL_SPECIAL_HANDLER_PREPROCESS_ALL) ||\n\t\t\t\t\t(len >= special_handler->magic_len &&\n\t\t\t\t\t memcmp (data, special_handler->magic, special_handler->magic_len) == 0)) {\n\t\t\t\tunsigned char *ndata = NULL;\n\t\t\t\tsize_t nlen = 0;\n\n\t\t\t\tif (!special_handler->handler (parser, data, len, &ndata, &nlen,\n\t\t\t\t\t\tspecial_handler->user_data)) {\n\t\t\t\t\tUCL_FREE(sizeof (struct ucl_chunk), chunk);\n\t\t\t\t\tucl_create_err (&parser->err, \"call for external handler failed\");\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tstruct ucl_parser_special_handler_chain *nchain;\n\t\t\t\tnchain = UCL_ALLOC (sizeof (*nchain));\n\t\t\t\tnchain->begin = ndata;\n\t\t\t\tnchain->len = nlen;\n\t\t\t\tnchain->special_handler = special_handler;\n\n\t\t\t\t\n\t\t\t\tLL_PREPEND (chunk->special_handlers, nchain);\n\n\t\t\t\tdata = ndata;\n\t\t\t\tlen = nlen;\n\t\t\t}\n\t\t}\n\n\t\tif (parse_type == UCL_PARSE_AUTO && len > 0) {\n\t\t\t\n\t\t\tif ((*data & 0x80) == 0x80 && (*data >= 0xdc && *data <= 0xdf)) {\n\t\t\t\tparse_type = UCL_PARSE_MSGPACK;\n\t\t\t}\n\t\t\telse if (*data == '(') {\n\t\t\t\tparse_type = UCL_PARSE_CSEXP;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparse_type = UCL_PARSE_UCL;\n\t\t\t}\n\t\t}\n\n\t\tchunk->begin = data;\n\t\tchunk->remain = len;\n\t\tchunk->pos = chunk->begin;\n\t\tchunk->end = chunk->begin + len;\n\t\tchunk->line = 1;\n\t\tchunk->column = 0;\n\t\tchunk->priority = priority;\n\t\tchunk->strategy = strat;\n\t\tchunk->parse_type = parse_type;\n\n\t\tif (parser->cur_file) {\n\t\t\tchunk->fname = strdup (parser->cur_file);\n\t\t}\n\n\t\tLL_PREPEND (parser->chunks, chunk);\n\t\tparser->recursion ++;\n\n\t\tif (parser->recursion > UCL_MAX_RECURSION) {\n\t\t\tucl_create_err (&parser->err, \"maximum include nesting limit is reached: %d\",\n\t\t\t\t\tparser->recursion);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (len > 0) {\n\t\t\t\n\t\t\tswitch (parse_type) {\n\t\t\tdefault:\n\t\t\tcase UCL_PARSE_UCL:\n\t\t\t\treturn ucl_state_machine (parser);\n\t\t\tcase UCL_PARSE_MSGPACK:\n\t\t\t\treturn ucl_parse_msgpack (parser);\n\t\t\tcase UCL_PARSE_CSEXP:\n\t\t\t\treturn ucl_parse_csexp (parser);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\tif (parser->top_obj == NULL) {\n\t\t\t\t\n\t\t\t\tparser->top_obj = ucl_object_new_full (UCL_OBJECT, priority);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tucl_create_err (&parser->err, \"a parser is in an invalid state\");\n\n\treturn false;\n}\n\nbool\nucl_parser_add_chunk_priority (struct ucl_parser *parser,\n\t\tconst unsigned char *data, size_t len, unsigned priority)\n{\n\t\n\tif (parser == NULL) {\n\t\treturn false;\n\t}", "Selected Statement": "\t\tLL_PREPEND (parser->chunks, chunk);\n", "Selected Pointer": "chunk", "Compared Statement": "\t\tchunk->begin = data;\n", "Compared Pointer": "data", "Aliasing": "No", "Function Input": {"data": {"type_category": "string", "concrete_type": "string", "value": "0x9e3779b1 <error: Cannot access memory at address 0x9e3779b1>"}, "len": {"type_category": "unknown", "concrete_type": "size_t", "value": "140737488346320"}, "parser": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdcc0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x7\n", "message": "Cannot access memory at address 0x7"}}, "priority": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}}, "Program Information": {"Project Name": "libucl"}, "idx": 208}
{"Programming Language": "C", "Source Code": "size_t len, unsigned priority, enum ucl_duplicate_strategy strat,\n\t\tenum ucl_parse_type parse_type)\n{\n\tstruct ucl_chunk *chunk;\n\tstruct ucl_parser_special_handler *special_handler;\n\n\tif (parser == NULL) {\n\t\treturn false;\n\t}\n\n\tif (data == NULL && len != 0) {\n\t\tucl_create_err (&parser->err, \"invalid chunk added\");\n\t\treturn false;\n\t}\n\n\tif (parser->state != UCL_STATE_ERROR) {\n\t\tchunk = UCL_ALLOC (sizeof (struct ucl_chunk));\n\t\tif (chunk == NULL) {\n\t\t\tucl_create_err (&parser->err, \"cannot allocate chunk structure\");\n\t\t\treturn false;\n\t\t}\n\n\t\tmemset (chunk, 0, sizeof (*chunk));\n\n\t\t\n\t\tLL_FOREACH (parser->special_handlers, special_handler) {\n\t\t\tif ((special_handler->flags & UCL_SPECIAL_HANDLER_PREPROCESS_ALL) ||\n\t\t\t\t\t(len >= special_handler->magic_len &&\n\t\t\t\t\t memcmp (data, special_handler->magic, special_handler->magic_len) == 0)) {\n\t\t\t\tunsigned char *ndata = NULL;\n\t\t\t\tsize_t nlen = 0;\n\n\t\t\t\tif (!special_handler->handler (parser, data, len, &ndata, &nlen,\n\t\t\t\t\t\tspecial_handler->user_data)) {\n\t\t\t\t\tUCL_FREE(sizeof (struct ucl_chunk), chunk);\n\t\t\t\t\tucl_create_err (&parser->err, \"call for external handler failed\");\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tstruct ucl_parser_special_handler_chain *nchain;\n\t\t\t\tnchain = UCL_ALLOC (sizeof (*nchain));\n\t\t\t\tnchain->begin = ndata;\n\t\t\t\tnchain->len = nlen;\n\t\t\t\tnchain->special_handler = special_handler;\n\n\t\t\t\t\n\t\t\t\tLL_PREPEND (chunk->special_handlers, nchain);\n\n\t\t\t\tdata = ndata;\n\t\t\t\tlen = nlen;\n\t\t\t}\n\t\t}\n\n\t\tif (parse_type == UCL_PARSE_AUTO && len > 0) {\n\t\t\t\n\t\t\tif ((*data & 0x80) == 0x80 && (*data >= 0xdc && *data <= 0xdf)) {\n\t\t\t\tparse_type = UCL_PARSE_MSGPACK;\n\t\t\t}\n\t\t\telse if (*data == '(') {\n\t\t\t\tparse_type = UCL_PARSE_CSEXP;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparse_type = UCL_PARSE_UCL;\n\t\t\t}\n\t\t}\n\n\t\tchunk->begin = data;\n\t\tchunk->remain = len;\n\t\tchunk->pos = chunk->begin;\n\t\tchunk->end = chunk->begin + len;\n\t\tchunk->line = 1;\n\t\tchunk->column = 0;\n\t\tchunk->priority = priority;\n\t\tchunk->strategy = strat;\n\t\tchunk->parse_type = parse_type;\n\n\t\tif (parser->cur_file) {\n\t\t\tchunk->fname = strdup (parser->cur_file);\n\t\t}\n\n\t\tLL_PREPEND (parser->chunks, chunk);\n\t\tparser->recursion ++;\n\n\t\tif (parser->recursion > UCL_MAX_RECURSION) {\n\t\t\tucl_create_err (&parser->err, \"maximum include nesting limit is reached: %d\",\n\t\t\t\t\tparser->recursion);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (len > 0) {\n\t\t\t\n\t\t\tswitch (parse_type) {\n\t\t\tdefault:\n\t\t\tcase UCL_PARSE_UCL:\n\t\t\t\treturn ucl_state_machine (parser);\n\t\t\tcase UCL_PARSE_MSGPACK:\n\t\t\t\treturn ucl_parse_msgpack (parser);\n\t\t\tcase UCL_PARSE_CSEXP:\n\t\t\t\treturn ucl_parse_csexp (parser);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\tif (parser->top_obj == NULL) {\n\t\t\t\t\n\t\t\t\tparser->top_obj = ucl_object_new_full (UCL_OBJECT, priority);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tucl_create_err (&parser->err, \"a parser is in an invalid state\");\n\n\treturn false;\n}\n\nbool\nucl_parser_add_chunk_priority (struct ucl_parser *parser,\n\t\tconst unsigned char *data, size_t len, unsigned priority)\n{\n\t\n\tif (parser == NULL) {\n\t\treturn false;\n\t}", "Selected Statement": "\t\tLL_PREPEND (parser->chunks, chunk);\n", "Selected Pointer": "chunk", "Compared Statement": "\t\tchunk->begin = data;\n", "Compared Pointer": "data", "Aliasing": "No", "Function Input": {"data": {"type_category": "string", "concrete_type": "string", "value": "0x9e3779b1 <error: Cannot access memory at address 0x9e3779b1>"}, "len": {"type_category": "unknown", "concrete_type": "size_t", "value": "140737488346320"}, "parser": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdcc0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x7\n", "message": "Cannot access memory at address 0x7"}}, "priority": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}}, "Program Information": {"Project Name": "libucl"}, "idx": 209}
{"Programming Language": "C", "Source Code": "size_t len, unsigned priority, enum ucl_duplicate_strategy strat,\n\t\tenum ucl_parse_type parse_type)\n{\n\tstruct ucl_chunk *chunk;\n\tstruct ucl_parser_special_handler *special_handler;\n\n\tif (parser == NULL) {\n\t\treturn false;\n\t}\n\n\tif (data == NULL && len != 0) {\n\t\tucl_create_err (&parser->err, \"invalid chunk added\");\n\t\treturn false;\n\t}\n\n\tif (parser->state != UCL_STATE_ERROR) {\n\t\tchunk = UCL_ALLOC (sizeof (struct ucl_chunk));\n\t\tif (chunk == NULL) {\n\t\t\tucl_create_err (&parser->err, \"cannot allocate chunk structure\");\n\t\t\treturn false;\n\t\t}\n\n\t\tmemset (chunk, 0, sizeof (*chunk));\n\n\t\t\n\t\tLL_FOREACH (parser->special_handlers, special_handler) {\n\t\t\tif ((special_handler->flags & UCL_SPECIAL_HANDLER_PREPROCESS_ALL) ||\n\t\t\t\t\t(len >= special_handler->magic_len &&\n\t\t\t\t\t memcmp (data, special_handler->magic, special_handler->magic_len) == 0)) {\n\t\t\t\tunsigned char *ndata = NULL;\n\t\t\t\tsize_t nlen = 0;\n\n\t\t\t\tif (!special_handler->handler (parser, data, len, &ndata, &nlen,\n\t\t\t\t\t\tspecial_handler->user_data)) {\n\t\t\t\t\tUCL_FREE(sizeof (struct ucl_chunk), chunk);\n\t\t\t\t\tucl_create_err (&parser->err, \"call for external handler failed\");\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tstruct ucl_parser_special_handler_chain *nchain;\n\t\t\t\tnchain = UCL_ALLOC (sizeof (*nchain));\n\t\t\t\tnchain->begin = ndata;\n\t\t\t\tnchain->len = nlen;\n\t\t\t\tnchain->special_handler = special_handler;\n\n\t\t\t\t\n\t\t\t\tLL_PREPEND (chunk->special_handlers, nchain);\n\n\t\t\t\tdata = ndata;\n\t\t\t\tlen = nlen;\n\t\t\t}\n\t\t}\n\n\t\tif (parse_type == UCL_PARSE_AUTO && len > 0) {\n\t\t\t\n\t\t\tif ((*data & 0x80) == 0x80 && (*data >= 0xdc && *data <= 0xdf)) {\n\t\t\t\tparse_type = UCL_PARSE_MSGPACK;\n\t\t\t}\n\t\t\telse if (*data == '(') {\n\t\t\t\tparse_type = UCL_PARSE_CSEXP;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparse_type = UCL_PARSE_UCL;\n\t\t\t}\n\t\t}\n\n\t\tchunk->begin = data;\n\t\tchunk->remain = len;\n\t\tchunk->pos = chunk->begin;\n\t\tchunk->end = chunk->begin + len;\n\t\tchunk->line = 1;\n\t\tchunk->column = 0;\n\t\tchunk->priority = priority;\n\t\tchunk->strategy = strat;\n\t\tchunk->parse_type = parse_type;\n\n\t\tif (parser->cur_file) {\n\t\t\tchunk->fname = strdup (parser->cur_file);\n\t\t}\n\n\t\tLL_PREPEND (parser->chunks, chunk);\n\t\tparser->recursion ++;\n\n\t\tif (parser->recursion > UCL_MAX_RECURSION) {\n\t\t\tucl_create_err (&parser->err, \"maximum include nesting limit is reached: %d\",\n\t\t\t\t\tparser->recursion);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (len > 0) {\n\t\t\t\n\t\t\tswitch (parse_type) {\n\t\t\tdefault:\n\t\t\tcase UCL_PARSE_UCL:\n\t\t\t\treturn ucl_state_machine (parser);\n\t\t\tcase UCL_PARSE_MSGPACK:\n\t\t\t\treturn ucl_parse_msgpack (parser);\n\t\t\tcase UCL_PARSE_CSEXP:\n\t\t\t\treturn ucl_parse_csexp (parser);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\tif (parser->top_obj == NULL) {\n\t\t\t\t\n\t\t\t\tparser->top_obj = ucl_object_new_full (UCL_OBJECT, priority);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tucl_create_err (&parser->err, \"a parser is in an invalid state\");\n\n\treturn false;\n}\n\nbool\nucl_parser_add_chunk_priority (struct ucl_parser *parser,\n\t\tconst unsigned char *data, size_t len, unsigned priority)\n{\n\t\n\tif (parser == NULL) {\n\t\treturn false;\n\t}", "Selected Statement": "\t\tLL_PREPEND (parser->chunks, chunk);\n", "Selected Pointer": "chunk", "Compared Statement": "\t\tchunk->begin = data;\n", "Compared Pointer": "data", "Aliasing": "No", "Function Input": {"data": {"type_category": "string", "concrete_type": "string", "value": "0x9e3779b1 <error: Cannot access memory at address 0x9e3779b1>"}, "len": {"type_category": "unknown", "concrete_type": "size_t", "value": "140737488346320"}, "parser": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdcc0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x7\n", "message": "Cannot access memory at address 0x7"}}, "priority": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}}, "Program Information": {"Project Name": "libucl"}, "idx": 210}
{"Programming Language": "C", "Source Code": "void\nucl_parser_free (struct ucl_parser *parser)\n{\n\tstruct ucl_stack *stack, *stmp;\n\tstruct ucl_macro *macro, *mtmp;\n\tstruct ucl_chunk *chunk, *ctmp;\n\tstruct ucl_pubkey *key, *ktmp;\n\tstruct ucl_variable *var, *vtmp;\n\tucl_object_t *tr, *trtmp;\n\n\tif (parser == NULL) {\n\t\treturn;\n\t}\n\n\tif (parser->top_obj != NULL) {\n\t\tucl_object_unref (parser->top_obj);\n\t}\n\n\tif (parser->includepaths != NULL) {\n\t\tucl_object_unref (parser->includepaths);\n\t}\n\n\tLL_FOREACH_SAFE (parser->stack, stack, stmp) {\n\t\tfree (stack);\n\t}\n\tHASH_ITER (hh, parser->macroes, macro, mtmp) {\n\t\tfree (macro->name);\n\t\tHASH_DEL (parser->macroes, macro);\n\t\tUCL_FREE (sizeof (struct ucl_macro), macro);\n\t}\n\tLL_FOREACH_SAFE (parser->chunks, chunk, ctmp) {\n\t\tucl_chunk_free (chunk);\n\t}\n\tLL_FOREACH_SAFE (parser->keys, key, ktmp) {\n\t\tUCL_FREE (sizeof (struct ucl_pubkey), key);\n\t}\n\tLL_FOREACH_SAFE (parser->variables, var, vtmp) {\n\t\tfree (var->value);\n\t\tfree (var->var);\n\t\tUCL_FREE (sizeof (struct ucl_variable), var);\n\t}\n\tLL_FOREACH_SAFE (parser->trash_objs, tr, trtmp) {\n\t\tucl_object_free_internal (tr, false, ucl_object_dtor_free);\n\t}\n\n\tif (parser->err != NULL) {\n\t\tutstring_free (parser->err);\n\t}\n\n\tif (parser->cur_file) {\n\t\tfree (parser->cur_file);\n\t}\n\n\tif (parser->comments) {\n\t\tucl_object_unref (parser->comments);\n\t}\n\n\tUCL_FREE (sizeof (struct ucl_parser), parser);", "Selected Statement": "\t\tHASH_DEL (parser->macroes, macro);\n", "Selected Pointer": "macro", "Compared Statement": "\tUCL_FREE (sizeof (struct ucl_parser), parser);\n", "Compared Pointer": "parser", "Aliasing": "No", "Function Input": {"parser": {"type_category": "pointer", "concrete_type": "NULL"}}, "Program Information": {"Project Name": "libucl"}, "idx": 211}
{"Programming Language": "C", "Source Code": "void\nucl_parser_free (struct ucl_parser *parser)\n{\n\tstruct ucl_stack *stack, *stmp;\n\tstruct ucl_macro *macro, *mtmp;\n\tstruct ucl_chunk *chunk, *ctmp;\n\tstruct ucl_pubkey *key, *ktmp;\n\tstruct ucl_variable *var, *vtmp;\n\tucl_object_t *tr, *trtmp;\n\n\tif (parser == NULL) {\n\t\treturn;\n\t}\n\n\tif (parser->top_obj != NULL) {\n\t\tucl_object_unref (parser->top_obj);\n\t}\n\n\tif (parser->includepaths != NULL) {\n\t\tucl_object_unref (parser->includepaths);\n\t}\n\n\tLL_FOREACH_SAFE (parser->stack, stack, stmp) {\n\t\tfree (stack);\n\t}\n\tHASH_ITER (hh, parser->macroes, macro, mtmp) {\n\t\tfree (macro->name);\n\t\tHASH_DEL (parser->macroes, macro);\n\t\tUCL_FREE (sizeof (struct ucl_macro), macro);\n\t}\n\tLL_FOREACH_SAFE (parser->chunks, chunk, ctmp) {\n\t\tucl_chunk_free (chunk);\n\t}\n\tLL_FOREACH_SAFE (parser->keys, key, ktmp) {\n\t\tUCL_FREE (sizeof (struct ucl_pubkey), key);\n\t}\n\tLL_FOREACH_SAFE (parser->variables, var, vtmp) {\n\t\tfree (var->value);\n\t\tfree (var->var);\n\t\tUCL_FREE (sizeof (struct ucl_variable), var);\n\t}\n\tLL_FOREACH_SAFE (parser->trash_objs, tr, trtmp) {\n\t\tucl_object_free_internal (tr, false, ucl_object_dtor_free);\n\t}\n\n\tif (parser->err != NULL) {\n\t\tutstring_free (parser->err);\n\t}\n\n\tif (parser->cur_file) {\n\t\tfree (parser->cur_file);\n\t}\n\n\tif (parser->comments) {\n\t\tucl_object_unref (parser->comments);\n\t}\n\n\tUCL_FREE (sizeof (struct ucl_parser), parser);", "Selected Statement": "\tUCL_FREE (sizeof (struct ucl_parser), parser);\n", "Selected Pointer": "parser", "Compared Statement": "\tLL_FOREACH_SAFE (parser->chunks, chunk, ctmp) {\n", "Compared Pointer": "chunk", "Aliasing": "No", "Function Input": {"parser": {"type_category": "pointer", "concrete_type": "NULL"}}, "Program Information": {"Project Name": "libucl"}, "idx": 212}
{"Programming Language": "C", "Source Code": "size_t len, unsigned priority, enum ucl_duplicate_strategy strat,\n\t\tenum ucl_parse_type parse_type)\n{\n\tstruct ucl_chunk *chunk;\n\tstruct ucl_parser_special_handler *special_handler;\n\n\tif (parser == NULL) {\n\t\treturn false;\n\t}\n\n\tif (data == NULL && len != 0) {\n\t\tucl_create_err (&parser->err, \"invalid chunk added\");\n\t\treturn false;\n\t}\n\n\tif (parser->state != UCL_STATE_ERROR) {\n\t\tchunk = UCL_ALLOC (sizeof (struct ucl_chunk));\n\t\tif (chunk == NULL) {\n\t\t\tucl_create_err (&parser->err, \"cannot allocate chunk structure\");\n\t\t\treturn false;\n\t\t}\n\n\t\tmemset (chunk, 0, sizeof (*chunk));\n\n\t\t\n\t\tLL_FOREACH (parser->special_handlers, special_handler) {\n\t\t\tif ((special_handler->flags & UCL_SPECIAL_HANDLER_PREPROCESS_ALL) ||\n\t\t\t\t\t(len >= special_handler->magic_len &&\n\t\t\t\t\t memcmp (data, special_handler->magic, special_handler->magic_len) == 0)) {\n\t\t\t\tunsigned char *ndata = NULL;\n\t\t\t\tsize_t nlen = 0;\n\n\t\t\t\tif (!special_handler->handler (parser, data, len, &ndata, &nlen,\n\t\t\t\t\t\tspecial_handler->user_data)) {\n\t\t\t\t\tUCL_FREE(sizeof (struct ucl_chunk), chunk);\n\t\t\t\t\tucl_create_err (&parser->err, \"call for external handler failed\");\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tstruct ucl_parser_special_handler_chain *nchain;\n\t\t\t\tnchain = UCL_ALLOC (sizeof (*nchain));\n\t\t\t\tnchain->begin = ndata;\n\t\t\t\tnchain->len = nlen;\n\t\t\t\tnchain->special_handler = special_handler;\n\n\t\t\t\t\n\t\t\t\tLL_PREPEND (chunk->special_handlers, nchain);\n\n\t\t\t\tdata = ndata;\n\t\t\t\tlen = nlen;\n\t\t\t}\n\t\t}\n\n\t\tif (parse_type == UCL_PARSE_AUTO && len > 0) {\n\t\t\t\n\t\t\tif ((*data & 0x80) == 0x80 && (*data >= 0xdc && *data <= 0xdf)) {\n\t\t\t\tparse_type = UCL_PARSE_MSGPACK;\n\t\t\t}\n\t\t\telse if (*data == '(') {\n\t\t\t\tparse_type = UCL_PARSE_CSEXP;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparse_type = UCL_PARSE_UCL;\n\t\t\t}\n\t\t}\n\n\t\tchunk->begin = data;\n\t\tchunk->remain = len;\n\t\tchunk->pos = chunk->begin;\n\t\tchunk->end = chunk->begin + len;\n\t\tchunk->line = 1;\n\t\tchunk->column = 0;\n\t\tchunk->priority = priority;\n\t\tchunk->strategy = strat;\n\t\tchunk->parse_type = parse_type;\n\n\t\tif (parser->cur_file) {\n\t\t\tchunk->fname = strdup (parser->cur_file);\n\t\t}\n\n\t\tLL_PREPEND (parser->chunks, chunk);\n\t\tparser->recursion ++;\n\n\t\tif (parser->recursion > UCL_MAX_RECURSION) {\n\t\t\tucl_create_err (&parser->err, \"maximum include nesting limit is reached: %d\",\n\t\t\t\t\tparser->recursion);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (len > 0) {\n\t\t\t\n\t\t\tswitch (parse_type) {\n\t\t\tdefault:\n\t\t\tcase UCL_PARSE_UCL:\n\t\t\t\treturn ucl_state_machine (parser);\n\t\t\tcase UCL_PARSE_MSGPACK:\n\t\t\t\treturn ucl_parse_msgpack (parser);\n\t\t\tcase UCL_PARSE_CSEXP:\n\t\t\t\treturn ucl_parse_csexp (parser);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\tif (parser->top_obj == NULL) {\n\t\t\t\t\n\t\t\t\tparser->top_obj = ucl_object_new_full (UCL_OBJECT, priority);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tucl_create_err (&parser->err, \"a parser is in an invalid state\");\n\n\treturn false;\n}\n\nbool\nucl_parser_add_chunk_priority (struct ucl_parser *parser,\n\t\tconst unsigned char *data, size_t len, unsigned priority)\n{\n\t\n\tif (parser == NULL) {\n\t\treturn false;\n\t}", "Selected Statement": "\t\tLL_PREPEND (parser->chunks, chunk);\n", "Selected Pointer": "chunk", "Compared Statement": "\t\tchunk->begin = data;\n", "Compared Pointer": "data", "Aliasing": "No", "Function Input": {"data": {"type_category": "string", "concrete_type": "string", "value": "0x9e3779b1 <error: Cannot access memory at address 0x9e3779b1>"}, "len": {"type_category": "unknown", "concrete_type": "size_t", "value": "140737488346320"}, "parser": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdcc0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x7\n", "message": "Cannot access memory at address 0x7"}}, "priority": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}}, "Program Information": {"Project Name": "libucl"}, "idx": 213}
{"Programming Language": "C", "Source Code": "void\nucl_parser_free (struct ucl_parser *parser)\n{\n\tstruct ucl_stack *stack, *stmp;\n\tstruct ucl_macro *macro, *mtmp;\n\tstruct ucl_chunk *chunk, *ctmp;\n\tstruct ucl_pubkey *key, *ktmp;\n\tstruct ucl_variable *var, *vtmp;\n\tucl_object_t *tr, *trtmp;\n\n\tif (parser == NULL) {\n\t\treturn;\n\t}\n\n\tif (parser->top_obj != NULL) {\n\t\tucl_object_unref (parser->top_obj);\n\t}\n\n\tif (parser->includepaths != NULL) {\n\t\tucl_object_unref (parser->includepaths);\n\t}\n\n\tLL_FOREACH_SAFE (parser->stack, stack, stmp) {\n\t\tfree (stack);\n\t}\n\tHASH_ITER (hh, parser->macroes, macro, mtmp) {\n\t\tfree (macro->name);\n\t\tHASH_DEL (parser->macroes, macro);\n\t\tUCL_FREE (sizeof (struct ucl_macro), macro);\n\t}\n\tLL_FOREACH_SAFE (parser->chunks, chunk, ctmp) {\n\t\tucl_chunk_free (chunk);\n\t}\n\tLL_FOREACH_SAFE (parser->keys, key, ktmp) {\n\t\tUCL_FREE (sizeof (struct ucl_pubkey), key);\n\t}\n\tLL_FOREACH_SAFE (parser->variables, var, vtmp) {\n\t\tfree (var->value);\n\t\tfree (var->var);\n\t\tUCL_FREE (sizeof (struct ucl_variable), var);\n\t}\n\tLL_FOREACH_SAFE (parser->trash_objs, tr, trtmp) {\n\t\tucl_object_free_internal (tr, false, ucl_object_dtor_free);\n\t}\n\n\tif (parser->err != NULL) {\n\t\tutstring_free (parser->err);\n\t}\n\n\tif (parser->cur_file) {\n\t\tfree (parser->cur_file);\n\t}\n\n\tif (parser->comments) {\n\t\tucl_object_unref (parser->comments);\n\t}\n\n\tUCL_FREE (sizeof (struct ucl_parser), parser);", "Selected Statement": "\tLL_FOREACH_SAFE (parser->chunks, chunk, ctmp) {\n", "Selected Pointer": "chunk", "Compared Statement": "\tLL_FOREACH_SAFE (parser->stack, stack, stmp) {\n", "Compared Pointer": "stack", "Aliasing": "No", "Function Input": {"parser": {"type_category": "pointer", "concrete_type": "NULL"}}, "Program Information": {"Project Name": "libucl"}, "idx": 214}
{"Programming Language": "C", "Source Code": "void\nucl_parser_free (struct ucl_parser *parser)\n{\n\tstruct ucl_stack *stack, *stmp;\n\tstruct ucl_macro *macro, *mtmp;\n\tstruct ucl_chunk *chunk, *ctmp;\n\tstruct ucl_pubkey *key, *ktmp;\n\tstruct ucl_variable *var, *vtmp;\n\tucl_object_t *tr, *trtmp;\n\n\tif (parser == NULL) {\n\t\treturn;\n\t}\n\n\tif (parser->top_obj != NULL) {\n\t\tucl_object_unref (parser->top_obj);\n\t}\n\n\tif (parser->includepaths != NULL) {\n\t\tucl_object_unref (parser->includepaths);\n\t}\n\n\tLL_FOREACH_SAFE (parser->stack, stack, stmp) {\n\t\tfree (stack);\n\t}\n\tHASH_ITER (hh, parser->macroes, macro, mtmp) {\n\t\tfree (macro->name);\n\t\tHASH_DEL (parser->macroes, macro);\n\t\tUCL_FREE (sizeof (struct ucl_macro), macro);\n\t}\n\tLL_FOREACH_SAFE (parser->chunks, chunk, ctmp) {\n\t\tucl_chunk_free (chunk);\n\t}\n\tLL_FOREACH_SAFE (parser->keys, key, ktmp) {\n\t\tUCL_FREE (sizeof (struct ucl_pubkey), key);\n\t}\n\tLL_FOREACH_SAFE (parser->variables, var, vtmp) {\n\t\tfree (var->value);\n\t\tfree (var->var);\n\t\tUCL_FREE (sizeof (struct ucl_variable), var);\n\t}\n\tLL_FOREACH_SAFE (parser->trash_objs, tr, trtmp) {\n\t\tucl_object_free_internal (tr, false, ucl_object_dtor_free);\n\t}\n\n\tif (parser->err != NULL) {\n\t\tutstring_free (parser->err);\n\t}\n\n\tif (parser->cur_file) {\n\t\tfree (parser->cur_file);\n\t}\n\n\tif (parser->comments) {\n\t\tucl_object_unref (parser->comments);\n\t}\n\n\tUCL_FREE (sizeof (struct ucl_parser), parser);", "Selected Statement": "\tLL_FOREACH_SAFE (parser->chunks, chunk, ctmp) {\n", "Selected Pointer": "chunk", "Compared Statement": "\tLL_FOREACH_SAFE (parser->stack, stack, stmp) {\n", "Compared Pointer": "stack", "Aliasing": "No", "Function Input": {"parser": {"type_category": "pointer", "concrete_type": "NULL"}}, "Program Information": {"Project Name": "libucl"}, "idx": 215}
{"Programming Language": "C", "Source Code": "size_t len, unsigned priority, enum ucl_duplicate_strategy strat,\n\t\tenum ucl_parse_type parse_type)\n{\n\tstruct ucl_chunk *chunk;\n\tstruct ucl_parser_special_handler *special_handler;\n\n\tif (parser == NULL) {\n\t\treturn false;\n\t}\n\n\tif (data == NULL && len != 0) {\n\t\tucl_create_err (&parser->err, \"invalid chunk added\");\n\t\treturn false;\n\t}\n\n\tif (parser->state != UCL_STATE_ERROR) {\n\t\tchunk = UCL_ALLOC (sizeof (struct ucl_chunk));\n\t\tif (chunk == NULL) {\n\t\t\tucl_create_err (&parser->err, \"cannot allocate chunk structure\");\n\t\t\treturn false;\n\t\t}\n\n\t\tmemset (chunk, 0, sizeof (*chunk));\n\n\t\t\n\t\tLL_FOREACH (parser->special_handlers, special_handler) {\n\t\t\tif ((special_handler->flags & UCL_SPECIAL_HANDLER_PREPROCESS_ALL) ||\n\t\t\t\t\t(len >= special_handler->magic_len &&\n\t\t\t\t\t memcmp (data, special_handler->magic, special_handler->magic_len) == 0)) {\n\t\t\t\tunsigned char *ndata = NULL;\n\t\t\t\tsize_t nlen = 0;\n\n\t\t\t\tif (!special_handler->handler (parser, data, len, &ndata, &nlen,\n\t\t\t\t\t\tspecial_handler->user_data)) {\n\t\t\t\t\tUCL_FREE(sizeof (struct ucl_chunk), chunk);\n\t\t\t\t\tucl_create_err (&parser->err, \"call for external handler failed\");\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tstruct ucl_parser_special_handler_chain *nchain;\n\t\t\t\tnchain = UCL_ALLOC (sizeof (*nchain));\n\t\t\t\tnchain->begin = ndata;\n\t\t\t\tnchain->len = nlen;\n\t\t\t\tnchain->special_handler = special_handler;\n\n\t\t\t\t\n\t\t\t\tLL_PREPEND (chunk->special_handlers, nchain);\n\n\t\t\t\tdata = ndata;\n\t\t\t\tlen = nlen;\n\t\t\t}\n\t\t}\n\n\t\tif (parse_type == UCL_PARSE_AUTO && len > 0) {\n\t\t\t\n\t\t\tif ((*data & 0x80) == 0x80 && (*data >= 0xdc && *data <= 0xdf)) {\n\t\t\t\tparse_type = UCL_PARSE_MSGPACK;\n\t\t\t}\n\t\t\telse if (*data == '(') {\n\t\t\t\tparse_type = UCL_PARSE_CSEXP;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparse_type = UCL_PARSE_UCL;\n\t\t\t}\n\t\t}\n\n\t\tchunk->begin = data;\n\t\tchunk->remain = len;\n\t\tchunk->pos = chunk->begin;\n\t\tchunk->end = chunk->begin + len;\n\t\tchunk->line = 1;\n\t\tchunk->column = 0;\n\t\tchunk->priority = priority;\n\t\tchunk->strategy = strat;\n\t\tchunk->parse_type = parse_type;\n\n\t\tif (parser->cur_file) {\n\t\t\tchunk->fname = strdup (parser->cur_file);\n\t\t}\n\n\t\tLL_PREPEND (parser->chunks, chunk);\n\t\tparser->recursion ++;\n\n\t\tif (parser->recursion > UCL_MAX_RECURSION) {\n\t\t\tucl_create_err (&parser->err, \"maximum include nesting limit is reached: %d\",\n\t\t\t\t\tparser->recursion);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (len > 0) {\n\t\t\t\n\t\t\tswitch (parse_type) {\n\t\t\tdefault:\n\t\t\tcase UCL_PARSE_UCL:\n\t\t\t\treturn ucl_state_machine (parser);\n\t\t\tcase UCL_PARSE_MSGPACK:\n\t\t\t\treturn ucl_parse_msgpack (parser);\n\t\t\tcase UCL_PARSE_CSEXP:\n\t\t\t\treturn ucl_parse_csexp (parser);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\tif (parser->top_obj == NULL) {\n\t\t\t\t\n\t\t\t\tparser->top_obj = ucl_object_new_full (UCL_OBJECT, priority);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tucl_create_err (&parser->err, \"a parser is in an invalid state\");\n\n\treturn false;\n}\n\nbool\nucl_parser_add_chunk_priority (struct ucl_parser *parser,\n\t\tconst unsigned char *data, size_t len, unsigned priority)\n{\n\t\n\tif (parser == NULL) {\n\t\treturn false;\n\t}", "Selected Statement": "\t\tLL_PREPEND (parser->chunks, chunk);\n", "Selected Pointer": "chunk", "Compared Statement": "\t\tchunk->begin = data;\n", "Compared Pointer": "data", "Aliasing": "No", "Function Input": {"data": {"type_category": "string", "concrete_type": "string", "value": "0x9e3779b1 <error: Cannot access memory at address 0x9e3779b1>"}, "len": {"type_category": "unknown", "concrete_type": "size_t", "value": "140737488346320"}, "parser": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdcc0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x7\n", "message": "Cannot access memory at address 0x7"}}, "priority": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}}, "Program Information": {"Project Name": "libucl"}, "idx": 216}
{"Programming Language": "C", "Source Code": "size_t len, unsigned priority, enum ucl_duplicate_strategy strat,\n\t\tenum ucl_parse_type parse_type)\n{\n\tstruct ucl_chunk *chunk;\n\tstruct ucl_parser_special_handler *special_handler;\n\n\tif (parser == NULL) {\n\t\treturn false;\n\t}\n\n\tif (data == NULL && len != 0) {\n\t\tucl_create_err (&parser->err, \"invalid chunk added\");\n\t\treturn false;\n\t}\n\n\tif (parser->state != UCL_STATE_ERROR) {\n\t\tchunk = UCL_ALLOC (sizeof (struct ucl_chunk));\n\t\tif (chunk == NULL) {\n\t\t\tucl_create_err (&parser->err, \"cannot allocate chunk structure\");\n\t\t\treturn false;\n\t\t}\n\n\t\tmemset (chunk, 0, sizeof (*chunk));\n\n\t\t\n\t\tLL_FOREACH (parser->special_handlers, special_handler) {\n\t\t\tif ((special_handler->flags & UCL_SPECIAL_HANDLER_PREPROCESS_ALL) ||\n\t\t\t\t\t(len >= special_handler->magic_len &&\n\t\t\t\t\t memcmp (data, special_handler->magic, special_handler->magic_len) == 0)) {\n\t\t\t\tunsigned char *ndata = NULL;\n\t\t\t\tsize_t nlen = 0;\n\n\t\t\t\tif (!special_handler->handler (parser, data, len, &ndata, &nlen,\n\t\t\t\t\t\tspecial_handler->user_data)) {\n\t\t\t\t\tUCL_FREE(sizeof (struct ucl_chunk), chunk);\n\t\t\t\t\tucl_create_err (&parser->err, \"call for external handler failed\");\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tstruct ucl_parser_special_handler_chain *nchain;\n\t\t\t\tnchain = UCL_ALLOC (sizeof (*nchain));\n\t\t\t\tnchain->begin = ndata;\n\t\t\t\tnchain->len = nlen;\n\t\t\t\tnchain->special_handler = special_handler;\n\n\t\t\t\t\n\t\t\t\tLL_PREPEND (chunk->special_handlers, nchain);\n\n\t\t\t\tdata = ndata;\n\t\t\t\tlen = nlen;\n\t\t\t}\n\t\t}\n\n\t\tif (parse_type == UCL_PARSE_AUTO && len > 0) {\n\t\t\t\n\t\t\tif ((*data & 0x80) == 0x80 && (*data >= 0xdc && *data <= 0xdf)) {\n\t\t\t\tparse_type = UCL_PARSE_MSGPACK;\n\t\t\t}\n\t\t\telse if (*data == '(') {\n\t\t\t\tparse_type = UCL_PARSE_CSEXP;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparse_type = UCL_PARSE_UCL;\n\t\t\t}\n\t\t}\n\n\t\tchunk->begin = data;\n\t\tchunk->remain = len;\n\t\tchunk->pos = chunk->begin;\n\t\tchunk->end = chunk->begin + len;\n\t\tchunk->line = 1;\n\t\tchunk->column = 0;\n\t\tchunk->priority = priority;\n\t\tchunk->strategy = strat;\n\t\tchunk->parse_type = parse_type;\n\n\t\tif (parser->cur_file) {\n\t\t\tchunk->fname = strdup (parser->cur_file);\n\t\t}\n\n\t\tLL_PREPEND (parser->chunks, chunk);\n\t\tparser->recursion ++;\n\n\t\tif (parser->recursion > UCL_MAX_RECURSION) {\n\t\t\tucl_create_err (&parser->err, \"maximum include nesting limit is reached: %d\",\n\t\t\t\t\tparser->recursion);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (len > 0) {\n\t\t\t\n\t\t\tswitch (parse_type) {\n\t\t\tdefault:\n\t\t\tcase UCL_PARSE_UCL:\n\t\t\t\treturn ucl_state_machine (parser);\n\t\t\tcase UCL_PARSE_MSGPACK:\n\t\t\t\treturn ucl_parse_msgpack (parser);\n\t\t\tcase UCL_PARSE_CSEXP:\n\t\t\t\treturn ucl_parse_csexp (parser);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\tif (parser->top_obj == NULL) {\n\t\t\t\t\n\t\t\t\tparser->top_obj = ucl_object_new_full (UCL_OBJECT, priority);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tucl_create_err (&parser->err, \"a parser is in an invalid state\");\n\n\treturn false;\n}\n\nbool\nucl_parser_add_chunk_priority (struct ucl_parser *parser,\n\t\tconst unsigned char *data, size_t len, unsigned priority)\n{\n\t\n\tif (parser == NULL) {\n\t\treturn false;\n\t}", "Selected Statement": "\t\tLL_PREPEND (parser->chunks, chunk);\n", "Selected Pointer": "chunk", "Compared Statement": "\t\tchunk->begin = data;\n", "Compared Pointer": "data", "Aliasing": "No", "Function Input": {"data": {"type_category": "string", "concrete_type": "string", "value": "0x9e3779b1 <error: Cannot access memory at address 0x9e3779b1>"}, "len": {"type_category": "unknown", "concrete_type": "size_t", "value": "140737488346320"}, "parser": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdcc0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x7\n", "message": "Cannot access memory at address 0x7"}}, "priority": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}}, "Program Information": {"Project Name": "libucl"}, "idx": 217}
{"Programming Language": "C", "Source Code": "size_t len, unsigned priority, enum ucl_duplicate_strategy strat,\n\t\tenum ucl_parse_type parse_type)\n{\n\tstruct ucl_chunk *chunk;\n\tstruct ucl_parser_special_handler *special_handler;\n\n\tif (parser == NULL) {\n\t\treturn false;\n\t}\n\n\tif (data == NULL && len != 0) {\n\t\tucl_create_err (&parser->err, \"invalid chunk added\");\n\t\treturn false;\n\t}\n\n\tif (parser->state != UCL_STATE_ERROR) {\n\t\tchunk = UCL_ALLOC (sizeof (struct ucl_chunk));\n\t\tif (chunk == NULL) {\n\t\t\tucl_create_err (&parser->err, \"cannot allocate chunk structure\");\n\t\t\treturn false;\n\t\t}\n\n\t\tmemset (chunk, 0, sizeof (*chunk));\n\n\t\t\n\t\tLL_FOREACH (parser->special_handlers, special_handler) {\n\t\t\tif ((special_handler->flags & UCL_SPECIAL_HANDLER_PREPROCESS_ALL) ||\n\t\t\t\t\t(len >= special_handler->magic_len &&\n\t\t\t\t\t memcmp (data, special_handler->magic, special_handler->magic_len) == 0)) {\n\t\t\t\tunsigned char *ndata = NULL;\n\t\t\t\tsize_t nlen = 0;\n\n\t\t\t\tif (!special_handler->handler (parser, data, len, &ndata, &nlen,\n\t\t\t\t\t\tspecial_handler->user_data)) {\n\t\t\t\t\tUCL_FREE(sizeof (struct ucl_chunk), chunk);\n\t\t\t\t\tucl_create_err (&parser->err, \"call for external handler failed\");\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tstruct ucl_parser_special_handler_chain *nchain;\n\t\t\t\tnchain = UCL_ALLOC (sizeof (*nchain));\n\t\t\t\tnchain->begin = ndata;\n\t\t\t\tnchain->len = nlen;\n\t\t\t\tnchain->special_handler = special_handler;\n\n\t\t\t\t\n\t\t\t\tLL_PREPEND (chunk->special_handlers, nchain);\n\n\t\t\t\tdata = ndata;\n\t\t\t\tlen = nlen;\n\t\t\t}\n\t\t}\n\n\t\tif (parse_type == UCL_PARSE_AUTO && len > 0) {\n\t\t\t\n\t\t\tif ((*data & 0x80) == 0x80 && (*data >= 0xdc && *data <= 0xdf)) {\n\t\t\t\tparse_type = UCL_PARSE_MSGPACK;\n\t\t\t}\n\t\t\telse if (*data == '(') {\n\t\t\t\tparse_type = UCL_PARSE_CSEXP;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparse_type = UCL_PARSE_UCL;\n\t\t\t}\n\t\t}\n\n\t\tchunk->begin = data;\n\t\tchunk->remain = len;\n\t\tchunk->pos = chunk->begin;\n\t\tchunk->end = chunk->begin + len;\n\t\tchunk->line = 1;\n\t\tchunk->column = 0;\n\t\tchunk->priority = priority;\n\t\tchunk->strategy = strat;\n\t\tchunk->parse_type = parse_type;\n\n\t\tif (parser->cur_file) {\n\t\t\tchunk->fname = strdup (parser->cur_file);\n\t\t}\n\n\t\tLL_PREPEND (parser->chunks, chunk);\n\t\tparser->recursion ++;\n\n\t\tif (parser->recursion > UCL_MAX_RECURSION) {\n\t\t\tucl_create_err (&parser->err, \"maximum include nesting limit is reached: %d\",\n\t\t\t\t\tparser->recursion);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (len > 0) {\n\t\t\t\n\t\t\tswitch (parse_type) {\n\t\t\tdefault:\n\t\t\tcase UCL_PARSE_UCL:\n\t\t\t\treturn ucl_state_machine (parser);\n\t\t\tcase UCL_PARSE_MSGPACK:\n\t\t\t\treturn ucl_parse_msgpack (parser);\n\t\t\tcase UCL_PARSE_CSEXP:\n\t\t\t\treturn ucl_parse_csexp (parser);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\tif (parser->top_obj == NULL) {\n\t\t\t\t\n\t\t\t\tparser->top_obj = ucl_object_new_full (UCL_OBJECT, priority);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tucl_create_err (&parser->err, \"a parser is in an invalid state\");\n\n\treturn false;\n}\n\nbool\nucl_parser_add_chunk_priority (struct ucl_parser *parser,\n\t\tconst unsigned char *data, size_t len, unsigned priority)\n{\n\t\n\tif (parser == NULL) {\n\t\treturn false;\n\t}", "Selected Statement": "\t\tLL_PREPEND (parser->chunks, chunk);\n", "Selected Pointer": "chunk", "Compared Statement": "\t\tchunk->begin = data;\n", "Compared Pointer": "data", "Aliasing": "No", "Function Input": {"data": {"type_category": "string", "concrete_type": "string", "value": "0x9e3779b1 <error: Cannot access memory at address 0x9e3779b1>"}, "len": {"type_category": "unknown", "concrete_type": "size_t", "value": "140737488346320"}, "parser": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdcc0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x7\n", "message": "Cannot access memory at address 0x7"}}, "priority": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}}, "Program Information": {"Project Name": "libucl"}, "idx": 218}
{"Programming Language": "C", "Source Code": "size_t len, unsigned priority, enum ucl_duplicate_strategy strat,\n\t\tenum ucl_parse_type parse_type)\n{\n\tstruct ucl_chunk *chunk;\n\tstruct ucl_parser_special_handler *special_handler;\n\n\tif (parser == NULL) {\n\t\treturn false;\n\t}\n\n\tif (data == NULL && len != 0) {\n\t\tucl_create_err (&parser->err, \"invalid chunk added\");\n\t\treturn false;\n\t}\n\n\tif (parser->state != UCL_STATE_ERROR) {\n\t\tchunk = UCL_ALLOC (sizeof (struct ucl_chunk));\n\t\tif (chunk == NULL) {\n\t\t\tucl_create_err (&parser->err, \"cannot allocate chunk structure\");\n\t\t\treturn false;\n\t\t}\n\n\t\tmemset (chunk, 0, sizeof (*chunk));\n\n\t\t\n\t\tLL_FOREACH (parser->special_handlers, special_handler) {\n\t\t\tif ((special_handler->flags & UCL_SPECIAL_HANDLER_PREPROCESS_ALL) ||\n\t\t\t\t\t(len >= special_handler->magic_len &&\n\t\t\t\t\t memcmp (data, special_handler->magic, special_handler->magic_len) == 0)) {\n\t\t\t\tunsigned char *ndata = NULL;\n\t\t\t\tsize_t nlen = 0;\n\n\t\t\t\tif (!special_handler->handler (parser, data, len, &ndata, &nlen,\n\t\t\t\t\t\tspecial_handler->user_data)) {\n\t\t\t\t\tUCL_FREE(sizeof (struct ucl_chunk), chunk);\n\t\t\t\t\tucl_create_err (&parser->err, \"call for external handler failed\");\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tstruct ucl_parser_special_handler_chain *nchain;\n\t\t\t\tnchain = UCL_ALLOC (sizeof (*nchain));\n\t\t\t\tnchain->begin = ndata;\n\t\t\t\tnchain->len = nlen;\n\t\t\t\tnchain->special_handler = special_handler;\n\n\t\t\t\t\n\t\t\t\tLL_PREPEND (chunk->special_handlers, nchain);\n\n\t\t\t\tdata = ndata;\n\t\t\t\tlen = nlen;\n\t\t\t}\n\t\t}\n\n\t\tif (parse_type == UCL_PARSE_AUTO && len > 0) {\n\t\t\t\n\t\t\tif ((*data & 0x80) == 0x80 && (*data >= 0xdc && *data <= 0xdf)) {\n\t\t\t\tparse_type = UCL_PARSE_MSGPACK;\n\t\t\t}\n\t\t\telse if (*data == '(') {\n\t\t\t\tparse_type = UCL_PARSE_CSEXP;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparse_type = UCL_PARSE_UCL;\n\t\t\t}\n\t\t}\n\n\t\tchunk->begin = data;\n\t\tchunk->remain = len;\n\t\tchunk->pos = chunk->begin;\n\t\tchunk->end = chunk->begin + len;\n\t\tchunk->line = 1;\n\t\tchunk->column = 0;\n\t\tchunk->priority = priority;\n\t\tchunk->strategy = strat;\n\t\tchunk->parse_type = parse_type;\n\n\t\tif (parser->cur_file) {\n\t\t\tchunk->fname = strdup (parser->cur_file);\n\t\t}\n\n\t\tLL_PREPEND (parser->chunks, chunk);\n\t\tparser->recursion ++;\n\n\t\tif (parser->recursion > UCL_MAX_RECURSION) {\n\t\t\tucl_create_err (&parser->err, \"maximum include nesting limit is reached: %d\",\n\t\t\t\t\tparser->recursion);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (len > 0) {\n\t\t\t\n\t\t\tswitch (parse_type) {\n\t\t\tdefault:\n\t\t\tcase UCL_PARSE_UCL:\n\t\t\t\treturn ucl_state_machine (parser);\n\t\t\tcase UCL_PARSE_MSGPACK:\n\t\t\t\treturn ucl_parse_msgpack (parser);\n\t\t\tcase UCL_PARSE_CSEXP:\n\t\t\t\treturn ucl_parse_csexp (parser);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\tif (parser->top_obj == NULL) {\n\t\t\t\t\n\t\t\t\tparser->top_obj = ucl_object_new_full (UCL_OBJECT, priority);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tucl_create_err (&parser->err, \"a parser is in an invalid state\");\n\n\treturn false;\n}\n\nbool\nucl_parser_add_chunk_priority (struct ucl_parser *parser,\n\t\tconst unsigned char *data, size_t len, unsigned priority)\n{\n\t\n\tif (parser == NULL) {\n\t\treturn false;\n\t}", "Selected Statement": "\t\tchunk->begin = data;\n", "Selected Pointer": "data", "Compared Statement": "\t\tLL_PREPEND (parser->chunks, chunk);\n", "Compared Pointer": "chunk", "Aliasing": "No", "Function Input": {"data": {"type_category": "string", "concrete_type": "string", "value": "0x9e3779b1 <error: Cannot access memory at address 0x9e3779b1>"}, "len": {"type_category": "unknown", "concrete_type": "size_t", "value": "140737488346320"}, "parser": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdcc0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x7\n", "message": "Cannot access memory at address 0x7"}}, "priority": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}}, "Program Information": {"Project Name": "libucl"}, "idx": 219}
{"Programming Language": "C", "Source Code": "void\nucl_parser_free (struct ucl_parser *parser)\n{\n\tstruct ucl_stack *stack, *stmp;\n\tstruct ucl_macro *macro, *mtmp;\n\tstruct ucl_chunk *chunk, *ctmp;\n\tstruct ucl_pubkey *key, *ktmp;\n\tstruct ucl_variable *var, *vtmp;\n\tucl_object_t *tr, *trtmp;\n\n\tif (parser == NULL) {\n\t\treturn;\n\t}\n\n\tif (parser->top_obj != NULL) {\n\t\tucl_object_unref (parser->top_obj);\n\t}\n\n\tif (parser->includepaths != NULL) {\n\t\tucl_object_unref (parser->includepaths);\n\t}\n\n\tLL_FOREACH_SAFE (parser->stack, stack, stmp) {\n\t\tfree (stack);\n\t}\n\tHASH_ITER (hh, parser->macroes, macro, mtmp) {\n\t\tfree (macro->name);\n\t\tHASH_DEL (parser->macroes, macro);\n\t\tUCL_FREE (sizeof (struct ucl_macro), macro);\n\t}\n\tLL_FOREACH_SAFE (parser->chunks, chunk, ctmp) {\n\t\tucl_chunk_free (chunk);\n\t}\n\tLL_FOREACH_SAFE (parser->keys, key, ktmp) {\n\t\tUCL_FREE (sizeof (struct ucl_pubkey), key);\n\t}\n\tLL_FOREACH_SAFE (parser->variables, var, vtmp) {\n\t\tfree (var->value);\n\t\tfree (var->var);\n\t\tUCL_FREE (sizeof (struct ucl_variable), var);\n\t}\n\tLL_FOREACH_SAFE (parser->trash_objs, tr, trtmp) {\n\t\tucl_object_free_internal (tr, false, ucl_object_dtor_free);\n\t}\n\n\tif (parser->err != NULL) {\n\t\tutstring_free (parser->err);\n\t}\n\n\tif (parser->cur_file) {\n\t\tfree (parser->cur_file);\n\t}\n\n\tif (parser->comments) {\n\t\tucl_object_unref (parser->comments);\n\t}\n\n\tUCL_FREE (sizeof (struct ucl_parser), parser);", "Selected Statement": "\t\tHASH_DEL (parser->macroes, macro);\n", "Selected Pointer": "macro", "Compared Statement": "\tLL_FOREACH_SAFE (parser->variables, var, vtmp) {\n", "Compared Pointer": "var", "Aliasing": "No", "Function Input": {"parser": {"type_category": "pointer", "concrete_type": "NULL"}}, "Program Information": {"Project Name": "libucl"}, "idx": 220}
{"Programming Language": "C", "Source Code": "static void\nws_alloc_free(struct ws_emu *we, struct ws_alloc **wap)\n{\n\tstruct ws_alloc *wa;\n\n\tTAKE_OBJ_NOTNULL(wa, wap, WS_ALLOC_MAGIC);\n\tAZ(VTAILQ_NEXT(wa, list));\n\tVTAILQ_REMOVE(&we->head, wa, list);\n\tfree(wa->ptr);\n\tFREE_OBJ(wa);\n}\n\nvoid\nWS_Reset(struct ws *ws, uintptr_t pp)\n{\n\tstruct ws_emu *we;\n\tstruct ws_alloc *wa;\n\tchar *p;\n\n\tWS_Assert(ws);\n\tAN(pp);\n\tif (pp == snap_overflowed) {\n\t\tDSLb(DBG_WORKSPACE, \"WS_Reset(%p, overflowed)\", ws);\n\t\tAN(WS_Overflowed(ws));\n\t\treturn;\n\t}\n\tp = (char *)pp;\n\tDSLb(DBG_WORKSPACE, \"WS_Reset(%p, %p)\", ws, p);\n\tAZ(ws->r);\n\n\twe = ws_emu(ws);", "Selected Statement": "\tTAKE_OBJ_NOTNULL(wa, wap, WS_ALLOC_MAGIC);\n", "Selected Pointer": "wap", "Compared Statement": "\twe = ws_emu(ws);\n", "Compared Pointer": "ws", "Aliasing": "No", "Function Input": {"wap": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffcfb0", "value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd0e0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3f81c89b6ab\n", "message": "Cannot access memory at address 0x3f81c89b6ab"}}}, "we": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffcfb8", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"magic": {"type_category": "int", "concrete_type": "unsigned int", "value": "905626964"}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "7431538"}, "ws": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd518", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"magic": {"type_category": "int", "concrete_type": "unsigned int", "value": "478787243"}, "id": {"type_category": "string", "concrete_type": "string", "value": "\"\\370\\003\\000\""}, "s": {"type_category": "string", "concrete_type": "NULL"}, "f": {"type_category": "string", "concrete_type": "string", "value": "0xec7bf0 \"\\005\\375\\347\\\"\""}, "r": {"type_category": "string", "concrete_type": "string", "value": "0xec7c08 \"\""}, "e": {"type_category": "string", "concrete_type": "string", "value": "0x7ffff7a535a8 \"F\\001u\\017\\337\\216\\226b\\244\\255+\\005\\222\\216\\204~{\\307d\\363\\251]\\017\\375Xf\\363\\224\\206K\\205\\346\\001\\323J3\\343\\017\\224\\037]\\b\\262\\343\\\\\\361\\017\\365\\244\\355K\\224\\222\\002}\\033\\034\\304,\\031\\234\\256\\336>GX7\\017\\246RO\\020\\252\\255+\\005\\272\\2622\\250\\241_2\\005\\344\\340\\366\\376\\002\\341G\\250\\333\\0303\\272\\252,:\\202\\272\\312\\366\\243^\\366a\\353m0X1.\\306\\306#\\216\\365\\343\\263B\\243\\001\\361\\371\\031sBh\\t\\232\\367\\344\\2614\\360\\370\\031sB\\215\\210k\\340\\236J\\\\e\\336\\210\\240^\\006%\\367\\f\\220\\251\\375\\364\\372\\031sBI\\3600\\206\\004&)\\005\\360\\024\\214\\357%\\211\\242\\202\\354\\222s\\360\\326\\204\\364\\245\\202\\034\\333\\370[\\213\\212\\034\\252\\201e\\216\\202\\337\\263\\224\\210y\\305A\\b\\260g3\\343W\\304\\030xR.\\251\\023\\243v\\376\\fK\\356o\\177\\213\\b\\224\\v&)\\005\\316\\205\\032\\021\\0348\\203\\333(f\\213\\222bD\\230\\376n<\\224|\\237\\353~\\206\\\\Z\\0221\\352A\\274\\376~U\\335q\\\"\\222$\\017\\366\\001\\331\\177~U\\335qI@\\204\\026\\355\\206\\205e~x\\265$s<\\224|n\\003M\\027\\332\\004\\320\\002\\017\\362@\\216&ka\\020\\t\\345k\\255Bw)\\221R\\266O\\361\\020\\247Z\\331^\\330\\204\\323u<\\224|\\374U\\217z#\\366\\305't\\376t\\227\\\"g>N\\n\\256\\235g#g>NV\\323\\003\\266\\340`v\\017\\240\\270C\\302\\371\\033\\236|\\016B\\025\\2634\\223M\\215Z\\232;\\017+-$\\202\\336\\306as\\272\\036\\265\\003\\2457\\202\\325\\220\\3236\\263\\220\\256@\\034\\341F\\336\\017\\036h\\200\\332\\315\\313\\374\\266\\362'i\\036\\367\\346\\230\\030\\263\\332\\024uv\\327\\233|\\251\\006u\\020\\251J.\\251\\236\\243\\316f\\363\\241\\311\\2006t\\210\\vY\\212\\230||\\350\\211h\\270\\332\\024uc~0\\312\\222\\207\\267\\026\\305\\250U_[s\\350\\317\\360\\022\\365\\253\\334\\024\\276\\343\\376\\177\\311x\\273U\\242\\n\\\"%\\250\\215\\277'\\0256\\344\\211\\240\\226\\374\\304\\300\\034\\254\\343\\275 \\242Z\\357\\220\\312\\356\\351\\035h\\351R\\030\\255\\271rM\\262\\224\\323g\\272\\225\\223\\034\\004e\\350\\365\\237\\372\\335\\016\\333\\f\\026\\211\\367\\vO]\\314&\\b\\203\\340\\237\\251\\304%\\257\\305'\\3664\\322\\356f3\\335\\305f3\\335\\305f3\\335\\305g3\\335\\305ho\\0037\\202\\216l\\023T\\024Gn\\355\\316%\\\"(\\262\\377\\023\\362\\234%\\311\\201n3i\\372\\217\\360\\023z2\\377=\\243\\3679\\276n\\317\\351\\225\\266\\270\\245\\357S\\200\\210\\203?\\371\\377\\2747\\025\\025e\\262-.\\326)\\234\\205\\020\\342Y\\004]\\202\\263\\253#\\026\\353Gij\\201\\362\\031\\271\\237\\016>?:,i@:,i\\232\\\\\\210\\vs\\372\\201\\033\\354\\016\\351\\312\\205k\\004w&l\\\"6v\\367\\263>z%\\223\\250%:\\375\\031\\214d\\2338\\214!\\220\\020\\3571u\\031h\\2328#Ni\\332\\260$\\331\\224V\\326A<\\n\\367\\316\\327\\342\\242S\\320\\016fY/\\345\\332\""}}}}, "head": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"vtqh_first": {"type_category": "pointer", "concrete_type": "NULL"}, "vtqh_last": {"type_category": "pointer", "concrete_type": "NULL"}}}}}}}, "Program Information": {"Project Name": "varnish"}, "idx": 221}
{"Programming Language": "C", "Source Code": "extern \"C\" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size)\n{\n  char test_file[] = \"libfuzzer.xml\";\n\n  FILE* fp = fopen(test_file, \"wb\");\n  if (!fp)\n    return 0;\n  fwrite(data, size, 1, fp);\n  fclose(fp);\n\n  cmXMLParser parser;", "Selected Statement": "  fwrite(data, size, 1, fp);\n", "Selected Pointer": "data", "Compared Statement": "  FILE* fp = fopen(test_file, \"wb\");\n", "Compared Pointer": "test_file", "Aliasing": "No", "Function Input": {"data": {"type_category": "string", "concrete_type": "string", "value": "0x103b010 \"\""}, "size": {"type_category": "unknown", "concrete_type": "size_t", "value": "6554624"}}, "Program Information": {"Project Name": "cmake"}, "idx": 222}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\rs\\n\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "16"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 223}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "4"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 224}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "3"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 225}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\r\\r\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "3"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 226}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "rest", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "tmp", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "4"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 227}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "rest", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "tmp", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\262CRo\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "8"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 228}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\rq:\\377\\377\\377\\377\\277]\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "2"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 229}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\r\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "2"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 230}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\r\\r\\r\\r\\r\\r\\r\\regAContactF:2\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "12"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 231}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "rest", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "tmp", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\r\\r\\r\\r\\r\\r\\r\\re!ogAna:4\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "10"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 232}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\312\\277\\377\\377\\377\\377\\377\\377\\377^\\377\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "4"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 233}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\255\\n!!!!!!!!\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "3"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 234}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"B\\n\\r\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "4"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 235}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\377\\n\\377\\377\\377\\377\\377\\377\\377\\377\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "3"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 236}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "4"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 237}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\r\\r\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "3"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 238}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "rest", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "tmp", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\n\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "2"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 239}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\r\\r\\r\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "4"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 240}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\r\\r\\r\\r\\r\\r\\r\\regAContaa\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "9"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 241}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "rest", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "tmp", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\212\\216\\212\\212\\377\\212\\n)\\212\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "2"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 242}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\r\\rCS\\377\\377\\277\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "2"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 243}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"ROut\\377\\377\\377e\\377\\003\\177\\n\\nx$\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "8"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 244}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "3"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 245}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\n\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "2"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 246}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "8"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 247}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\r\\r\\r\\r\\r\\r\\regAContaa \""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "9"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 248}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "rest", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "tmp", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"%\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "8"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 249}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\212\\212\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "3"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 250}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\rsB\\n\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "16"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 251}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\267\\267,Y\\372\\266>#,y\\372\\266\\267\\247\\305\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "8"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 252}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "rest", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "tmp", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\r\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "2"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 253}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \" \\n!!\\306\\031!!!!!\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "4"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 254}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\332\\n\\232\\372\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "2"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 255}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\377\\n\\377\\377\\377\\377\\367\\377\\377\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "2"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 256}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "rest", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "tmp", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\nContact:\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "2"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 257}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\377\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "8"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 258}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\n!!!!!!!!\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "2"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 259}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "2"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 260}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \">Via::>\\370\\n\\377\\377\\377\\377\\377\\v\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "8"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 261}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\ri\\326Cal\\267\\267\\n\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "2"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 262}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\r\\r\\r ))):\\n\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "4"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 263}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"^^^^^^^^^^\\n\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "4"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 264}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "rest", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "tmp", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "4"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 265}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "rest", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "tmp", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\356\\356\\356\\356\\356\\356\\356\\356\\356\\356\\356\\356\\356\\356\\356\\356\\377\\377\\377\\377\\377\\377t\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "16"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 266}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "rest", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "tmp", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\n\\r\\r\\r\\r\\r\\r\\r\\362\\362\\362 /1(O \""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "9"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 267}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\215\\n\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "4"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 268}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "rest", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "tmp", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\212\\n\\212\\212\\212\\212\\212\\212\\212\\n\\372\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "4"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 269}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "rest", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "tmp", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\r\\r\\r\\r\\r\\r\\r\\reServer:0rINF:2\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "16"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 270}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\377\\377\\377\\377\\377\\377\\377\\3773NO\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "4"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 271}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\267\\267\\247\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "3"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 272}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\267\\267Y\\377H\\301H\\267H\\247\\305\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "4"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 273}
{"Programming Language": "C", "Source Code": "inline static char* eat_space_end(const char* p, const char* pend)\n{\n\tfor(;(p<pend)&&(*p==' ' || *p=='\\t') ;p++);\n\treturn (char *)p;\n}\n#define SP(_c) ((_c)=='\\t' || (_c)==' ')\ninline static char* eat_lws_end(const char* p, const char* pend)\n{\n\twhile(p<pend) {\n\t\tif (SP(*p)) p++;\n\t\t\n\t\telse if (*p=='\\n' && p+1<pend && SP(*(p+1))) p+=2;\n\t\telse if (*p=='\\r' && p+2<pend && *(p+1)=='\\n'\n\t\t\t\t\t&& SP(*(p+2))) p+=3;\n\t\telse break; \n\t}\n\treturn (char *)p;\n}\n\n\n\ninline static char* eat_token_end(const char* p, const char* pend)\n{\n\tfor (;(p<pend)&&(*p!=' ')&&(*p!='\\t')&&(*p!='\\n')&&(*p!='\\r'); p++);\n\treturn (char *)p;\n}\n\n\n\ninline static char* eat_token2_end(const char* p, const char* pend, char delim)\n{\n\tfor (;(p<pend)&&(*p!=(delim))&&(*p!='\\n')&&(*p!='\\r'); p++);\n\treturn (char *)p;\n}\n\n\n\ninline static int is_empty_end(const char* p, const char* pend )\n{", "Selected Statement": "\tfor(;(p<pend)&&(*p==' ' || *p=='\\t') ;p++);\n", "Selected Pointer": "p", "Compared Statement": "\tfor(;(p<pend)&&(*p==' ' || *p=='\\t') ;p++);\n", "Compared Pointer": "pend", "Aliasing": "Yes", "Function Input": {"p": {"type_category": "string", "concrete_type": "string", "value": "0x76d25db \" /  / A\""}, "pend": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"User-User-P /  / A\""}}, "Program Information": {"Project Name": "opensips"}, "idx": 274}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "rest", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "tmp", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"C\\nall-IC]l\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "3"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 275}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\r\\n\\n\\n\\n\\n\\n\\n\\n*\\031\\031\\031BE\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "10"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 276}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\r\\r\\r\\r\\r\\r\\r\\reC!ogAna:4\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "10"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 277}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\n\\370'f\\377\\377;\\377\\v\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "2"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 278}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "3"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 279}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\r\\r\\r\\r\\r\\r\\r''Contaa\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "8"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 280}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "rest", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "tmp", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\300\\n\\377\\n\\377\\377\\277\\377\\371\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "2"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 281}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "2"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 282}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "rest", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "tmp", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\343\\n\\r\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "4"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 283}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\n\\267\\267\\247\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "2"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 284}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\n0\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "2"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 285}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"applicatio/sdp\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "8"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 286}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "rest", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "tmp", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\r\\r\\r\\r\\r\\r\\r\\r\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "9"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 287}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "rest", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "tmp", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"BYE!!\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "4"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 288}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\343\\n\\332\\232\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "4"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 289}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\364\\nC\\351ClCl-\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "2"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 290}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\r\\r\\vBYEYE\\373\\250\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "3"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 291}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\r\\rNF\\212\\n\\372%\\n\\n\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "3"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 292}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "rest", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "tmp", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\r\\253\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "2"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 293}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\212\\n\\212\\252\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "2"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 294}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\370\\n\\377\\377\\377\\377\\377\\377\\377\\v\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "3"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 295}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "rest", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "tmp", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\262C]ll-ID:\\n\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "3"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 296}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "rest", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "tmp", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "3"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 297}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"/\\n\\r\\206\\216\\016\\001\\206\\206\\001n\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "4"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 298}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\r\\212\\212\\212\\207\\212\\n\\372\\n\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "2"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 299}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "rest", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "tmp", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\377\\n\\377\\377\\377\\001\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "2"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 300}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "rest", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "tmp", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\n\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "2"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 301}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"E\\n\\r\\003\\rBYE\\n\\003\\003\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "4"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 302}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"'\\n\\rQ\\370\\377\\3772uAT\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "4"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 303}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\nCall\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "2"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 304}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "rest", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "tmp", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"-\\rCnac:ot\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "16"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 305}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"%\\020\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "4"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 306}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\r\\r\\r\\r\\r\\r\\r\\re!ogAna: \""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "8"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 307}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\212\\n\\r\\r\\212\\b\\372%\\n\\n\\n\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "4"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 308}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "rest", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "tmp", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"%\\n\\377\\377\\377\\377\\377\\377\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "3"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 309}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\r\\r\\r\\r\\r\\r\\r\\regAContc2\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "10"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 310}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\267\\n\\267Cal-\\311D\\032\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "3"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 311}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\r\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "2"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 312}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\r\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "2"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 313}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "rest", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "tmp", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\rs\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "16"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 314}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\312\\377\\377\\377\\n\\377\\377\\377\\377\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "2"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 315}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "4"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 316}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "rest", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "tmp", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\r\\r\\r>Vi\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "4"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 317}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"INVE\\266\\261\\314\\261(\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "2"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 318}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\377\\n\\r\\375\\n\\3764\\377\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "4"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 319}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\r\\r\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "3"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 320}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\370\\n'f\\377\\377\\377\\377\\377\\377\\v\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "4"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 321}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\212\\n\\377\\377\\377\\003\\212\\212\\212\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "2"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 322}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \" \\n!!!!!!!\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "2"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 323}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\\"\\n\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "2"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 324}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "rest", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "tmp", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffd310 \"\\b\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "32767"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x403869"}}, "Program Information": {"Project Name": "opensips"}, "idx": 325}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "rest", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "tmp", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "4"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 326}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "rest", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "tmp", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"1 INVITE\\325CCCINO\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "8"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 327}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "rest", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "tmp", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "16"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 328}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "rest", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "tmp", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "4"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 329}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\r\\rCnac:ott\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "3"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 330}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "rest", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "tmp", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\r\\r\\r\\212\\b%\\372\\234\\n\\n\\n\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "4"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 331}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"%\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "3"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 332}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "rest", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "tmp", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \" !!\\n!!!!!\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "2"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 333}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r]\\n\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "16"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 334}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\n\\332\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "4"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 335}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "3"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 336}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "rest", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "tmp", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\377\\nC]\\nC]ont:\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "4"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 337}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "4"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 338}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\rsB\\n\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "16"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 339}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\n\\212\\212\\212\\207\\212\\n\\372\\n\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "2"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 340}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\312\\377\\377\\377\\377\\377\\377\\377\\377\\377\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "3"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 341}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "4"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 342}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "rest", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "tmp", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\rB\\n\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "16"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 343}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "rest", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "tmp", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\267\\267\\247\\267>\\267\\267\\267\\n\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "2"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 344}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "rest", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "tmp", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"!!!\\n\\337\\337\\336!!!\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "3"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 345}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\212\\212\\212\\212\\212\\212\\212\\212\\212\\n\\372\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "4"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 346}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"!!! !!\\n!!!\\333\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "4"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 347}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\rs\\nmax-E\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "16"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 348}
{"Programming Language": "C", "Source Code": "int parse_msg(char* buf, unsigned int len, struct sip_msg* msg)\n{\n\n\tchar *tmp;\n\tchar* rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor (tmp=buf; (unsigned int)(tmp-buf) < len\n\t        && (*tmp=='\\n' || *tmp=='\\r'); tmp++);\n\toffset=tmp-buf;\n\tfl=&(msg->first_line);\n\trest=parse_first_line(tmp, len-offset, fl);\n\n\toffset+=rest-tmp;\n\ttmp=rest;\n\tswitch(fl->type){\n\t\tcase SIP_INVALID:\n\t\t\tLM_DBG(\"invalid message\\n\");\n\t\t\t\n\t\t\tmsg->unparsed = msg->buf + msg->len;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tLM_DBG(\"SIP Request:\\n\");\n\t\t\tLM_DBG(\" method:  <%.*s>\\n\",fl->u.request.method.len,\n\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tLM_DBG(\" uri:     <%.*s>\\n\",fl->u.request.uri.len,\n\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.request.version.len,\n\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tLM_DBG(\"SIP Reply  (status):\\n\");\n\t\t\tLM_DBG(\" version: <%.*s>\\n\",fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tLM_DBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tLM_DBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\tflags=HDR_EOH_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLM_DBG(\"unknown type %d\\n\",fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed=tmp;\n\t\n\tif (parse_headers(msg, flags, 0)==-1) goto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif (msg->via1){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via1->name.len,\n\t\t\tZSW(msg->via1->name.s),\n\t\t\tmsg->via1->version.len,\n\t\t\tZSW(msg->via1->version.s),\n\t\t\tmsg->via1->transport.len,\n\t\t\tZSW(msg->via1->transport.s),\n\t\t\tmsg->via1->host.len,\n\t\t\tZSW(msg->via1->host.s),\n\t\t\tmsg->via1->port_str.len,\n\t\t\tZSW(msg->via1->port_str.s),\n\t\t\tmsg->via1->port);\n\t\tif (msg->via1->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif (msg->via1->comment.s)\n\t\t\t\tLM_DBG(\" <%.*s>\\n\",\n\t\t\t\t\tmsg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n\tif (msg->via2){\n\t\tLM_DBG(\" first  via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\\n\",\n\t\t\tmsg->via2->name.len,\n\t\t\tZSW(msg->via2->name.s),\n\t\t\tmsg->via2->version.len,\n\t\t\tZSW(msg->via2->version.s),\n\t\t\tmsg->via2->transport.len,\n\t\t\tZSW(msg->via2->transport.s),\n\t\t\tmsg->via2->host.len,\n\t\t\tZSW(msg->via2->host.s),\n\t\t\tmsg->via2->port_str.len,\n\t\t\tZSW(msg->via2->port_str.s),\n\t\t\tmsg->via2->port);\n\t\tif (msg->via2->params.s)  LM_DBG(\";<%.*s>\\n\",\n\t\t\t\tmsg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif (msg->via2->comment.s) LM_DBG(\" <%.*s>\\n\",\n\t\t\t\tmsg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tLM_DBG (\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tLM_DBG(\"exiting\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLM_ERR(\"message=<%.*s>\\n\", (int)len, ZSW(buf));\n\treturn -1;", "Selected Statement": "\ttmp=rest;\n", "Selected Pointer": "tmp", "Compared Statement": "\ttmp=rest;\n", "Compared Pointer": "rest", "Aliasing": "Yes", "Function Input": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x76d25d0 \"\\024\\024\\t\\t\\t\\t\\t\\t\\t\""}, "len": {"type_category": "int", "concrete_type": "unsigned int", "value": "2"}, "msg": {"type_category": "pointer", "concrete_type": "pointer", "value": "0x7fffffffd368"}}, "Program Information": {"Project Name": "opensips"}, "idx": 349}
