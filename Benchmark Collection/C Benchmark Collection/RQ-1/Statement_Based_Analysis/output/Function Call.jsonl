{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nvoid\nfiber_init(int (*invoke)(fiber_func f, va_list ap))\n{\n\tpage_size = small_getpagesize();\n\tstack_direction = check_stack_direction(__builtin_frame_address(0));\n\tfiber_invoke = invoke;\n\tmain_thread_id = pthread_self();\n\tmain_cord.loop = ev_default_loop(EVFLAG_AUTO | EVFLAG_ALLOCFD);\n\tif (main_cord.loop == NULL)\n\t\tpanic(\"can't init event loop\");\n\tcord_create(&main_cord, \"main\");\n", "Selected Statement": "main_cord.loop = ev_default_loop(EVFLAG_AUTO | EVFLAG_ALLOCFD);", "Function Input": {}, "Variable Values Before Statement": {}, "Value After Statement Execution": "NULL", "Function Name": "ev_default_loop", "Project Information": "tarantool"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\ndouble\nclock_monotonic(void)\n{\n\tstruct timespec ts;\n\tint rc = clock_gettime(CLOCK_MONOTONIC, &ts);\n\tif (rc != 0)\n\t\tpanic_syserror(\"clock_gettime failed\");\n", "Selected Statement": "int rc = clock_gettime(CLOCK_MONOTONIC, &ts);", "Function Input": {}, "Variable Values Before Statement": {"CLOCK_MONOTONIC": "NULL"}, "Value After Statement Execution": "int", "Function Name": "clock_gettime", "Project Information": "tarantool"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nint\ntt_sigaction(int signum, struct sigaction *sa, struct sigaction *osa)\n{\n\tassert(signum < SIGMAX);\n\tassert(sa != NULL);\n\n\t\n\tif (!main_thread_initialized) {\n\t\tmain_thread_id = pthread_self();\n\t\tmain_thread_initialized = true;\n\t}\n\n\tvoid (*old_handler)(int) = sighandlers[signum];\n\tif (sa->sa_handler == SIG_DFL || sa->sa_handler == SIG_IGN) {\n\t\tsighandlers[signum] = NULL;\n\t} else {\n\t\tsighandlers[signum] = sa->sa_handler;\n\t\tsa->sa_handler = sighandler_dispatcher;\n\t}\n\tint rc = sigaction(signum, sa, osa);\n\tif (osa != NULL && old_handler != NULL)\n\t\tosa->sa_handler = old_handler;\n", "Selected Statement": "main_thread_id = pthread_self();", "Function Input": {"signum": {"value": "0"}}, "Variable Values Before Statement": {}, "Value After Statement Execution": "pthread_t", "Function Name": "pthread_self", "Project Information": "tarantool"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\ndecimal_t *\ndecimal_from_string(decimal_t *dec, const char *str)\n{\n\tconst char *end = decNumberFromString(dec, str, &decimal_context);\n\tif (*end != '\\0') {\n\t\tdecContextZeroStatus(&decimal_context);\n\t\treturn NULL;\n\t}\n\treturn decimal_check_status(dec, &decimal_context);\n", "Selected Statement": "const char *end = decNumberFromString(dec, str, &decimal_context);", "Function Input": {"dec": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"digits": {"type_category": "unknown", "concrete_type": "int32_t", "value": "-8560"}, "exponent": {"type_category": "unknown", "concrete_type": "int32_t", "value": "32767"}, "bits": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "180 '\\264'"}, "lsu": {"type_category": "array", "concrete_type": "uint16_t", "value": [{"type_category": "unknown", "concrete_type": "uint16_t", "value": "41"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "57280"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "65535"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "32767"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "24912"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "221"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "47936"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "216"}]}}}}}, "Variable Values Before Statement": {"dec": {"digits": "1", "exponent": "0", "bits": "0 '\\000'", "lsu": [{"type_category": "unknown", "concrete_type": "uint16_t", "value": "1"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "47936"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "216"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "30780"}, {"type_category": "unknown", "concrete_type": "uint16_t", "value": "42"}]}, "str": "0xd980a0 \"1\\375\""}, "Value After Statement Execution": "NULL", "Function Name": "decNumberFromString", "Project Information": "tarantool"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "ssize_t\ndatetime_parse_full(struct datetime *date, const char *str, size_t len,\n\t\t    const char *tzsuffix, int32_t offset)\n{\n\tsize_t n;\n\tdt_t dt;\n\tconst char *svp = str;\n\tchar c;\n\tint sec_of_day = 0, nanosecond = 0;\n\tint16_t tzindex = 0;\n\n\tn = dt_parse_iso_date(str, len, &dt);\n\tif (n == 0)\n\t\treturn 0;\n\n\tstr += n;\n\tlen -= n;\n\tif (len <= 0)\n\t\tgoto exit;\n\n\tc = *str++;\n\tif (c != 'T' && c != 't' && c != ' ')\n\t\treturn 0;\n\tlen--;\n\tif (len <= 0)\n\t\tgoto exit;\n\n\tn = dt_parse_iso_time(str, len, &sec_of_day, &nanosecond);\n\tif (n == 0)\n\t\treturn 0;\n\n\tstr += n;\n\tlen -= n;\n\tif (len <= 0)\n\t\tgoto exit;\n\n\t\n\ttime_t base = dt_epoch(dt) + sec_of_day - offset * 60;\n\tssize_t l;\n\tif (tzsuffix != NULL) {\n\t\tl = parse_tz_suffix(tzsuffix, strlen(tzsuffix), base,\n\t\t\t\t    &tzindex, &offset);\n\t\tif (l < 0)\n\t\t\treturn l;\n\t\tgoto exit;\n\t}\n\n\tif (*str == ' ') {\n\t\tstr++;\n\t\tlen--;\n\t}\n\tif (len <= 0)\n\t\tgoto exit;\n\n\tl = parse_tz_suffix(str, len, base, &tzindex, &offset);\n\tif (l < 0)\n\t\treturn l;\n\tstr += l;\n\nexit:\n\tdate->epoch = dt_epoch(dt) + sec_of_day - offset * 60;\n\tdate->nsec = nanosecond;\n\tdate->tzoffset = offset;\n\tdate->tzindex = tzindex;\n\n\treturn str - svp;\n", "Selected Statement": "n = dt_parse_iso_date(str, len, &dt);", "Function Input": {}, "Variable Values Before Statement": {"str": "0xe70cd0 \"\"", "len": "0"}, "Value After Statement Execution": "0", "Function Name": "dt_parse_iso_date", "Project Information": "tarantool"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nextern \"C\" int\nLLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n\tFuzzedDataProvider fdp(data, size);\n\n\tauto buf = fdp.ConsumeRandomLengthString();\n\tauto fmt = fdp.ConsumeRandomLengthString();\n\n\tstruct datetime date_expected;\n\tdatetime_strptime(&date_expected, buf.c_str(), fmt.c_str());\n\n\treturn 0;\n", "Selected Statement": "auto buf = fdp.ConsumeRandomLengthString();", "Function Input": {}, "Variable Values Before Statement": {}, "Value After Statement Execution": "NULL", "Function Name": "fdp.ConsumeRandomLengthString", "Project Information": "tarantool"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nint\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;\n", "Selected Statement": "uri->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);", "Function Input": {}, "Variable Values Before Statement": {"uri_raw.scheme": "NULL", "uri_raw.scheme_len": "0"}, "Value After Statement Execution": "NULL", "Function Name": "XSTRNDUP", "Project Information": "tarantool"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\t\t\t\t\t\t\t  Size minContextSize,\n\t\t\t\t\t\t\t  Size initBlockSize,\n\t\t\t\t\t\t\t  Size maxBlockSize)\n{\n\tint\t\t\tfreeListIndex;\n\tSize\t\tfirstBlockSize;\n\tAllocSet\tset;\n\tAllocBlock\tblock;\n\n\t\n\tStaticAssertDecl(ALLOC_CHUNKHDRSZ == MAXALIGN(ALLOC_CHUNKHDRSZ),\n\t\t\t\t\t \"sizeof(MemoryChunk) is not maxaligned\");\n\t\n\tStaticAssertDecl(sizeof(AllocFreeListLink) <= (1 << ALLOC_MINBITS),\n\t\t\t\t\t \"sizeof(AllocFreeListLink) larger than minimum allocation size\");\n\n\t\n\tAssert(initBlockSize == MAXALIGN(initBlockSize) &&\n\t\t   initBlockSize >= 1024);\n\tAssert(maxBlockSize == MAXALIGN(maxBlockSize) &&\n\t\t   maxBlockSize >= initBlockSize &&\n\t\t   AllocHugeSizeIsValid(maxBlockSize)); \n\tAssert(minContextSize == 0 ||\n\t\t   (minContextSize == MAXALIGN(minContextSize) &&\n\t\t\tminContextSize >= 1024 &&\n\t\t\tminContextSize <= maxBlockSize));\n\tAssert(maxBlockSize <= MEMORYCHUNK_MAX_BLOCKOFFSET);\n\n\t\n\tif (minContextSize == ALLOCSET_DEFAULT_MINSIZE &&\n\t\tinitBlockSize == ALLOCSET_DEFAULT_INITSIZE)\n\t\tfreeListIndex = 0;\n\telse if (minContextSize == ALLOCSET_SMALL_MINSIZE &&\n\t\t\t initBlockSize == ALLOCSET_SMALL_INITSIZE)\n\t\tfreeListIndex = 1;\n\telse\n\t\tfreeListIndex = -1;\n\n\t\n\tif (freeListIndex >= 0)\n\t{\n\t\tAllocSetFreeList *freelist = &context_freelists[freeListIndex];\n\n\t\tif (freelist->first_free != NULL)\n\t\t{\n\t\t\t\n\t\t\tset = freelist->first_free;\n\t\t\tfreelist->first_free = (AllocSet) set->header.nextchild;\n\t\t\tfreelist->num_free--;\n\n\t\t\t\n\t\t\tset->maxBlockSize = maxBlockSize;\n\n\t\t\t\n\t\t\tMemoryContextCreate((MemoryContext) set,\n\t\t\t\t\t\t\t\tT_AllocSetContext,\n\t\t\t\t\t\t\t\tMCTX_ASET_ID,\n\t\t\t\t\t\t\t\tparent,\n\t\t\t\t\t\t\t\tname);\n\n\t\t\t((MemoryContext) set)->mem_allocated =\n\t\t\t\tset->keeper->endptr - ((char *) set);\n\n\t\t\treturn (MemoryContext) set;\n\t\t}\n\t}\n\n\t\n\tfirstBlockSize = MAXALIGN(sizeof(AllocSetContext)) +\n\t\tALLOC_BLOCKHDRSZ + ALLOC_CHUNKHDRSZ;\n\tif (minContextSize != 0)\n\t\tfirstBlockSize = Max(firstBlockSize, minContextSize);\n\telse\n\t\tfirstBlockSize = Max(firstBlockSize, initBlockSize);\n\n\t\n\tset = (AllocSet) malloc(firstBlockSize);\n\tif (set == NULL)\n\t{\n\t\tif (TopMemoryContext)\n\t\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed while creating memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   name)));\n\t}\n\n\t\n\n\t\n\tblock = (AllocBlock) (((char *) set) + MAXALIGN(sizeof(AllocSetContext)));\n\tblock->aset = set;\n\tblock->freeptr = ((char *) block) + ALLOC_BLOCKHDRSZ;\n\tblock->endptr = ((char *) set) + firstBlockSize;\n\tblock->prev = NULL;\n\tblock->next = NULL;\n\n\t\n\tVALGRIND_MAKE_MEM_NOACCESS(block->freeptr, block->endptr - block->freeptr);\n\n\t\n\tset->blocks = block;\n\t\n\tset->keeper = block;\n\n\t\n\tMemSetAligned(set->freelist, 0, sizeof(set->freelist));\n\n\tset->initBlockSize = initBlockSize;\n\tset->maxBlockSize = maxBlockSize;\n\tset->nextBlockSize = initBlockSize;\n\tset->freeListIndex = freeListIndex;\n\n\t\n\tStaticAssertStmt(ALLOC_CHUNK_LIMIT == ALLOCSET_SEPARATE_THRESHOLD,\n\t\t\t\t\t \"ALLOC_CHUNK_LIMIT != ALLOCSET_SEPARATE_THRESHOLD\");\n\n\t\n\tset->allocChunkLimit = ALLOC_CHUNK_LIMIT;\n\twhile ((Size) (set->allocChunkLimit + ALLOC_CHUNKHDRSZ) >\n\t\t   (Size) ((maxBlockSize - ALLOC_BLOCKHDRSZ) / ALLOC_CHUNK_FRACTION))\n\t\tset->allocChunkLimit >>= 1;\n\n\t\n\tMemoryContextCreate((MemoryContext) set,\n\t\t\t\t\t\tT_AllocSetContext,\n\t\t\t\t\t\tMCTX_ASET_ID,\n\t\t\t\t\t\tparent,\n\t\t\t\t\t\tname);\n\n\t((MemoryContext) set)->mem_allocated = firstBlockSize;\n\n\treturn (MemoryContext) set;\n", "Selected Statement": "block = (AllocBlock) (((char *) set) + MAXALIGN(sizeof(AllocSetContext)));", "Function Input": {}, "Variable Values Before Statement": {}, "Value After Statement Execution": "AllocBlock", "Function Name": "(AllocBlock)", "Project Information": "libpg_query"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "#include <unistd.h>\n\nstatic int process_file(const char *name)\n{\n    int rc = -1;\n    blkid_probe pr = blkid_new_probe_from_filename(name);\n    if (pr != NULL) {\n        blkid_probe_enable_partitions(pr, TRUE);\n        blkid_probe_set_partitions_flags(pr, FALSE);\n        blkid_probe_enable_superblocks(pr, TRUE);\n        blkid_probe_set_superblocks_flags(pr, BLKID_SUBLKS_DEFAULT | BLKID_SUBLKS_FSINFO | BLKID_SUBLKS_MAGIC | BLKID_SUBLKS_VERSION | BLKID_SUBLKS_BADCSUM);\n        rc = blkid_do_safeprobe(pr) == -1 ? -1 : 0;\n    }\n    blkid_free_probe(pr);\n    return rc;\n}\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n    int fd;\n    char name[] = \"/tmp/test-script-fuzz.XXXXXX\";\n\n    fd = mkostemp(name, O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC);\n    if (fd == -1)\n        err(EXIT_FAILURE, \"mkostemp() failed\");\n\n    if (write(fd, data, size) != (ssize_t)size)\n        goto out;\n\n    process_file(name);\nout:\n", "Selected Statement": "blkid_probe pr = blkid_new_probe_from_filename(name);", "Function Input": {"name": {"value": null}}, "Variable Values Before Statement": {"name": "0x7fffffffdf20 \"/tmp/test-script-fuzz.2FhyGN\""}, "Value After Statement Execution": "blkid_probe", "Function Name": "blkid_new_probe_from_filename", "Project Information": "util-linux"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": " * error.\n */\nblkid_probe blkid_new_probe_from_filename(const char *filename)\n{\n\tint fd;\n\tblkid_probe pr = NULL;\n\n\tfd = open(filename, O_RDONLY|O_CLOEXEC|O_NONBLOCK);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tpr = blkid_new_probe();\n\tif (!pr)\n\t\tgoto err;\n\n\tif (blkid_probe_set_device(pr, fd, 0, 0))\n\t\tgoto err;\n\n\tpr->flags |= BLKID_FL_PRIVATE_FD;\n\treturn pr;\nerr:\n\tclose(fd);\n\tblkid_free_probe(pr);\n\treturn NULL;\n", "Selected Statement": "fd = open(filename, O_RDONLY|O_CLOEXEC|O_NONBLOCK);", "Function Input": {}, "Variable Values Before Statement": {"filename": "0x7fffffffdf20 \"/tmp/test-script-fuzz.2FhyGN\""}, "Value After Statement Execution": "int", "Function Name": "open", "Project Information": "util-linux"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": " * allocates BSD label driver\n */\nstruct fdisk_label *fdisk_new_bsd_label(struct fdisk_context *cxt __attribute__ ((__unused__)))\n{\n\tstruct fdisk_label *lb;\n\tstruct fdisk_bsd_label *bsd;\n\n\tbsd = calloc(1, sizeof(*bsd));\n\tif (!bsd)\n\t\treturn NULL;\n\n\t\n\tlb = (struct fdisk_label *) bsd;\n\tlb->name = \"bsd\";\n\tlb->id = FDISK_DISKLABEL_BSD;\n\tlb->op = &bsd_operations;\n\tlb->parttypes = bsd_fstypes;\n\tlb->nparttypes = ARRAY_SIZE(bsd_fstypes) - 1;\n\n\tlb->fields = bsd_fields;\n\tlb->nfields = ARRAY_SIZE(bsd_fields);\n\n\tlb->flags |= FDISK_LABEL_FL_INCHARS_PARTNO;\n\tlb->flags |= FDISK_LABEL_FL_REQUIRE_GEOMETRY;\n\n\t\n\treturn (struct fdisk_label *) bsd;\n", "Selected Statement": "bsd = calloc(1, sizeof(*bsd));", "Function Input": {}, "Variable Values Before Statement": {"1": "1"}, "Value After Statement Execution": {"head": null, "dos_part": null, "bsd": null, "bsdbuffer": "\"\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\""}, "Function Name": "calloc", "Project Information": "util-linux"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": " * Returns: newly allocated tab struct.\n */\nstruct libmnt_table *mnt_new_table(void)\n{\n\tstruct libmnt_table *tb = NULL;\n\n\ttb = calloc(1, sizeof(*tb));\n\tif (!tb)\n\t\treturn NULL;\n\n\tDBG(TAB, ul_debugobj(tb, \"alloc\"));\n\ttb->refcount = 1;\n\tINIT_LIST_HEAD(&tb->ents);\n\treturn tb;\n", "Selected Statement": "tb = calloc(1, sizeof(*tb));", "Function Input": {"tb": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"fmt": {"type_category": "int", "concrete_type": "int", "value": "1220708680"}, "nents": {"type_category": "int", "concrete_type": "int", "value": "1668857989"}, "refcount": {"type_category": "int", "concrete_type": "int", "value": "139103049"}, "comms": {"type_category": "int", "concrete_type": "int", "value": "675515209"}, "comm_intro": {"type_category": "string", "concrete_type": "string", "value": "0x76ca394818728b41 <error: Cannot access memory at address 0x76ca394818728b41>"}, "comm_tail": {"type_category": "string", "concrete_type": "string", "value": "0xd6af0f48ca29480a <error: Cannot access memory at address 0xd6af0f48ca29480a>"}, "cache": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7ffff7fcd82a", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x491c4a8b41d00148\n", "message": "Cannot access memory at address 0x491c4a8b41d00148"}}, "errcb": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7ffff7fcd832", "value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3941128b4120738b\n", "message": "Cannot access memory at address 0x3941128b4120738b"}}, "fltrcb": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7ffff7fcd83a", "value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3d48e8d348b775d5\n", "message": "Cannot access memory at address 0x3d48e8d348b775d5"}}, "fltrcb_data": {"type_category": "pointer", "concrete_type": "VOID"}, "noautofs": {"type_category": "int", "concrete_type": "int", "value": "-905958072"}, "ents": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"next": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7ffff7fcd852", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x773b9ac9ff3d4801\n", "message": "Cannot access memory at address 0x773b9ac9ff3d4801"}}, "prev": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7ffff7fcd85a", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x24348949d60148ef\n", "message": "Cannot access memory at address 0x24348949d60148ef"}}}}, "userdata": {"type_category": "pointer", "concrete_type": "VOID"}}}}}, "Variable Values Before Statement": {"1": "1"}, "Value After Statement Execution": {"fmt": "0", "nents": "0", "refcount": "0", "comms": "0", "comm_intro": null, "comm_tail": null, "cache": null, "errcb": null, "fltrcb": null, "fltrcb_data": null, "noautofs": "0", "ents": null, "userdata": null}, "Function Name": "calloc", "Project Information": "util-linux"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": " * Returns: 0 on success, negative number in case of error.\n */\nint mnt_table_parse_stream(struct libmnt_table *tb, FILE *f, const char *filename)\n{\n\tint rc = -1;\n\tint flags = 0;\n\tpid_t tid = -1;\n\tstruct libmnt_parser pa = { .line = 0 };\n\n\tassert(tb);\n\tassert(f);\n\tassert(filename);\n\n\tDBG(TAB, ul_debugobj(tb, \"%s: start parsing [entries=%d, filter=%s]\",\n\t\t\t\tfilename, mnt_table_get_nents(tb),\n\t\t\t\ttb->fltrcb ? \"yes\" : \"not\"));\n\n\tpa.filename = filename;\n\tpa.f = f;\n\n\t\n\tif (tb->fmt == MNT_FMT_SWAPS)\n\t\tflags = MNT_FS_SWAP;\n\telse if (filename && strcmp(filename, _PATH_PROC_MOUNTS) == 0)\n\t\tflags = MNT_FS_KERNEL;\n\n\tdo {\n\t\tstruct libmnt_fs *fs;\n\n\t\tif (feof(f)) {\n\t\t\tDBG(TAB, ul_debugobj(tb, \"end-of-file\"));\n\t\t\tbreak;\n\t\t}\n\t\tfs = mnt_new_fs();\n\t\tif (!fs)\n\t\t\tgoto err;\n\n\t\t\n\t\trc = mnt_table_parse_next(&pa, tb, fs);\n\n\t\tif (rc == 0 && tb->fltrcb && tb->fltrcb(fs, tb->fltrcb_data))\n\t\t\trc = 1;\t\n\n\t\tif (rc == 0 && mnt_table_is_noautofs(tb)) {\n\t\t\tconst char *fstype = mnt_fs_get_fstype(fs);\n\n\t\t\tif (fstype && strcmp(fstype, \"autofs\") == 0 &&\n\t\t\t    mnt_fs_get_option(fs, \"ignore\", NULL, NULL) == 0)\n\t\t\t\trc = 1; \n\t\t}\n\n\t\t\n\t\tif (rc == 0) {\n\t\t\trc = mnt_table_add_fs(tb, fs);\n\t\t\tfs->flags |= flags;\n\n\t\t\tif (rc == 0 && tb->fmt == MNT_FMT_MOUNTINFO) {\n\t\t\t\trc = kernel_fs_postparse(&pa, tb, fs, &tid);\n\t\t\t\tif (rc)\n\t\t\t\t\tmnt_table_remove_fs(tb, fs);\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tmnt_unref_fs(fs);\n\n\t\t\n\t\tif (rc > 0) {\n\t\t\tDBG(TAB, ul_debugobj(tb, \"recoverable error (continue)\"));\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (rc < 0 && !feof(f)) {\n\t\t\tDBG(TAB, ul_debugobj(tb, \"fatal error\"));\n\t\t\tgoto err;\n\t\t}\n\t} while (1);\n\n\tDBG(TAB, ul_debugobj(tb, \"%s: stop parsing (%d entries)\",\n\t\t\t\tfilename, mnt_table_get_nents(tb)));\n\tparser_cleanup(&pa);\n\treturn 0;\nerr:\n\tDBG(TAB, ul_debugobj(tb, \"%s: parse error (rc=%d)\", filename, rc));\n\tparser_cleanup(&pa);\n\treturn rc;\n", "Selected Statement": "fs = mnt_new_fs();", "Function Input": {}, "Variable Values Before Statement": {}, "Value After Statement Execution": {"ents": null, "tab": null, "refcount": "1", "opts_age": "0", "optlist": null, "id": "0", "parent": "0", "devno": "0", "bindsrc": null, "source": null, "tagname": null, "tagval": null, "root": null, "target": null, "fstype": null, "optstr": null, "vfs_optstr": null, "opt_fields": null, "fs_optstr": null, "user_optstr": null, "attrs": null, "freq": "0", "passno": "0", "swaptype": null, "size": "0", "usedsize": "0", "priority": "0", "flags": "0", "tid": "0", "comment": null, "userdata": null}, "Function Name": "mnt_new_fs", "Project Information": "util-linux"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": " * Returns mallocated buffer or NULL in case of error.\n */\nchar *unmangle(const char *s, const char **end)\n{\n\tchar *buf;\n\tconst char *e;\n\tsize_t sz;\n\n\tif (!s)\n\t\treturn NULL;\n\n\te = skip_nonspaces(s);\n\tsz = e - s + 1;\n\n\tif (end)\n\t\t*end = e;\n\tif (e == s)\n\t\treturn NULL;\t\n\n\tbuf = malloc(sz);\n\tif (!buf)\n\t\treturn NULL;\n\n\tunmangle_to_buffer(s, buf, sz);\n\treturn buf;\n", "Selected Statement": "e = skip_nonspaces(s);", "Function Input": {"buf": {"value": "0x655800 <fuzzer::TPC> \"\""}, "s": {"value": "0x1055340 \"\\210$\\255\\373\""}}, "Variable Values Before Statement": {"s": "0x1056ca0 \"^\""}, "Value After Statement Execution": "0x1056ca1 \"\"", "Function Name": "skip_nonspaces", "Project Information": "util-linux"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": " * Returns 0 on success, and -1 on failure.\n */\nint blkid_parse_tag_string(const char *token, char **ret_type, char **ret_val)\n{\n\tchar *name, *value, *cp;\n\n\tDBG(TAG, ul_debug(\"trying to parse '%s' as a tag\", token));\n\n\tif (!token || !(cp = strchr(token, '=')))\n\t\treturn -1;\n\n\tname = strdup(token);\n\tif (!name)\n\t\treturn -1;\n\tvalue = name + (cp - token);\n\t*value++ = '\\0';\n\tif (*value == '\"' || *value == '\\'') {\n\t\tchar c = *value++;\n\t\tif (!(cp = strrchr(value, c)))\n\t\t\tgoto errout; \n\t\t*cp = '\\0';\n\t}\n\n\tif (ret_val) {\n\t\tvalue = *value ? strdup(value) : NULL;\n\t\tif (!value)\n\t\t\tgoto errout;\n\t\t*ret_val = value;\n\t}\n\n\tif (ret_type)\n\t\t*ret_type = name;\n\telse\n\t\tfree(name);\n\n\treturn 0;\n\nerrout:\n\tDBG(TAG, ul_debug(\"parse error: '%s'\", token));\n\tfree(name);\n\treturn -1;\n", "Selected Statement": "if (!token || !(cp = strchr(token, '=')))", "Function Input": {}, "Variable Values Before Statement": {"token": "0x105b490 \"^\""}, "Value After Statement Execution": "NULL", "Function Name": "strchr", "Project Information": "util-linux"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "}\n\nint strappend(char **a, const char *b)\n{\n\tsize_t al, bl;\n\tchar *tmp;\n\n\tif (!a)\n\t\treturn -EINVAL;\n\tif (!b || !*b)\n\t\treturn 0;\n\tif (!*a) {\n\t\t*a = strdup(b);\n\t\treturn !*a ? -ENOMEM : 0;\n\t}\n\n\tal = strlen(*a);\n\tbl = strlen(b);\n\n\ttmp = realloc(*a, al + bl + 1);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\t*a = tmp;\n\tmemcpy((*a) + al, b, bl + 1);\n\treturn 0;\n", "Selected Statement": "*a = strdup(b);", "Function Input": {}, "Variable Values Before Statement": {"b": "0x1056ca0 \"#\\n\""}, "Value After Statement Execution": "NULL", "Function Name": "strdup", "Project Information": "util-linux"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "APR_DECLARE(apr_status_t) apr_thread_mutex_create(apr_thread_mutex_t **mutex,\n                                                  unsigned int flags,\n                                                  apr_pool_t *pool)\n{\n    apr_thread_mutex_t *new_mutex;\n    apr_status_t rv;\n\n#ifndef HAVE_PTHREAD_MUTEX_RECURSIVE\n    if (flags & APR_THREAD_MUTEX_NESTED) {\n        return APR_ENOTIMPL;\n    }\n#endif\n\n    new_mutex = apr_pcalloc(pool, sizeof(apr_thread_mutex_t));\n    new_mutex->pool = pool;\n\n#ifdef HAVE_PTHREAD_MUTEX_RECURSIVE\n    if (flags & APR_THREAD_MUTEX_NESTED) {\n        pthread_mutexattr_t mattr;\n\n        rv = pthread_mutexattr_init(&mattr);\n        if (rv) return rv;\n\n        rv = pthread_mutexattr_settype(&mattr, PTHREAD_MUTEX_RECURSIVE);\n        if (rv) {\n            pthread_mutexattr_destroy(&mattr);\n            return rv;\n        }\n\n        rv = pthread_mutex_init(&new_mutex->mutex, &mattr);\n\n        pthread_mutexattr_destroy(&mattr);\n    } else\n#endif\n    {\n#if defined(APR_THREAD_DEBUG)\n        pthread_mutexattr_t mattr;\n\n        rv = pthread_mutexattr_init(&mattr);\n        if (rv) return rv;\n\n        rv = pthread_mutexattr_settype(&mattr, PTHREAD_MUTEX_ERRORCHECK);\n        if (rv) {\n            pthread_mutexattr_destroy(&mattr);\n            return rv;\n        }\n\n        rv = pthread_mutex_init(&new_mutex->mutex, &mattr);\n\n        pthread_mutexattr_destroy(&mattr);\n#else\n        rv = pthread_mutex_init(&new_mutex->mutex, NULL);\n#endif\n    }\n\n    if (rv) {\n#ifdef HAVE_ZOS_PTHREADS\n        rv = errno;\n#endif\n        return rv;\n    }\n\n#ifndef HAVE_PTHREAD_MUTEX_TIMEDLOCK\n    if (flags & APR_THREAD_MUTEX_TIMED) {\n        rv = apr_thread_cond_create(&new_mutex->cond, pool);\n        if (rv) {\n#ifdef HAVE_ZOS_PTHREADS\n            rv = errno;\n#endif\n            pthread_mutex_destroy(&new_mutex->mutex);\n            return rv;\n        }\n    }\n#endif\n\n    apr_pool_cleanup_register(new_mutex->pool,\n                              new_mutex, thread_mutex_cleanup,\n                              apr_pool_cleanup_null);\n\n    *mutex = new_mutex;\n    return APR_SUCCESS;\n", "Selected Statement": "rv = pthread_mutexattr_settype(&mattr, PTHREAD_MUTEX_RECURSIVE);", "Function Input": {}, "Variable Values Before Statement": {"PTHREAD_MUTEX_RECURSIVE": "NULL"}, "Value After Statement Execution": "apr_status_t", "Function Name": "pthread_mutexattr_settype", "Project Information": "apache-httpd"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "%%\n\nvoid yyerror(ap_expr_parse_ctx_t *ctx, const char *s)\n{\n    \n    ctx->error = apr_pstrdup(ctx->ptemp, s);\n", "Selected Statement": "ctx->error = apr_pstrdup(ctx->ptemp, s);", "Function Input": {}, "Variable Values Before Statement": {"ctx->ptemp": "{parent = 0x11a10c0, child = 0x0, sibling = 0x0, ref = 0x11a10c8, cleanups = 0x0, free_cleanups = 0x0, allocator = 0x0, subprocesses = 0x0, abort_fn = 0x0, user_data = 0x0, tag = 0x6c8fa4 \"undefined\", joined = 0x0, nodes = 0x11a77f0, file_line = 0x6c8fa4 \"undefined\", creation_flags = 0, stat_alloc = 2, stat_total_alloc = 2, stat_clear = 0, owner = 140737349677056, mutex = 0x11a1160, pre_cleanups = 0x0}", "s": "0x7fffffffd500 \"syntax error, unexpected $end\""}, "Value After Statement Execution": "0x11a7c10 \"syntax error, unexpected $end\"", "Function Name": "apr_pstrdup", "Project Information": "apache-httpd"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "                                              apr_port_t *port,\n                                              const char *str,\n                                              apr_pool_t *p)\n{\n    const char *ch, *lastchar;\n    int big_port;\n    apr_size_t addrlen;\n\n    *addr = NULL;         \n    *scope_id = NULL;     \n    *port = 0;            \n\n    \n    ch = lastchar = str + strlen(str) - 1;\n    while (ch >= str && apr_isdigit(*ch)) {\n        --ch;\n    }\n\n    if (ch < str) {       \n        big_port = atoi(str);\n        if (big_port < 1 || big_port > 65535) {\n            return APR_EINVAL;\n        }\n        *port = big_port;\n        return APR_SUCCESS;\n    }\n\n    if (*ch == ':' && ch < lastchar) { \n        if (ch == str) {               \n            return APR_EINVAL;\n        }\n        big_port = atoi(ch + 1);\n        if (big_port < 1 || big_port > 65535) {\n            return APR_EINVAL;\n        }\n        *port = big_port;\n        lastchar = ch - 1;\n    }\n\n    \n    addrlen = lastchar - str + 1;\n\n\n#if APR_HAVE_IPV6\n    if (*str == '[') {\n        const char *end_bracket = memchr(str, ']', addrlen);\n        struct in6_addr ipaddr;\n        const char *scope_delim;\n\n        if (!end_bracket || end_bracket != lastchar) {\n            *port = 0;\n            return APR_EINVAL;\n        }\n\n        \n        scope_delim = memchr(str, '%', addrlen);\n        if (scope_delim) {\n            if (scope_delim == end_bracket - 1) { \n                *port = 0;\n                return APR_EINVAL;\n            }\n            addrlen = scope_delim - str - 1;\n            *scope_id = apr_pstrmemdup(p, scope_delim + 1, end_bracket - scope_delim - 1);\n        }\n        else {\n            addrlen = addrlen - 2; \n        }\n\n        *addr = apr_pstrmemdup(p, str + 1, addrlen);\n        if (apr_inet_pton(AF_INET6, *addr, &ipaddr) != 1) {\n            *addr = NULL;\n            *scope_id = NULL;\n            *port = 0;\n            return APR_EINVAL;\n        }\n    }\n    else\n#endif\n    {\n        \n        *addr = apr_pstrmemdup(p, str, addrlen);\n    }\n    return APR_SUCCESS;\n", "Selected Statement": "big_port = atoi(str);", "Function Input": {}, "Variable Values Before Statement": {"str": "0x11a16a0 \"\""}, "Value After Statement Execution": "int", "Function Name": "atoi", "Project Information": "apache-httpd"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "nxt_mp_t *\nnxt_mp_create(size_t cluster_size, size_t page_alignment, size_t page_size,\n    size_t min_chunk_size)\n{\n    nxt_mp_t     *mp;\n    uint32_t     pages, chunk_size_shift, page_size_shift;\n    nxt_queue_t  *chunk_pages;\n\n    chunk_size_shift = nxt_lg2(min_chunk_size);\n    page_size_shift = nxt_lg2(page_size);\n\n    pages = page_size_shift - chunk_size_shift;\n\n    mp = nxt_zalloc(sizeof(nxt_mp_t) + pages * sizeof(nxt_queue_t));\n\n    if (nxt_fast_path(mp != NULL)) {\n        mp->retain = 1;\n        mp->chunk_size_shift = chunk_size_shift;\n        mp->page_size_shift = page_size_shift;\n        mp->page_size = page_size;\n        mp->page_alignment = nxt_max(page_alignment, NXT_MAX_ALIGNMENT);\n        mp->cluster_size = cluster_size;\n\n        chunk_pages = mp->chunk_pages;\n\n        while (pages != 0) {\n            nxt_queue_init(chunk_pages);\n            chunk_pages++;\n            pages--;\n        }\n\n        nxt_queue_init(&mp->free_pages);\n        nxt_queue_init(&mp->nget_pages);\n        nxt_queue_init(&mp->get_pages);\n\n        nxt_rbtree_init(&mp->blocks, nxt_mp_rbtree_compare);\n    }\n\n    nxt_debug_alloc(\"mp %p create(%uz, %uz, %uz, %uz)\", mp, cluster_size,\n                    page_alignment, page_size, min_chunk_size);\n\n", "Selected Statement": "chunk_size_shift = nxt_lg2(min_chunk_size);", "Function Input": {}, "Variable Values Before Statement": {"min_chunk_size": "32"}, "Value After Statement Execution": "5", "Function Name": "nxt_lg2", "Project Information": "unit"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nvoid nxt_cdecl\nnxt_log_handler(nxt_uint_t level, nxt_log_t *log, const char *fmt, ...)\n{\n    u_char   *p, *end;\n#if 0\n    u_char   *syslogmsg;\n#endif\n    va_list  args;\n    u_char   msg[NXT_MAX_ERROR_STR];\n\n    p = msg;\n    end = msg + NXT_MAX_ERROR_STR;\n\n    if (nxt_log_prefix != NULL) {\n        p = nxt_cpystrn(p, nxt_log_prefix, end - p);\n        *p++ = ':';\n        *p++ = ' ';\n    }\n\n#if 0\n    syslogmsg = p;\n#endif\n\n    p = nxt_sprintf(p, end, (log->ident != 0) ? \"[%V] *%D \" : \"[%V] \",\n                    &nxt_log_levels[level], log->ident);\n\n    va_start(args, fmt);\n    p = nxt_vsprintf(p, end, fmt, args);\n    va_end(args);\n\n    if (level != NXT_LOG_DEBUG && log->ctx_handler != NULL) {\n        p = log->ctx_handler(log->ctx, p, end);\n    }\n\n    if (p > end - nxt_length(\"\\n\")) {\n        p = end - nxt_length(\"\\n\");\n    }\n\n    *p++ = '\\n';\n\n    (void) nxt_write_console(nxt_stderr, msg, p - msg);\n\n#if 0\n    if (level == NXT_LOG_ALERT) {\n        *(p - nxt_length(\"\\n\")) = '\\0';\n\n        \n        nxt_write_syslog(LOG_ALERT, syslogmsg);\n    }\n#endif\n", "Selected Statement": "p = nxt_vsprintf(p, end, fmt, args);", "Function Input": {}, "Variable Values Before Statement": {"p": "0x7fffffffd463 \"\\367\"", "end": "0x7fffffffdc40 \"(\"", "fmt": "0x5e19ab \"malloc(%uz): %p\"", "args": "NULL"}, "Value After Statement Execution": "0x7fffffffd463 \"\\367\"", "Function Name": "nxt_vsprintf", "Project Information": "unit"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nnxt_int_t\nnxt_lib_start(const char *app, char **argv, char ***envp)\n{\n    int           n;\n    nxt_int_t     flags;\n    nxt_bool_t    update;\n    nxt_thread_t  *thread;\n\n    flags = nxt_stderr_start();\n\n    nxt_log_start(app);\n\n    nxt_pid = getpid();\n    nxt_ppid = getppid();\n    nxt_euid = geteuid();\n    nxt_egid = getegid();\n\n#if (NXT_DEBUG)\n\n    nxt_main_log.level = NXT_LOG_DEBUG;\n\n#if (NXT_HAVE_MALLOPT)\n    \n    mallopt(M_PERTURB, 0x55);\n#endif\n\n#if (NXT_MACOSX)\n    \n    setenv(\"MallocScribble\", \"1\", 0);\n#endif\n\n#endif \n\n    \n\n    nxt_thread_init_data(nxt_thread_context);\n    thread = nxt_thread();\n    thread->log = &nxt_main_log;\n\n    thread->handle = nxt_thread_handle();\n    thread->time.signal = -1;\n    nxt_thread_time_update(thread);\n\n    nxt_main_task.thread = thread;\n    nxt_main_task.log = thread->log;\n    nxt_main_task.ident = nxt_task_next_ident();\n\n    if (nxt_strerror_start() != NXT_OK) {\n        return NXT_ERROR;\n    }\n\n    if (flags != -1) {\n        nxt_debug(&nxt_main_task, \"stderr flags: 0x%04Xd\", flags);\n    }\n\n#ifdef _SC_NPROCESSORS_ONLN\n    \n    n = sysconf(_SC_NPROCESSORS_ONLN);\n\n#elif (NXT_HPUX)\n    n = mpctl(MPC_GETNUMSPUS, NULL, NULL);\n\n#else\n    n = 0;\n\n#endif\n\n    nxt_debug(&nxt_main_task, \"ncpu: %d\", n);\n\n    if (n > 1) {\n        nxt_ncpu = n;\n    }\n\n    nxt_thread_spin_init(nxt_ncpu, 0);\n\n    nxt_random_init(&thread->random);\n\n    nxt_pagesize = getpagesize();\n\n    nxt_debug(&nxt_main_task, \"pagesize: %ui\", nxt_pagesize);\n\n    if (argv != NULL) {\n        update = (argv[0] == app);\n\n        nxt_process_arguments(&nxt_main_task, argv, envp);\n\n        if (update) {\n            nxt_log_start(nxt_process_argv[0]);\n        }\n    }\n\n    return NXT_OK;\n", "Selected Statement": "thread = nxt_thread();", "Function Input": {"app": {"value": "0x622e00 <vtable for std::__Fuzzer::ios_base::failure+8> \"\\260.b\""}, "argv": {"value": {"type_category": "string", "concrete_type": "string", "value": "0x8c48348707e8b49 <error: Cannot access memory at address 0x8c48348707e8b49>"}}, "envp": {"value": null}}, "Variable Values Before Statement": {}, "Value After Statement Execution": {"log": null, "main_log": null, "task": null, "tid": "0", "handle": "0", "link": null, "thread_pool": null, "time": null, "runtime": null, "engine": null, "data": null, "random": null}, "Function Name": "nxt_thread", "Project Information": "unit"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nnxt_int_t\nnxt_strerror_start(void)\n{\n    char        *msg;\n    u_char      *p;\n    size_t      size, length, n;\n    nxt_uint_t  err, invalid;\n\n    \n    size = nxt_length(\"Unknown error\");\n\n    \n\n    for (invalid = 0; invalid < 100 && nxt_sys_nerr < 65536; nxt_sys_nerr++) {\n\n        nxt_set_errno(0);\n        msg = strerror((int) nxt_sys_nerr);\n\n        \n\n        if (msg == NULL) {\n            invalid++;\n            continue;\n        }\n\n        length = nxt_strlen(msg);\n        size += length;\n\n        if (length == 0  \n            || nxt_errno == NXT_EINVAL\n            || memcmp(msg, \"Unknown error\", 13) == 0)\n        {\n            invalid++;\n            continue;\n        }\n\n#if (NXT_AIX)\n\n        if (memcmp(msg, \"Error \", 6) == 0\n            && memcmp(msg + length - 10, \" occurred.\", 9) == 0)\n        {\n            invalid++;\n            continue;\n        }\n\n#endif\n    }\n\n    nxt_sys_nerr -= invalid;\n\n    nxt_main_log_debug(\"sys_nerr: %d\", nxt_sys_nerr);\n\n    n = (nxt_sys_nerr + 1) * sizeof(nxt_str_t);\n\n    nxt_sys_errlist = nxt_malloc(n + size);\n    if (nxt_sys_errlist == NULL) {\n        return NXT_ERROR;\n    }\n\n    p = nxt_pointer_to(nxt_sys_errlist, n);\n\n    for (err = 0; err < nxt_sys_nerr; err++) {\n        msg = strerror((int) err);\n        length = nxt_strlen(msg);\n\n        nxt_sys_errlist[err].length = length;\n        nxt_sys_errlist[err].start = p;\n\n        p = nxt_cpymem(p, msg, length);\n    }\n\n    nxt_sys_errlist[err].length = 13;\n    nxt_sys_errlist[err].start = p;\n    nxt_memcpy(p, \"Unknown error\", 13);\n\n    nxt_strerror = nxt_runtime_strerror;\n\n    return NXT_OK;\n", "Selected Statement": "msg = strerror((int) err);", "Function Input": {}, "Variable Values Before Statement": {}, "Value After Statement Execution": "0x7ffff7c050a3 \"State not recoverable\"", "Function Name": "strerror", "Project Information": "unit"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "    return result;\n}\n\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n    \n\n    uint32_t range_start = 0;\n    uint32_t range_end = 10'000'000;\n\n    \n\n    FuzzedDataProvider fdp(data, size);\n    \n    std::vector<uint32_t> bitmap_data_a = ConsumeVecInRange(fdp, 500, 0, 1000);\n", "Selected Statement": "std::vector<uint32_t> bitmap_data_a = ConsumeVecInRange(fdp, 500, 0, 1000);", "Function Input": {"data": {"value": "0xff3ad0 \"\\300?\\377\""}, "size": {"value": "16732112"}}, "Variable Values Before Statement": {"fdp": {"data_ptr_": "0xff4fd0 \"\"", "remaining_bytes_": "0"}, "500": "500", "0": "0", "1000": "1000"}, "Value After Statement Execution": {"__begin_": "0xff5010", "__end_": "0xff57e0", "__end_cap_": null}, "Function Name": "ConsumeVecInRange", "Project Information": "croaring"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "}\n\nvoid roaring_bitmap_add_many(roaring_bitmap_t *r, size_t n_args,\n                             const uint32_t *vals) {\n    uint32_t val;\n    const uint32_t *start = vals;\n    const uint32_t *end = vals + n_args;\n    const uint32_t *current_val = start;\n\n    if (n_args == 0) {\n        return;\n    }\n\n    uint8_t typecode;\n    int idx;\n    container_t *container;\n    val = *current_val;\n    container = containerptr_roaring_bitmap_add(r, val, &typecode, &idx);\n", "Selected Statement": "container = containerptr_roaring_bitmap_add(r, val, &typecode, &idx);", "Function Input": {}, "Variable Values Before Statement": {"r": "NULL", "val": "<optimized out>"}, "Value After Statement Execution": "NULL", "Function Name": "containerptr_roaring_bitmap_add", "Project Information": "croaring"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nstruct window *\nwindow_create(u_int sx, u_int sy, u_int xpixel, u_int ypixel)\n{\n\tstruct window\t*w;\n\n\tif (xpixel == 0)\n\t\txpixel = DEFAULT_XPIXEL;\n\tif (ypixel == 0)\n\t\typixel = DEFAULT_YPIXEL;\n\n\tw = xcalloc(1, sizeof *w);\n\tw->name = xstrdup(\"\");\n\tw->flags = 0;\n\n\tTAILQ_INIT(&w->panes);\n\tTAILQ_INIT(&w->last_panes);\n\tw->active = NULL;\n\n\tw->lastlayout = -1;\n\tw->layout_root = NULL;\n\n\tw->sx = sx;\n\tw->sy = sy;\n\tw->manual_sx = sx;\n\tw->manual_sy = sy;\n\tw->xpixel = xpixel;\n\tw->ypixel = ypixel;\n\n\tw->options = options_create(global_w_options);\n\n\tw->references = 0;\n\tTAILQ_INIT(&w->winlinks);\n\n\tw->id = next_window_id++;\n\tRB_INSERT(windows, &windows, w);\n\n\twindow_set_fill_character(w);\n", "Selected Statement": "w->name = xstrdup(\"\");", "Function Input": {}, "Variable Values Before Statement": {"\"\"": "\"\""}, "Value After Statement Execution": "0x1139e70 \"\"", "Function Name": "xstrdup", "Project Information": "tmux"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatalx(\"xcalloc: zero size\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatalx(\"xcalloc: allocating %zu * %zu bytes: %s\",\n\t\t    nmemb, size, strerror(errno));\n", "Selected Statement": "ptr = calloc(nmemb, size);", "Function Input": {}, "Variable Values Before Statement": {"nmemb": "1", "size": "624"}, "Value After Statement Execution": "VOID", "Function Name": "calloc", "Project Information": "tmux"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nstruct options *\noptions_create(struct options *parent)\n{\n\tstruct options\t*oo;\n\n\too = xcalloc(1, sizeof *oo);\n\tRB_INIT(&oo->tree);\n\too->parent = parent;\n", "Selected Statement": "oo = xcalloc(1, sizeof *oo);", "Function Input": {}, "Variable Values Before Statement": {"1": "1"}, "Value After Statement Execution": {"tree": null, "parent": null}, "Function Name": "xcalloc", "Project Information": "tmux"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nvoid\nscreen_init(struct screen *s, u_int sx, u_int sy, u_int hlimit)\n{\n\ts->grid = grid_create(sx, sy, hlimit);\n\ts->saved_grid = NULL;\n\n\ts->title = xstrdup(\"\");\n\ts->titles = NULL;\n\ts->path = NULL;\n\n\ts->cstyle = SCREEN_CURSOR_DEFAULT;\n\ts->default_cstyle = SCREEN_CURSOR_DEFAULT;\n\ts->mode = MODE_CURSOR;\n\ts->default_mode = 0;\n\ts->ccolour = -1;\n\ts->default_ccolour = -1;\n\ts->tabs = NULL;\n\ts->sel = NULL;\n\n#ifdef ENABLE_SIXEL\n\tTAILQ_INIT(&s->images);\n#endif\n\n\ts->write_list = NULL;\n\ts->hyperlinks = NULL;\n\n\tscreen_reinit(s);\n", "Selected Statement": "s->grid = grid_create(sx, sy, hlimit);", "Function Input": {"s": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"title": {"type_category": "string", "concrete_type": "string", "value": "0x800000008 <error: Cannot access memory at address 0x800000008>"}, "path": {"type_category": "string", "concrete_type": "NULL"}, "titles": {"type_category": "pointer", "concrete_type": "NULL"}, "grid": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x26ebb10", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xffffffff\n", "message": "Cannot access memory at address 0xffffffff"}}, "cx": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "cy": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "cstyle": {"type_category": "unknown", "concrete_type": "screen_cursor_style", "value": "SCREEN_CURSOR_DEFAULT"}, "default_cstyle": {"type_category": "unknown", "concrete_type": "screen_cursor_style", "value": "SCREEN_CURSOR_DEFAULT"}, "ccolour": {"type_category": "int", "concrete_type": "int", "value": "0"}, "default_ccolour": {"type_category": "int", "concrete_type": "int", "value": "0"}, "rupper": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "rlower": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "mode": {"type_category": "int", "concrete_type": "int", "value": "0"}, "default_mode": {"type_category": "int", "concrete_type": "int", "value": "0"}, "saved_cx": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "saved_cy": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "saved_grid": {"type_category": "pointer", "concrete_type": "NULL"}, "saved_cell": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"data": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"data": {"type_category": "string", "concrete_type": "string", "value": "\"\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\""}, "have": {"type_category": "unknown", "concrete_type": "u_char", "value": "0 '\\000'"}, "size": {"type_category": "unknown", "concrete_type": "u_char", "value": "0 '\\000'"}, "width": {"type_category": "unknown", "concrete_type": "u_char", "value": "0 '\\000'"}}}, "attr": {"type_category": "unknown", "concrete_type": "u_short", "value": "0"}, "flags": {"type_category": "unknown", "concrete_type": "u_char", "value": "0 '\\000'"}, "fg": {"type_category": "int", "concrete_type": "int", "value": "0"}, "bg": {"type_category": "int", "concrete_type": "int", "value": "0"}, "us": {"type_category": "int", "concrete_type": "int", "value": "0"}, "link": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}}}, "saved_flags": {"type_category": "int", "concrete_type": "int", "value": "0"}, "tabs": {"type_category": "string", "concrete_type": "NULL"}, "sel": {"type_category": "pointer", "concrete_type": "NULL"}, "write_list": {"type_category": "pointer", "concrete_type": "NULL"}, "hyperlinks": {"type_category": "pointer", "concrete_type": "NULL"}}}}}, "Variable Values Before Statement": {"sx": "u_int", "sy": "u_int", "hlimit": "u_int"}, "Value After Statement Execution": "NULL", "Function Name": "grid_create", "Project Information": "tmux"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nstruct grid *\ngrid_create(u_int sx, u_int sy, u_int hlimit)\n{\n\tstruct grid\t*gd;\n\n\tgd = xmalloc(sizeof *gd);\n\tgd->sx = sx;\n\tgd->sy = sy;\n\n\tif (hlimit != 0)\n\t\tgd->flags = GRID_HISTORY;\n\telse\n\t\tgd->flags = 0;\n\n\tgd->hscrolled = 0;\n\tgd->hsize = 0;\n\tgd->hlimit = hlimit;\n\n\tif (gd->sy != 0)\n\t\tgd->linedata = xcalloc(gd->sy, sizeof *gd->linedata);\n\telse\n\t\tgd->linedata = NULL;\n\n", "Selected Statement": "gd = xmalloc(sizeof *gd);", "Function Input": {}, "Variable Values Before Statement": {}, "Value After Statement Execution": {"flags": "29426448", "sx": "0", "sy": "0", "hscrolled": "0", "hsize": "779711604", "hlimit": "892549169", "linedata": null}, "Function Name": "xmalloc", "Project Information": "tmux"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nstruct hyperlinks *\nhyperlinks_init(void)\n{\n\tstruct hyperlinks\t*hl;\n\n\thl = xcalloc(1, sizeof *hl);\n\thl->next_inner = 1;\n\tRB_INIT(&hl->by_uri);\n\tRB_INIT(&hl->by_inner);\n", "Selected Statement": "hl = xcalloc(1, sizeof *hl);", "Function Input": {}, "Variable Values Before Statement": {"1": "1"}, "Value After Statement Execution": {"next_inner": "0", "by_inner": null, "by_uri": null}, "Function Name": "xcalloc", "Project Information": "tmux"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\n\n\nint stun_is_command_message_str(const uint8_t *buf, size_t blen) {\n  if (buf && blen >= STUN_HEADER_LENGTH) {\n    if (!STUN_VALID_CHANNEL(nswap16(((const uint16_t *)buf)[0]))) {\n      if ((((uint8_t)buf[0]) & ((uint8_t)(0xC0))) == 0) {\n        if (nswap32(((const uint32_t *)(buf))[1]) == STUN_MAGIC_COOKIE) {\n          uint16_t len = nswap16(((const uint16_t *)(buf))[1]);\n          if ((len & 0x0003) == 0) {\n            if ((size_t)(len + STUN_HEADER_LENGTH) == blen) {\n              return 1;\n            }\n          }\n        }\n      }\n    }\n  }\n  return 0;\n", "Selected Statement": "uint16_t len = nswap16(((const uint16_t *)(buf))[1]);", "Function Input": {}, "Variable Values Before Statement": {}, "Value After Statement Execution": "64256", "Function Name": "nswap16", "Project Information": "coturn"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "onig_detect_can_be_slow_pattern(const UChar* pattern,\n  const UChar* pattern_end, OnigOptionType option, OnigEncoding enc,\n  OnigSyntaxType* syntax)\n{\n  int r;\n  regex_t* reg;\n  Node* root;\n  ParseEnv scan_env;\n  SlowElementCount count;\n  int calls[MAX_CALLS_IN_DETECT];\n#ifdef USE_CALL\n  UnsetAddrList  uslist = {0};\n#endif\n\n  reg = (regex_t* )xmalloc(sizeof(regex_t));\n  if (IS_NULL(reg)) return ONIGERR_MEMORY;\n\n  r = onig_reg_init(reg, option, ONIGENC_CASE_FOLD_DEFAULT, enc, syntax);\n  if (r != 0) {\n    xfree(reg);\n    return r;\n  }\n\n  r = parse_and_tune(reg, pattern, pattern_end, &scan_env, &root, NULL\n#ifdef USE_CALL\n                     , &uslist\n#endif\n                    );\n  if (r != 0) goto err;\n\n#ifdef USE_CALL\n  if (scan_env.num_call > 0) {\n    unset_addr_list_end(&uslist);\n  }\n#endif\n\n  count.prec_read          = 0;\n  count.look_behind        = 0;\n  count.backref            = 0;\n  count.backref_with_level = 0;\n  count.call               = 0;\n  count.is_keep            = FALSE;\n  count.anychar_reluctant_many     = 0;\n  count.empty_check_nest_level     = 0;\n  count.max_empty_check_nest_level = 0;\n  count.heavy_element = 0;\n\n  r = detect_can_be_slow(root, &count, 0, calls);\n  if (r == 0) {\n    int n;\n\n    n = count.prec_read + count.look_behind\n      + count.backref + count.backref_with_level + count.call\n      + count.anychar_reluctant_many;\n\n    if (count.is_keep) count.max_empty_check_nest_level++;\n\n    if (count.max_empty_check_nest_level > 2)\n      n += count.max_empty_check_nest_level - 2;\n    if (count.heavy_element != 0) {\n      if (count.heavy_element < 0x10000)\n        n += count.heavy_element << 8;\n      else\n        n += count.heavy_element;\n    }\n\n    r = n;\n\n#ifdef ONIG_DEBUG_PARSE\n    fprintf(DBGFP, \"-- detect can be slow --\\n\");\n    fprintf(DBGFP, \"  prec_read:          %d\\n\", count.prec_read);\n    fprintf(DBGFP, \"  look_behind:        %d\\n\", count.look_behind);\n    fprintf(DBGFP, \"  backref:            %d\\n\", count.backref);\n    fprintf(DBGFP, \"  backref_with_level: %d\\n\", count.backref_with_level);\n    fprintf(DBGFP, \"  call:               %d\\n\", count.call);\n    fprintf(DBGFP, \"  is_keep:            %d\\n\", count.is_keep);\n    fprintf(DBGFP, \"  any_reluctant_many: %d\\n\", count.anychar_reluctant_many);\n    fprintf(DBGFP, \"  max_empty_check_nest_level: %d\\n\", count.max_empty_check_nest_level);\n    fprintf(DBGFP, \"  heavy_element:      %d\\n\", count.heavy_element);\n    fprintf(DBGFP, \"  r:                  %d\\n\", r);\n    fprintf(DBGFP, \"\\n\");\n#endif\n  }\n\n  if (IS_NOT_NULL(scan_env.mem_env_dynamic))\n    xfree(scan_env.mem_env_dynamic);\n\n err:\n  onig_node_free(root);\n  onig_free(reg);\n  return r;\n", "Selected Statement": "r = onig_reg_init(reg, option, ONIGENC_CASE_FOLD_DEFAULT, enc, syntax);", "Function Input": {"reg": {"value": null}}, "Variable Values Before Statement": {"reg": {"ops": null, "ocs": null, "ops_curr": null, "ops_used": "0", "ops_alloc": "0", "string_pool": null, "string_pool_end": null, "num_mem": "0", "num_repeat": "0", "num_empty_check": "0", "num_call": "0", "capture_history": "0", "push_mem_start": "0", "push_mem_end": "0", "stack_pop_level": "0", "repeat_range_alloc": "0", "repeat_range": null, "enc": "0x656be0 <OnigEncodingEUC_JP>", "options": "29524", "syntax": null, "case_fold_flag": "1073741824", "name_table": null, "optimize": "0", "threshold_len": "0", "anchor": "0", "anc_dist_min": "0", "anc_dist_max": "0", "sub_anchor": "0", "exact": null, "exact_end": null, "map": "\"\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\"", "map_offset": "0", "dist_min": "0", "dist_max": "0", "extp": null}, "option": "OnigOptionType", "ONIGENC_CASE_FOLD_DEFAULT": "NULL", "enc": "OnigEncoding", "syntax": {"op": "92476758", "op2": "0", "behavior": "2155872263", "options": "12", "meta_char_table": null}}, "Value After Statement Execution": "int", "Function Name": "onig_reg_init", "Project Information": "oniguruma"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "                         OnigCalloutFunc end_func,\n                         int arg_num, unsigned int arg_types[],\n                         int opt_arg_num, OnigValue opt_defaults[])\n{\n  int r;\n  int i;\n  int j;\n  int id;\n  int is_not_single;\n  CalloutNameEntry* e;\n  CalloutNameListEntry* fe;\n\n  if (callout_type != ONIG_CALLOUT_TYPE_SINGLE)\n    return ONIGERR_INVALID_ARGUMENT;\n\n  if (arg_num < 0 || arg_num > ONIG_CALLOUT_MAX_ARGS_NUM)\n    return ONIGERR_INVALID_CALLOUT_ARG;\n\n  if (opt_arg_num < 0 || opt_arg_num > arg_num)\n    return ONIGERR_INVALID_CALLOUT_ARG;\n\n  if (start_func == 0 && end_func == 0)\n    return ONIGERR_INVALID_CALLOUT_ARG;\n\n  if ((in & ONIG_CALLOUT_IN_PROGRESS) == 0 && (in & ONIG_CALLOUT_IN_RETRACTION) == 0)\n    return ONIGERR_INVALID_CALLOUT_ARG;\n\n  for (i = 0; i < arg_num; i++) {\n    unsigned int t = arg_types[i];\n    if (t == ONIG_TYPE_VOID)\n      return ONIGERR_INVALID_CALLOUT_ARG;\n    else {\n      if (i >= arg_num - opt_arg_num) {\n        if (t != ONIG_TYPE_LONG && t != ONIG_TYPE_CHAR && t != ONIG_TYPE_STRING &&\n            t != ONIG_TYPE_TAG)\n          return ONIGERR_INVALID_CALLOUT_ARG;\n      }\n      else {\n        if (t != ONIG_TYPE_LONG) {\n          t = t & ~ONIG_TYPE_LONG;\n          if (t != ONIG_TYPE_CHAR && t != ONIG_TYPE_STRING && t != ONIG_TYPE_TAG)\n            return ONIGERR_INVALID_CALLOUT_ARG;\n        }\n      }\n    }\n  }\n\n  if (! is_allowed_callout_name(enc, name, name_end)) {\n    return ONIGERR_INVALID_CALLOUT_NAME;\n  }\n\n  is_not_single = (callout_type != ONIG_CALLOUT_TYPE_SINGLE);\n  id = callout_name_entry(&e, enc, is_not_single, name, name_end);\n  if (id < 0) return id;\n\n  r = ONIG_NORMAL;\n  if (IS_NULL(GlobalCalloutNameList)) {\n    r = make_callout_func_list(&GlobalCalloutNameList, 10);\n    if (r != ONIG_NORMAL) return r;\n  }\n\n  while (id >= GlobalCalloutNameList->n) {\n    int rid;\n    r = callout_func_list_add(GlobalCalloutNameList, &rid);\n    if (r != ONIG_NORMAL) return r;\n  }\n\n  fe = GlobalCalloutNameList->v + id;\n  fe->type         = callout_type;\n  fe->in           = in;\n  fe->start_func   = start_func;\n  fe->end_func     = end_func;\n  fe->arg_num      = arg_num;\n  fe->opt_arg_num  = opt_arg_num;\n  fe->name         = e->name;\n\n  for (i = 0; i < arg_num; i++) {\n    fe->arg_types[i] = arg_types[i];\n  }\n  for (i = arg_num - opt_arg_num, j = 0; i < arg_num; i++, j++) {\n    if (IS_NULL(opt_defaults)) return ONIGERR_INVALID_ARGUMENT;\n    if (fe->arg_types[i] == ONIG_TYPE_STRING) {\n      OnigValue* val;\n      UChar* ds;\n\n      val = opt_defaults + j;\n      ds = onigenc_strdup(enc, val->s.start, val->s.end);\n      CHECK_NULL_RETURN_MEMERR(ds);\n\n      fe->opt_defaults[i].s.start = ds;\n      fe->opt_defaults[i].s.end   = ds + (val->s.end - val->s.start);\n    }\n    else {\n      fe->opt_defaults[i] = opt_defaults[j];\n    }\n  }\n\n  r = id;\n  return r;\n", "Selected Statement": "id = callout_name_entry(&e, enc, is_not_single, name, name_end);", "Function Input": {}, "Variable Values Before Statement": {"enc": "OnigEncoding", "is_not_single": "int", "name": "0x5dc019 \"FAIL\"", "name_end": "0x5dc01d \"\""}, "Value After Statement Execution": "int", "Function Name": "callout_name_entry", "Project Information": "oniguruma"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nextern st_table*\nst_init_table_with_size(struct st_hash_type* type, int size)\n{\n  st_table *tbl;\n\n#ifdef HASH_LOG\n  if (init_st == 0) {\n    init_st = 1;\n    atexit(stat_col);\n  }\n#endif\n\n  size = new_size(size);\t\n  if (size <= 0) return 0;\n\n  tbl = alloc(st_table);\n  if (tbl == 0) return 0;\n\n  tbl->type = type;\n  tbl->num_entries = 0;\n  tbl->num_bins = size;\n  tbl->bins = (st_table_entry **)Calloc(size, sizeof(st_table_entry*));\n  if (tbl->bins == 0) {\n    free(tbl);\n    return 0;\n  }\n\n  return tbl;\n", "Selected Statement": "size = new_size(size);\t/* round up to prime number */", "Function Input": {"size": {"value": "0"}}, "Variable Values Before Statement": {"size": "int"}, "Value After Statement Execution": "int", "Function Name": "new_size", "Project Information": "oniguruma"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "#include \"dds/ddsrt/random.h\"\n\nbool ddsrt_prng_makeseed (struct ddsrt_prng_seed *seed)\n{\n  FILE *rndfile;\n  memset (seed->key, 0, sizeof (seed->key));\n  if ((rndfile = fopen (\"/dev/urandom\", \"rb\")) == NULL)\n    return false;\n  else\n  {\n    size_t n = fread (seed->key, sizeof (seed->key), 1, rndfile);\n    fclose (rndfile);\n    return (n == 1);\n  }\n", "Selected Statement": "size_t n = fread (seed->key, sizeof (seed->key), 1, rndfile);", "Function Input": {}, "Variable Values Before Statement": {"1": "1", "rndfile": "NULL"}, "Value After Statement Execution": "1", "Function Name": "fread", "Project Information": "cyclonedds"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nstruct ucl_parser*\nucl_parser_new (int flags)\n{\n\tstruct ucl_parser *parser;\n\n\tparser = UCL_ALLOC (sizeof (struct ucl_parser));\n\tif (parser == NULL) {\n\t\treturn NULL;\n\t}\n\n\tmemset (parser, 0, sizeof (struct ucl_parser));\n\n\tUPRM_SAFE(ucl_parser_register_macro, parser, \"include\", ucl_include_handler, e0);\n\tUPRM_SAFE(ucl_parser_register_macro, parser, \"try_include\", ucl_try_include_handler, e0);\n\tUPRM_SAFE(ucl_parser_register_macro, parser, \"includes\", ucl_includes_handler, e0);\n\tUPRM_SAFE(ucl_parser_register_macro, parser, \"priority\", ucl_priority_handler, e0);\n\tUPRM_SAFE(ucl_parser_register_macro, parser, \"load\", ucl_load_handler, e0);\n\tUPRM_SAFE(ucl_parser_register_context_macro, parser, \"inherit\", ucl_inherit_handler, e0);\n\n\tparser->flags = flags;\n\tparser->includepaths = NULL;\n\n\tif (flags & UCL_PARSER_SAVE_COMMENTS) {\n\t\tparser->comments = ucl_object_typed_new (UCL_OBJECT);\n\t}\n\n\tif (!(flags & UCL_PARSER_NO_FILEVARS)) {\n\t\t\n\t\tucl_parser_set_filevars (parser, NULL, false);\n\t}\n\n\treturn parser;\ne0:\n\tucl_parser_free(parser);\n\treturn NULL;\n", "Selected Statement": "parser = UCL_ALLOC (sizeof (struct ucl_parser));", "Function Input": {"parser": {"value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x1\n", "message": "Cannot access memory at address 0x1"}}}, "Variable Values Before Statement": {}, "Value After Statement Execution": {"state": "4158786528", "prev_state": "32767", "recursion": "4158786528", "flags": "32767", "default_priority": "0", "err_code": "0", "top_obj": null, "cur_obj": null, "trash_objs": null, "includepaths": null, "cur_file": "0x3833366263622f65 <error: Cannot access memory at address 0x3833366263622f65>", "macroes": null, "stack": null, "chunks": null, "keys": null, "special_handlers": null, "include_trace_func": null, "include_trace_ud": "0x13a0", "variables": "0x50", "var_handler": "0xf9f290", "var_data": "0x3461373064662f65", "comments": "0x3639356362626262", "last_comment": "0x3363636637663233", "err": "0x3461643564313864"}, "Function Name": "UCL_ALLOC", "Project Information": "libucl"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nbool\nucl_parser_set_filevars (struct ucl_parser *parser, const char *filename, bool need_expand)\n{\n\tchar realbuf[PATH_MAX], *curdir;\n\n\tif (filename != NULL) {\n\t\tif (need_expand) {\n\t\t\tif (ucl_realpath (filename, realbuf) == NULL) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tucl_strlcpy (realbuf, filename, sizeof (realbuf));\n\t\t}\n\n\t\tif (parser->cur_file) {\n\t\t\tfree (parser->cur_file);\n\t\t}\n\n\t\tparser->cur_file = strdup (realbuf);\n\n\t\t\n\t\tucl_parser_register_variable (parser, \"FILENAME\", realbuf);\n\t\tcurdir = dirname (realbuf);\n\t\tucl_parser_register_variable (parser, \"CURDIR\", curdir);\n\t}\n\telse {\n\t\t\n\t\tcurdir = getcwd (realbuf, sizeof (realbuf));\n\t\tucl_parser_register_variable (parser, \"FILENAME\", \"undef\");\n\t\tucl_parser_register_variable (parser, \"CURDIR\", curdir);\n\t}\n\n\treturn true;\n", "Selected Statement": "curdir = getcwd (realbuf, sizeof (realbuf));", "Function Input": {}, "Variable Values Before Statement": {"realbuf": "\"/out\\000\\177\\000\\000\\240\\037\\000\\000\\377\\377\\000\\000\\020\\000\\000\\0000\\000\\000\\000\\240\\330\\377\\377\\377\\177\\000\\000\\000^\\371\\000\\000\\000\\000\\000\\000^\\371\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\006\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\\\\244\\375\\367\\377\\177\\000\\0000I\\374\\367\\377\\177\\000\\000\\242\\201F\\263\\000\\000\\000\\000\\220\\023@\\000\\000\\000\\000\\000\\001\\000\\000\\000\\000\\000\\000\\000\\240\\321\\341\\367\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\220\\001\\337\\367\\377\\177\\000\\000\\000\\326\\377\\377\\377\\177\\000\\0000\\324\\377\\377\\377\\177\\000\\0003|\\313\\367\\377\\177\\000\\000\\300\\240\\371\\000\\000\\000\\000\\000\\300\\240\\371\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000Y`\\314\\367\\377\\177\\000\\0002BT\\000\\000\\000\\000\\000\\000\\215l\\\\g\\030\\303\\366\\355\\206\\334\\030\\264Y\\024@\\322?T\\000\\000\\000\\000\\000\\020\\324\\377\\377\\377\\177\\000\\0000\\324\\377\\377\\377\\177\\000\\000\\216?T\\000\\000\\000\\000\\000\\000\\326\\377\\377\\377\\177\\000\\000\\001\\000\\000\\000\\000\\000\\000\\000\\346\\257\\312\\367\\377\\177\\000\\000tures_dir, corpu\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\377\\377\\377\\377\\377\\377\\377\\377\\000\\000\\000\\000\\000\\000\\000\\000\\005\\000\\000\\000\\000\\000\\000\\000\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000 ?T\\000\\000\\000\\000\\000\\330\\323\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000a\\000\\000\\000\\000\\000\\000\\000a\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\240\\310\\341\\367\\377\\177\\000\\000h\\r\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\242?T\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\340\\v\\342\\367\\377\\177\\000\\000\\001\\000\\000\\000\\000\\000\\000\\000\\002\\000\\000\\000\\000\\000\\000\\000\\356\\000\\000\\000\\000\\000\\000\\200\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000/DT\\000\\000\\000\\000\\000\\020\\000\\000\\0000\\000\\000\\000`\\327\\377\\377\\377\\177\\000\\000p\\326\\377\\377\\377\\177\\000\\000\\260\\333\\377\\377\\377\\177\\000\\000\\260\\333\\377\\377\\377\\177\\000\\000\\030\\335\\377\\377\\377\\177\\000\\000\\240\\333\\377\\377\\377\\177\\000\\000\\030\\000\\000\\000\\000\\000\\000\\000\\227\\001\\376\\367\\377\\177\\000\\000\\005\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\377\\377\\377\\377\\377\\377\\377\\377\\260\\246\\303\\367\\377\\177\\000\\000p\\332\\377\\377\\377\\177\\000\\000>|\\376\\367\\377\\177\\000\\000 \\000\\000\\0000\\000\\000\\000\\240\\333\\377\\377\\377\\177\\000\\000`\\371\\341\\367\\377\\177\\000\\000\\030\\000\\000\\000\\000\\000\\000\\000`\\371\\341\\367\\377\\177\\000\\000\\302\\000\\000\\000\\000\\000\\000\\000\\305]Q\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\240\\310\\341\\367\\377\\177\\000\\000h\\r\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\240\\037\\000\\000\\377\\377\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\240^\\304\\367\\377\\177\\000\\000\\212\\250\\375\\367\\377\\177\\000\\000\\221\\006\\000\\000\\000\\000\\000\\000\\\\\\244\\375\\367\\377\\177\\000\\0000I\\374\\367\\377\\177\\000\\000\\026\\352v\\376\\000\\000\\000\\000H\\031@\\000\\000\\000\\000\\0000 \\303\\367\\377\\177\\000\\000\\220u\\303\\367\\377\\177\\000\\000\\212\\250\\375\\367\\377\\177\\000\\000\\213\\006\\000\\000\\000\\000\\000\\000\\240^\\304\\367\\377\\177\\000\\0000I\\374\\367\\377\\177\\000\\000\\310\\321\\377\\377\\377\\177\\000\\000\\304\\321\\377\\377\\377\\177\\000\\000\\n)U\\r\\363P[j\\240^\\304\\367\\377\\177\\000\\000\\n\\000)\\000U\\000\\r\\000~\\245\\305\\334\\023|\\337>p\\200\\303\\367\\377\\177\\000\\000\\313,@\\000\\000\\000\\000\\000\\026\\352v\\376\\000\\000\\000\\000\\250\\333\\371\\003\\000\\000\\000\\000\\304\\321\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\263\\231\\311?\\220\\322\\377\\377\\377\\177\\000\\000H\\031@\\000\\000\\000\\000\\000\\200\\322\\377\\377\\377\\177\\000\\000 9\\000\\000\\000\\000\\000\\000\\250O\\374\\367\\377\\177\\000\\000\\b\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\026\\352v\\376\\000\\000\\000\\000\\370\\344\\377\\367\\377\\177\\000\\000(\\323\\377\\377\\377\\177\\000\\000\\313,@\\000\\000\\000\\000\\000\\200\\322\\377\\377\\377\\177\\000\\000\\220\\322\\377\\377\\377\\177\\000\\000\\361\\261\\375\\367\\377\\177\\000\\000\\006\\000\\000\\000\\000\\000\\000\\0000 \\303\\367\\377\\177\\000\\000\\005\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\001\\000\\000\\000\\000\\000\\000\\000\\220\\341\\377\\367\\377\\177\\000\\000\\320\\322\\377\\377\\000\\000\\000\\0000 \\303\\367\\377\\177\\000\\000\\220\\341\\377\\367\\377\\177\\000\\000\\370\\344\\377\\367\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\250\\323\\377\\377\\377\\177\\000\\000\\251*@\\000\\000\\000\\000\\000\\001\\000\\000\\000\\377\\177\\000\\000\\377\\377\\377\\377\\000\\000\\000\\000\\356\\000\\000\\000\\000\\000\\000\\200x\\035\\304\\367\\377\\177\\000\\0000I\\374\\367\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\240\\321\\341\\367\\377\\177\\000\\000P\\330\\377\\377\\377\\177\\000\\000p\\330\\377\\377\\377\\177\\000\\000\\000\\333\\377\\377\\377\\177\\000\\000\\360\\331\\377\\377\\377\\177\\000\\000x\\000\\000\\000\\000\\000\\000\\000\\346\\257\\312\\367\\377\\177\\000\\000\\220\\335\\377\\377\\377\\177\\000\\000\\223\\200Q\\000\\000\\000\\000\\000 \\273\\370\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\002\\333\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\377\\377\\377\\377\\377\\377\\377\\377\\000\\000\\000\\000\\000\\000\\000\\000\\001\\000\\000\\000\\000\\000\\000\\000\\020\\000\\000\\000\\377\\177\\000\\000'\\000\\000\\000\\000\\000\\000\\000\\240\\321\\341\\367\\377\\177\\000\\000\\360\\330\\377\\377\\377\\177\\000\\000\\020\\331\\377\\377\\377\\177\\000\\000\\240\\333\\377\\377\\377\\177\\000\\000\\220\\332\\377\\377\\377\\177\\000\\000x\\000\\000\\000\\000\\000\\000\\000\\346\\257\\312\\367\\377\\177\\000\\000\\240\\310\\341\\367\\377\\177\\000\\000h\\r\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000@\\361\\371\\000\\000\\000\\000\\000\\277\\361\\371\\000\\000\\000\\000\\000\\377\\377\\377\\377\\377\\377\\377\\377\\277\\361\\371\\000\\000\\000\\000\\0000\\324\\377\\377\\377\\177\\0000\\000\\215l\\\\g\\030\\303\\366@\\361\\371\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\177\\000\\000\\000\\000\\000\\000\\0000\\324\\377\\377\\377\\177\\000\\000\\216?T\\000\\000\\000\\000\\000\\000\\326\\377\\377\\377\\177\\000\\000@\\361\\371\\000\\000\\000\\000\\000\\232\\377\\313\\367\\377\\177\\000\\000\\240\\310\\341\\367\\000\\000\\000\\000 \\325\\377\\377\\377\\177\\000\\000\\001\\200\\255\\373\\000\\000\\000\\000@\\361\\371\\000\\000\\000\\000\\000@\\361\\371\\000\\000\\000\\000\\000@\\361\\371\\000\\000\\000\\000\\000@\\361\\371\\000\\000\\000\\000\\000\\242\\361\\371\\000\\000\\000\\000\\000\\277\\361\\371\\000\\000\\000\\000\\000@\\361\\371\\000\\000\\000\\000\\000\\277\\361\\371\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\002\\000\\000\\000\\200\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\341\\367\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\0000\\334\\377\\377\\377\\177\\000\\000\\377\\377\\377\\377\\377\\377\\377\\377\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\377\\377\\377\\377\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\240\\321\\341\\367\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000 9\\000\\00009\\000\\000@9\\000\\000`T\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000 \\000\\000\\0000\\000\\000\\000 \\334\\377\\377\\377\\177\\000\\000@\\333\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\215l\\\\g\\030\\303\\366\\000\\000\\000\\000\\000\\000\\000\\000\\001\\000\\000\\000\\000\\000\\000\\000@\\326\\377\\377\\377\\177\\000\\000P\\354\\371\\000\\000\\000\\000\\000\\000@Y\\000\\000\\000\\000\\000\\360\\307\\371\\000\\000\\000\\000\\000@\\326\\377\\377\\377\\177\\000\\000A\\214L\\000\\000\\000\\000\\000\\002\\000\\000\\000\\000\\000\\000\\000\\t\\000\\000\\0002\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\200\\000\\000\\000b\\000\\000\\000b\\000\\000\\000\\020\\361\\371\\000\\000\\000\\000\\000\\216?T\\000\\000\\000\\000\\000 \\327\\377\\377\\377\\177\\000\\000@\\326\\377\\377\\377\\177\\000\\0000\\000\\000\\0000\\000\\000\\000h\\327\\377\\377\\377\\177\\000\\000p\\326\\377\\377\\377\\177\\000\\000\\360\\307\\371\\000\\000\\000\\000\\000 \\273\\370\\000b\\000\\000\\000 \\327\\377\\377\\377\\177\\000\\000\\216?T\\000\\000\\000\\000\\000\\020\\361\\371\\000\\000\\000\\000\\000P\\327\\377\\377\\377\\177\\000\\000pWL\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\216?T\\000\\000\\000\\000\\000\\000\\347\\371\\000\\000\\000\\000\\000P\\327\\377\\377\\377\\177\\000\\000\\000\\327\\037\\366\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\\\\\"T\\000\\000\\000\\000\\000\\001\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\0002BT\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\215l\\\\g\\030\\303\\366\\a\\000\\000\\000\\000\\000\\000\\000\\001\\000\\000\\000\\000\\000\\000\\000\\200\\327\\377\\377\\377\\177\\000\\000\\220@\\371\\000\\000\\000\\000\\000\\000@Y\\000\\000\\000\\000\\000\\320\\363\\370\\000\\000\\000\\000\\000\\200\\327\\377\\377\\377\\177\\000\\000A\\214L\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\215l\\\\g\\030\\303\\366\\002\\000\\000\\000\\000\\000\\000\\000\\260\\334\\377\\377\\377\\177\\000\\000\\023[\\315W\\330\\\\\\363'v6\\b\\022\\277\\264O\\000\\023[\\315W\\330\\\\\\363'v6\\b\\022\\277\\264O\\000\\033F\\261\\231|\\324G\\257inherit\\000 \\330\\377\\377\\377\\177\\000\\000\\201\\207L\\000\\000\\000\\000\\000(\\000\\000\\000<\\000\\000\\000\\000\\215l\\\\\\000\\200\\000\\000(\\323\\327w\\017QC\\234l-&\\021\\365\\211,\\0202BT\\000\\000\\000\\000\\000\\000\\347\\371\\000\\000\\000\\000\\000\\037D\\250>\\200\\244\\256\\\\\\a\\000\\000\\000\\000\\000\\000\\000\\006\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\a\\000\\000\\000\\000\\000\\000\\000\\270y7\\236\\000\\000\\000\\000\\371\\322s\\005\\016\\037\\336p3\\\\\\342:\\355p\\016\\a\\371\\322s\\005\\016\\037\\336p3\\\\\\342:\\355p\\016\\a\\033F\\261\\231|\\324G\\257{\\254W\\255\\312UN\\n \\330\\377\\377\\377\\177\\000\\000\\226\\212L\\000\\000\\000\\000\\000\\a\\000\\000\\000\\000\\000\\000\\000\\226\\325}W\\027\\265\\355t \\330\\377\\377\\377\\177\\000\\000W\\203\\001\\3551\\332\\242}\\200\\334\\377\\377\\377\\177\\000\\000\\321\\204L\\000\\000\\000\\000\\000`\\367\\371\\000\\000\\000\\000\\000\\a\\000\\000\\000\\000\\000\\000\\000\\261y7\\236\\000\\000\\000\\000\\200\\334\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000|\\000\\000\\000w\\000\\000\\000n\\000\\000\\000[\\000\\000\\000\\017\\316N\\000\\000\\000\\000\\000\\001\\000\\000\\000\\000\\000\\000\\000\\001\\000\\000\\000\\000\\000\\000\\000(\\000\\000\\000(\\000\\000\\000\\200\\v\\342\\367(\\000\\000\\000\\000@Y\\000\\000\\000\\000\\000\\001\\000\\000\\000\\000\\000\\000\\000 \\273\\370\\000\\000\\000\\000\\000\\231\\342\\314\\367(\\000\\000\\000`\\346\\371\\000\\000\\000\\000\\000\\360\\354\\371\\000\\000\\000\\000\\000G\\333\\377\\377\\377\\177\\000\\000F\\333\\377\\377\\377\\177\\000\\000@\\331\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\377\\177\\000\\000\\240\\333\\377\\377\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\001\\000\\000\\000\\000\\000\\000\\000@\\331\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\360\\307\\371\\000\\000\\000\\000\\000F\\333\\377\\377\\377\\177\\000\\000G\\333\\377\\377\\377\\177\\000\\000\\360\\354\\371\\000\\000\\000\\000\\000`\\346\\371\\000\\000\\000\\000\\000\\020\\000\\000\\000\\000\\000\\000\\000\\240\\333\\377\\377\\377\\177\\000\\000\\316_L\\000\\000\\000\\000\\000@\\334\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\027\\000\\000\\000\\000\\000\\000\\000\\240\\331\\377\\377\\377\\177\\000\\0000\\334\\377\\377\\377\\177\\000\\000 \\333\\377\\377\\377\\177\\000\\000@\\334\\377\\377\\377\\177\\000\\000\\232\\377\\313\\367\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\220\\332\\377\\377\\377\\177\\000\\000\\001\\200\\255\\373\\000\\000\\000\\000@\\334\\377\\377\\377\\177\\000\\000@\\334\\377\\377\\377\\177\\000\\000@\\334\\377\\377\\377\\177\\000\\000@\\334\\377\\377\\377\\177\\000\\000B\\334\\377\\377\\377\\177\\000\\000W\\334\\377\\377\\377\\177\\000\\000@\\334\\377\\377\\377\\177\\000\\000W\\334\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000H\\204X\\000\\200\\000\\000\\000`\\332\\377\\377\\377\\177\\000\\000\\000\\000\\\\\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\0000\\000\\000\\000\\000\\000\\000\\0000\\000\\000\\000\\000\\000\\000\\000\\377\\377\\377\\377\\377\\377\\377\\377\\000\\000\\000\\000\\000\\000\\000\\000,\\000\\000\\000\\000\\000\\000\\000\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\177\\000\\000\\260\\333\\377\\377\\377\\177\\000\\000\\030\\335\\377\\377\\377\\177\\000\\000\\240\\321\\341\\367\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\363\\305\\314\\367\\377\\177\\000\\000\\320\\001\\372\\000\\000\\000\\000\\000\\340\\v\\342\\367\\377\\177\\000\\000\\a\\000\\000\\000\\000\\000\\000\\000\\016\\262\\370\\000\\000\\000\\000\\000\\000\\020\\000\\000\\000\\000\\000\\000c\\000\\000\\000\\377\\177\\000\\000\\b\\270\\370\\000\\000\\000\\000\\0000\\020\\000\\000\\000\\000\\000\\000@\\000\\000\\000\\000\\000\\000\\000\\001\\001\\000\\000p\\000\\000\\000\\b\\000\\000\\000\\000\\000\\000\\000\\001\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000|\\000\\000\\000w\\000\\000\\000o\\000\\000\\000c\\000\\000\\0000\\334\\377\\377\\377\\177\\000\\000\\003\\000\\000\\000\\000\\000\\000\\000\\377\\000\\000\\000\\000\\000\\000\\000\\000\\020\\000\\000\\000\\000\\000\\000\\200\\v\\342\\367\\377\\177\\000\\000\\002\\000\\000\\000\\000\\000\\000\\000\\377\\377\\377\\377\\377\\377\\377\\377\\340\\001\\372\\000\\000\\000\\000\\000\\340\\021\\372\\000\\000\\000\\000\\000\\000\\020\\000\\000\\000\\000\\000\\000\\000\\020\\000\\000\\000\\000\\000\\000\\360E\\371\\000\\000\\000\\000\\000\\035]\\313\\367\\377\\177\\000\\000\\000\\375\\000\\000\\000\\000\\000\\000\\246\\200>\\000\\000\\000\\000\\000\\001\\000\\000\\000\\000\\000\\000\\000\\244\\201\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\001\\000\\000\\000\\000\\000\\000\\000\\000\\020\\000\\000\\000\\000\\000\\000\\b\\000\\000\\000\\000\\000\\000\\000\\n\\300\\316e\\000\\000\\000\\000\\264\\372O$\\000\\000\\000\\000\\t\\300\\316e\\000\\000\\000\\000\\357T\\357&\\000\\000\\000\\000\\t\\300\\316e\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000 \\000\\000\\000\\000\\000\\000\\000\\a\\000\\000\\000\\000\\000\\000\\000\\020\\260\\370\\000\\000\\000\\000\\000\\b\\000\\000\\000\\000\\000\\000\\000\\002\\000\\000\\000\\000\\000\\000\\000\\020\\260\\370\\000\\000\\000\\000\\000@\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\002\\000\\000\\0000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000|\\000\\000\\000w\\000\\000\\000n\\000\\000\\000[\\000\\000\\000`\\367\\371\\000\\000\\000\\000\\000\\226\\325}W\\027\\265\\355t\\261y7\\236\\000\\000\\000\\000\\a\\000\\000\\000\\000\\000\\000\\000`\\367\\371\\000\\000\\000\\000\\000\\320\\334\\377\\377\\377\\177\\000\\000\\225FL\\000\\000\\000\\000\\000 \\273\\370\\000\\000\\000\\000\\000`\\367\\371\\000\\000\\000\\000\\000\\a\\000\\000\\000\\000\\000\\000\\000\\261y7\\236\\000\\000\\000\\000\\320\\334\\377\\377\\377\\177\\000\\000\\261y7\\236\\000\\000\\000\\000\\a\\000\\000\\000\\000\\000\\000\\000`\\367\\371\\000\\000\\000\\000\\000\\260\\335\\377\\377\\377\\177\\000\\000\\270@L\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\260\\000\\000\\000\\000\\000\\000\\000\\a\\000\\000\\000\\000\\000\\000\\000\\\"\\260\\370\\000\\000\\000\\000\\000\\250\\000\\000\\000\\000\\000\\000\\000\\v\\000\\000\\000\\377\\177\\000\\000X\\260\\370\\000\\000\\000\\000\\000\\n\\000\\000\\000\\001\\000\\000\\000`\\367\\371\\000\\000\\000\\000\\000\\320\\361\\371\\000\\000\\000\\000\\000+>T\\000\\000\\000\\000\\000\\300\\214M\\000\\000\\000\\000\\000\\320\\361\\371\\000\\000\\000\\000\\000\\260\\335\\377\\377\\377\\177\\000\\000n\\000\\000\\000[\\000\\000\\000\\370\\335\\377\\377\\377\\177\\000\\000\\260\\335\\377\\377\\377\\177\\000\\000\\t\\000\\000\\000\\000\\000\\000\\000\\250\\000\\000\\000\\000\\000\\000\\000\\200\\v\\342\\367\\027\\000\\000\\000\\000\\367\\371\\000\\000\\000\\000\\000\\320\\361\\371\\000\\000\\000\\000\""}, "Value After Statement Execution": "0x7fffffffcd90 \"/out\"", "Function Name": "getcwd", "Project Information": "libucl"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nucl_hash_t*\nucl_hash_create (bool ignore_case)\n{\n\tucl_hash_t *new;\n\n\tnew = UCL_ALLOC (sizeof (ucl_hash_t));\n\tif (new != NULL) {\n\t\tvoid *h;\n\t\tnew->head = NULL;\n\t\tnew->caseless = ignore_case;\n\t\tif (ignore_case) {\n\t\t\th = (void *)kh_init (ucl_hash_caseless_node);\n\t\t}\n\t\telse {\n\t\t\th = (void *)kh_init (ucl_hash_node);\n\t\t}\n\t\tif (h == NULL) {\n\t\t\tUCL_FREE (sizeof (ucl_hash_t), new);\n\t\t\treturn NULL;\n\t\t}\n\t\tnew->hash = h;\n\t}\n\treturn new;\n", "Selected Statement": "new = UCL_ALLOC (sizeof (ucl_hash_t));", "Function Input": {}, "Variable Values Before Statement": {}, "Value After Statement Execution": {"hash": null, "head": null, "caseless": "false"}, "Function Name": "UCL_ALLOC", "Project Information": "libucl"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nvoid\nWS_Init(struct ws *ws, const char *id, void *space, unsigned len)\n{\n\tstruct ws_emu *we;\n\n\tDSLb(DBG_WORKSPACE,\n\t    \"WS_Init(%p, \\\"%s\\\", %p, %u)\", ws, id, space, len);\n\tassert(space != NULL);\n\tassert(PAOK(space));\n\tassert(len >= sizeof *we);\n\n\tlen = PRNDDN(len - 1);\n\tINIT_OBJ(ws, WS_MAGIC);\n\tws->s = space;\n\tws->e = ws->s + len;\n\n\tassert(id[0] & 0x20);\t\t\n\tbstrcpy(ws->id, id);\n\n\twe = space;\n\tINIT_OBJ(we, WS_EMU_MAGIC);\n\tVTAILQ_INIT(&we->head);\n\twe->len = len;\n\n\tWS_Assert(ws);\n", "Selected Statement": "len = PRNDDN(len - 1);", "Function Input": {"ws": {"value": null}}, "Variable Values Before Statement": {}, "Value After Statement Execution": "unsigned int", "Function Name": "PRNDDN", "Project Information": "varnish"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "CxPlatSystemLoad(\n    void\n    )\n{\n#if defined(CX_PLATFORM_DARWIN)\n    \n    \n    \n    \n    CxPlatProcessorCount = 1;\n#else\n    CxPlatProcessorCount = (uint32_t)sysconf(_SC_NPROCESSORS_ONLN);\n#endif\n\n#ifdef CXPLAT_NUMA_AWARE\n    if (numa_available() >= 0) {\n        CxPlatNumaNodeCount = (uint32_t)numa_num_configured_nodes();\n        CxPlatNumaNodeMasks =\n            CXPLAT_ALLOC_NONPAGED(sizeof(cpu_set_t) * CxPlatNumaNodeCount, QUIC_POOL_PLATFORM_PROC);\n        CXPLAT_FRE_ASSERT(CxPlatNumaNodeMasks);\n        for (uint32_t n = 0; n < CxPlatNumaNodeCount; ++n) {\n            CPU_ZERO(&CxPlatNumaNodeMasks[n]);\n            CXPLAT_FRE_ASSERT(numa_node_to_cpus_compat((int)n, CxPlatNumaNodeMasks[n].__bits, sizeof(cpu_set_t)) >= 0);\n        }\n    } else {\n        CxPlatNumaNodeCount = 0;\n    }\n#endif \n\n#ifdef DEBUG\n    CxPlatform.AllocFailDenominator = 0;\n    CxPlatform.AllocCounter = 0;\n#endif\n\n    \n    \n    \n    \n\n    \n    \n    \n    \n\n    long ShouldLoad = 1;\n\n    \n    \n    \n    char *DisableValue = getenv(\"QUIC_LTTng\");\n    if (DisableValue != NULL) {\n        ShouldLoad = strtol(DisableValue, NULL, 10);\n    }\n\n    if (!ShouldLoad) {\n        goto Exit;\n    }\n\n    \n    \n    \n    Dl_info Info;\n    int Succeeded = dladdr((void *)CxPlatSystemLoad, &Info);\n    if (!Succeeded) {\n        goto Exit;\n    }\n\n    size_t PathLen = strlen(Info.dli_fname);\n\n    \n    \n    \n    int LastTrailingSlashLen = -1;\n    for (int i = PathLen; i >= 0; i--) {\n        if (Info.dli_fname[i] == '/') {\n            LastTrailingSlashLen = i + 1;\n            break;\n        }\n    }\n\n    if (LastTrailingSlashLen == -1) {\n        goto Exit;\n    }\n\n    size_t TpLibNameLen = strlen(TpLibName);\n    size_t ProviderFullPathLength = TpLibNameLen + LastTrailingSlashLen + 1;\n\n    char* ProviderFullPath = CXPLAT_ALLOC_PAGED(ProviderFullPathLength, QUIC_POOL_PLATFORM_TMP_ALLOC);\n    if (ProviderFullPath == NULL) {\n        goto Exit;\n    }\n\n    CxPlatCopyMemory(ProviderFullPath, Info.dli_fname, LastTrailingSlashLen);\n    CxPlatCopyMemory(ProviderFullPath + LastTrailingSlashLen, TpLibName, TpLibNameLen);\n    ProviderFullPath[LastTrailingSlashLen + TpLibNameLen] = '\\0';\n\n    \n    \n    \n    \n    dlopen(ProviderFullPath, RTLD_NOW | RTLD_GLOBAL);\n\n    CXPLAT_FREE(ProviderFullPath, QUIC_POOL_PLATFORM_TMP_ALLOC);\n\nExit:\n\n    QuicTraceLogInfo(\n        PosixLoaded,\n        \"[ dso] Loaded\");\n", "Selected Statement": "char *DisableValue = getenv(\"QUIC_LTTng\");", "Function Input": {}, "Variable Values Before Statement": {"\"QUIC_LTTng\"": "\"QUIC_LTTng\""}, "Value After Statement Execution": "NULL", "Function Name": "getenv", "Project Information": "msquic"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "#include \"cmXMLParser.h\"\n\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size)\n{\n  char test_file[] = \"libfuzzer.xml\";\n\n  FILE* fp = fopen(test_file, \"wb\");\n  if (!fp)\n    return 0;\n  fwrite(data, size, 1, fp);\n  fclose(fp);\n\n  cmXMLParser parser;\n", "Selected Statement": "FILE* fp = fopen(test_file, \"wb\");", "Function Input": {"data": {"value": "0x103b010 \"\""}, "size": {"value": "6554624"}}, "Variable Values Before Statement": {"test_file": "\"libfuzzer.xml\"", "\"wb\"": "\"wb\""}, "Value After Statement Execution": "NULL", "Function Name": "fopen", "Project Information": "cmake"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "int\nsonmp_decode(struct lldpd *cfg, char *frame, int s, struct lldpd_hardware *hardware,\n    struct lldpd_chassis **newchassis, struct lldpd_port **newport)\n{\n\tconst u_int8_t mcastaddr[] = SONMP_MULTICAST_ADDR;\n\tstruct lldpd_chassis *chassis;\n\tstruct lldpd_port *port;\n\tstruct lldpd_mgmt *mgmt;\n\tint length, i;\n\tu_int8_t *pos;\n\tu_int8_t seg[3], rchassis;\n\tstruct in_addr address;\n\n\tlog_debug(\"sonmp\", \"decode SONMP PDU from %s\", hardware->h_ifname);\n\n\tif ((chassis = calloc(1, sizeof(struct lldpd_chassis))) == NULL) {\n\t\tlog_warn(\"sonmp\", \"failed to allocate remote chassis\");\n\t\treturn -1;\n\t}\n\tTAILQ_INIT(&chassis->c_mgmt);\n\tif ((port = calloc(1, sizeof(struct lldpd_port))) == NULL) {\n\t\tlog_warn(\"sonmp\", \"failed to allocate remote port\");\n\t\tfree(chassis);\n\t\treturn -1;\n\t}\n#  ifdef ENABLE_DOT1\n\tTAILQ_INIT(&port->p_vlans);\n#  endif\n\n\tlength = s;\n\tpos = (u_int8_t *)frame;\n\tif (length < SONMP_SIZE + 2 * ETHER_ADDR_LEN + sizeof(u_int16_t)) {\n\t\tlog_warnx(\"sonmp\", \"too short SONMP frame received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tif (PEEK_CMP(mcastaddr, sizeof(mcastaddr)) != 0)\n\t\t\n\t\tgoto malformed;\n\t\n\tPEEK_DISCARD(ETHER_ADDR_LEN);\n\tPEEK_DISCARD_UINT16;\n\tPEEK_DISCARD(6);\n\tif (PEEK_UINT16 != LLC_PID_SONMP_HELLO) {\n\t\tlog_debug(\"sonmp\", \"incorrect LLC protocol ID received for SONMP on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\n\tchassis->c_id_subtype = LLDP_CHASSISID_SUBTYPE_ADDR;\n\tif ((chassis->c_id = calloc(1, sizeof(struct in_addr) + 1)) == NULL) {\n\t\tlog_warn(\"sonmp\", \"unable to allocate memory for chassis id on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tchassis->c_id_len = sizeof(struct in_addr) + 1;\n\tchassis->c_id[0] = 1;\n\tPEEK_BYTES(&address, sizeof(struct in_addr));\n\tmemcpy(chassis->c_id + 1, &address, sizeof(struct in_addr));\n\tif (asprintf(&chassis->c_name, \"%s\", inet_ntoa(address)) == -1) {\n\t\tlog_warnx(\"sonmp\", \"unable to write chassis name for %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tPEEK_BYTES(seg, sizeof(seg));\n\trchassis = PEEK_UINT8;\n\tfor (i = 0; sonmp_chassis_types[i].type != 0; i++) {\n\t\tif (sonmp_chassis_types[i].type == rchassis) break;\n\t}\n\tif (asprintf(&chassis->c_descr, \"%s\", sonmp_chassis_types[i].description) ==\n\t    -1) {\n\t\tlog_warnx(\"sonmp\", \"unable to write chassis description for %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tmgmt = lldpd_alloc_mgmt(LLDPD_AF_IPV4, &address, sizeof(struct in_addr), 0);\n\tif (mgmt == NULL) {\n\t\tif (errno == ENOMEM)\n\t\t\tlog_warn(\"sonmp\",\n\t\t\t    \"unable to allocate memory for management address\");\n\t\telse\n\t\t\tlog_warn(\"sonmp\", \"too large management address received on %s\",\n\t\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tTAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries);\n\tport->p_ttl =\n\t    cfg ? (cfg->g_config.c_tx_interval * cfg->g_config.c_tx_hold) : LLDPD_TTL;\n\tport->p_ttl = (port->p_ttl + 999) / 1000;\n\n\tport->p_id_subtype = LLDP_PORTID_SUBTYPE_LOCAL;\n\n\tport->p_id_len =\n\t    asprintf(&port->p_id, \"%02x-%02x-%02x\", seg[0], seg[1], seg[2]);\n\tif (port->p_id_len == -1) {\n\t\tlog_warn(\"sonmp\", \"unable to allocate memory for port id on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\n\t\n\tif ((seg[0] == 0) && (seg[1] == 0)) {\n\t\tif (asprintf(&port->p_descr, \"port %d\", seg[2]) == -1) {\n\t\t\tlog_warnx(\"sonmp\", \"unable to write port description for %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t} else if (seg[0] == 0) {\n\t\tif (asprintf(&port->p_descr, \"port %d/%d\", seg[1], seg[2]) == -1) {\n\t\t\tlog_warnx(\"sonmp\", \"unable to write port description for %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t} else {\n\t\tif (asprintf(&port->p_descr, \"port %x:%x:%x\", seg[0], seg[1], seg[2]) ==\n\t\t    -1) {\n\t\t\tlog_warnx(\"sonmp\", \"unable to write port description for %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t}\n\t*newchassis = chassis;\n\t*newport = port;\n\treturn 1;\n\nmalformed:\n\tlldpd_chassis_cleanup(chassis, 1);\n\tlldpd_port_cleanup(port, 1);\n\tfree(port);\n\treturn -1;\n", "Selected Statement": "mgmt = lldpd_alloc_mgmt(LLDPD_AF_IPV4, &address, sizeof(struct in_addr), 0);", "Function Input": {"hardware": {"value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x18\n", "message": "Cannot access memory at address 0x18"}}}, "Variable Values Before Statement": {"LLDPD_AF_IPV4": "NULL", "0": "0"}, "Value After Statement Execution": {"m_entries": null, "m_family": "1", "m_addr": null, "m_addrsize": "4", "m_iface": "0"}, "Function Name": "lldpd_alloc_mgmt", "Project Information": "lldpd"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nstruct lldpd_mgmt *\nlldpd_alloc_mgmt(int family, void *addrptr, size_t addrsize, u_int32_t iface)\n{\n\tstruct lldpd_mgmt *mgmt;\n\n\tlog_debug(\"alloc\", \"allocate a new management address (family: %d)\", family);\n\n\tif (family <= LLDPD_AF_UNSPEC || family >= LLDPD_AF_LAST) {\n\t\terrno = EAFNOSUPPORT;\n\t\treturn NULL;\n\t}\n\tif (addrsize > LLDPD_MGMT_MAXADDRSIZE) {\n\t\terrno = EOVERFLOW;\n\t\treturn NULL;\n\t}\n\tmgmt = calloc(1, sizeof(struct lldpd_mgmt));\n\tif (mgmt == NULL) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\tmgmt->m_family = family;\n\tmemcpy(&mgmt->m_addr, addrptr, addrsize);\n\tmgmt->m_addrsize = addrsize;\n\tmgmt->m_iface = iface;\n\treturn mgmt;\n", "Selected Statement": "mgmt = calloc(1, sizeof(struct lldpd_mgmt));", "Function Input": {}, "Variable Values Before Statement": {"1": "1"}, "Value After Statement Execution": {"m_entries": null, "m_family": "0", "m_addr": null, "m_addrsize": "0", "m_iface": "0"}, "Function Name": "calloc", "Project Information": "lldpd"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "}\n\nint symtab_init(symtab_t * s, unsigned int size)\n{\n\ts->table = hashtab_create(symhash, symcmp, size);\n\tif (!s->table)\n\t\treturn -1;\n\ts->nprim = 0;\n\treturn 0;\n", "Selected Statement": "s->table = hashtab_create(symhash, symcmp, size);", "Function Input": {}, "Variable Values Before Statement": {"symhash": "NULL", "symcmp": "NULL", "size": "unsigned int"}, "Value After Statement Execution": "0x10be070", "Function Name": "hashtab_create", "Project Information": "selinux"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": " * Initialize a policy database structure.\n */\nint policydb_init(policydb_t * p)\n{\n\tint i, rc;\n\n\tmemset(p, 0, sizeof(policydb_t));\n\n\tfor (i = 0; i < SYM_NUM; i++) {\n\t\tp->sym_val_to_name[i] = NULL;\n\t\trc = symtab_init(&p->symtab[i], symtab_sizes[i]);\n\t\tif (rc)\n\t\t\tgoto err;\n\t}\n\n\t\n\tfor (i = 0; i < SYM_NUM; i++) {\n\t\tif (symtab_init(&p->scope[i], symtab_sizes[i])) {\n\t\t\tgoto err;\n\t\t}\n\t}\n\tif ((p->global = avrule_block_create()) == NULL ||\n\t    (p->global->branch_list = avrule_decl_create(1)) == NULL) {\n\t\tgoto err;\n\t}\n\tp->decl_val_to_struct = NULL;\n\n\trc = avtab_init(&p->te_avtab);\n\tif (rc)\n\t\tgoto err;\n\n\trc = roles_init(p);\n\tif (rc)\n\t\tgoto err;\n\n\trc = cond_policydb_init(p);\n\tif (rc)\n\t\tgoto err;\n\n\tp->filename_trans = hashtab_create(filenametr_hash, filenametr_cmp, (1 << 10));\n\tif (!p->filename_trans) {\n\t\trc = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tp->range_tr = hashtab_create(rangetr_hash, rangetr_cmp, 256);\n\tif (!p->range_tr) {\n\t\trc = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tebitmap_init(&p->policycaps);\n\tebitmap_init(&p->permissive_map);\n\n\treturn 0;\nerr:\n\thashtab_destroy(p->filename_trans);\n\thashtab_destroy(p->range_tr);\n\tfor (i = 0; i < SYM_NUM; i++) {\n\t\thashtab_destroy(p->symtab[i].table);\n\t\thashtab_destroy(p->scope[i].table);\n\t}\n\tavrule_block_list_destroy(p->global);\n\treturn rc;\n", "Selected Statement": "rc = cond_policydb_init(p);", "Function Input": {}, "Variable Values Before Statement": {"p": {"policy_type": "0", "name": null, "version": null, "target_platform": "0", "unsupported_format": "0", "mls": "0", "symtab": [{"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x10a42f0"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x10a4340"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x10a4480"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "1"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x10a4540"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x109da90"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x109d2d0"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x10aaa90"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x109e4c0"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}], "sym_val_to_name": [{"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}], "class_val_to_struct": null, "role_val_to_struct": null, "user_val_to_struct": null, "type_val_to_struct": null, "scope": [{"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x10a5610"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x10a5640"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x10a5780"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x10a5840"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x10aab50"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x10a6c90"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x10a6d50"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x10a6e10"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}], "global": null, "decl_val_to_struct": null, "te_avtab": null, "bool_val_to_struct": null, "te_cond_avtab": null, "cond_list": null, "role_tr": null, "role_allow": null, "ocontexts": [{"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}], "genfs": null, "range_tr": null, "filename_trans": null, "filename_trans_count": "0", "type_attr_map": null, "attr_type_map": null, "policycaps": null, "permissive_map": null, "policyvers": "0", "handle_unknown": "0", "process_class": "0", "dir_class": "0", "process_trans": "0", "process_trans_dyntrans": "0"}}, "Value After Statement Execution": "int", "Function Name": "cond_policydb_init", "Project Information": "selinux"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "}\n\nstatic int read_source_policy(policydb_t *p, const uint8_t *data, size_t size)\n{\n\tint fd, rc;\n\tssize_t wr;\n\n\tfd = memfd_create(\"fuzz-input\", MFD_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\twr = full_write(fd, data, size);\n\tif (wr < 0 || (size_t)wr != size) {\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\tfsync(fd);\n\n\tyynerrs = 0;\n\n\tyyin = fdopen(fd, \"r\");\n\tif (!yyin) {\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\trewind(yyin);\n\n\tset_source_file(\"fuzz-input\");\n\n\tid_queue = queue_create();\n\tif (id_queue == NULL) {\n\t\tfclose(yyin);\n\t\tyylex_destroy();\n\t\treturn -1;\n\t}\n\n\tpolicydbp = p;\n\tmlspol = p->mls;\n\n\tinit_parser(1);\n\n\tif (!setjmp(fuzzing_pre_parse_stack_state)) {\n\t\tqueue_destroy(id_queue);\n\t\tfclose(yyin);\n\t\tyylex_destroy();\n\t\treturn -1;\n\t}\n\n\trc = yyparse();\n\t\n\tassert(rc || !policydb_errors);\n\tif (rc || policydb_errors) {\n\t\tqueue_destroy(id_queue);\n\t\tfclose(yyin);\n\t\tyylex_destroy();\n\t\treturn -1;\n\t}\n\n\trewind(yyin);\n\tinit_parser(2);\n\tset_source_file(\"fuzz-input\");\n\tyyrestart(yyin);\n\n\trc = yyparse();\n\tassert(rc || !policydb_errors);\n\tif (rc || policydb_errors) {\n\t\tqueue_destroy(id_queue);\n\t\tfclose(yyin);\n\t\tyylex_destroy();\n\t\treturn -1;\n\t}\n\n\tqueue_destroy(id_queue);\n\tfclose(yyin);\n\tyylex_destroy();\n\n\treturn 0;\n}\n\nstatic int write_binary_policy(FILE *outfp, policydb_t *p)\n{\n\tstruct policy_file pf;\n\n\tpolicy_file_init(&pf);\n\tpf.type = PF_USE_STDIO;\n\tpf.fp = outfp;\n\treturn policydb_write(p, &pf);\n}\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n\tpolicydb_t parsepolicydb = {};\n\tpolicydb_t kernpolicydb = {};\n\tpolicydb_t *finalpolicydb;\n\tsidtab_t sidtab = {};\n\tFILE *devnull = NULL;\n\tint mls, platform, policyvers;\n\n\tsepol_debug(VERBOSE);\n\n\t\n\tif (size < 3)\n\t\treturn 0;\n\tswitch (data[0]) {\n\tcase 'S':\n\t\tplatform = SEPOL_TARGET_SELINUX;\n\t\tbreak;\n\tcase 'X':\n\t\tplatform = SEPOL_TARGET_XEN;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tswitch (data[1]) {\n\tcase '0':\n\t\tmls = 0;\n\t\tbreak;\n\tcase '1':\n\t\tmls = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tstatic_assert(0x7F - 'A' >= POLICYDB_VERSION_MAX, \"Max policy version should be representable\");\n\tpolicyvers = data[2] - 'A';\n\tif (policyvers < POLICYDB_VERSION_MIN || policyvers > POLICYDB_VERSION_MAX)\n\t\treturn 0;\n\tdata += 3;\n\tsize -= 3;\n\n\tif (policydb_init(&parsepolicydb))\n\t\tgoto exit;\n\n\tparsepolicydb.policy_type = POLICY_BASE;\n\tparsepolicydb.mls = mls;\n\tparsepolicydb.handle_unknown = DENY_UNKNOWN;\n\tparsepolicydb.policyvers = policyvers;\n\tpolicydb_set_target_platform(&parsepolicydb, platform);\n\n", "Selected Statement": "id_queue = queue_create();", "Function Input": {"fd": {"value": "0"}}, "Variable Values Before Statement": {}, "Value After Statement Execution": "NULL", "Function Name": "queue_create", "Project Information": "selinux"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nint parse_msg(\n\t\tchar *const buf, const unsigned int len, struct sip_msg *const msg)\n{\n\n\tchar *tmp;\n\tchar *rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor(tmp = buf; (tmp - buf < len)\n\t\t\t\t   && (*tmp == '\\n' || *tmp == '\\r' || *tmp == '\\0'\n\t\t\t\t\t\t   || *tmp == '\\t' || *tmp == ' ');\n\t\t\ttmp++)\n\t\t;\n\toffset = tmp - buf;\n\tfl = &(msg->first_line);\n\trest = parse_first_line(tmp, len - offset, fl);\n\toffset += rest - tmp;\n\ttmp = rest;\n\tswitch(fl->type) {\n\t\tcase SIP_INVALID:\n\t\t\tDBG(\"invalid message\\n\");\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tDBG(\"SIP Request:\\n\");\n\t\t\tDBG(\" method:  <%.*s>\\n\", fl->u.request.method.len,\n\t\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tDBG(\" uri:     <%.*s>\\n\", fl->u.request.uri.len,\n\t\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tDBG(\" version: <%.*s>\\n\", fl->u.request.version.len,\n\t\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags = HDR_VIA_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tDBG(\"SIP Reply  (status):\\n\");\n\t\t\tDBG(\" version: <%.*s>\\n\", fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tDBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tDBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\t\n\t\t\t\n\t\t\tflags = HDR_VIA_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDBG(\"unknown type %d\\n\", fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed = tmp;\n\t\n\tif(parse_headers(msg, flags, 0) == -1)\n\t\tgoto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif(msg->via1) {\n\t\tDBG(\"first via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\", msg->via1->name.len,\n\t\t\t\tZSW(msg->via1->name.s), msg->via1->version.len,\n\t\t\t\tZSW(msg->via1->version.s), msg->via1->transport.len,\n\t\t\t\tZSW(msg->via1->transport.s), msg->via1->host.len,\n\t\t\t\tZSW(msg->via1->host.s), msg->via1->port_str.len,\n\t\t\t\tZSW(msg->via1->port_str.s), msg->via1->port);\n\t\tif(msg->via1->params.s)\n\t\t\tDBG(\";<%.*s>\", msg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif(msg->via1->comment.s)\n\t\t\tDBG(\" <%.*s>\", msg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tDBG(\"\\n\");\n\t}\n\tif(msg->via2) {\n\t\tDBG(\"second via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\", msg->via2->name.len,\n\t\t\t\tZSW(msg->via2->name.s), msg->via2->version.len,\n\t\t\t\tZSW(msg->via2->version.s), msg->via2->transport.len,\n\t\t\t\tZSW(msg->via2->transport.s), msg->via2->host.len,\n\t\t\t\tZSW(msg->via2->host.s), msg->via2->port_str.len,\n\t\t\t\tZSW(msg->via2->port_str.s), msg->via2->port);\n\t\tif(msg->via2->params.s)\n\t\t\tDBG(\";<%.*s>\", msg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif(msg->via2->comment.s)\n\t\t\tDBG(\" <%.*s>\", msg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tDBG(\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tDBG(\"exiting parse_msg\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLOG(cfg_get(core, core_cfg, sip_parser_log),\n\t\t\t\"ERROR: parse_msg: message=<%.*s>\\n\", (int)msg->len,\n\t\t\tZSW(ksr_buf_oneline(msg->buf, (int)msg->len)));\n\treturn -1;\n", "Selected Statement": "rest = parse_first_line(tmp, len - offset, fl);", "Function Input": {"flags": {"value": "140737322669824"}, "msg": {"value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xffff00001f80\n", "message": "Cannot access memory at address 0xffff00001f80"}}}, "Variable Values Before Statement": {"tmp": "0x1b7b2f0 \"\"", "fl": {"type": "0", "flags": "0", "len": "0", "u": null}}, "Value After Statement Execution": "0x1b7b2f0 \"\"", "Function Name": "parse_first_line", "Project Information": "kamailio"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "    return found;\n}\n\nGHashTable *g_hash_table_new(GHashFunc hashes, GEqualFunc equals) {\n    GHashTable *table = calloc(1, sizeof(GHashTable));\n    table->array = g_ptr_array_new();\n    table->compare = equals;\n", "Selected Statement": "GHashTable *table = calloc(1, sizeof(GHashTable));", "Function Input": {}, "Variable Values Before Statement": {"1": "1"}, "Value After Statement Execution": "NULL", "Function Name": "calloc", "Project Information": "mdbtools"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "#endif\n\nvoid mdb_iconv_init(MdbHandle *mdb)\n{\n\tconst char *iconv_code;\n\n\t\n\tif (!(iconv_code=getenv(\"MDBICONV\"))) {\n\t\ticonv_code=\"UTF-8\";\n\t}\n\n#ifdef HAVE_ICONV\n\tif (!IS_JET3(mdb)) {\n\t\tmdb->iconv_out = iconv_open(\"UCS-2LE\", iconv_code);\n\t\tmdb->iconv_in = iconv_open(iconv_code, \"UCS-2LE\");\n\t} else {\n\t\t\n\t\tconst char *jet3_iconv_code = getenv(\"MDB_JET3_CHARSET\");\n\n\t\tif (!jet3_iconv_code) {\n\t\t\t\n\t\t\t\n\t\t\tjet3_iconv_code = mdb_iconv_name_from_code_page(mdb->f->code_page);\n\t\t}\n\t\tif (!jet3_iconv_code) {\n\t\t\tjet3_iconv_code = \"CP1252\";\n\t\t}\n\n\t\tmdb->iconv_out = iconv_open(jet3_iconv_code, iconv_code);\n\t\tmdb->iconv_in = iconv_open(iconv_code, jet3_iconv_code);\n\t}\n#elif defined(_WIN32) || defined(WIN32) || defined(_WIN64) || defined(WIN64) || defined(WINDOWS)\n    mdb->locale = _create_locale(LC_CTYPE, \".65001\");\n#else\n    mdb->locale = newlocale(LC_CTYPE_MASK, \"C.UTF-8\", NULL);\n#endif\n", "Selected Statement": "mdb->iconv_out = iconv_open(jet3_iconv_code, iconv_code);", "Function Input": {}, "Variable Values Before Statement": {"jet3_iconv_code": "0x53100c \"CP1252\"", "iconv_code": "0x530fed \"UTF-8\""}, "Value After Statement Execution": "0xf74f80", "Function Name": "iconv_open", "Project Information": "mdbtools"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "}\n\nstatic isc_result_t\nparse_message(isc_buffer_t *input, dns_message_t **messagep) {\n\tisc_result_t result;\n\tdns_message_t *message = NULL;\n\n\tdns_message_create(mctx, NULL, NULL, DNS_MESSAGE_INTENTPARSE, &message);\n\n\tresult = dns_message_parse(message, input, DNS_MESSAGEPARSE_BESTEFFORT);\n\tif (result == DNS_R_RECOVERABLE) {\n\t\tresult = ISC_R_SUCCESS;\n\t}\n\n\tif (result == ISC_R_SUCCESS && messagep != NULL) {\n\t\t*messagep = message;\n\t} else {\n\t\tdns_message_detach(&message);\n\t}\n\n\treturn (result);\n}\n\nstatic isc_result_t\nprint_message(dns_message_t *message) {\n\tisc_result_t result;\n\tisc_buffer_t buffer;\n\n\tdo {\n\t\tisc_buffer_init(&buffer, output, output_len);\n\t\tresult = dns_message_totext(message, &dns_master_style_debug, 0,\n\t\t\t\t\t    &buffer);\n\t\tif (result == ISC_R_NOSPACE) {\n\t\t\tisc_mem_put(mctx, output, output_len);\n\t\t\toutput_len *= 2;\n\t\t\toutput = isc_mem_get(mctx, output_len);\n\t\t\tcontinue;\n\t\t}\n\t} while (result == ISC_R_NOSPACE);\n\n\tif (debug) {\n\t\tfprintf(stderr, \"%.*s\\n\", (int)isc_buffer_usedlength(&buffer),\n\t\t\toutput);\n\t}\n\n\treturn (result);\n}\n\n#define CHECKRESULT(r, f)                 \\\n\t{                                 \\\n\t\tr = (f);                  \\\n\t\tif (r != ISC_R_SUCCESS) { \\\n\t\t\tgoto cleanup;     \\\n\t\t}                         \\\n\t}\n\nstatic isc_result_t\nrender_message(dns_message_t **messagep) {\n\tisc_result_t result;\n\tdns_message_t *message = *messagep;\n\tisc_buffer_t buffer;\n\tdns_compress_t cctx;\n\n\tisc_buffer_init(&buffer, render_buf, sizeof(render_buf));\n\n\tmessage->from_to_wire = DNS_MESSAGE_INTENTRENDER;\n\tfor (size_t i = 0; i < DNS_SECTION_MAX; i++) {\n\t\tmessage->counts[i] = 0;\n\t}\n\n\tdns_compress_init(&cctx, mctx, 0);\n\n\tCHECKRESULT(result, dns_message_renderbegin(message, &cctx, &buffer));\n\n\tCHECKRESULT(result, dns_message_rendersection(message,\n\t\t\t\t\t\t      DNS_SECTION_QUESTION, 0));\n\n\tCHECKRESULT(result,\n\t\t    dns_message_rendersection(message, DNS_SECTION_ANSWER, 0));\n\tCHECKRESULT(result, dns_message_rendersection(\n\t\t\t\t    message, DNS_SECTION_AUTHORITY, 0));\n\n\tCHECKRESULT(result, dns_message_rendersection(\n\t\t\t\t    message, DNS_SECTION_ADDITIONAL, 0));\n\n\tdns_message_renderend(message);\n\n\tdns_compress_invalidate(&cctx);\n\n\tmessage->from_to_wire = DNS_MESSAGE_INTENTPARSE;\n\n\tdns_message_detach(messagep);\n\n\tresult = parse_message(&buffer, messagep);\n\n\treturn (result);\n\ncleanup:\n\tdns_compress_invalidate(&cctx);\n\treturn (result);\n}\n\nint\nLLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tisc_buffer_t buffer;\n\tisc_result_t result;\n\tdns_message_t *message = NULL;\n\n\tif (size > 65535) {\n\t\treturn (0);\n\t}\n\n\tisc_buffer_constinit(&buffer, data, size);\n\tisc_buffer_add(&buffer, size);\n\tisc_buffer_setactive(&buffer, size);\n\n", "Selected Statement": "result = dns_message_parse(message, input, DNS_MESSAGEPARSE_BESTEFFORT);", "Function Input": {}, "Variable Values Before Statement": {"message": {"magic": "1297303360", "references": "1", "id": "0", "flags": "0", "rcode": "0", "opcode": "0", "rdclass": "0", "counts": [{"type_category": "int", "concrete_type": "unsigned int", "value": "0"}, {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}, {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}, {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}], "sections": [{"type_category": "struct", "concrete_type": "STRUCT", "value": {"head": {"type_category": "pointer", "concrete_type": "NULL"}, "tail": {"type_category": "pointer", "concrete_type": "NULL"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"head": {"type_category": "pointer", "concrete_type": "NULL"}, "tail": {"type_category": "pointer", "concrete_type": "NULL"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"head": {"type_category": "pointer", "concrete_type": "NULL"}, "tail": {"type_category": "pointer", "concrete_type": "NULL"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"head": {"type_category": "pointer", "concrete_type": "NULL"}, "tail": {"type_category": "pointer", "concrete_type": "NULL"}}}], "cursors": [{"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}], "opt": null, "sig0": null, "tsig": null, "state": "-1", "from_to_wire": "DNS_MESSAGE_INTENTPARSE", "header_ok": "0", "question_ok": "0", "tcp_continuation": "0", "verified_sig": "0", "verify_attempted": "0", "free_query": "0", "free_saved": "0", "cc_ok": "0", "cc_bad": "0", "cc_echoed": "0", "tkey": "0", "rdclass_set": "0", "fuzzing": "0", "free_pools": "1", "opt_reserved": "0", "sig_reserved": "0", "reserved": "0", "padding": "0", "padding_off": "0", "buffer": null, "cctx": null, "mctx": null, "namepool": "{magic = 1296387440, mctx = 0x1892a50, link = {prev = 0x0, next = 0x18961f0}, items = 0x0, size = 536, allocated = 0, freecount = 0, freemax = 8192, fillcount = 1024, gets = 0, name = \"dns_fixedname_p\"}", "rdspool": "{magic = 1296387440, mctx = 0x1892a50, link = {prev = 0x1897d10, next = 0x0}, items = 0x0, size = 112, allocated = 0, freecount = 0, freemax = 8192, fillcount = 1024, gets = 0, name = \"dns_rdataset_po\"}", "scratchpad": null, "cleanup": null, "rdatas": null, "rdatalists": null, "offsets": null, "freerdata": null, "freerdatalist": null, "tsigstatus": "0", "querytsigstatus": "0", "tsigname": null, "querytsig": null, "tsigkey": null, "tsigctx": null, "sigstart": "-1", "timeadjust": "0", "sig0name": null, "sig0key": null, "sig0status": "0", "query": null, "saved": null, "fuzztime": "0", "order": null, "order_arg": null, "indent": null, "minttl": [{"type_category": "struct", "concrete_type": "STRUCT", "value": {"is_set": {"type_category": "unknown", "concrete_type": "_Bool", "value": "false"}, "ttl": {"type_category": "unknown", "concrete_type": "dns_ttl_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"is_set": {"type_category": "unknown", "concrete_type": "_Bool", "value": "false"}, "ttl": {"type_category": "unknown", "concrete_type": "dns_ttl_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"is_set": {"type_category": "unknown", "concrete_type": "_Bool", "value": "false"}, "ttl": {"type_category": "unknown", "concrete_type": "dns_ttl_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"is_set": {"type_category": "unknown", "concrete_type": "_Bool", "value": "false"}, "ttl": {"type_category": "unknown", "concrete_type": "dns_ttl_t", "value": "0"}}}]}, "input": {"magic": "1114990113", "base": null, "length": "0", "used": "0", "current": "0", "active": "0", "extra": "0", "dynamic": "false", "link": null, "mctx": null}, "DNS_MESSAGEPARSE_BESTEFFORT": "NULL"}, "Value After Statement Execution": "isc_result_t", "Function Name": "dns_message_parse", "Project Information": "bind9"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "void\ndns_message_create(isc_mem_t *mctx, isc_mempool_t *namepool,\n\t\t   isc_mempool_t *rdspool, dns_message_intent_t intent,\n\t\t   dns_message_t **msgp) {\n\tREQUIRE(mctx != NULL);\n\tREQUIRE(msgp != NULL);\n\tREQUIRE(*msgp == NULL);\n\tREQUIRE(intent == DNS_MESSAGE_INTENTPARSE ||\n\t\tintent == DNS_MESSAGE_INTENTRENDER);\n\tREQUIRE((namepool != NULL && rdspool != NULL) ||\n\t\t(namepool == NULL && rdspool == NULL));\n\n\tdns_message_t *msg = isc_mem_get(mctx, sizeof(dns_message_t));\n\t*msg = (dns_message_t){\n\t\t.from_to_wire = intent,\n\t\t.references = ISC_REFCOUNT_INITIALIZER(1),\n\t\t.scratchpad = ISC_LIST_INITIALIZER,\n\t\t.cleanup = ISC_LIST_INITIALIZER,\n\t\t.rdatas = ISC_LIST_INITIALIZER,\n\t\t.rdatalists = ISC_LIST_INITIALIZER,\n\t\t.offsets = ISC_LIST_INITIALIZER,\n\t\t.freerdata = ISC_LIST_INITIALIZER,\n\t\t.freerdatalist = ISC_LIST_INITIALIZER,\n\t\t.magic = DNS_MESSAGE_MAGIC,\n\t\t.namepool = namepool,\n\t\t.rdspool = rdspool,\n\t\t.free_pools = (namepool == NULL && rdspool == NULL),\n\t};\n\n\tisc_mem_attach(mctx, &msg->mctx);\n\n\tif (msg->free_pools) {\n\t\tdns_message_createpools(mctx, &msg->namepool, &msg->rdspool);\n\t}\n\n\tmsginit(msg);\n\n\tfor (size_t i = 0; i < DNS_SECTION_MAX; i++) {\n\t\tISC_LIST_INIT(msg->sections[i]);\n\t}\n\n\tisc_buffer_t *dynbuf = NULL;\n\tisc_buffer_allocate(mctx, &dynbuf, SCRATCHPAD_SIZE);\n\tISC_LIST_APPEND(msg->scratchpad, dynbuf, link);\n\n\t*msgp = msg;\n", "Selected Statement": "dns_message_t *msg = isc_mem_get(mctx, sizeof(dns_message_t));", "Function Input": {}, "Variable Values Before Statement": {"mctx": {"magic": "1298492739", "flags": "4", "jemalloc_flags": "0", "jemalloc_arena": "4294967295", "debugging": "0", "lock": null, "checkfree": "true", "references": "1", "name": "\"\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\"", "inuse": "1568", "hi_called": "false", "is_overmem": "false", "hi_water": "0", "lo_water": "0", "pools": null, "poolcnt": "0", "debuglist": null, "debuglistcnt": "0", "link": null}}, "Value After Statement Execution": "NULL", "Function Name": "isc_mem_get", "Project Information": "bind9"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "impfind(const char *name) {\n\tdns_dbimplementation_t *imp;\n\n\tfor (imp = ISC_LIST_HEAD(implementations); imp != NULL;\n\t     imp = ISC_LIST_NEXT(imp, link))\n\t{\n", "Selected Statement": "for (imp = ISC_LIST_HEAD(implementations); imp != NULL;", "Function Input": {}, "Variable Values Before Statement": {"implementations": {"head": null, "tail": null}}, "Value After Statement Execution": "NULL", "Function Name": "ISC_LIST_HEAD", "Project Information": "bind9"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "#include <isc/result.h>\n\nisc_result_t\nisc_parse_uint32(uint32_t *uip, const char *string, int base) {\n\tunsigned long n;\n\tuint32_t r;\n\tchar *e;\n\tif (!isalnum((unsigned char)(string[0]))) {\n\t\treturn (ISC_R_BADNUMBER);\n\t}\n\terrno = 0;\n\tn = strtoul(string, &e, base);\n\tif (*e != '\\0') {\n\t\treturn (ISC_R_BADNUMBER);\n\t}\n\t\n\tr = (uint32_t)n;\n\tif ((n == ULONG_MAX && errno == ERANGE) || (n != (unsigned long)r)) {\n\t\treturn (ISC_R_RANGE);\n\t}\n\t*uip = r;\n\treturn (ISC_R_SUCCESS);\n", "Selected Statement": "n = strtoul(string, &e, base);", "Function Input": {"base": {"value": "-1"}, "string": {"value": "0x7ffffffed9b0 \"\\260\\334\\376\\377\\377\\177\""}, "uip": {"value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xffffffff00000000\n", "message": "Cannot access memory at address 0xffffffff00000000"}}}, "Variable Values Before Statement": {"string": "0x18865d0 \"8\"", "base": "int"}, "Value After Statement Execution": "unsigned long", "Function Name": "strtoul", "Project Information": "bind9"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "int\n_dwarf_object_read_random(int fd, char *buf, Dwarf_Unsigned loc,\n    Dwarf_Unsigned size, Dwarf_Unsigned filesize, int *errc)\n{\n    Dwarf_Unsigned endpoint = 0;\n    int res = 0;\n\n    if (loc >= filesize) {\n        \n        *errc = DW_DLE_SEEK_OFF_END;\n        return DW_DLV_ERROR;\n    }\n    endpoint = loc+size;\n    if (endpoint < loc) {\n        \n        *errc = DW_DLE_READ_OFF_END;\n        return DW_DLV_ERROR;\n    }\n    if (endpoint > filesize) {\n        \n        *errc = DW_DLE_READ_OFF_END;\n        return DW_DLV_ERROR;\n    }\n    res = _dwarf_seekr(fd,loc,SEEK_SET,0);\n    if (res != DW_DLV_OK) {\n        *errc = DW_DLE_SEEK_ERROR;\n        return DW_DLV_ERROR;\n    }\n    res = _dwarf_readr(fd,buf,size,0);\n    if (res != DW_DLV_OK) {\n        *errc = DW_DLE_READ_ERROR;\n        return DW_DLV_ERROR;\n    }\n    return DW_DLV_OK;\n", "Selected Statement": "res = _dwarf_seekr(fd,loc,SEEK_SET,0);", "Function Input": {"buf": {"value": "0x3 <error: Cannot access memory at address 0x3>"}, "errc": {"value": null}, "fd": {"value": "-10544"}, "filesize": {"value": "6002422"}, "loc": {"value": "140737348690585"}, "size": {"value": "3"}}, "Variable Values Before Statement": {"fd": "int", "loc": "Dwarf_Unsigned", "SEEK_SET": "NULL", "0": "0"}, "Value After Statement Execution": "int", "Function Name": "_dwarf_seekr", "Project Information": "libdwarf"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "int\n_dwarf_load_elf_header(\n    dwarf_elf_object_access_internals_t *ep,int*errcode)\n{\n    unsigned offsetsize = ep->f_offsetsize;\n    int res = 0;\n\n    if (offsetsize == 32) {\n        res = elf_load_elf_header32(ep,errcode);\n    } else if (offsetsize == 64) {\n        if (sizeof(Dwarf_Unsigned) < 8) {\n            *errcode =  DW_DLE_INTEGER_TOO_SMALL;\n            return DW_DLV_ERROR;\n        }\n        res = elf_load_elf_header64(ep,errcode);\n    } else {\n        *errcode = DW_DLE_OFFSET_SIZE;\n        return DW_DLV_ERROR;\n    }\n    return res;\n", "Selected Statement": "res = elf_load_elf_header64(ep,errcode);", "Function Input": {}, "Variable Values Before Statement": {"ep": {"f_ident": "\"F1\\000\\000\\000\\000\\000\"", "f_path": null, "f_fd": "3", "f_machine": "0", "f_destruct_close_fd": "0", "f_is_64bit": "1", "f_endian": "2", "f_filesize": "25", "f_flags": "0", "f_offsetsize": "64 '@'", "f_pointersize": "64 '@'", "f_ftype": "1", "f_path_source": "0", "f_max_secdata_offset": "0", "f_max_progdata_offset": "0", "f_copy_word": "{void (void *, const void *, unsigned long)} 0x53ac40 <_dwarf_memcpy_noswap_bytes>", "f_loc_ehdr": null, "f_ehdr": null, "f_loc_shdr": null, "f_shdr": null, "f_loc_phdr": null, "f_phdr": null, "f_elf_shstrings_data": null, "f_elf_shstrings_length": "0", "f_elf_shstrings_max": "0", "f_loc_dynamic": null, "f_dynamic": null, "f_dynamic_sect_index": "0", "f_loc_dynsym": null, "f_dynsym": null, "f_dynsym_sect_strings": null, "f_dynsym_sect_strings_max": "0", "f_dynsym_sect_strings_sect_index": "0", "f_dynsym_sect_index": "0", "f_loc_symtab": null, "f_symtab": null, "f_symtab_sect_strings": null, "f_symtab_sect_strings_max": "0", "f_symtab_sect_strings_sect_index": "0", "f_symtab_sect_index": "0", "f_sg_next_group_number": "0", "f_sht_group_type_section_count": "0", "f_shf_group_flag_section_count": "0", "f_dwo_group_section_count": "0"}, "errcode": "445"}, "Value After Statement Execution": "int", "Function Name": "elf_load_elf_header64", "Project Information": "libdwarf"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "int\ndwarf_formaddr(Dwarf_Attribute attr,\n    Dwarf_Addr * return_addr, Dwarf_Error * error)\n{\n    Dwarf_Debug dbg = 0;\n    Dwarf_Addr ret_addr = 0;\n    Dwarf_CU_Context cu_context = 0;\n    Dwarf_Half attrform = 0;\n    int res = 0;\n\n    res  = get_attr_dbg(&dbg,&cu_context,attr,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    attrform = attr->ar_attribute_form;\n    if (dwarf_addr_form_is_indexed(attrform)) {\n        res = _dwarf_look_in_local_and_tied(\n            attrform,\n            cu_context,\n            attr->ar_debug_ptr,\n            return_addr,\n            error);\n        return res;\n    }\n    if (attrform == DW_FORM_addr ||\n        (cu_context->cc_producer == CC_PROD_METROWERKS &&\n        attrform == DW_FORM_ref_addr)\n            \n        ) {\n        Dwarf_Small *section_end =\n            _dwarf_calculate_info_section_end_ptr(cu_context);\n\n        READ_UNALIGNED_CK(dbg, ret_addr, Dwarf_Addr,\n            attr->ar_debug_ptr,\n            cu_context->cc_address_size,\n            error,section_end);\n        *return_addr = ret_addr;\n        return DW_DLV_OK;\n    }\n    generate_form_error(dbg,error,attrform,\n        DW_DLE_ATTR_FORM_BAD,\n        \"DW_DLE_ATTR_FORM_BAD\",\n        \"dwarf_formaddr\");\n    return DW_DLV_ERROR;\n", "Selected Statement": "res  = get_attr_dbg(&dbg,&cu_context,attr,error);", "Function Input": {}, "Variable Values Before Statement": {"attr": "Dwarf_Attribute", "error": "NULL"}, "Value After Statement Execution": "int", "Function Name": "get_attr_dbg", "Project Information": "libdwarf"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "** to signal that. So, the real value is (1xxxx) * 2^(eeee - 7 - 1) if\n** eeee != 0, and (xxxx) * 2^-7 otherwise (subnormal numbers).\n*/\nunsigned int luaO_codeparam (unsigned int p) {\n  if (p >= (cast(lu_mem, 0x1F) << (0xF - 7 - 1)) * 100u)  \n    return 0xFF;  \n  else {\n    p = (cast(l_uint32, p) * 128 + 99) / 100;  \n    if (p < 0x10)  \n      return p;  \n    else {\n      int log = luaO_ceillog2(p + 1) - 5;  \n      return ((p >> log) - 0x10) | ((log + 1) << 4);\n    }\n  }\n", "Selected Statement": "if ((e = l_str2int(s, &i)) != NULL) {  /* try as an integer */", "Function Input": {}, "Variable Values Before Statement": {"s": "NULL"}, "Value After Statement Execution": "NULL", "Function Name": "l_str2int", "Project Information": "lua"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "}\n\n\nvoid *luaM_malloc_ (lua_State *L, size_t size, int tag) {\n  if (size == 0)\n    return NULL;  \n  else {\n    global_State *g = G(L);\n    void *newblock = firsttry(g, NULL, tag, size);\n    if (l_unlikely(newblock == NULL)) {\n      newblock = tryagain(L, NULL, tag, size);\n      if (newblock == NULL)\n        luaM_error(L);\n    }\n    g->totalbytes += size;\n    return newblock;\n  }\n", "Selected Statement": "void *newblock = firsttry(g, NULL, tag, size);", "Function Input": {"L": {"value": null}}, "Variable Values Before Statement": {"g": {"frealloc": "0x53d5c0 <l_alloc>", "ud": null, "totalbytes": "1632", "totalobjs": "1", "GCdebt": "0", "marked": "0", "GCmajorminor": "7364001358723691830", "strt": null, "l_registry": null, "nilvalue": null, "seed": "1737306150", "gcparams": "\" 0@PPT\"", "currentwhite": "8 '\\b'", "gcstate": "8 '\\b'", "gckind": "0 '\\000'", "gcstopem": "0 '\\000'", "gcstp": "2 '\\002'", "gcemergency": "0 '\\000'", "allgc": null, "sweepgc": null, "finobj": null, "gray": null, "grayagain": null, "weak": null, "ephemeron": null, "allweak": null, "tobefnz": null, "fixedgc": null, "survival": null, "old1": null, "reallyold": null, "firstold1": null, "finobjsur": null, "finobjold1": null, "finobjrold": null, "twups": null, "panic": null, "mainthread": "{next = 0x0, tt = 8 '\\b', marked = 8 '\\b', status = 0 '\\000', allowhook = 1 '\\001', nci = 0, top = {p = 0xf59ff0, offset = 16097264}, l_G = 0xf5a0d0, ci = 0x0, stack_last = {p = 0x6362, offset = 25442}, stack = {p = 0x0, offset = 0}, openupval = 0x0, tbclist = {p = 0x50, offset = 80}, gclist = 0xf5a090, twups = 0xf5a008, errorJmp = 0x7fffffffdcf8, base_ci = {func = {p = 0x3831613364633431, offset = 4049124413338235953}, top = {p = 0x6363646464356636, offset = 7161678214789948982}, previous = 0x3937333963356165, next = 0x6138, u = {l = {savedpc = 0x0, trap = 160, nextraargs = 0}, c = {k = 0x0, old_errfunc = 160, ctx = 80}}, u2 = {funcidx = 16097504, nyield = 16097504, nres = 16097504, transferinfo = {ftransfer = 41184, ntransfer = 245}}, nresults = 0, callstatus = 0}, hook = 0x0, errfunc = 0, nCcalls = 65536, oldpc = 0, basehookcount = 0, hookcount = 0, hookmask = 0}", "memerrmsg": null, "tmname": [{"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a1f0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3864643865663537\n", "message": "Cannot access memory at address 0x3864643865663537"}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a1f8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3033306563393834\n", "message": "Cannot access memory at address 0x3033306563393834"}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a200", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3239313266383765\n", "message": "Cannot access memory at address 0x3239313266383765"}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a208", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x6438613461343639\n", "message": "Cannot access memory at address 0x6438613461343639"}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a210", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3430\n", "message": "Cannot access memory at address 0x3430"}}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a220", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x230\n", "message": "Cannot access memory at address 0x230"}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a228", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x50\n", "message": "Cannot access memory at address 0x50"}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a230", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"next": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a270", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x280\n", "message": "Cannot access memory at address 0x280"}}, "tt": {"type_category": "unknown", "concrete_type": "lu_byte", "value": "80 'P'"}, "marked": {"type_category": "unknown", "concrete_type": "lu_byte", "value": "0 '\\000'"}, "extra": {"type_category": "unknown", "concrete_type": "lu_byte", "value": "0 '\\000'"}, "shrlen": {"type_category": "unknown", "concrete_type": "ls_byte", "value": "0 '\\000'"}, "hash": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}, "u": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"lnglen": {"type_category": "unknown", "concrete_type": "size_t", "value": "16097984"}, "hnext": {"type_category": "pointer", "concrete_type": "NESTED", "value": "0xf5a2c0"}}}, "contents": {"type_category": "string", "concrete_type": "string", "value": "0x6338623138392f65 <error: Cannot access memory at address 0x6338623138392f65>"}, "falloc": {"type_category": "unknown", "concrete_type": "lua_Alloc", "value": "0x6163666137653533"}, "ud": {"type_category": "pointer", "concrete_type": "VOID"}}}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a238", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3936313731352f65\n", "message": "Cannot access memory at address 0x3936313731352f65"}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a240", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x6163313037316136\n", "message": "Cannot access memory at address 0x6163313037316136"}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a248", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3635643163306338\n", "message": "Cannot access memory at address 0x3635643163306338"}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a250", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3736396436356530\n", "message": "Cannot access memory at address 0x3736396436356530"}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a258", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3832356262323636\n", "message": "Cannot access memory at address 0x3832356262323636"}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a260", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3561\n", "message": "Cannot access memory at address 0x3561"}}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "RECURSIVE", "value": "0x280"}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a278", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x50\n", "message": "Cannot access memory at address 0x50"}}, {"type_category": "pointer", "concrete_type": "RECURSIVE", "value": "0xf5a2c0"}, {"type_category": "pointer", "concrete_type": "RECURSIVE", "value": "0x6338623138392f65"}, {"type_category": "pointer", "concrete_type": "RECURSIVE", "value": "0x6163666137653533"}, {"type_category": "pointer", "concrete_type": "RECURSIVE", "value": "0x3466393730616164"}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a2a0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x6335656636326536\n", "message": "Cannot access memory at address 0x6335656636326536"}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a2a8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3438646165333061\n", "message": "Cannot access memory at address 0x3438646165333061"}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a2b0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x6130\n", "message": "Cannot access memory at address 0x6130"}}], "mt": [{"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}], "strcache": [{"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a300", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x6237\n", "message": "Cannot access memory at address 0x6237"}}, {"type_category": "pointer", "concrete_type": "NULL"}]}, {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a310", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x320\n", "message": "Cannot access memory at address 0x320"}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a318", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x50\n", "message": "Cannot access memory at address 0x50"}}]}, {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a320", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"next": {"type_category": "pointer", "concrete_type": "NESTED", "value": "0x370"}, "tt": {"type_category": "unknown", "concrete_type": "lu_byte", "value": "80 'P'"}, "marked": {"type_category": "unknown", "concrete_type": "lu_byte", "value": "0 '\\000'"}, "extra": {"type_category": "unknown", "concrete_type": "lu_byte", "value": "0 '\\000'"}, "shrlen": {"type_category": "unknown", "concrete_type": "ls_byte", "value": "0 '\\000'"}, "hash": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}, "u": {"type_category": "struct", "concrete_type": "NESTED", "value": "{lnglen = 16098224, hnext = 0xf5a3b0}"}, "contents": {"type_category": "string", "concrete_type": "string", "value": "0x3035316637662f65 <error: Cannot access memory at address 0x3035316637662f65>"}, "falloc": {"type_category": "unknown", "concrete_type": "lua_Alloc", "value": "0x6465323065333638"}, "ud": {"type_category": "pointer", "concrete_type": "NESTED", "value": "0x6364313035353634"}}}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a328", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3663653461642f65\n", "message": "Cannot access memory at address 0x3663653461642f65"}}]}, {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a330", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x6531303865653464\n", "message": "Cannot access memory at address 0x6531303865653464"}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a338", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3736613363306139\n", "message": "Cannot access memory at address 0x3736613363306139"}}]}, {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a340", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3366316633313662\n", "message": "Cannot access memory at address 0x3366316633313662"}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a348", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3265646266366633\n", "message": "Cannot access memory at address 0x3265646266366633"}}]}, {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a350", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3761\n", "message": "Cannot access memory at address 0x3761"}}, {"type_category": "pointer", "concrete_type": "NULL"}]}, {"type_category": "array", "concrete_type": "RECURSIVE", "value": "{0x370, 0x50}"}, {"type_category": "array", "concrete_type": "RECURSIVE", "value": "{0xf5a3b0, 0x3035316637662f65}"}, {"type_category": "array", "concrete_type": "RECURSIVE", "value": "{0x6465323065333638, 0x6364313035353634}"}, {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a390", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x6438366237326232\n", "message": "Cannot access memory at address 0x6438366237326232"}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a398", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3138653832323734\n", "message": "Cannot access memory at address 0x3138653832323734"}}]}, {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a3a0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x6338\n", "message": "Cannot access memory at address 0x6338"}}, {"type_category": "pointer", "concrete_type": "NULL"}]}, {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a3b0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3c0\n", "message": "Cannot access memory at address 0x3c0"}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a3b8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x50\n", "message": "Cannot access memory at address 0x50"}}]}, {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a3c0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"next": {"type_category": "pointer", "concrete_type": "NESTED", "value": "0x410"}, "tt": {"type_category": "unknown", "concrete_type": "lu_byte", "value": "80 'P'"}, "marked": {"type_category": "unknown", "concrete_type": "lu_byte", "value": "0 '\\000'"}, "extra": {"type_category": "unknown", "concrete_type": "lu_byte", "value": "0 '\\000'"}, "shrlen": {"type_category": "unknown", "concrete_type": "ls_byte", "value": "0 '\\000'"}, "hash": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}, "u": {"type_category": "struct", "concrete_type": "NESTED", "value": "{lnglen = 16098384, hnext = 0xf5a450}"}, "contents": {"type_category": "string", "concrete_type": "string", "value": "0x3336376234642f65 <error: Cannot access memory at address 0x3336376234642f65>"}, "falloc": {"type_category": "unknown", "concrete_type": "lua_Alloc", "value": "0x3361323037666261"}, "ud": {"type_category": "pointer", "concrete_type": "NESTED", "value": "0x6565313132646538"}}}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a3c8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3561386133652f65\n", "message": "Cannot access memory at address 0x3561386133652f65"}}]}, {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a3d0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3833316264393135\n", "message": "Cannot access memory at address 0x3833316264393135"}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a3d8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3235613263386335\n", "message": "Cannot access memory at address 0x3235613263386335"}}]}, {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a3e0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3435333636633230\n", "message": "Cannot access memory at address 0x3435333636633230"}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a3e8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x6136303838366364\n", "message": "Cannot access memory at address 0x6136303838366364"}}]}, {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a3f0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3864\n", "message": "Cannot access memory at address 0x3864"}}, {"type_category": "pointer", "concrete_type": "NULL"}]}, {"type_category": "array", "concrete_type": "RECURSIVE", "value": "{0x410, 0x50}"}, {"type_category": "array", "concrete_type": "RECURSIVE", "value": "{0xf5a450, 0x3336376234642f65}"}, {"type_category": "array", "concrete_type": "RECURSIVE", "value": "{0x3361323037666261, 0x6565313132646538}"}, {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a430", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3064666337356165\n", "message": "Cannot access memory at address 0x3064666337356165"}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a438", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3664316330646162\n", "message": "Cannot access memory at address 0x3664316330646162"}}]}, {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a440", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x6230\n", "message": "Cannot access memory at address 0x6230"}}, {"type_category": "pointer", "concrete_type": "NULL"}]}, {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a450", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x460\n", "message": "Cannot access memory at address 0x460"}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a458", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x50\n", "message": "Cannot access memory at address 0x50"}}]}, {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a460", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"next": {"type_category": "pointer", "concrete_type": "NESTED", "value": "0x4b0"}, "tt": {"type_category": "unknown", "concrete_type": "lu_byte", "value": "80 'P'"}, "marked": {"type_category": "unknown", "concrete_type": "lu_byte", "value": "0 '\\000'"}, "extra": {"type_category": "unknown", "concrete_type": "lu_byte", "value": "0 '\\000'"}, "shrlen": {"type_category": "unknown", "concrete_type": "ls_byte", "value": "0 '\\000'"}, "hash": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}, "u": {"type_category": "struct", "concrete_type": "NESTED", "value": "{lnglen = 16098544, hnext = 0xf5a4f0}"}, "contents": {"type_category": "string", "concrete_type": "string", "value": "0x6635366234372f65 <error: Cannot access memory at address 0x6635366234372f65>"}, "falloc": {"type_category": "unknown", "concrete_type": "lua_Alloc", "value": "0x3931356264326633"}, "ud": {"type_category": "pointer", "concrete_type": "NESTED", "value": "0x6162316361646561"}}}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a468", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x6562376237662f65\n", "message": "Cannot access memory at address 0x6562376237662f65"}}]}, {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a470", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3531633333306333\n", "message": "Cannot access memory at address 0x3531633333306333"}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a478", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3236623935366462\n", "message": "Cannot access memory at address 0x3236623935366462"}}]}, {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a480", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3063363261613335\n", "message": "Cannot access memory at address 0x3063363261613335"}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a488", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3136353166393561\n", "message": "Cannot access memory at address 0x3136353166393561"}}]}, {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a490", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3232\n", "message": "Cannot access memory at address 0x3232"}}, {"type_category": "pointer", "concrete_type": "NULL"}]}, {"type_category": "array", "concrete_type": "RECURSIVE", "value": "{0x4b0, 0x50}"}, {"type_category": "array", "concrete_type": "RECURSIVE", "value": "{0xf5a4f0, 0x6635366234372f65}"}, {"type_category": "array", "concrete_type": "RECURSIVE", "value": "{0x3931356264326633, 0x6162316361646561}"}, {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a4d0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3432383165313734\n", "message": "Cannot access memory at address 0x3432383165313734"}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a4d8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3230303431653734\n", "message": "Cannot access memory at address 0x3230303431653734"}}]}, {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a4e0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x6166\n", "message": "Cannot access memory at address 0x6166"}}, {"type_category": "pointer", "concrete_type": "NULL"}]}, {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a4f0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x500\n", "message": "Cannot access memory at address 0x500"}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a4f8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x50\n", "message": "Cannot access memory at address 0x50"}}]}, {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a500", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"next": {"type_category": "pointer", "concrete_type": "NESTED", "value": "0x550"}, "tt": {"type_category": "unknown", "concrete_type": "lu_byte", "value": "80 'P'"}, "marked": {"type_category": "unknown", "concrete_type": "lu_byte", "value": "0 '\\000'"}, "extra": {"type_category": "unknown", "concrete_type": "lu_byte", "value": "0 '\\000'"}, "shrlen": {"type_category": "unknown", "concrete_type": "ls_byte", "value": "0 '\\000'"}, "hash": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}, "u": {"type_category": "struct", "concrete_type": "NESTED", "value": "{lnglen = 16098704, hnext = 0xf5a590}"}, "contents": {"type_category": "string", "concrete_type": "string", "value": "0x3731386132362f65 <error: Cannot access memory at address 0x3731386132362f65>"}, "falloc": {"type_category": "unknown", "concrete_type": "lua_Alloc", "value": "0x6337356263393463"}, "ud": {"type_category": "pointer", "concrete_type": "NESTED", "value": "0x6262363663663266"}}}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a508", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x6637383036372f65\n", "message": "Cannot access memory at address 0x6637383036372f65"}}]}, {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a510", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3232373836313765\n", "message": "Cannot access memory at address 0x3232373836313765"}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a518", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x6633356139623730\n", "message": "Cannot access memory at address 0x6633356139623730"}}]}, {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a520", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x6138393764623231\n", "message": "Cannot access memory at address 0x6138393764623231"}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a528", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x6530636365373836\n", "message": "Cannot access memory at address 0x6530636365373836"}}]}, {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a530", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3763\n", "message": "Cannot access memory at address 0x3763"}}, {"type_category": "pointer", "concrete_type": "NULL"}]}, {"type_category": "array", "concrete_type": "RECURSIVE", "value": "{0x550, 0x50}"}, {"type_category": "array", "concrete_type": "RECURSIVE", "value": "{0xf5a590, 0x3731386132362f65}"}, {"type_category": "array", "concrete_type": "RECURSIVE", "value": "{0x6337356263393463, 0x6262363663663266}"}, {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a570", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3339356136316462\n", "message": "Cannot access memory at address 0x3339356136316462"}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a578", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3266643162303732\n", "message": "Cannot access memory at address 0x3266643162303732"}}]}, {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a580", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3064\n", "message": "Cannot access memory at address 0x3064"}}, {"type_category": "pointer", "concrete_type": "NULL"}]}, {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a590", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x5a0\n", "message": "Cannot access memory at address 0x5a0"}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a598", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x50\n", "message": "Cannot access memory at address 0x50"}}]}, {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a5a0", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"next": {"type_category": "pointer", "concrete_type": "NESTED", "value": "0x5f0"}, "tt": {"type_category": "unknown", "concrete_type": "lu_byte", "value": "80 'P'"}, "marked": {"type_category": "unknown", "concrete_type": "lu_byte", "value": "0 '\\000'"}, "extra": {"type_category": "unknown", "concrete_type": "lu_byte", "value": "0 '\\000'"}, "shrlen": {"type_category": "unknown", "concrete_type": "ls_byte", "value": "0 '\\000'"}, "hash": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}, "u": {"type_category": "struct", "concrete_type": "NESTED", "value": "{lnglen = 16098864, hnext = 0xf5a630}"}, "contents": {"type_category": "string", "concrete_type": "string", "value": "0x6339313030622f65 <error: Cannot access memory at address 0x6339313030622f65>"}, "falloc": {"type_category": "unknown", "concrete_type": "lua_Alloc", "value": "0x3536663566323230"}, "ud": {"type_category": "pointer", "concrete_type": "NESTED", "value": "0x3537323262623136"}}}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a5a8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3339616637392f65\n", "message": "Cannot access memory at address 0x3339616637392f65"}}]}, {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a5b0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3738646333633836\n", "message": "Cannot access memory at address 0x3738646333633836"}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a5b8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x6438393061343735\n", "message": "Cannot access memory at address 0x6438393061343735"}}]}, {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a5c0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x6333616465643432\n", "message": "Cannot access memory at address 0x6333616465643432"}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a5c8", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3338336239343463\n", "message": "Cannot access memory at address 0x3338336239343463"}}]}, {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a5d0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3436\n", "message": "Cannot access memory at address 0x3436"}}, {"type_category": "pointer", "concrete_type": "NULL"}]}, {"type_category": "array", "concrete_type": "RECURSIVE", "value": "{0x5f0, 0x50}"}, {"type_category": "array", "concrete_type": "RECURSIVE", "value": "{0xf5a630, 0x6339313030622f65}"}, {"type_category": "array", "concrete_type": "RECURSIVE", "value": "{0x3536663566323230, 0x3537323262623136}"}, {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a610", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3630376565386361\n", "message": "Cannot access memory at address 0x3630376565386361"}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a618", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x6434366530633132\n", "message": "Cannot access memory at address 0x6434366530633132"}}]}, {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a620", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x6235\n", "message": "Cannot access memory at address 0x6235"}}, {"type_category": "pointer", "concrete_type": "NULL"}]}, {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a630", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x640\n", "message": "Cannot access memory at address 0x640"}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a638", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x50\n", "message": "Cannot access memory at address 0x50"}}]}, {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a640", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"next": {"type_category": "pointer", "concrete_type": "NESTED", "value": "0x690"}, "tt": {"type_category": "unknown", "concrete_type": "lu_byte", "value": "80 'P'"}, "marked": {"type_category": "unknown", "concrete_type": "lu_byte", "value": "0 '\\000'"}, "extra": {"type_category": "unknown", "concrete_type": "lu_byte", "value": "0 '\\000'"}, "shrlen": {"type_category": "unknown", "concrete_type": "ls_byte", "value": "0 '\\000'"}, "hash": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}, "u": {"type_category": "struct", "concrete_type": "NESTED", "value": "{lnglen = 16099024, hnext = 0xf5a6d0}"}, "contents": {"type_category": "string", "concrete_type": "string", "value": "0x3662623461612f65 <error: Cannot access memory at address 0x3662623461612f65>"}, "falloc": {"type_category": "unknown", "concrete_type": "lua_Alloc", "value": "0x3265636337303432"}, "ud": {"type_category": "pointer", "concrete_type": "NESTED", "value": "0x6261386530303436"}}}}, {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a648", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x6536666235642f65\n", "message": "Cannot access memory at address 0x6536666235642f65"}}]}], "warnf": null, "ud_warn": null}, "tag": "int", "size": "720"}, "Value After Statement Execution": "NULL", "Function Name": "firsttry", "Project Information": "lua"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "*/\n\n\nTable *luaH_new (lua_State *L) {\n  GCObject *o = luaC_newobj(L, LUA_VTABLE, sizeof(Table));\n  Table *t = gco2t(o);\n  t->metatable = NULL;\n  t->flags = cast_byte(maskflags);  \n  t->array = NULL;\n  t->alimit = 0;\n  setnodevector(L, t, 0);\n", "Selected Statement": "t->flags = cast_byte(maskflags);  /* table has no metamethod fields */", "Function Input": {}, "Variable Values Before Statement": {"maskflags": "NULL"}, "Value After Statement Execution": "63 '?'", "Function Name": "cast_byte", "Project Information": "lua"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nvoid luaS_init (lua_State *L) {\n  global_State *g = G(L);\n  int i, j;\n  stringtable *tb = &G(L)->strt;\n  tb->hash = luaM_newvector(L, MINSTRTABSIZE, TString*);\n  tablerehash(tb->hash, 0, MINSTRTABSIZE);  \n  tb->size = MINSTRTABSIZE;\n  \n  g->memerrmsg = luaS_newliteral(L, MEMERRMSG);\n  luaC_fix(L, obj2gco(g->memerrmsg));  \n  for (i = 0; i < STRCACHE_N; i++)  \n    for (j = 0; j < STRCACHE_M; j++)\n      g->strcache[i][j] = g->memerrmsg;\n", "Selected Statement": "g->memerrmsg = luaS_newliteral(L, MEMERRMSG);", "Function Input": {}, "Variable Values Before Statement": {"L": "NULL", "MEMERRMSG": "NULL"}, "Value After Statement Execution": "{next = 0xf59850, tt = 4 '\\004', marked = 8 '\\b', extra = 0 '\\000', shrlen = 17 '\\021', hash = 1174080900, u = {lnglen = 0, hnext = 0x0}, contents = 0x756f6e6520746f6e &lt;error: Cannot access memory at address 0x756f6e6520746f6e&gt;, falloc = 0x726f6d656d206867, ud = 0x79}", "Function Name": "luaS_newliteral", "Project Information": "lua"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "};\n\n\nvoid luaT_init (lua_State *L) {\n  static const char *const luaT_eventname[] = {  \n    \"__index\", \"__newindex\",\n    \"__gc\", \"__mode\", \"__len\", \"__eq\",\n    \"__add\", \"__sub\", \"__mul\", \"__mod\", \"__pow\",\n    \"__div\", \"__idiv\",\n    \"__band\", \"__bor\", \"__bxor\", \"__shl\", \"__shr\",\n    \"__unm\", \"__bnot\", \"__lt\", \"__le\",\n    \"__concat\", \"__call\", \"__close\"\n  };\n  int i;\n  for (i=0; i<TM_N; i++) {\n    G(L)->tmname[i] = luaS_new(L, luaT_eventname[i]);\n    luaC_fix(L, obj2gco(G(L)->tmname[i]));  \n  }\n", "Selected Statement": "G(L)->tmname[i] = luaS_new(L, luaT_eventname[i]);", "Function Input": {}, "Variable Values Before Statement": {"L": "NULL"}, "Value After Statement Execution": "NULL", "Function Name": "luaS_new", "Project Information": "lua"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "}\n\n\nvoid luaX_init (lua_State *L) {\n  int i;\n  TString *e = luaS_newliteral(L, LUA_ENV);  \n  luaC_fix(L, obj2gco(e));  \n  for (i=0; i<NUM_RESERVED; i++) {\n    TString *ts = luaS_new(L, luaX_tokens[i]);\n    luaC_fix(L, obj2gco(ts));  \n    ts->extra = cast_byte(i+1);  \n  }\n", "Selected Statement": "TString *e = luaS_newliteral(L, LUA_ENV);  /* create env name */", "Function Input": {}, "Variable Values Before Statement": {"L": "NULL", "LUA_ENV": "NULL"}, "Value After Statement Execution": "NULL", "Function Name": "luaS_newliteral", "Project Information": "lua"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nextern \"C\" int\nLLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n\tFuzzedDataProvider fdp(data, size);\n\n\tlua_State *L = luaL_newstate();\n\tif (L == NULL)\n\t\treturn 0;\n\n\tauto str1 = fdp.ConsumeRandomLengthString(size);\n\tauto str2 = fdp.ConsumeRandomLengthString(size);\n\tauto str3 = fdp.ConsumeRandomLengthString(size);\n\tconst char *c_str1 = str1.c_str();\n\tconst char *c_str2 = str2.c_str();\n\tconst char *c_str3 = str3.c_str();\n\tif (strlen(c_str1) == 0 ||\n\t    strlen(c_str2) == 0 ||\n\t    strlen(c_str3) == 0) {\n\t\tlua_settop(L, 0);\n\t\tlua_close(L);\n\t\treturn -1;\n\t}\n\tint top = lua_gettop(L);\n\tluaL_gsub(L, c_str1, c_str2, c_str3);\n\t\n\tassert(lua_gettop(L) == top + 1);\n\n\tlua_settop(L, 0);\n\tlua_close(L);\n\n\treturn 0;\n", "Selected Statement": "auto str1 = fdp.ConsumeRandomLengthString(size);", "Function Input": {"data": {"value": "0x1037fd0 \"\""}, "size": {"value": "6552064"}}, "Variable Values Before Statement": {"size": "0"}, "Value After Statement Execution": "NULL", "Function Name": "fdp.ConsumeRandomLengthString", "Project Information": "lua"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "#include \"sndfile_fuzz_header.h\"\n\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size)\n{  VIO_DATA vio_data ;\n   SF_VIRTUAL_IO vio ;\n   SF_INFO sndfile_info ;\n   SNDFILE *sndfile = NULL ;\n   float* read_buffer = NULL ;\n\n   int err = sf_init_file(data, size, &sndfile, &vio_data, &vio, &sndfile_info) ;\n   if (err)\n     goto EXIT_LABEL ;\n\n   \n   read_buffer = (float*)malloc(sizeof(float) * sndfile_info.channels);\n   if (read_buffer == NULL)\n     abort() ;\n\n   while (sf_readf_float(sndfile, read_buffer, 1))\n   {\n     \n   }\n\nEXIT_LABEL:\n\n   if (sndfile != NULL)\n     sf_close(sndfile) ;\n\n   free(read_buffer) ;\n\n", "Selected Statement": "int err = sf_init_file(data, size, &sndfile, &vio_data, &vio, &sndfile_info) ;", "Function Input": {"data": {"value": "0x1058b40 \"0\\220\\005\\001\""}, "size": {"value": "17145920"}}, "Variable Values Before Statement": {"data": "0x105a040 \"\"", "size": "0"}, "Value After Statement Execution": "int", "Function Name": "sf_init_file", "Project Information": "libsndfile"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nextern \"C\" int\nLLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n\tchar new_file[256];\n\tsprintf(new_file, \"/tmp/libfuzzer.uti\");\n\n\tFILE *fp = fopen(new_file, \"wb\");\n\tif (!fp)\n\t\treturn 0;\n\tfwrite(data, size, 1, fp);\n\tfclose(fp);\n\n\tchar *table = \"empty.ctb\";\n\tlou_compileString(table, \"include /tmp/libfuzzer.uti\");\n\n\tlou_free();\n\tstd::__fs::filesystem::remove_all(\"/tmp/libfuzzer.uti\");\n\n\treturn 0;\n", "Selected Statement": "FILE *fp = fopen(new_file, \"wb\");", "Function Input": {"data": {"value": "0xfc2f80 \"\""}, "size": {"value": "6017536"}}, "Variable Values Before Statement": {"new_file": "\"/tmp/libfuzzer.uti\\000\\000\\000\\000\\000\\000|\\232\\314\\367\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\340\\v\\342\\367\\377\\177\\000\\000@\\000\\000\\000\\000\\000\\000\\000\\200\\v\\342\\367\\377\\177\\000\\000\\000\\020\\000\\000\\000\\000\\000\\000\\000SG_\\223\\224L\\r\\020\\020\\000\\000\\000\\000\\000\\000\\300\\025\\342\\367\\377\\177\\000\\000\\240\\324\\341\\367\\377\\177\\000\\000\\306c\\313\\367\\377\\177\\000\\000\\000\\020\\000\\000\\000\\000\\000\\000\\316\\017\\000\\000\\000\\000\\000\\000\\240\\337\\377\\377\\377\\177\\000\\000{#B\\000\\000\\000\\000\\000\\000\\020\\000\\000\\000\\000\\000\\000\\000\\020\\000\\000\\000\\000\\000\\000\\200\\v\\342\\367\\377\\177\\000\\000\\260:\\374\\000\\000\\000\\000\\000\\n\\330\\374\\367\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000X\\337\\377\\377\\377\\177\\000\\000\\000\\322[\\000\\000\\000\\000\\000\\200/\\374\\000\\000\\000\\000\\000p\\252\\373\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000,\\333C\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\"", "\"wb\"": "\"wb\""}, "Value After Statement Execution": "NULL", "Function Name": "fopen", "Project Information": "liblouis"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\n\n__attribute_noinline__\nbuffer* buffer_init(void) {\n  #if 0 \n\treturn ck_calloc(1, sizeof(buffer));\n  #else\n\tbuffer * const b = calloc(1, sizeof(*b));\n\tforce_assert(b);\n", "Selected Statement": "buffer * const b = calloc(1, sizeof(*b));", "Function Input": {"b": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"ptr": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "used": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "4350436"}, "size": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}}}, "Variable Values Before Statement": {"1": "1"}, "Value After Statement Execution": "NULL", "Function Name": "calloc", "Project Information": "lighttpd"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nvoid run_burl_normalize (buffer *psrc, buffer *ptmp, \n\t\t\t\t\t\tint flags, int line, const char *in, \n\t\t\t\t\t\tsize_t in_len) {\n    int qs;\n    buffer_copy_string_len(psrc, in, in_len);\n    qs = burl_normalize(psrc, ptmp, flags);\n}\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n    if (size <= 4) {\n        return 0;\n    }\n    int flags = ((int*)data)[0];\n    data += 4;\n    size -= 4;\n    char *new_str = (char *)malloc(size+1);\n    if (new_str == NULL){\n        return 0;\n    }\n    memcpy(new_str, data, size);\n    new_str[size] = '\\0';\n\n    \n    buffer *psrc = buffer_init();\n    buffer *ptmp = buffer_init();\n    run_burl_normalize(psrc, ptmp, flags, __LINE__, new_str, size);\n", "Selected Statement": "qs = burl_normalize(psrc, ptmp, flags);", "Function Input": {"flags": {"value": "0"}, "in": {"value": "0x55aa00 <fuzzer::TPC> \"\""}, "in_len": {"value": "16181808"}, "line": {"value": "5001103"}, "psrc": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"ptr": {"type_category": "string", "concrete_type": "NULL"}, "used": {"type_category": "unknown", "concrete_type": "u_int32_t", "value": "0"}, "size": {"type_category": "unknown", "concrete_type": "u_int32_t", "value": "0"}}}}, "ptmp": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"ptr": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffde80 \"\\300\\336\\377\\377\\377\\177\""}, "used": {"type_category": "unknown", "concrete_type": "u_int32_t", "value": "4981897"}, "size": {"type_category": "unknown", "concrete_type": "u_int32_t", "value": "0"}}}}}, "Variable Values Before Statement": {"psrc": {"ptr": "0x153d770 \"/%01\"", "used": "5", "size": "65"}, "ptmp": {"ptr": "0x153d810 \"///%01\"", "used": "0", "size": "65"}, "flags": "int"}, "Value After Statement Execution": "int", "Function Name": "burl_normalize", "Project Information": "lighttpd"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\n\nint burl_normalize (buffer *b, buffer *t, int flags)\n{\n    int qs;\n\n  #if defined(_WIN32) || defined(__CYGWIN__)\n    \n    if (flags & HTTP_PARSEOPT_URL_NORMALIZE_PATH_BACKSLASH_TRANS) {\n        for (char *p = b->ptr; *p != '?' && *p != '\\0'; ++p) {\n            if (*p == '\\\\') *p = '/';\n        }\n    }\n  #endif\n\n    qs = (flags & HTTP_PARSEOPT_URL_NORMALIZE_REQUIRED)\n      ? burl_normalize_basic_required(b, t)\n      : burl_normalize_basic_unreserved(b, t);\n    if (-2 == qs) {\n        if (flags & HTTP_PARSEOPT_URL_NORMALIZE_INVALID_UTF8_REJECT) return -2;\n        qs = burl_scan_qmark(b);\n    }\n\n    if (flags & HTTP_PARSEOPT_URL_NORMALIZE_CTRLS_REJECT) {\n        if (burl_contains_ctrls(b)) return -2;\n    }\n\n    if (flags & (HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_DECODE\n                |HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_REJECT)) {\n        qs = burl_normalize_2F_to_slash(b, qs, flags);\n        if (-2 == qs) return -2;\n    }\n\n    if (flags & (HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REMOVE\n                |HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REJECT)) {\n        qs = burl_normalize_path(b, t, qs, flags);\n        if (-2 == qs) return -2;\n    }\n\n    if (flags & HTTP_PARSEOPT_URL_NORMALIZE_QUERY_20_PLUS) {\n        if (qs >= 0) burl_normalize_qs20_to_plus(b, qs);\n    }\n\n    return qs;\n", "Selected Statement": "qs = burl_normalize_path(b, t, qs, flags);", "Function Input": {}, "Variable Values Before Statement": {"b": {"ptr": "0x153d770 \"/%01\"", "used": "5", "size": "65"}, "t": {"ptr": "0x153d810 \"///%01\"", "used": "0", "size": "65"}, "qs": "int", "flags": "int"}, "Value After Statement Execution": "int", "Function Name": "burl_normalize_path", "Project Information": "lighttpd"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nint\nparse_packet(sldns_buffer* pkt, struct msg_parse* msg, struct regional* region)\n{\n\tint ret;\n\tif(sldns_buffer_remaining(pkt) < LDNS_HEADER_SIZE)\n\t\treturn LDNS_RCODE_FORMERR;\n\t\n\tsldns_buffer_read(pkt, &msg->id, sizeof(uint16_t));\n\tmsg->flags = sldns_buffer_read_u16(pkt);\n\tmsg->qdcount = sldns_buffer_read_u16(pkt);\n\tmsg->ancount = sldns_buffer_read_u16(pkt);\n\tmsg->nscount = sldns_buffer_read_u16(pkt);\n\tmsg->arcount = sldns_buffer_read_u16(pkt);\n\tif(msg->qdcount > 1)\n\t\treturn LDNS_RCODE_FORMERR;\n\tif((ret = parse_query_section(pkt, msg)) != 0)\n\t\treturn ret;\n\tif((ret = parse_section(pkt, msg, region, LDNS_SECTION_ANSWER,\n\t\tmsg->ancount, &msg->an_rrsets)) != 0)\n\t\treturn ret;\n\tif((ret = parse_section(pkt, msg, region, LDNS_SECTION_AUTHORITY,\n\t\tmsg->nscount, &msg->ns_rrsets)) != 0)\n\t\treturn ret;\n\tif(sldns_buffer_remaining(pkt) == 0 && msg->arcount == 1) {\n\t\t\n\t} else if((ret = parse_section(pkt, msg, region,\n\t\tLDNS_SECTION_ADDITIONAL, msg->arcount, &msg->ar_rrsets)) != 0)\n\t\treturn ret;\n\t\n\t\t\n\t\n\tmsg->rrset_count = msg->an_rrsets + msg->ns_rrsets + msg->ar_rrsets;\n\treturn 0;\n", "Selected Statement": "msg->arcount = sldns_buffer_read_u16(pkt);", "Function Input": {"pkt": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"_position": {"type_category": "unknown", "concrete_type": "size_t", "value": "0"}, "_limit": {"type_category": "unknown", "concrete_type": "size_t", "value": "12"}, "_capacity": {"type_category": "unknown", "concrete_type": "size_t", "value": "3546920299816956257"}, "_data": {"type_category": "string", "concrete_type": "string", "value": "0x31 <error: Cannot access memory at address 0x31>"}, "_fixed": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}, "_status_err": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}}}}}, "Variable Values Before Statement": {"pkt": {"_position": "12", "_limit": "12", "_capacity": "12", "_data": "0x11e62d0 \"\"", "_fixed": "1", "_status_err": "0"}}, "Value After Statement Execution": "0", "Function Name": "sldns_buffer_read_u16", "Project Information": "unbound"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nvoid\nlog_init(const char* filename, int use_syslog, const char* chrootdir)\n{\n\tFILE *f;\n\tif(!key_created) {\n\t\tkey_created = 1;\n\t\tub_thread_key_create(&logkey, NULL);\n\t\tlock_basic_init(&log_lock);\n\t}\n\tlock_basic_lock(&log_lock);\n\tif(logfile \n#if defined(HAVE_SYSLOG_H) || defined(UB_ON_WINDOWS)\n\t|| logging_to_syslog\n#endif\n\t) {\n\t\tlock_basic_unlock(&log_lock); \n\t\tverbose(VERB_QUERY, \"switching log to %s\", \n\t\t\tuse_syslog?\"syslog\":(filename&&filename[0]?filename:\"stderr\"));\n\t\tlock_basic_lock(&log_lock);\n\t}\n\tif(logfile && logfile != stderr) {\n\t\tFILE* cl = logfile;\n\t\tlogfile = NULL; \n\t\tfclose(cl);\n\t}\n#ifdef HAVE_SYSLOG_H\n\tif(logging_to_syslog) {\n\t\tcloselog();\n\t\tlogging_to_syslog = 0;\n\t}\n\tif(use_syslog) {\n\t\t\n\t\t\n\t\topenlog(ident, LOG_NDELAY, UB_SYSLOG_FACILITY);\n\t\tlogging_to_syslog = 1;\n\t\tlock_basic_unlock(&log_lock);\n\t\treturn;\n\t}\n#elif defined(UB_ON_WINDOWS)\n\tif(logging_to_syslog) {\n\t\tlogging_to_syslog = 0;\n\t}\n\tif(use_syslog) {\n\t\tlogging_to_syslog = 1;\n\t\tlock_basic_unlock(&log_lock);\n\t\treturn;\n\t}\n#endif \n\tif(!filename || !filename[0]) {\n\t\tlogfile = stderr;\n\t\tlock_basic_unlock(&log_lock);\n\t\treturn;\n\t}\n\t\n\tif(chrootdir && chrootdir[0] && strncmp(filename, chrootdir,\n\t\tstrlen(chrootdir)) == 0) \n\t\tfilename += strlen(chrootdir);\n\tf = fopen(filename, \"a\");\n\tif(!f) {\n\t\tlock_basic_unlock(&log_lock);\n\t\tlog_err(\"Could not open logfile %s: %s\", filename, \n\t\t\tstrerror(errno));\n\t\treturn;\n\t}\n#ifndef UB_ON_WINDOWS\n\t\n\tsetvbuf(f, NULL, (int)_IOLBF, 0);\n#endif\n\tlogfile = f;\n\tlock_basic_unlock(&log_lock);\n", "Selected Statement": "f = fopen(filename, \"a\");", "Function Input": {"chrootdir": {"value": "0x1ee000 <error: Cannot access memory at address 0x1ee000>"}, "filename": {"value": "0x1f1660 <error: Cannot access memory at address 0x1f1660>"}, "use_syslog": {"value": "0"}}, "Variable Values Before Statement": {"filename": "0x6f0931 \"/tmp/foo\"", "\"a\"": "\"a\""}, "Value After Statement Execution": "NULL", "Function Name": "fopen", "Project Information": "unbound"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nint sldns_wire2str_edns_subnet_print(char** s, size_t* sl, uint8_t* data,\n\tsize_t len)\n{\n\tint w = 0;\n\tuint16_t family;\n\tuint8_t source, scope;\n\tif(len < 4) {\n\t\tw += sldns_str_print(s, sl, \"malformed subnet \");\n\t\tw += print_hex_buf(s, sl, data, len);\n\t\treturn w;\n\t}\n\tfamily = sldns_read_uint16(data);\n\tsource = data[2];\n\tscope = data[3];\n\tif(family == 1) {\n\t\t\n\t\tchar buf[64];\n\t\tuint8_t ip4[4];\n\t\tmemset(ip4, 0, sizeof(ip4));\n\t\tif(len-4 > 4) {\n\t\t\tw += sldns_str_print(s, sl, \"trailingdata:\");\n\t\t\tw += print_hex_buf(s, sl, data+4+4, len-4-4);\n\t\t\tw += sldns_str_print(s, sl, \" \");\n\t\t\tlen = 4+4;\n\t\t}\n\t\tmemmove(ip4, data+4, len-4);\n\t\tif(!inet_ntop(AF_INET, ip4, buf, (socklen_t)sizeof(buf))) {\n\t\t\tw += sldns_str_print(s, sl, \"ip4ntoperror \");\n\t\t\tw += print_hex_buf(s, sl, data+4+4, len-4-4);\n\t\t} else {\n\t\t\tw += sldns_str_print(s, sl, \"%s\", buf);\n\t\t}\n\t} else if(family == 2) {\n\t\t\n\t\tchar buf[64];\n\t\tuint8_t ip6[16];\n\t\tmemset(ip6, 0, sizeof(ip6));\n\t\tif(len-4 > 16) {\n\t\t\tw += sldns_str_print(s, sl, \"trailingdata:\");\n\t\t\tw += print_hex_buf(s, sl, data+4+16, len-4-16);\n\t\t\tw += sldns_str_print(s, sl, \" \");\n\t\t\tlen = 4+16;\n\t\t}\n\t\tmemmove(ip6, data+4, len-4);\n#ifdef AF_INET6\n\t\tif(!inet_ntop(AF_INET6, ip6, buf, (socklen_t)sizeof(buf))) {\n\t\t\tw += sldns_str_print(s, sl, \"ip6ntoperror \");\n\t\t\tw += print_hex_buf(s, sl, data+4+4, len-4-4);\n\t\t} else {\n\t\t\tw += sldns_str_print(s, sl, \"%s\", buf);\n\t\t}\n#else\n\t\tw += print_hex_buf(s, sl, data+4+4, len-4-4);\n#endif\n\t} else {\n\t\t\n\t\tw += sldns_str_print(s, sl, \"family %d \",\n\t\t\t(int)family);\n\t\tw += print_hex_buf(s, sl, data, len);\n\t}\n\tw += sldns_str_print(s, sl, \"/%d scope /%d\", (int)source, (int)scope);\n\treturn w;\n", "Selected Statement": "w += sldns_str_print(s, sl, \"malformed subnet \");", "Function Input": {"s": {"value": {"type_category": "string", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}}, "Variable Values Before Statement": {"s": "NULL", "sl": "0", "\"malformed subnet \"": "\"malformed subnet \""}, "Value After Statement Execution": "int", "Function Name": "sldns_str_print", "Project Information": "unbound"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nint client(Fuzzer *fuzzer);\n\nvoid fuzzinit(Fuzzer *fuzzer){\n    struct sockaddr_in server_addr;\n    fuzzer->socket = socket(AF_INET, SOCK_STREAM, 0);\n\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(fuzzer->port);\n    server_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n\n    setsockopt(fuzzer->socket, SOL_SOCKET, SO_REUSEADDR, &(int){1}, sizeof(int));\n\n    bind(fuzzer->socket, (struct sockaddr*)&server_addr, sizeof(server_addr));\n    listen(fuzzer->socket,1);\n}\n\nvoid *Server(void *args){\n\n    Fuzzer *fuzzer = (Fuzzer*)args;\n    {\n        int client;\n        char clientData[10240];\n        struct sockaddr_in clientAddr;\n        uint32_t clientSZ = sizeof(clientAddr);\n\n        client = accept(fuzzer->socket, (struct sockaddr*)&clientAddr, &clientSZ);\n\n        send(client, fuzzer->buffer, fuzzer->size, 0);\n        recv(client, clientData, sizeof(clientData), 0);\n\n        send(client, fuzzer->buffer, fuzzer->size, 0);\n        recv(client, clientData, sizeof(clientData), 0);\n\n        shutdown(client,SHUT_RDWR);\n        close(client);\n    }\n    pthread_exit(NULL);\n}\n\nvoid clean(Fuzzer *fuzzer){\n    {\n        shutdown(fuzzer->socket,SHUT_RDWR);\n        close(fuzzer->socket);\n    }\n    free(fuzzer);\n}\n\nextern int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\n    if (size < kMinInputLength || size > kMaxInputLength){\n        return 0;\n    }\n\n    Fuzzer *fuzzer = (Fuzzer*)malloc(sizeof(Fuzzer));\n    fuzzer->port = PORT;\n    fuzzer->size = size;\n    fuzzer->buffer = data;\n\n    fuzzinit(fuzzer);\n\n", "Selected Statement": "server_addr.sin_port = htons(fuzzer->port);", "Function Input": {}, "Variable Values Before Statement": {"fuzzer->port": "8080"}, "Value After Statement Execution": "36895", "Function Name": "htons", "Project Information": "libmodbus"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "#define kMinInputLength 10\n#define kMaxInputLength 5120\n\nint CheckXML(char *filename){\n\n    int rc;\n    DOMString s;\n    IXML_Document *doc = NULL;\n\n    rc = ixmlLoadDocumentEx(filename, &doc);\n    if (rc != IXML_SUCCESS) {\n        return rc;\n    }\n\n    s = ixmlPrintDocument(doc);\n    if (s == NULL || s[0] == '\\0') {\n        ixmlDocument_free(doc);\n        return 1;\n    }\n\n    ixmlFreeDOMString(s);\n    ixmlDocument_free(doc);\n\n    return 0;\n}\n\nextern int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {\n\n    if (Size < kMinInputLength || Size > kMaxInputLength){\n        return 1;\n    }\n    \n    int ret;\n    char filename[256];\n\n    sprintf(filename, \"/tmp/libfuzzer.%d\", getpid());\n    FILE *fp = fopen(filename, \"wb\");\n    if (!fp) {\n        return 0;\n    }\n\n    fwrite(Data, Size, 1, fp);\n    fclose(fp);\n\n", "Selected Statement": "rc = ixmlLoadDocumentEx(filename, &doc);", "Function Input": {"filename": {"value": "0xa <error: Cannot access memory at address 0xa>"}}, "Variable Values Before Statement": {"filename": "0x7fffffffdd60 \"/tmp/libfuzzer.61\""}, "Value After Statement Execution": "int", "Function Name": "ixmlLoadDocumentEx", "Project Information": "pupnp"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\t\n\tint file)\n{\n\tint rc = IXML_SUCCESS;\n\tParser *xmlParser = NULL;\n\n\txmlParser = Parser_init();\n\tif (xmlParser == NULL) {\n\t\treturn IXML_INSUFFICIENT_MEMORY;\n\t}\n\n\trc = Parser_readFileOrBuffer(xmlParser, xmlFileName, file);\n\tif (rc != IXML_SUCCESS) {\n\t\tParser_free(xmlParser);\n\t\treturn rc;\n\t}\n\n\txmlParser->curPtr = xmlParser->dataBuffer;\n\trc = Parser_parseDocument(retDoc, xmlParser);\n\treturn rc;\n", "Selected Statement": "xmlParser = Parser_init();", "Function Input": {}, "Variable Values Before Statement": {}, "Value After Statement Execution": {"dataBuffer": null, "curPtr": null, "savePtr": null, "lastElem": null, "tokenBuf": null, "pNeedPrefixNode": null, "pCurElement": null, "currentNodePtr": null, "state": "eELEMENT", "bHasTopLevel": "0"}, "Function Name": "Parser_init", "Project Information": "pupnp"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "}\n\nint ixmlDocument_createDocumentEx(IXML_Document **rtDoc)\n{\n\tIXML_Document *doc;\n\tint errCode = IXML_SUCCESS;\n\n\tdoc = NULL;\n\tdoc = (IXML_Document *)malloc(sizeof(IXML_Document));\n\tif (doc == NULL) {\n\t\terrCode = IXML_INSUFFICIENT_MEMORY;\n\t\tgoto ErrorHandler;\n\t}\n\n\tixmlDocument_init(doc);\n\n\tdoc->n.nodeName = strdup((const char *)DOCUMENTNODENAME);\n\tif (doc->n.nodeName == NULL) {\n\t\tixmlDocument_free(doc);\n\t\tdoc = NULL;\n\t\terrCode = IXML_INSUFFICIENT_MEMORY;\n\t\tgoto ErrorHandler;\n\t}\n\n\tdoc->n.nodeType = eDOCUMENT_NODE;\n\tdoc->n.ownerDocument = doc;\n\nErrorHandler:\n\t*rtDoc = doc;\n", "Selected Statement": "doc->n.nodeName = strdup((const char *)DOCUMENTNODENAME);", "Function Input": {"doc": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"n": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"nodeName": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdc20 \"\\200\\334\\377\\377\\377\\177\""}, "nodeValue": {"type_category": "string", "concrete_type": "string", "value": "0x4c6354 <Parser_parseDocument+180> \"\\211\\205\\\\\\377\\377\\377\\213\\265\\\\\\377\\377\\377\\211\\2654\\377\\377\\3771\\377\\350Cw\\367\\377\\213\\2054\\377\\377\\377\\203\\370\""}, "nodeType": {"type_category": "unknown", "concrete_type": "IXML_NODE_TYPE", "value": "eINVALID_NODE"}, "namespaceURI": {"type_category": "string", "concrete_type": "NULL"}, "prefix": {"type_category": "string", "concrete_type": "string", "value": "0x539400 <fuzzer::TPC> \"\""}, "localName": {"type_category": "string", "concrete_type": "string", "value": "0xeeb830 \"<?\""}, "readOnly": {"type_category": "int", "concrete_type": "int", "value": "15472256"}, "parentNode": {"type_category": "unknown", "concrete_type": "Nodeptr", "value": "0x7ffff7ae1e75 <_IO_setb+85>"}, "firstChild": {"type_category": "unknown", "concrete_type": "Nodeptr"}, "prevSibling": {"type_category": "unknown", "concrete_type": "Nodeptr", "value": "0xb75c702cdf80b200"}, "nextSibling": {"type_category": "unknown", "concrete_type": "Nodeptr"}, "firstAttr": {"type_category": "unknown", "concrete_type": "Nodeptr", "value": "0x7fffffffdce8"}, "ownerDocument": {"type_category": "unknown", "concrete_type": "Docptr", "value": "0xecb6f0"}, "ctag": {"type_category": "pointer", "concrete_type": "VOID"}}}}}}}, "Variable Values Before Statement": {}, "Value After Statement Execution": "NULL", "Function Name": "strdup", "Project Information": "pupnp"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\n#include \"ext2fs/ext2fs.h\"\n\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\n  enum FuzzerType {\n    ext2fsImageBitmapRead,\n    ext2fsImageInodeRead,\n    ext2fsImageSuperRead,\n    ext2fsImageBitmapWrite,\n    ext2fsImageInodeWrite,\n    ext2fsImageSuperWrite,\n    kMaxValue = ext2fsImageSuperWrite\n  };\n\n  FuzzedDataProvider stream(data, size);\n  const FuzzerType f = stream.ConsumeEnum<FuzzerType>();\n  (void) stream.ConsumeIntegral<int>();\n  \n\n  static const char* fname = \"ext2_test_file\";\n\n  \n  int fd = syscall(SYS_memfd_create, fname, 0);\n  std::vector<char> buffer = stream.ConsumeRemainingBytes<char>();\n  write(fd, buffer.data(), buffer.size());\n\n  std::string fspath(\"/proc/self/fd/\" + std::to_string(fd));\n\n  ext2_filsys fs;\n  errcode_t retval = ext2fs_open(\n      fspath.c_str(),\n      EXT2_FLAG_IGNORE_CSUM_ERRORS, 0, 0,\n      unix_io_manager,\n      &fs);\n\n  if (!retval) {\n    switch (f) {\n      case ext2fsImageBitmapRead: {\n        ext2fs_image_bitmap_read(fs, fd, 0);\n        break;\n      }\n      case ext2fsImageInodeRead: {\n        ext2fs_image_inode_read(fs, fd, 0);\n        break;\n      }\n      case ext2fsImageSuperRead: {\n        ext2fs_image_super_read(fs, fd, 0);\n        break;\n      }\n      case ext2fsImageBitmapWrite: {\n        ext2fs_image_bitmap_write(fs, fd, 0);\n        break;\n      }\n      case ext2fsImageInodeWrite: {\n        ext2fs_image_inode_write(fs, fd, 0);\n        break;\n      }\n      case ext2fsImageSuperWrite: {\n        ext2fs_image_super_write(fs, fd, 0);\n        break;\n      }\n      default: {\n        assert(false);\n      }\n    }\n    ext2fs_close(fs);\n  }\n  close(fd);\n\n  return 0;\n", "Selected Statement": "int fd = syscall(SYS_memfd_create, fname, 0);", "Function Input": {"data": {"value": "0x1016b70 \"`p\\001\\001\""}, "size": {"value": "16875632"}}, "Variable Values Before Statement": {"SYS_memfd_create": "NULL", "fname": "0x58a998 \"ext2_test_file\"", "0": "0"}, "Value After Statement Execution": "int", "Function Name": "syscall", "Project Information": "e2fsprogs"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nstatic errcode_t unix_open(const char *name, int flags,\n\t\t\t   io_channel *channel)\n{\n\tint fd = -1;\n\tint open_flags;\n\n\tif (name == 0)\n\t\treturn EXT2_ET_BAD_DEVICE_NAME;\n\n\topen_flags = (flags & IO_FLAG_RW) ? O_RDWR : O_RDONLY;\n\tif (flags & IO_FLAG_EXCLUSIVE)\n\t\topen_flags |= O_EXCL;\n#if defined(O_DIRECT)\n\tif (flags & IO_FLAG_DIRECT_IO)\n\t\topen_flags |= O_DIRECT;\n#endif\n\tfd = ext2fs_open_file(name, open_flags, 0);\n\tif (fd < 0)\n\t\treturn errno;\n#if defined(F_NOCACHE) && !defined(IO_DIRECT)\n\tif (flags & IO_FLAG_DIRECT_IO) {\n\t\tif (fcntl(fd, F_NOCACHE, 1) < 0)\n\t\t\treturn errno;\n\t}\n#endif\n\treturn unix_open_channel(name, fd, flags, channel, unix_io_manager);\n", "Selected Statement": "fd = ext2fs_open_file(name, open_flags, 0);", "Function Input": {}, "Variable Values Before Statement": {"name": "0x1018210 \"/proc/self/fd/3\"", "open_flags": "int", "0": "0"}, "Value After Statement Execution": "int", "Function Name": "ext2fs_open_file", "Project Information": "e2fsprogs"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "#define MAX_STRIDE_LENGTH (4194304 / (int) fs->blocksize)\nerrcode_t ext2fs_zero_blocks2(ext2_filsys fs, blk64_t blk, int num,\n\t\t\t      blk64_t *ret_blk, int *ret_count)\n{\n\tint\t\tj, count;\n\tstatic void\t*buf;\n\tstatic int\tstride_length;\n\terrcode_t\tretval;\n\n\t\n\tif (!fs) {\n\t\tif (buf) {\n\t\t\tfree(buf);\n\t\t\tbuf = 0;\n\t\t\tstride_length = 0;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t\n\tif (num <= 0)\n\t\treturn 0;\n\n\t\n\tretval = io_channel_zeroout(fs->io, blk, num);\n\tif (retval == 0)\n\t\treturn 0;\n\n\t\n\tif (num > stride_length && stride_length < MAX_STRIDE_LENGTH) {\n\t\tvoid *p;\n\t\tint new_stride = num;\n\n\t\tif (new_stride > MAX_STRIDE_LENGTH)\n\t\t\tnew_stride = MAX_STRIDE_LENGTH;\n\t\tp = realloc(buf, fs->blocksize * new_stride);\n\t\tif (!p)\n\t\t\treturn EXT2_ET_NO_MEMORY;\n\t\tbuf = p;\n\t\tstride_length = new_stride;\n\t\tmemset(buf, 0, fs->blocksize * stride_length);\n\t}\n\t\n\tj=0;\n\twhile (j < num) {\n\t\tif (blk % stride_length) {\n\t\t\tcount = stride_length - (blk % stride_length);\n\t\t\tif (count > (num - j))\n\t\t\t\tcount = num - j;\n\t\t} else {\n\t\t\tcount = num - j;\n\t\t\tif (count > stride_length)\n\t\t\t\tcount = stride_length;\n\t\t}\n\t\tretval = io_channel_write_blk64(fs->io, blk, count, buf);\n\t\tif (retval) {\n\t\t\tif (ret_count)\n\t\t\t\t*ret_count = count;\n\t\t\tif (ret_blk)\n\t\t\t\t*ret_blk = blk;\n\t\t\treturn retval;\n\t\t}\n\t\tj += count; blk += count;\n\t}\n\treturn 0;\n", "Selected Statement": "if ((retval = ext2fs_write_new_inode(fs, journal_ino, &inode)))", "Function Input": {"fs": {"value": null}}, "Variable Values Before Statement": {"fs": "ext2_filsys", "journal_ino": "NULL"}, "Value After Statement Execution": "errcode_t", "Function Name": "ext2fs_write_new_inode", "Project Information": "e2fsprogs"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\n#include \"ext2fs/ext2fs.h\"\n\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\n  enum FuzzerType {\n    ext2fsReadBlockBitmap,\n    ext2fsReadInodeBitmap,\n    kMaxValue = ext2fsReadInodeBitmap\n  };\n\n  FuzzedDataProvider stream(data, size);\n  const FuzzerType f = stream.ConsumeEnum<FuzzerType>();\n  (void) stream.ConsumeIntegral<int>();\n\n  static const char* fname = \"ext2_test_file\";\n\n  \n  int fd = syscall(SYS_memfd_create, fname, 0);\n  std::vector<char> buffer = stream.ConsumeRemainingBytes<char>();\n  write(fd, buffer.data(), buffer.size());\n\n  std::string fspath(\"/proc/self/fd/\" + std::to_string(fd));\n\n  ext2_filsys fs;\n  errcode_t retval = ext2fs_open(\n      fspath.c_str(),\n      EXT2_FLAG_IGNORE_CSUM_ERRORS, 0, 0,\n      unix_io_manager,\n      &fs);\n\n  if (!retval) {\n    switch (f) {\n      case ext2fsReadBlockBitmap: {\n        ext2fs_read_block_bitmap(fs);\n        break;\n      }\n      case ext2fsReadInodeBitmap: {\n        ext2fs_read_inode_bitmap(fs);\n        break;\n      }\n      default: {\n        assert(false);\n      }\n    }\n    ext2fs_close(fs);\n  }\n  close(fd);\n\n  return 0;\n", "Selected Statement": "int fd = syscall(SYS_memfd_create, fname, 0);", "Function Input": {"data": {"value": "0x1014b60 \"PP\\001\\001\""}, "size": {"value": "16867424"}}, "Variable Values Before Statement": {"SYS_memfd_create": "NULL", "fname": "0x588961 \"ext2_test_file\"", "0": "0"}, "Value After Statement Execution": "int", "Function Name": "syscall", "Project Information": "e2fsprogs"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\n#include \"ext2fs/ext2fs.h\"\n\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n  static const char* fname = \"/tmp/ext2_test_file\";\n\n  \n  int fd = open(fname, O_RDWR|O_CREAT|O_TRUNC);\n  write(fd, data, size);\n  close(fd);\n\n  ext2_filsys fs;\n  errcode_t retval = ext2fs_open(\n      fname,\n      EXT2_FLAG_IGNORE_CSUM_ERRORS, 0, 0,\n      unix_io_manager,\n      &fs);\n\n  if (!retval) {\n    retval = ext2fs_check_directory(fs, EXT2_ROOT_INO);\n    ext2fs_close(fs);\n  }\n\n", "Selected Statement": "int fd = open(fname, O_RDWR|O_CREAT|O_TRUNC);", "Function Input": {"data": {"value": "0xfe1b70 \"` \\376\""}, "size": {"value": "16658544"}}, "Variable Values Before Statement": {"fname": "0x578961 \"/tmp/ext2_test_file\""}, "Value After Statement Execution": "int", "Function Name": "open", "Project Information": "e2fsprogs"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "  return 0;\n}\n\nint pr_log_event_listening(unsigned int log_type) {\n  const char *event_name;\n  int res;\n\n  event_name = get_log_event_name(log_type);\n  if (event_name == NULL) {\n    return FALSE;\n  }\n\n  res = pr_event_listening(event_name);\n  if (res <= 0) {\n    return FALSE;\n  }\n\n  return TRUE;\n", "Selected Statement": "event_name = get_log_event_name(log_type);", "Function Input": {}, "Variable Values Before Statement": {"log_type": "unsigned int"}, "Value After Statement Execution": "0x672686 \"core.log.tracelog\"", "Function Name": "get_log_event_name", "Project Information": "proftpd"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nvoid\np11_debug_init (void)\n{\n\tp11_debug_current_flags = parse_environ_flags ();\n", "Selected Statement": "p11_debug_current_flags = parse_environ_flags ();", "Function Input": {}, "Variable Values Before Statement": {}, "Value After Statement Execution": "int", "Function Name": "parse_environ_flags", "Project Information": "p11-kit"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "              p11_dict_equals equal_func,\n              p11_destroyer key_destroy_func,\n              p11_destroyer value_destroy_func)\n{\n\tp11_dict *dict;\n\n\tassert (hash_func);\n\tassert (equal_func);\n\n\tdict = malloc (sizeof (p11_dict));\n\tif (dict) {\n\t\tdict->hash_func = hash_func;\n\t\tdict->equal_func = equal_func;\n\t\tdict->key_destroy_func = key_destroy_func;\n\t\tdict->value_destroy_func = value_destroy_func;\n\n\t\tdict->num_buckets = 9;\n\t\tdict->buckets = (dictbucket **)calloc (dict->num_buckets, sizeof (dictbucket *));\n\t\tif (!dict->buckets) {\n\t\t\tfree (dict);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tdict->num_items = 0;\n\t}\n\n\treturn dict;\n", "Selected Statement": "dict = malloc (sizeof (p11_dict));", "Function Input": {}, "Variable Values Before Statement": {}, "Value After Statement Execution": {"hash_func": null, "equal_func": null, "key_destroy_func": null, "value_destroy_func": null, "buckets": null, "num_items": "0", "num_buckets": "0"}, "Function Name": "malloc", "Project Information": "p11-kit"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nCK_ATTRIBUTE *\np11_attrs_dup (const CK_ATTRIBUTE *attrs)\n{\n\tCK_ULONG count;\n\n\tcount = p11_attrs_count (attrs);\n", "Selected Statement": "count = p11_attrs_count (attrs);", "Function Input": {"attrs": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"type": {"type_category": "unknown", "concrete_type": "CK_ATTRIBUTE_TYPE", "value": "7287248"}, "pValue": {"type_category": "pointer", "concrete_type": "VOID"}, "ulValueLen": {"type_category": "int", "concrete_type": "unsigned long", "value": "0"}}}}}, "Variable Values Before Statement": {"attrs": {"type": "0", "pValue": null, "ulValueLen": "8"}}, "Value After Statement Execution": "CK_ULONG", "Function Name": "p11_attrs_count", "Project Information": "p11-kit"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nvoid\np11_message_clear (void)\n{\n\tchar *buffer;\n\tbuffer = p11_message_storage ();\n\tif (buffer != NULL)\n\t\tbuffer[0] = 0;\n", "Selected Statement": "buffer = p11_message_storage ();", "Function Input": {}, "Variable Values Before Statement": {}, "Value After Statement Execution": "0x7ffff7c23778 \"\"", "Function Name": "p11_message_storage", "Project Information": "p11-kit"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\n\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n  tjhandle handle = NULL;\n  unsigned short *srcBuf = NULL;\n  unsigned char *dstBuf = NULL;\n  int width = 0, height = 0, fd = -1, i, ti;\n  char filename[FILENAME_MAX] = { 0 };\n  struct test tests[NUMTESTS] = {\n    { TJPF_RGB, 1, 0 },\n    { TJPF_BGR, 2, 2 },\n    { TJPF_RGBX, 3, 4 },\n    { TJPF_BGRA, 4, 7 },\n    { TJPF_XRGB, 5, 5 },\n    { TJPF_GRAY, 6, 3 },\n    { TJPF_CMYK, 7, 0 }\n  };\n#if defined(__has_feature) && __has_feature(memory_sanitizer)\n  char env[18] = \"JSIMD_FORCENONE=1\";\n\n  \n  putenv(env);\n#endif\n\n  snprintf(filename, FILENAME_MAX, \"/tmp/libjpeg-turbo_compress_fuzz.XXXXXX\");\n  if ((fd = mkstemp(filename)) < 0 || write(fd, data, size) < 0)\n    goto bailout;\n\n  if ((handle = tj3Init(TJINIT_COMPRESS)) == NULL)\n    goto bailout;\n\n  for (ti = 0; ti < NUMTESTS; ti++) {\n    int sum = 0, pf = tests[ti].pf;\n    size_t dstSize = 0, maxBufSize;\n\n    \n    tj3Set(handle, TJPARAM_BOTTOMUP, ti == 0);\n    tj3Set(handle, TJPARAM_NOREALLOC, ti != 2);\n    tj3Set(handle, TJPARAM_RESTARTROWS, ti == 0 || ti == 6 ? 1 : 0);\n\n    tj3Set(handle, TJPARAM_MAXPIXELS, 1048576);\n    \n    if ((srcBuf = tj3LoadImage16(handle, filename, &width, 1, &height,\n                                 &pf)) == NULL)\n      continue;\n\n    maxBufSize = tj3JPEGBufSize(width, height, TJSAMP_444);\n    if (tj3Get(handle, TJPARAM_NOREALLOC)) {\n      if ((dstBuf = (unsigned char *)malloc(maxBufSize)) == NULL)\n        goto bailout;\n    } else\n      dstBuf = NULL;\n\n    tj3Set(handle, TJPARAM_LOSSLESS, 1);\n    tj3Set(handle, TJPARAM_LOSSLESSPSV, tests[ti].psv);\n    tj3Set(handle, TJPARAM_LOSSLESSPT, tests[ti].pt);\n    if (tj3Compress16(handle, srcBuf, width, 0, height, pf, &dstBuf,\n                      &dstSize) == 0) {\n      \n      for (i = 0; i < dstSize; i++)\n        sum += dstBuf[i];\n    }\n\n    free(dstBuf);\n    dstBuf = NULL;\n    tj3Free(srcBuf);\n    srcBuf = NULL;\n\n    \n    if (sum > 255 * maxBufSize)\n      goto bailout;\n  }\n\nbailout:\n  free(dstBuf);\n  tj3Free(srcBuf);\n  if (fd >= 0) {\n    close(fd);\n    if (strlen(filename) > 0) unlink(filename);\n  }\n  tj3Destroy(handle);\n", "Selected Statement": "if ((fd = mkstemp(filename)) < 0 || write(fd, data, size) < 0)", "Function Input": {"data": {"value": "0x1108b30 \" \\220\\020\\001\""}, "size": {"value": "17866800"}}, "Variable Values Before Statement": {"filename": "\"/tmp/libjpeg-turbo_compress_fuzz.XXXXXX\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\""}, "Value After Statement Execution": "int", "Function Name": "mkstemp", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\n\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n  char filename[FILENAME_MAX] = { 0 };\n  char *argv1[] = {\n    (char *)\"cjpeg\", (char *)\"-dct\", (char *)\"float\", (char *)\"-memdst\",\n    (char *)\"-optimize\", (char *)\"-quality\", (char *)\"100,99,98\",\n    (char *)\"-restart\", (char *)\"2\", (char *)\"-sample\", (char *)\"4x1,2x2,1x2\",\n    (char *)\"-targa\", NULL\n  };\n  char *argv2[] = {\n    (char *)\"cjpeg\", (char *)\"-arithmetic\", (char *)\"-dct\", (char *)\"float\",\n    (char *)\"-memdst\", (char *)\"-quality\", (char *)\"90,80,70\", (char *)\"-rgb\",\n    (char *)\"-sample\", (char *)\"2x2\", (char *)\"-smooth\", (char *)\"50\",\n    (char *)\"-targa\", NULL\n  };\n  int fd = -1;\n#if defined(__has_feature) && __has_feature(memory_sanitizer)\n  char env[18] = \"JSIMD_FORCENONE=1\";\n\n  \n  putenv(env);\n#endif\n\n  snprintf(filename, FILENAME_MAX, \"/tmp/libjpeg-turbo_cjpeg_fuzz.XXXXXX\");\n  if ((fd = mkstemp(filename)) < 0 || write(fd, data, size) < 0)\n    goto bailout;\n\n  argv1[12] = argv2[13] = filename;\n\n  cjpeg_main(13, argv1);\n  cjpeg_main(14, argv2);\n\n  argv1[12] = argv2[13] = NULL;\n  argv1[11] = argv2[12] = filename;\n\n  cjpeg_main(12, argv1);\n  cjpeg_main(13, argv2);\n\nbailout:\n  if (fd >= 0) {\n    close(fd);\n    if (strlen(filename) > 0) unlink(filename);\n  }\n", "Selected Statement": "if ((fd = mkstemp(filename)) < 0 || write(fd, data, size) < 0)", "Function Input": {"data": {"value": "0x1005a50 \"\\020\\340\\254\\367\\377\\177\""}, "size": {"value": "16966192"}}, "Variable Values Before Statement": {"filename": "\"/tmp/libjpeg-turbo_cjpeg_fuzz.XXXXXX\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\""}, "Value After Statement Execution": "int", "Function Name": "mkstemp", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nGLOBAL(boolean)\nkeymatch(char *arg, const char *keyword, int minchars)\n{\n  register int ca, ck;\n  register int nmatched = 0;\n\n  while ((ca = *arg++) != '\\0') {\n    if ((ck = *keyword++) == '\\0')\n      return FALSE;             \n    if (isupper(ca))            \n      ca = tolower(ca);\n    if (ca != ck)\n      return FALSE;             \n    nmatched++;                 \n  }\n  \n  if (nmatched < minchars)\n    return FALSE;\n  return TRUE;                  \n", "Selected Statement": "ca = tolower(ca);", "Function Input": {}, "Variable Values Before Statement": {"ca": "int"}, "Value After Statement Execution": "int", "Function Name": "tolower", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\n\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n  tjhandle handle = NULL;\n  unsigned char *srcBuf = NULL, *dstBuf = NULL;\n  int width = 0, height = 0, fd = -1, i, ti;\n  char filename[FILENAME_MAX] = { 0 };\n  struct test tests[NUMTESTS] = {\n    { TJPF_RGB, 1, 0 },\n    { TJPF_BGR, 2, 2 },\n    { TJPF_RGBX, 3, 4 },\n    { TJPF_BGRA, 4, 7 },\n    { TJPF_XRGB, 5, 5 },\n    { TJPF_GRAY, 6, 3 },\n    { TJPF_CMYK, 7, 0 }\n  };\n#if defined(__has_feature) && __has_feature(memory_sanitizer)\n  char env[18] = \"JSIMD_FORCENONE=1\";\n\n  \n  putenv(env);\n#endif\n\n  snprintf(filename, FILENAME_MAX, \"/tmp/libjpeg-turbo_compress_fuzz.XXXXXX\");\n  if ((fd = mkstemp(filename)) < 0 || write(fd, data, size) < 0)\n    goto bailout;\n\n  if ((handle = tj3Init(TJINIT_COMPRESS)) == NULL)\n    goto bailout;\n\n  for (ti = 0; ti < NUMTESTS; ti++) {\n    int sum = 0, pf = tests[ti].pf;\n    size_t dstSize = 0, maxBufSize;\n\n    \n    tj3Set(handle, TJPARAM_BOTTOMUP, ti == 0);\n    tj3Set(handle, TJPARAM_NOREALLOC, ti != 2);\n    tj3Set(handle, TJPARAM_RESTARTROWS, ti == 0 || ti == 6 ? 1 : 0);\n\n    tj3Set(handle, TJPARAM_MAXPIXELS, 1048576);\n    \n    if ((srcBuf = tj3LoadImage8(handle, filename, &width, 1, &height,\n                                &pf)) == NULL)\n      continue;\n\n    maxBufSize = tj3JPEGBufSize(width, height, TJSAMP_444);\n    if (tj3Get(handle, TJPARAM_NOREALLOC)) {\n      if ((dstBuf = (unsigned char *)malloc(maxBufSize)) == NULL)\n        goto bailout;\n    } else\n      dstBuf = NULL;\n\n    tj3Set(handle, TJPARAM_LOSSLESS, 1);\n    tj3Set(handle, TJPARAM_LOSSLESSPSV, tests[ti].psv);\n    tj3Set(handle, TJPARAM_LOSSLESSPT, tests[ti].pt);\n    if (tj3Compress8(handle, srcBuf, width, 0, height, pf, &dstBuf,\n                     &dstSize) == 0) {\n      \n      for (i = 0; i < dstSize; i++)\n        sum += dstBuf[i];\n    }\n\n    free(dstBuf);\n    dstBuf = NULL;\n    tj3Free(srcBuf);\n    srcBuf = NULL;\n\n    \n    if (sum > 255 * maxBufSize)\n      goto bailout;\n  }\n\nbailout:\n  free(dstBuf);\n  tj3Free(srcBuf);\n  if (fd >= 0) {\n    close(fd);\n    if (strlen(filename) > 0) unlink(filename);\n  }\n  tj3Destroy(handle);\n", "Selected Statement": "if ((fd = mkstemp(filename)) < 0 || write(fd, data, size) < 0)", "Function Input": {"data": {"value": "0x1108b70 \"`\\220\\020\\001\""}, "size": {"value": "17866864"}}, "Variable Values Before Statement": {"filename": "\"/tmp/libjpeg-turbo_compress_fuzz.XXXXXX\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\""}, "Value After Statement Execution": "int", "Function Name": "mkstemp", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\n\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n  tjhandle handle = NULL;\n  void *dstBuf = NULL;\n  int width = 0, height = 0, precision, sampleSize, pfi;\n  \n  enum TJPF pixelFormats[NUMPF] =\n    { TJPF_RGB, TJPF_BGRX, TJPF_GRAY, TJPF_CMYK };\n#if defined(__has_feature) && __has_feature(memory_sanitizer)\n  char env[18] = \"JSIMD_FORCENONE=1\";\n\n  \n  putenv(env);\n#endif\n\n  if ((handle = tj3Init(TJINIT_DECOMPRESS)) == NULL)\n    goto bailout;\n\n  \n  tj3DecompressHeader(handle, data, size);\n  width = tj3Get(handle, TJPARAM_JPEGWIDTH);\n  height = tj3Get(handle, TJPARAM_JPEGHEIGHT);\n  precision = tj3Get(handle, TJPARAM_PRECISION);\n  sampleSize = (precision > 8 ? 2 : 1);\n\n  \n  if (width < 1 || height < 1 || (uint64_t)width * height > 1048576)\n    goto bailout;\n\n  tj3Set(handle, TJPARAM_SCANLIMIT, 500);\n\n  for (pfi = 0; pfi < NUMPF; pfi++) {\n    int w = width, h = height;\n    int pf = pixelFormats[pfi], i;\n    int64_t sum = 0;\n\n    \n    tj3Set(handle, TJPARAM_BOTTOMUP, pfi == 0);\n    tj3Set(handle, TJPARAM_FASTUPSAMPLE, pfi == 0);\n\n    if (!tj3Get(handle, TJPARAM_LOSSLESS)) {\n      tj3Set(handle, TJPARAM_FASTDCT, pfi == 0);\n\n      \n      if (pfi == 1) {\n        tjscalingfactor sf = { 1, 2 };\n        tj3SetScalingFactor(handle, sf);\n        w = TJSCALED(width, sf);\n        h = TJSCALED(height, sf);\n      } else\n        tj3SetScalingFactor(handle, TJUNSCALED);\n\n      \n      if (pfi == 3 && w >= 97 && h >= 75) {\n        tjregion cr = { 32, 16, 65, 59 };\n        tj3SetCroppingRegion(handle, cr);\n      } else\n        tj3SetCroppingRegion(handle, TJUNCROPPED);\n    }\n\n    if ((dstBuf = malloc(w * h * tjPixelSize[pf] * sampleSize)) == NULL)\n      goto bailout;\n\n    if (precision == 8) {\n      if (tj3Decompress8(handle, data, size, (unsigned char *)dstBuf, 0,\n                         pf) == 0) {\n        \n        for (i = 0; i < w * h * tjPixelSize[pf]; i++)\n          sum += ((unsigned char *)dstBuf)[i];\n      } else\n        goto bailout;\n    } else if (precision == 12) {\n      if (tj3Decompress12(handle, data, size, (short *)dstBuf, 0, pf) == 0) {\n        \n        for (i = 0; i < w * h * tjPixelSize[pf]; i++)\n          sum += ((short *)dstBuf)[i];\n      } else\n        goto bailout;\n    } else {\n      if (tj3Decompress16(handle, data, size, (unsigned short *)dstBuf, 0,\n                          pf) == 0) {\n        \n        for (i = 0; i < w * h * tjPixelSize[pf]; i++)\n          sum += ((unsigned short *)dstBuf)[i];\n      } else\n        goto bailout;\n    }\n\n    free(dstBuf);\n    dstBuf = NULL;\n\n    \n    if (sum > ((1LL << precision) - 1LL) * 1048576LL * tjPixelSize[pf])\n      goto bailout;\n  }\n\nbailout:\n  free(dstBuf);\n  tj3Destroy(handle);\n", "Selected Statement": "width = tj3Get(handle, TJPARAM_JPEGWIDTH);", "Function Input": {"data": {"value": "0x1108b70 \"`\\220\\020\\001\""}, "size": {"value": "17866864"}}, "Variable Values Before Statement": {"handle": "tjhandle", "TJPARAM_JPEGWIDTH": "NULL"}, "Value After Statement Execution": "int", "Function Name": "tj3Get", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\n\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n  tjhandle handle = NULL;\n  unsigned char *dstBufs[1] = { NULL };\n  size_t dstSizes[1] = { 0 }, maxBufSize;\n  int width = 0, height = 0, jpegSubsamp, i;\n  tjtransform transforms[1];\n#if defined(__has_feature) && __has_feature(memory_sanitizer)\n  char env[18] = \"JSIMD_FORCENONE=1\";\n\n  \n  putenv(env);\n#endif\n\n  if ((handle = tj3Init(TJINIT_TRANSFORM)) == NULL)\n    goto bailout;\n\n  \n  tj3DecompressHeader(handle, data, size);\n  width = tj3Get(handle, TJPARAM_JPEGWIDTH);\n  height = tj3Get(handle, TJPARAM_JPEGHEIGHT);\n  jpegSubsamp = tj3Get(handle, TJPARAM_SUBSAMP);\n  \n  tj3Set(handle, TJPARAM_ARITHMETIC, 0);\n  tj3Set(handle, TJPARAM_PROGRESSIVE, 0);\n  tj3Set(handle, TJPARAM_OPTIMIZE, 0);\n\n  \n  if (width < 1 || height < 1 || (uint64_t)width * height > 1048576)\n    goto bailout;\n\n  tj3Set(handle, TJPARAM_SCANLIMIT, 500);\n\n  if (jpegSubsamp < 0 || jpegSubsamp >= TJ_NUMSAMP)\n    jpegSubsamp = TJSAMP_444;\n\n  memset(&transforms[0], 0, sizeof(tjtransform));\n\n  transforms[0].op = TJXOP_NONE;\n  transforms[0].options = TJXOPT_PROGRESSIVE | TJXOPT_COPYNONE;\n  dstBufs[0] =\n    (unsigned char *)malloc(tj3JPEGBufSize(width, height, jpegSubsamp));\n  if (!dstBufs[0])\n    goto bailout;\n\n  maxBufSize = tj3JPEGBufSize(width, height, jpegSubsamp);\n\n  tj3Set(handle, TJPARAM_NOREALLOC, 1);\n  if (tj3Transform(handle, data, size, 1, dstBufs, dstSizes,\n                   transforms) == 0) {\n    \n    int sum = 0;\n\n    for (i = 0; i < dstSizes[0]; i++)\n      sum += dstBufs[0][i];\n\n    \n    if (sum > 255 * maxBufSize)\n      goto bailout;\n  }\n\n  free(dstBufs[0]);\n  dstBufs[0] = NULL;\n\n  transforms[0].r.w = (height + 1) / 2;\n  transforms[0].r.h = (width + 1) / 2;\n  transforms[0].op = TJXOP_TRANSPOSE;\n  transforms[0].options = TJXOPT_GRAY | TJXOPT_CROP | TJXOPT_COPYNONE |\n                          TJXOPT_OPTIMIZE;\n  dstBufs[0] =\n    (unsigned char *)malloc(tj3JPEGBufSize((height + 1) / 2, (width + 1) / 2,\n                                           jpegSubsamp));\n  if (!dstBufs[0])\n    goto bailout;\n\n  maxBufSize = tj3JPEGBufSize((height + 1) / 2, (width + 1) / 2, jpegSubsamp);\n\n  if (tj3Transform(handle, data, size, 1, dstBufs, dstSizes,\n                   transforms) == 0) {\n    int sum = 0;\n\n    for (i = 0; i < dstSizes[0]; i++)\n      sum += dstBufs[0][i];\n\n    if (sum > 255 * maxBufSize)\n      goto bailout;\n  }\n\n  free(dstBufs[0]);\n  dstBufs[0] = NULL;\n\n  transforms[0].op = TJXOP_ROT90;\n  transforms[0].options = TJXOPT_TRIM | TJXOPT_ARITHMETIC;\n  dstBufs[0] =\n    (unsigned char *)malloc(tj3JPEGBufSize(height, width, jpegSubsamp));\n  if (!dstBufs[0])\n    goto bailout;\n\n  maxBufSize = tj3JPEGBufSize(height, width, jpegSubsamp);\n\n  if (tj3Transform(handle, data, size, 1, dstBufs, dstSizes,\n                   transforms) == 0) {\n    int sum = 0;\n\n    for (i = 0; i < dstSizes[0]; i++)\n      sum += dstBufs[0][i];\n\n    if (sum > 255 * maxBufSize)\n      goto bailout;\n  }\n\n  free(dstBufs[0]);\n  dstBufs[0] = NULL;\n\n  transforms[0].op = TJXOP_NONE;\n  transforms[0].options = TJXOPT_PROGRESSIVE;\n  dstSizes[0] = 0;\n\n  tj3Set(handle, TJPARAM_NOREALLOC, 0);\n  if (tj3Transform(handle, data, size, 1, dstBufs, dstSizes,\n                   transforms) == 0) {\n    int sum = 0;\n\n    for (i = 0; i < dstSizes[0]; i++)\n      sum += dstBufs[0][i];\n\n    if (sum > 255 * maxBufSize)\n      goto bailout;\n  }\n\nbailout:\n  free(dstBufs[0]);\n  tj3Destroy(handle);\n", "Selected Statement": "height = tj3Get(handle, TJPARAM_JPEGHEIGHT);", "Function Input": {"data": {"value": "0x1108b40 \"0\\220\\020\\001\""}, "size": {"value": "17866816"}}, "Variable Values Before Statement": {"handle": "tjhandle", "TJPARAM_JPEGHEIGHT": "NULL"}, "Value After Statement Execution": "int", "Function Name": "tj3Get", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nGLOBAL(cjpeg_source_ptr)\njinit_read_targa(j_compress_ptr cinfo)\n{\n  tga_source_ptr source;\n\n  \n  source = (tga_source_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(tga_source_struct));\n  source->cinfo = cinfo;        \n  \n  source->pub.start_input = start_input_tga;\n  source->pub.finish_input = finish_input_tga;\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n  source->pub.max_pixels = 0;\n#endif\n\n", "Selected Statement": "if ((c = getc(infile)) == EOF)", "Function Input": {}, "Variable Values Before Statement": {"infile": "NULL"}, "Value After Statement Execution": "NULL", "Function Name": "getc", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nGLOBAL(cjpeg_source_ptr)\njinit_read_gif(j_compress_ptr cinfo)\n{\n  gif_source_ptr source;\n\n  \n  source = (gif_source_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(gif_source_struct));\n  source->cinfo = cinfo;        \n  \n  source->pub.start_input = start_input_gif;\n  source->pub.finish_input = finish_input_gif;\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n  source->pub.max_pixels = 0;\n#endif\n\n", "Selected Statement": "if ((c = getc(infile)) == EOF)", "Function Input": {}, "Variable Values Before Statement": {"infile": "NULL"}, "Value After Statement Execution": "NULL", "Function Name": "getc", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\n\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n  tjhandle handle = NULL;\n  unsigned char *dstBuf = NULL, *yuvBuf = NULL;\n  int width = 0, height = 0, jpegSubsamp, jpegColorspace, pfi;\n  \n  enum TJPF pixelFormats[NUMPF] =\n    { TJPF_BGR, TJPF_XRGB, TJPF_GRAY };\n#if defined(__has_feature) && __has_feature(memory_sanitizer)\n  char env[18] = \"JSIMD_FORCENONE=1\";\n\n  \n  putenv(env);\n#endif\n\n  if ((handle = tjInitDecompress()) == NULL)\n    goto bailout;\n\n  if (tjDecompressHeader3(handle, data, size, &width, &height, &jpegSubsamp,\n                          &jpegColorspace) < 0)\n    goto bailout;\n\n  \n  if (width < 1 || height < 1 || (uint64_t)width * height > 1048576)\n    goto bailout;\n\n  for (pfi = 0; pfi < NUMPF; pfi++) {\n    int pf = pixelFormats[pfi], flags = TJFLAG_LIMITSCANS, i, sum = 0;\n    int w = width, h = height;\n\n    \n    if (pfi == 0)\n      flags |= TJFLAG_BOTTOMUP | TJFLAG_FASTUPSAMPLE | TJFLAG_FASTDCT;\n    \n    else if (pfi == 1) {\n      w = (width + 3) / 4;\n      h = (height + 3) / 4;\n    }\n\n    if ((dstBuf = (unsigned char *)malloc(w * h * tjPixelSize[pf])) == NULL)\n      goto bailout;\n    if ((yuvBuf =\n         (unsigned char *)malloc(tjBufSizeYUV2(w, 1, h, jpegSubsamp))) == NULL)\n      goto bailout;\n\n    if (tjDecompressToYUV2(handle, data, size, yuvBuf, w, 1, h, flags) == 0 &&\n        tjDecodeYUV(handle, yuvBuf, 1, jpegSubsamp, dstBuf, w, 0, h, pf,\n                    flags) == 0) {\n      \n      for (i = 0; i < w * h * tjPixelSize[pf]; i++)\n        sum += dstBuf[i];\n    } else\n      goto bailout;\n\n    free(dstBuf);\n    dstBuf = NULL;\n    free(yuvBuf);\n    yuvBuf = NULL;\n\n    \n    if (sum > 255 * 1048576 * tjPixelSize[pf])\n      goto bailout;\n  }\n\nbailout:\n  free(dstBuf);\n  free(yuvBuf);\n  if (handle) tjDestroy(handle);\n", "Selected Statement": "if ((handle = tjInitDecompress()) == NULL)", "Function Input": {"data": {"value": "0x106b080 \"\""}, "size": {"value": "6760448"}}, "Variable Values Before Statement": {}, "Value After Statement Execution": "tjhandle", "Function Name": "tjInitDecompress", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\n\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n  tjhandle handle = NULL;\n  unsigned char *dstBuf = NULL, *yuvBuf = NULL;\n  int width = 0, height = 0, jpegSubsamp, pfi;\n  \n  enum TJPF pixelFormats[NUMPF] =\n    { TJPF_BGR, TJPF_XRGB, TJPF_GRAY };\n#if defined(__has_feature) && __has_feature(memory_sanitizer)\n  char env[18] = \"JSIMD_FORCENONE=1\";\n\n  \n  putenv(env);\n#endif\n\n  if ((handle = tj3Init(TJINIT_DECOMPRESS)) == NULL)\n    goto bailout;\n\n  \n  tj3DecompressHeader(handle, data, size);\n  width = tj3Get(handle, TJPARAM_JPEGWIDTH);\n  height = tj3Get(handle, TJPARAM_JPEGHEIGHT);\n  jpegSubsamp = tj3Get(handle, TJPARAM_SUBSAMP);\n\n  \n  if (width < 1 || height < 1 || (uint64_t)width * height > 1048576)\n    goto bailout;\n\n  tj3Set(handle, TJPARAM_SCANLIMIT, 500);\n\n  for (pfi = 0; pfi < NUMPF; pfi++) {\n    int w = width, h = height;\n    int pf = pixelFormats[pfi], i, sum = 0;\n\n    \n    if (!tj3Get(handle, TJPARAM_LOSSLESS)) {\n      tj3Set(handle, TJPARAM_BOTTOMUP, pfi == 0);\n      tj3Set(handle, TJPARAM_FASTUPSAMPLE, pfi == 0);\n      tj3Set(handle, TJPARAM_FASTDCT, pfi == 0);\n\n      \n      if (pfi == 1) {\n        tjscalingfactor sf = { 3, 4 };\n        tj3SetScalingFactor(handle, sf);\n        w = TJSCALED(width, sf);\n        h = TJSCALED(height, sf);\n      } else\n        tj3SetScalingFactor(handle, TJUNSCALED);\n    }\n\n    if ((dstBuf = (unsigned char *)malloc(w * h * tjPixelSize[pf])) == NULL)\n      goto bailout;\n    if ((yuvBuf =\n         (unsigned char *)malloc(tj3YUVBufSize(w, 1, h, jpegSubsamp))) == NULL)\n      goto bailout;\n\n    if (tj3DecompressToYUV8(handle, data, size, yuvBuf, 1) == 0 &&\n        tj3DecodeYUV8(handle, yuvBuf, 1, dstBuf, w, 0, h, pf) == 0) {\n      \n      for (i = 0; i < w * h * tjPixelSize[pf]; i++)\n        sum += dstBuf[i];\n    } else\n      goto bailout;\n\n    free(dstBuf);\n    dstBuf = NULL;\n    free(yuvBuf);\n    yuvBuf = NULL;\n\n    \n    if (sum > 255 * 1048576 * tjPixelSize[pf])\n      goto bailout;\n  }\n\nbailout:\n  free(dstBuf);\n  free(yuvBuf);\n  tj3Destroy(handle);\n", "Selected Statement": "width = tj3Get(handle, TJPARAM_JPEGWIDTH);", "Function Input": {"data": {"value": "0x1107b70 \"`\\200\\020\\001\""}, "size": {"value": "17862768"}}, "Variable Values Before Statement": {"handle": "tjhandle", "TJPARAM_JPEGWIDTH": "NULL"}, "Value After Statement Execution": "int", "Function Name": "tj3Get", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\n\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n  tjhandle handle = NULL;\n  unsigned char *srcBuf = NULL, *dstBuf = NULL, *yuvBuf = NULL;\n  int width = 0, height = 0, fd = -1, i, ti;\n  char filename[FILENAME_MAX] = { 0 };\n  struct test tests[NUMTESTS] = {\n    { TJPF_XBGR, TJSAMP_444, 100 },\n    { TJPF_XRGB, TJSAMP_422, 90 },\n    { TJPF_BGR, TJSAMP_420, 80 },\n    { TJPF_RGB, TJSAMP_411, 70 },\n    { TJPF_BGR, TJSAMP_GRAY, 60 },\n    { TJPF_GRAY, TJSAMP_GRAY, 50 }\n  };\n#if defined(__has_feature) && __has_feature(memory_sanitizer)\n  char env[18] = \"JSIMD_FORCENONE=1\";\n\n  \n  putenv(env);\n#endif\n\n  snprintf(filename, FILENAME_MAX, \"/tmp/libjpeg-turbo_compress_yuv_fuzz.XXXXXX\");\n  if ((fd = mkstemp(filename)) < 0 || write(fd, data, size) < 0)\n    goto bailout;\n\n  if ((handle = tj3Init(TJINIT_COMPRESS)) == NULL)\n    goto bailout;\n\n  for (ti = 0; ti < NUMTESTS; ti++) {\n    int sum = 0, pf = tests[ti].pf;\n    size_t dstSize = 0, maxBufSize;\n\n    \n    tj3Set(handle, TJPARAM_BOTTOMUP, ti == 0);\n    tj3Set(handle, TJPARAM_FASTDCT, ti == 1);\n    tj3Set(handle, TJPARAM_OPTIMIZE, ti == 4);\n    tj3Set(handle, TJPARAM_PROGRESSIVE, ti == 1 || ti == 3);\n    tj3Set(handle, TJPARAM_ARITHMETIC, ti == 2 || ti == 3);\n    tj3Set(handle, TJPARAM_NOREALLOC, 1);\n    tj3Set(handle, TJPARAM_RESTARTBLOCKS, ti == 3 || ti == 4 ? 4 : 0);\n\n    tj3Set(handle, TJPARAM_MAXPIXELS, 1048576);\n    \n    if ((srcBuf = tj3LoadImage8(handle, filename, &width, 1, &height,\n                                &pf)) == NULL)\n      continue;\n\n    maxBufSize = tj3JPEGBufSize(width, height, tests[ti].subsamp);\n    if ((dstBuf = (unsigned char *)malloc(maxBufSize)) == NULL)\n      goto bailout;\n    if ((yuvBuf =\n         (unsigned char *)malloc(tj3YUVBufSize(width, 1, height,\n                                               tests[ti].subsamp))) == NULL)\n      goto bailout;\n\n    tj3Set(handle, TJPARAM_SUBSAMP, tests[ti].subsamp);\n    tj3Set(handle, TJPARAM_QUALITY, tests[ti].quality);\n    if (tj3EncodeYUV8(handle, srcBuf, width, 0, height, pf, yuvBuf, 1) == 0 &&\n        tj3CompressFromYUV8(handle, yuvBuf, width, 1, height, &dstBuf,\n                            &dstSize) == 0) {\n      \n      for (i = 0; i < dstSize; i++)\n        sum += dstBuf[i];\n    }\n\n    free(dstBuf);\n    dstBuf = NULL;\n    free(yuvBuf);\n    yuvBuf = NULL;\n    tj3Free(srcBuf);\n    srcBuf = NULL;\n\n    \n    if (sum > 255 * maxBufSize)\n      goto bailout;\n  }\n\nbailout:\n  free(dstBuf);\n  free(yuvBuf);\n  tj3Free(srcBuf);\n  if (fd >= 0) {\n    close(fd);\n    if (strlen(filename) > 0) unlink(filename);\n  }\n  tj3Destroy(handle);\n", "Selected Statement": "if ((handle = tj3Init(TJINIT_COMPRESS)) == NULL)", "Function Input": {"data": {"value": "0x1108b70 \"`\\220\\020\\001\""}, "size": {"value": "17866864"}}, "Variable Values Before Statement": {"TJINIT_COMPRESS": "NULL"}, "Value After Statement Execution": "tjhandle", "Function Name": "tj3Init", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nvoid empty_log(int level, const char *msg, void *usrptr) {}\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tint fd, r;\n\tstruct crypt_device *cd = NULL;\n\tchar name[] = \"/tmp/test-script-fuzz.XXXXXX\";\n\n\tfd = mkostemp(name, O_RDWR | O_CREAT | O_EXCL | O_CLOEXEC);\n\tif (fd == -1)\n\t\terr(EXIT_FAILURE, \"mkostemp() failed\");\n\n\t\n\tif (ftruncate(fd, FILESIZE) == -1)\n\t\tgoto out;\n\n\tif (write_buffer(fd, data, size) != (ssize_t) size)\n\t\tgoto out;\n\n\tcrypt_set_log_callback(NULL, empty_log, NULL);\n\n\tif (crypt_init(&cd, name) == 0) {\n\t\tr = crypt_load(cd, CRYPT_LUKS1, NULL);\n\t\tif (r == 0)\n\t\t\tgoto out;\n\n\t\tr = crypt_load(cd, CRYPT_FVAULT2, NULL);\n\t\tif (r == 0)\n\t\t\tgoto out;\n\n\t\t(void) crypt_load(cd, CRYPT_BITLK, NULL);\n\t}\nout:\n\tcrypt_free(cd);\n\tclose(fd);\n\tunlink(name);\n", "Selected Statement": "fd = mkostemp(name, O_RDWR | O_CREAT | O_EXCL | O_CLOEXEC);", "Function Input": {}, "Variable Values Before Statement": {"name": "\"/tmp/test-script-fuzz.qF9OuM\""}, "Value After Statement Execution": "int", "Function Name": "mkostemp", "Project Information": "cryptsetup"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "}\n\nint device_alloc(struct crypt_device *cd, struct device **device, const char *path)\n{\n\tstruct device *dev;\n\tint r;\n\n\tr = device_alloc_no_check(&dev, path);\n\tif (r < 0)\n\t\treturn r;\n\n\tif (dev) {\n\t\tr = device_ready(cd, dev);\n\t\tif (!r) {\n\t\t\tdev->init_done = 1;\n\t\t} else if (r == -ENOTBLK) {\n\t\t\t\n\t\t} else if (r < 0) {\n\t\t\tfree(dev->path);\n\t\t\tfree(dev);\n\t\t\treturn -ENOTBLK;\n\t\t}\n\t}\n\n\t*device = dev;\n\treturn 0;\n", "Selected Statement": "r = device_alloc_no_check(&dev, path);", "Function Input": {}, "Variable Values Before Statement": {"path": "0x7fffffffddf0 \"/tmp/test-script-fuzz.o5sGzP\""}, "Value After Statement Execution": "int", "Function Name": "device_alloc_no_check", "Project Information": "cryptsetup"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "#include \"internal.h\"\n\nsize_t crypt_getpagesize(void)\n{\n\tlong r = sysconf(_SC_PAGESIZE);\n", "Selected Statement": "long r = sysconf(_SC_PAGESIZE);", "Function Input": {}, "Variable Values Before Statement": {"_SC_PAGESIZE": "NULL"}, "Value After Statement Execution": "4096", "Function Name": "sysconf", "Project Information": "cryptsetup"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "}\n\nvoid *CRYPTO_zalloc(size_t num, const char *file, int line)\n{\n    void *ret;\n\n    ret = CRYPTO_malloc(num, file, line);\n    if (ret != NULL)\n        memset(ret, 0, num);\n\n", "Selected Statement": "ret = CRYPTO_malloc(num, file, line);", "Function Input": {}, "Variable Values Before Statement": {"num": "320", "file": "0xb4aa24 \"crypto/context.c\"", "line": "int"}, "Value After Statement Execution": "VOID", "Function Name": "CRYPTO_malloc", "Project Information": "cryptsetup"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": " * for computation\n */\nOSSL_METHOD_STORE *ossl_method_store_new(OSSL_LIB_CTX *ctx)\n{\n    OSSL_METHOD_STORE *res;\n\n    res = OPENSSL_zalloc(sizeof(*res));\n    if (res != NULL) {\n        res->ctx = ctx;\n        if ((res->algs = ossl_sa_ALGORITHM_new()) == NULL\n            || (res->lock = CRYPTO_THREAD_lock_new()) == NULL\n            || (res->biglock = CRYPTO_THREAD_lock_new()) == NULL) {\n            ossl_method_store_free(res);\n            return NULL;\n        }\n    }\n    return res;\n", "Selected Statement": "if ((res->algs = ossl_sa_ALGORITHM_new()) == NULL", "Function Input": {}, "Variable Values Before Statement": {}, "Value After Statement Execution": "NULL", "Function Name": "ossl_sa_ALGORITHM_new", "Project Information": "cryptsetup"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "};\n\nOPENSSL_SA *ossl_sa_new(void)\n{\n    OPENSSL_SA *res = OPENSSL_zalloc(sizeof(*res));\n\n", "Selected Statement": "if (p[i] == NULL && (p[i] = alloc_node()) == NULL)", "Function Input": {}, "Variable Values Before Statement": {}, "Value After Statement Execution": "NULL", "Function Name": "alloc_node", "Project Information": "cryptsetup"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "} PROVIDER_CONF_GLOBAL;\n\nvoid *ossl_prov_conf_ctx_new(OSSL_LIB_CTX *libctx)\n{\n    PROVIDER_CONF_GLOBAL *pcgbl = OPENSSL_zalloc(sizeof(*pcgbl));\n\n    if (pcgbl == NULL)\n        return NULL;\n\n    pcgbl->lock = CRYPTO_THREAD_lock_new();\n    if (pcgbl->lock == NULL) {\n        OPENSSL_free(pcgbl);\n        return NULL;\n    }\n\n    return pcgbl;\n", "Selected Statement": "pcgbl->lock = CRYPTO_THREAD_lock_new();", "Function Input": {}, "Variable Values Before Statement": {}, "Value After Statement Execution": "NULL", "Function Name": "CRYPTO_THREAD_lock_new", "Project Information": "cryptsetup"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "}\n\nint LLVMFuzzerTestOneInput(const uint8_t* data, size_t size)\n{\n\tint fd, r = EXIT_FAILURE;\n\tstruct crypt_device *cd = NULL;\n\tchar name[] = \"/tmp/test-script-fuzz.XXXXXX\";\n\tstruct luks2_hdr_disk hdr_rw;\n\tsize_t modified_data_size;\n\n\t\n\tif (size >= sizeof(hdr_rw) && calculate_checksum((const char *)data, size, &hdr_rw))\n\t\tmodified_data_size = sizeof(hdr_rw);\n\telse\n\t\tmodified_data_size = 0;\n\n\t\n\tfd = mkostemp(name, O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC);\n\tif (fd == -1)\n\t\treturn r;\n\n\t\n\tif (ftruncate(fd, FILESIZE) == -1)\n\t\tgoto out;\n\n\tif (modified_data_size &&\n\t    write_buffer(fd, &hdr_rw, modified_data_size) != (ssize_t)modified_data_size)\n\t\tgoto out;\n\n\tif (write_buffer(fd, data + modified_data_size, size - modified_data_size) != (ssize_t)size)\n\t\tgoto out;\n\n\t\n\tif (crypt_init(&cd, name) == 0)\n\t\t(void)crypt_load(cd, CRYPT_LUKS2, NULL);\n\tcrypt_free(cd);\n\tr = 0;\nout:\n\tclose(fd);\n\tunlink(name);\n\n\treturn r;\n", "Selected Statement": "fd = mkostemp(name, O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC);", "Function Input": {"data": {"value": "0x1824d50 \"\""}}, "Variable Values Before Statement": {"name": "\"/tmp/test-script-fuzz.KU4VxQ\""}, "Value After Statement Execution": "int", "Function Name": "mkostemp", "Project Information": "cryptsetup"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\t\t\t             MIME_STATE_ANY_END body_end,\n\t\t\t             MIME_STATE_ERR_PRINT err_print,\n\t\t\t             void *context)\n{\n    MIME_STATE *state;\n\n    state = (MIME_STATE *) mymalloc(sizeof(*state));\n\n    \n    state->err_flags = 0;\n    state->body_offset = 0;\t\t\t\n    SET_MIME_STATE(state, MIME_STATE_PRIMARY,\n\t\t   MIME_CTYPE_TEXT, MIME_STYPE_PLAIN,\n\t\t   MIME_ENC_7BIT, MIME_ENC_7BIT);\n    state->output_buffer = vstring_alloc(100);\n    state->prev_rec_type = 0;\n    state->stack = 0;\n    state->token_buffer = vstring_alloc(1);\n    state->nesting_level = -1;\t\t\t\n\n    \n    state->static_flags = flags;\n    state->head_out = head_out;\n    state->head_end = head_end;\n    state->body_out = body_out;\n    state->body_end = body_end;\n    state->err_print = err_print;\n    state->app_context = context;\n", "Selected Statement": "state->output_buffer = vstring_alloc(100);", "Function Input": {}, "Variable Values Before Statement": {"100": "100"}, "Value After Statement Execution": "NULL", "Function Name": "vstring_alloc", "Project Information": "postfix"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\n\nssize_t is_header_buf(const char *str, ssize_t str_len)\n{\n    const unsigned char *cp;\n    int     state;\n    int     c;\n    ssize_t len;\n\n#define INIT\t\t0\n#define IN_CHAR\t\t1\n#define IN_CHAR_SPACE\t2\n#define CU_CHAR_PTR(x)\t((const unsigned char *) (x))\n\n    \n    for (len = 0, state = INIT, cp = CU_CHAR_PTR(str); ; cp++) {\n\tif (str_len != IS_HEADER_NULL_TERMINATED && str_len-- <= 0)\n\t    return (0);\n\tswitch (c = *cp) {\n\tdefault:\n\t    if (c == 0 || !ISASCII(c) || ISCNTRL(c))\n\t\treturn (0);\n\t    if (state == INIT)\n\t\tstate = IN_CHAR;\n\t    if (state == IN_CHAR) {\n\t\tlen++;\n\t\tcontinue;\n\t    }\n\t    return (0);\n\tcase ' ':\n\tcase '\\t':\n\t    if (state == IN_CHAR)\n\t\tstate = IN_CHAR_SPACE;\n\t    if (state == IN_CHAR_SPACE)\n\t\tcontinue;\n\t    return (0);\n\tcase ':':\n\t    return ((state == IN_CHAR || state == IN_CHAR_SPACE) ? len : 0);\n\t}\n    }\n    \n    return (0);\n", "Selected Statement": "for (len = 0, state = INIT, cp = CU_CHAR_PTR(str); /* see below */; cp++) {", "Function Input": {"str": {"value": "<optimized out>"}, "str_len": {"value": "<optimized out>"}}, "Variable Values Before Statement": {"str": "<optimized out>"}, "Value After Statement Execution": "0xfa6d75 \"\"", "Function Name": "CU_CHAR_PTR", "Project Information": "postfix"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\n\nTOK822 *tok822_cut_before(TOK822 *tp)\n{\n    TOK822 *prev = tp->prev;\n\n    if (prev) {\n\tprev->next = 0;\n\ttp->prev = 0;\n    }\n", "Selected Statement": "if ((result = action(tp)) != 0)", "Function Input": {}, "Variable Values Before Statement": {"tp": {"type": "0", "vstr": null, "prev": null, "next": null, "head": null, "tail": null, "owner": null}}, "Value After Statement Execution": "NULL", "Function Name": "action", "Project Information": "postfix"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\n\nVSTRING *quote_822_local_flags(VSTRING *dst, const char *mbox, int flags)\n{\n    const char *start;\t\t\t\n    const char *end;\t\t\t\n    const char *colon;\n\n    \n    if (mbox[0] == '@' && (colon = strchr(mbox, ':')) != 0)\n\tstart = colon + 1;\n    else\n\tstart = mbox;\n    if ((flags & QUOTE_FLAG_BARE_LOCALPART) != 0\n\t|| (end = strrchr(start, '@')) == 0)\n\tend = start + strlen(start);\n    if ((flags & QUOTE_FLAG_APPEND) == 0)\n\tVSTRING_RESET(dst);\n    if (is_822_dot_string(start, end, flags)) {\n\treturn (vstring_strcat(dst, mbox));\n    } else {\n\tvstring_strncat(dst, mbox, start - mbox);\n\tmake_822_quoted_string(dst, start, end, flags & QUOTE_FLAG_8BITCLEAN);\n\treturn (vstring_strcat(dst, end));\n    }\n", "Selected Statement": "|| (end = strrchr(start, '@')) == 0)", "Function Input": {"end": {"value": "<optimized out>"}, "flags": {"value": "<optimized out>"}}, "Variable Values Before Statement": {"start": "0xf5e2d0 \"[ ]\""}, "Value After Statement Execution": "<optimized out>", "Function Name": "strrchr", "Project Information": "postfix"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "static int ssh_known_hosts_read_entries(const char *match,\n                                        const char *filename,\n                                        struct ssh_list **entries)\n{\n    char line[MAX_LINE_SIZE];\n    size_t lineno = 0;\n    size_t len = 0;\n    FILE *fp;\n    int rc;\n\n    fp = fopen(filename, \"r\");\n    if (fp == NULL) {\n        char err_msg[SSH_ERRNO_MSG_MAX] = {0};\n        SSH_LOG(SSH_LOG_TRACE, \"Failed to open the known_hosts file '%s': %s\",\n                filename, ssh_strerror(errno, err_msg, SSH_ERRNO_MSG_MAX));\n        \n        return SSH_OK;\n    }\n\n    if (*entries == NULL) {\n        *entries = ssh_list_new();\n        if (*entries == NULL) {\n            fclose(fp);\n            return SSH_ERROR;\n        }\n    }\n\n    for (rc = known_hosts_read_line(fp, line, sizeof(line), &len, &lineno);\n         rc == 0;\n         rc = known_hosts_read_line(fp, line, sizeof(line), &len, &lineno)) {\n        struct ssh_knownhosts_entry *entry = NULL;\n        struct ssh_iterator *it = NULL;\n        char *p = NULL;\n\n        if (line[len] != '\\n') {\n            len = strcspn(line, \"\\n\");\n        }\n        line[len] = '\\0';\n\n        \n        for (p = line; isspace((int)p[0]); p++);\n\n        \n        if (p[0] == '\\0' || p[0] == '#') {\n            continue;\n        }\n\n        \n        if (p[0] == '@') {\n            continue;\n        }\n\n        rc = ssh_known_hosts_parse_line(match,\n                                        line,\n                                        &entry);\n        if (rc == SSH_AGAIN) {\n            continue;\n        } else if (rc != SSH_OK) {\n            goto error;\n        }\n\n        \n        for (it = ssh_list_get_iterator(*entries);\n             it != NULL;\n             it = it->next) {\n            struct ssh_knownhosts_entry *entry2;\n            int cmp;\n            entry2 = ssh_iterator_value(struct ssh_knownhosts_entry *, it);\n            cmp = ssh_known_hosts_entries_compare(entry, entry2);\n            if (cmp == 0) {\n                ssh_knownhosts_entry_free(entry);\n                entry = NULL;\n                break;\n            }\n        }\n        if (entry != NULL) {\n            ssh_list_append(*entries, entry);\n        }\n    }\n\n    fclose(fp);\n    return SSH_OK;\nerror:\n    fclose(fp);\n    return SSH_ERROR;\n", "Selected Statement": "rc = known_hosts_read_line(fp, line, sizeof(line), &len, &lineno)) {", "Function Input": {}, "Variable Values Before Statement": {"fp": "NULL", "line": "\"**\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\\\\244\\375\\367\\377\\177\\000\\0000I\\374\\367\\377\\177\\000\\000\\017\\204\\035\\346\\000\\000\\000\\000X\\032@\\000\\000\\000\\000\\0000 \\303\\367\\377\\177\\000\\000\\304k\\303\\367\\377\\177\\000\\000\\212\\250\\375\\367\\377\\177\\000\\000\\030\\004\\000\\000\\000\\000\\000\\000\\240^\\304\\367\\377\\177\\000\\0000I\\374\\367\\377\\177\\000\\000\\b\\317\\377\\377\\377\\177\\000\\000\\004\\317\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\240^\\304\\367\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000p\\200\\303\\367\\377\\177\\000\\000\\3436@\\000\\000\\000\\000\\000\\017\\204\\035\\346\\000\\000\\000\\000\\020v\\230\\003\\000\\000\\000\\000\\004\\317\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\320\\317\\377\\377\\377\\177\\000\\000X\\032@\\000\\000\\000\\000\\000\\300\\317\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\250O\\374\\367\\377\\177\\000\\000\\b\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\017\\204\\035\\346\\000\\000\\000\\000\\370\\344\\377\\367\\377\\177\\000\\000h\\320\\377\\377\\377\\177\\000\\000\\3436@\\000\\000\\000\\000\\000\\300\\317\\377\\377\\377\\177\\000\\000\\320\\317\\377\\377\\377\\177\\000\\000\\361\\261\\375\\367\\377\\177\\000\\000\\006\\000\\000\\000\\000\\000\\000\\0000 \\303\\367\\377\\177\\000\\000\\005\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\001\\000\\000\\000\\000\\000\\000\\000\\220\\341\\377\\367\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\0000 \\303\\367\\377\\177\\000\\000\\220\\341\\377\\367\\377\\177\\000\\000\\370\\344\\377\\367\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\001\\000\\000\\000\\000\\000\\000\\000\\377\\377\\377\\377\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\260\\342\\303\\367\\377\\177\\000\\0000I\\374\\367\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\\\\244\\375\\367\\377\\177\\000\\0000I\\374\\367\\377\\177\\000\\000\\366#\\316 \\000\\000\\000\\000\\030\\017@\\000\\000\\000\\000\\0000 \\303\\367\\377\\177\\000\\000,c\\303\\367\\377\\177\\000\\000\\212\\250\\375\\367\\377\\177\\000\\000\\362\\001\\000\\000\\000\\000\\000\\000\\240^\\304\\367\\377\\177\\000\\0000I\\374\\367\\377\\177\\000\\000\\b\\321\\377\\377\\377\\177\\000\\000\\004\\321\\377\\377\\377\\177\\000\\000>|\\376\\367\\377\\177\\000\\000\\240^\\304\\367\\377\\177\\000\\000\\240\\332\\377\\377\\377\\177\\000\\000\\260\\333\\377\\377\\377\\177\\000\\000p\\200\\303\\367\\377\\177\\000\\000e4@\\000\\000\\000\\000\\000\\366#\\316 \\000\\000\\000\\000\\2178\\203\\000\\000\\000\\000\\000\\004\\321\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\377\\177\\000\\000\\320\\321\\377\\377\\377\\177\\000\\000\\030\\017@\\000\\000\\000\\000\\000\\300\\321\\377\\377\\377\\177\\000\\0000I\\374\\367\\000\\000\\000\\000\\250O\\374\\367\\377\\177\\000\\000\\b\\000\\000\\000\\000\\000\\000\\0000 \\303\\367\\377\\177\\000\\000\\240^\\304\\367\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\006\\005\\000\\000\\000\\000\\000\\000\\366#\\316 \\000\\000\\000\\000\\370\\344\\377\\367\\377\\177\\000\\000h\\322\\377\\377\\377\\177\\000\\000e4@\\000\\000\\000\\000\\000\\300\\321\\377\\377\\377\\177\\000\\000\\320\\321\\377\\377\\377\\177\\000\\000\\361\\261\\375\\367\\377\\177\\000\\000\\006\\000\\000\\000\\000\\000\\000\\0000 \\303\\367\\377\\177\\000\\000\\005\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\001\\000\\000\\000\\000\\000\\000\\000\\220\\341\\377\\367\\377\\177\\000\\000e\\000\\205\\000\\242\\000\\036\\0000 \\303\\367\\377\\177\\000\\000\\220\\341\\377\\367\\377\\177\\000\\000\\370\\344\\377\\367\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\373\\250\\275YEe\\325?\\001\\000\\000\\000\\000\\000\\000\\000\\377\\377\\377\\377\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000 \\257\\303\\367\\377\\177\\000\\0000I\\374\\367\\377\\177\\000\\000\\000NEW   \\000INFO: li\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\210b\\202\\000\\000\\000\\000\\000P\\336\\377\\377\\377\\177\\000\\000\\300\\270%\\001\\000\\000\\000\\000\\000p\\205\\000\\000\\000\\000\\000\\320Q%\\001\\000\\000\\000\\000P3%\\001\\000\\000\\000\\000\\227\\001\\376\\367\\377\\177\\000\\000\\005\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\370\\344\\377\\367\\377\\177\\000\\000 \\257\\303\\367\\377\\177\\000\\000\\260\\334\\377\\377\\377\\177\\000\\000>|\\376\\367\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\004\\000\\000\\000\\000\\000\\000\\000`\\271%\\001\\000\\000\\000\\000@\\271%\\001\\000\\000\\000\\000 \\335\\377\\377\\377\\177\\000\\000\\003\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\240\\321\\341\\367\\377\\177\\000\\000`\\330\\377\\377\\377\\177\\000\\000\\200\\330\\377\\377\\377\\177\\000\\000\\020\\333\\377\\377\\377\\177\\000\\000\\000\\332\\377\\377\\377\\177\\000\\000x\\000\\000\\000\\000\\000\\000\\000\\346\\257\\312\\367\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\377\\377\\377\\377\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\022\\333\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\377\\377\\377\\377\\377\\377\\377\\377\\000\\000\\000\\000\\000\\000\\000\\000\\001\\000\\000\\000\\000\\000\\000\\000\\020\\000\\000\\000\\377\\177\\000\\000,\\000\\000\\000\\000\\000\\000\\000 \\321\\341\\367\\377\\177\\000\\000\\000\\000\\000\\000\\377\\177\\000\\000\\002\\000\\000\\000\\377\\177\\000\\000\\022\\333\\377\\377\\377\\177\\000\\000\\002\\000\\000\\000\\000\\000\\000\\000\\002\\000\\000\\000\\377\\177\\000\\000\\000\\000\\000\\000\\a\\000\\000\\000\\240\\310\\341\\367\\377\\177\\000\\000h\\r\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\020\\333\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\262\\333\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\377\\377\\377\\377\\377\\377\\377\\377\\000\\000\\000\\000\\000\\000\\000\\000\\001\\000\\000\\000\\000\\000\\000\\000\\240\\321\\341\\367\\377\\177\\000\\000\\220\\331\\377\\377\\377\\177\\000\\000\\260\\331\\377\\377\\377\\177\\000\\000@\\334\\377\\377\\377\\177\\000\\0000\\333\\377\\377\\377\\177\\000\\000x\\000\\000\\000\\000\\000\\000\\000 \\000\\000\\0000\\000\\000\\000\\000\\333\\377\\377\\377\\177\\000\\000 \\332\\377\\377\\377\\177\\000\\000\\240\\310\\341\\367\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000B\\334\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\377\\377\\377\\377\\377\\377\\377\\377\\000\\000\\000\\000\\000\\000\\000\\000\\001\\000\\000\\000\\000\\000\\000\\000\\020\\000\\000\\000\\000\\000\\000\\000\\021\\000\\000\\000\\000\\000\\000\\000 \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\377\\177\\000\\000\\002\\000\\000\\000\\000\\000\\000\\000B\\334\\377\\377\\377\\177\\000\\000\\240\\321\\341\\367\\377\\177\\000\\000P\\332\\377\\377\\377\\177\\000\\000p\\332\\377\\377\\377\\177\\000\\000x\\234r\\000\\000\\000\\000\\000\\360\\333\\377\\377\\377\\177\\000\\000d\\000\\000\\000\\000\\000\\000\\000\\346\\257\\312\\367\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\017\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\210\\234r\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\377\\377\\377\\377\\377\\377\\377\\377\\000\\000\\000\\000\\000\\000\\000\\000\\001\\000\\000\\000\\000\\000\\000\\000\\n\\000\\000\\000\\000\\000\\000\\000=\\000\\000\\000\\000\\000\\000\\000 \\000\\000\\0000\\000\\000\\000\\017\\000\\000\\000\\377\\177\\000\\000\\002\\000\\000\\000\\377\\177\\000\\000\\210\\234r\\000\\000\\000\\000\\000\\021\\000\\000\\000\\000\\000\\000\\000\\021\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\a\\000\\000\\000\\240\\310\\341\\367\\377\\177\\000\\000h\\r\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\207\\234r\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\002\\000\\000\\000\\000\\000\\000\\000\\356\\000\\000\\000\\000\\000\\000\\200\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\002\\000\\000\\000\\000\\000\\000\\000\\030\\000\\000\\0000\\000\\000\\000\\320\\334\\377\\377\\377\\177\\000\\000\\020\\334\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000=0.\\n\\n\\000CustomCros\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\002\\000\\000\\000\\000\\000\\000\\000\\356\\000\\000\\000\\000\\000\\000\\200\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\002\\000\\000\\000\\000\\000\\000\\000\\356\\000\\000\\000\\000\\000\\000\\200\\000\\000\\000\\000\\000\\000\\000\\000\\000\\246\\226\\300\\tx\\233\\355\\002\\000\\000\\000\\000\\000\\000\\000\\300\\334\\377\\377\\377\\177\\000\\000\\300\\025\\342\\367\\377\\177\\000\\000\\206\\340o\\000\\000\\000\\000\\000\\200\\335\\377\\377\\377\\177\\000\\000$\\255\\312\\367\\377\\177\\000\\000\\000\\020\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\200\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\020\\000\\000\\000\\000\\000\\000\\000\\246\\226\\300\\tx\\233\\355\\002\\000\\000\\000\\000\\000\\000\\000 \\335\\377\\377\\377\\177\\000\\000\\300\\025\\342\\367\\377\\177\\000\\000\\305\\276o\\000\\000\\000\\000\\000\\340\\335\\377\\377\\377\\177\\000\\000$\\255\\312\\367\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\246\\226\\300\\tx\\233\\355\\002\\000\\000\\000\\000\\000\\000\\000`\\335\\377\\377\\377\\177\\000\\000\\300\\025\\342\\367\\377\\177\\000\\000\\311\\263o\\000\\000\\000\\000\\000 \\336\\377\\377\\377\\177\\000\\000$\\255\\312\\367\\a\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\377\\177\\000\\0007\\333\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\0007\\333\\377\\377\\377\\177\\000\\000\\200\\330\\377\\377\\377\\1772c\\000\\246\\226\\300\\tx\\233\\355 \\333\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\027\\000\\000\\000\\000\\000\\000\\000\\200\\330\\377\\377\\377\\177\\000\\000\\020\\333\\377\\377\\377\\177\\000\\000\\000\\332\\377\\377\\377\\177\\000\\000 \\333\\377\\377\\377\\177\\000\\000\\232\\377\\313\\367\\377\\177\\000\\000\\004\\331\\377\\377\\377\\177\\000\\000p\\331\\377\\377\\377\\177\\000\\000\\001\\200\\255\\373\\000\\000\\000\\000 \\333\\377\\377\\377\\177\\000\\000 \\333\\377\\377\\377\\177\\000\\000 \\333\\377\\377\\377\\177\\000\\000 \\333\\377\\377\\377\\177\\000\\000\\\"\\333\\377\\377\\377\\177\\000\\0007\\333\\377\\377\\377\\177\\000\\000 \\333\\377\\377\\377\\177\\000\\0007\\333\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\260\\333\\377\\377\\200\\000\\000\\000\\240\\332\\377\\377\\377\\177\\000\\000\\000\\000\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\300\\025\\342\\367\\377\\177\\000\\000\\020\\332\\377\\377\\377\\177\\000\\000\\377\\377\\377\\377\\377\\377\\377\\377\\000\\000\\000\\000\\000\\000\\000\\000P\\334\\377\\377\\377\\177\\000\\000g\\334\\377\\377\\377\\177\\000\\000\\377\\377\\377\\377\\377\\177\\000\\000g\\334\\377\\377\\377\\177\\000\\000\\260\\331\\377\\377\\377\\17711\\240\\321\\341\\367\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\027\\000\\000\\000\\000\\000\\000\\000\\260\\331\\377\\377\\377\\177\\000\\000@\\334\\377\\377\\377\\177\\000\\0000\\333\\377\\377\\377\\177\\000\\000P\\334\\377\\377\\377\\177\\000\\000\\232\\377\\313\\367\\377\\177\\000\\0000\\000\\000\\000\\000\\000\\000\\0000\\000\\000\\000\\000\\000\\000\\000\\026\\000\\000\\000\\000\\000\\000\\000\\000\\246\\226\\300\\tx\\233\\355,\\000\\000\\000\\000\\000\\000\\000\\377\\377\\377\\377\\377\\377\\377\\377 \\333\\377\\377\\377\\177\\000\\000 \\333\\377\\377\\377\\177\\000\\000\\210\\334\\377\\377\\377\\177\\000\\000\\020\\333\\377\\377\\377\\177\\000\\000 \\335\\377\\377\\377\\177\\000\\000\\037\\336\\377\\377\\377\\177\\000\\000(\\000\\000\\0000\\000\\000\\000\\037\\336\\377\\377\\377\\177\\000\\000p\\332\\377\\377\\377\\17761\\000\\246\\226\\300\\tx\\233\\355 \\335\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\377\\000\\000\\000\\000\\000\\000\\000p\\332\\377\\377\\377\\177\\000\\000x\\234r\\000\\000\\000\\000\\000\\360\\333\\377\\377\\377\\177\\000\\000 \\335\\377\\377\\377\\177\\000\\000\\363\\305\\314\\367\\377\\177\\000\\000\\360'&\\001\\000\\000\\000\\000\\340\\v\\342\\367\\377\\177\\000\\000\\a\\000\\000\\000\\000\\000\\000\\000\\016\\\"%\\001\\000\\000\\000\\000\\000\\020\\000\\000\\000\\000\\000\\000c\\000\\000\\000\\377\\177\\000\\000\\b(%\\001\\000\\000\\000\\0000\\020\\000\\000\\000\\000\\000\\000@\\000\\000\\000\\000\\000\\000\\000\\001\\001\\000\\000p\\000\\000\\000\\b\\000\\000\\000\\000\\000\\000\\000\\001\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000|\\000\\000\\000w\\000\\000\\000o\\000\\000\\000c\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000@\\000\\000\\000\\200\\000\\000\\000\\377\\000\\000\\000\\000\\000\\000\\000\\000\\020\\000\\000\\000\\000\\000\\000\\200\\v\\342\\367\\377\\177\\000\\000h\\r\\000\\000\\000\\000\\000\\000\\002\\000\\000\\000\\000\\000\\000\\000\\000(&\\001\\000\\000\\000\\000\\0008&\\001\\000\\000\\000\\000\\000\\020\\000\\000\\000\\000\\000\\000\\000\\020\\000\\000\\000\\000\\000\\000p\\276%\\001\\000\\000\\000\\000\\035]\\313\\367\\377\\177\\000\\000<\\000\\000\\000\\000\\000\\000\\000.\\030\\236\\000\\000\\000\\000\\000\\001\\000\\000\\000\\000\\000\\000\\000\\244\\201\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\020\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\236\\341\\321e\\000\\000\\000\\000\\2376\\373\\036\\000\\000\\000\\000\\236\\341\\321e\\000\\000\\000\\000\\2376\\373\\036\\000\\000\\000\\000\\236\\341\\321e\\000\\000\\000\\000\\2376\\373\\036\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\266\\001\\000\\000\\000\\000\\000\\000\\213\\256\\314\\367\\377\\177\\000\\000p\\276%\\001\\000\\000\\000\\000\\344\\\"\\324\\367\\377\\177\\000\\000\\322\\0259\\001\\000\\000\\000\\000\\002\\000\\000\\000\\000\\000\\000\\000\\000(&\\001\\000\\000\\000\\000\\002\\000\\000\\000\\000\\000\\000\\000p\\276%\\001\\000\\000\\000\\000\\000\\246\\226\\300\\tx\\233\\355`\\334\\377\\377\\377\\177\\000\\000x\\314P\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000(\\320$\\001\\000\\000\\000\\000`\\334\\377\\377\\377\\177\\000\\000P3%\\001\\000\\000\\000\\000(\\320$\\001\\000\\000\\000\\000\\240\\334\\377\\377\\377\\177\\000\\000\\035\\366L\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\240\\324\\341\\367\\377\\177\\000\\000p\\276%\\001\\002\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\240\\334\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\""}, "Value After Statement Execution": "int", "Function Name": "known_hosts_read_line", "Project Information": "libssh"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "}\n\nstruct ssh_list *ssh_list_new(void)\n{\n    struct ssh_list *ret = malloc(sizeof(struct ssh_list));\n    if (ret == NULL) {\n        return NULL;\n    }\n    ret->root = ret->end = NULL;\n    return ret;\n", "Selected Statement": "struct ssh_list *ret = malloc(sizeof(struct ssh_list));", "Function Input": {}, "Variable Values Before Statement": {}, "Value After Statement Execution": "NULL", "Function Name": "malloc", "Project Information": "libssh"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": " * @returns A buffer containing the decoded string, NULL if something went\n *          wrong (e.g. incorrect char).\n */\nssh_buffer base64_to_bin(const char *source) {\n  ssh_buffer buffer = NULL;\n  unsigned char block[3];\n  char *base64;\n  char *ptr;\n  size_t len;\n  int equals;\n\n  base64 = strdup(source);\n  if (base64 == NULL) {\n    return NULL;\n  }\n  ptr = base64;\n\n  \n  equals = get_equals(ptr);\n  if (equals > 2) {\n    SAFE_FREE(base64);\n    return NULL;\n  }\n\n  buffer = ssh_buffer_new();\n  if (buffer == NULL) {\n    SAFE_FREE(base64);\n    return NULL;\n  }\n  \n  ssh_buffer_set_secure(buffer);\n\n  len = strlen(ptr);\n  while (len > 4) {\n    if (_base64_to_bin(block, ptr, 3) < 0) {\n      goto error;\n    }\n    if (ssh_buffer_add_data(buffer, block, 3) < 0) {\n      goto error;\n    }\n    len -= 4;\n    ptr += 4;\n  }\n\n  \n  switch (len) {\n    \n    case 4:\n      if (equals != 0) {\n        goto error;\n      }\n      if (_base64_to_bin(block, ptr, 3) < 0) {\n        goto error;\n      }\n      if (ssh_buffer_add_data(buffer, block, 3) < 0) {\n        goto error;\n      }\n      SAFE_FREE(base64);\n\n      return buffer;\n    \n    case 2:\n      if (equals != 2){\n        goto error;\n      }\n\n      if (_base64_to_bin(block, ptr, 1) < 0) {\n        goto error;\n      }\n      if (ssh_buffer_add_data(buffer, block, 1) < 0) {\n        goto error;\n      }\n      SAFE_FREE(base64);\n\n      return buffer;\n    \n    case 3:\n      if (equals != 1) {\n        goto error;\n      }\n      if (_base64_to_bin(block, ptr, 2) < 0) {\n        goto error;\n      }\n      if (ssh_buffer_add_data(buffer,block,2) < 0) {\n        goto error;\n      }\n      SAFE_FREE(base64);\n\n      return buffer;\n    default:\n      \n      goto error;\n  }\n\nerror:\n  SAFE_FREE(base64);\n  SSH_BUFFER_FREE(buffer);\n  return NULL;\n", "Selected Statement": "base64 = strdup(source);", "Function Input": {"source": {"value": "0x2 <error: Cannot access memory at address 0x2>"}}, "Variable Values Before Statement": {"source": "0x1262d90 \"\""}, "Value After Statement Execution": "0x1262e10 \"\"", "Function Name": "strdup", "Project Information": "libssh"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": " * @return A newly initialized SSH buffer, NULL on error.\n */\nstruct ssh_buffer_struct *ssh_buffer_new(void)\n{\n    struct ssh_buffer_struct *buf = NULL;\n    int rc;\n\n    buf = calloc(1, sizeof(struct ssh_buffer_struct));\n    if (buf == NULL) {\n        return NULL;\n    }\n\n    \n    rc = ssh_buffer_allocate_size(buf, 64 - 1);\n    if (rc != 0) {\n        SAFE_FREE(buf);\n        return NULL;\n    }\n    buffer_verify(buf);\n\n    return buf;\n", "Selected Statement": "rc = ssh_buffer_allocate_size(buf, 64 - 1);", "Function Input": {"buf": {"value": null}}, "Variable Values Before Statement": {"buf": {"secure": "false", "used": "0", "allocated": "64", "pos": "0", "data": "0x136cb50 \"\\360\\3136\\001\""}}, "Value After Statement Execution": "int", "Function Name": "ssh_buffer_allocate_size", "Project Information": "libssh"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": " * @return               The newly allocated string, NULL on error.\n */\nstruct ssh_string_struct *ssh_string_new(size_t size)\n{\n    struct ssh_string_struct *str = NULL;\n\n    if (size > STRING_SIZE_MAX) {\n        errno = EINVAL;\n        return NULL;\n    }\n\n    str = malloc(sizeof(struct ssh_string_struct) + size);\n    if (str == NULL) {\n        return NULL;\n    }\n\n    str->size = htonl(size);\n    str->data[0] = 0;\n\n    return str;\n", "Selected Statement": "str = malloc(sizeof(struct ssh_string_struct) + size);", "Function Input": {}, "Variable Values Before Statement": {}, "Value After Statement Execution": {"size": "19580432", "data": "\"\""}, "Function Name": "malloc", "Project Information": "libssh"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "}\n\nstatic int write_rsa_hostkey(const char *rsakey_path)\n{\n    FILE *fp = NULL;\n    size_t nwritten;\n\n    fp = fopen(rsakey_path, \"wb\");\n    if (fp == NULL) {\n        return -1;\n    }\n\n    nwritten = fwrite(kRSAPrivateKeyPEM, 1, strlen(kRSAPrivateKeyPEM), fp);\n    fclose(fp);\n\n    if (nwritten != strlen(kRSAPrivateKeyPEM)) {\n        return -1;\n    }\n\n    return 0;\n}\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n    int socket_fds[2] = {-1, -1};\n    ssize_t nwritten;\n    bool no = false;\n    const char *env = NULL;\n    int rc;\n\n    \n    struct session_data_struct sdata = {\n        .channel       = NULL,\n        .auth_attempts = 0,\n        .authenticated = false,\n    };\n\n    struct ssh_server_callbacks_struct server_cb = {\n        .userdata = &sdata,\n        .auth_none_function = auth_none,\n        .channel_open_request_session_function = channel_open,\n    };\n\n    \n    if (size > 219264) {\n        return -1;\n    }\n\n    \n", "Selected Statement": "fp = fopen(rsakey_path, \"wb\");", "Function Input": {}, "Variable Values Before Statement": {"rsakey_path": "0x72c8f4 \"/tmp/libssh_fuzzer_private_key\"", "\"wb\"": "\"wb\""}, "Value After Statement Execution": "NULL", "Function Name": "fopen", "Project Information": "libssh"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "    return s;\n}\n\nssh_bind ssh_bind_new(void) {\n    ssh_bind ptr;\n\n    ptr = calloc(1, sizeof(struct ssh_bind_struct));\n    if (ptr == NULL) {\n        return NULL;\n    }\n    ptr->bindfd = SSH_INVALID_SOCKET;\n    ptr->bindport = 22;\n    ptr->common.log_verbosity = 0;\n\n    return ptr;\n", "Selected Statement": "ptr = calloc(1, sizeof(struct ssh_bind_struct));", "Function Input": {}, "Variable Values Before Statement": {"1": "1"}, "Value After Statement Execution": "ssh_bind", "Function Name": "calloc", "Project Information": "libssh"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": " * @returns             A new ssh_session pointer, NULL on error.\n */\nssh_session ssh_new(void)\n{\n    ssh_session session;\n    char *id = NULL;\n    int rc;\n\n    session = calloc(1, sizeof (struct ssh_session_struct));\n    if (session == NULL) {\n        return NULL;\n    }\n\n    session->next_crypto = crypto_new();\n    if (session->next_crypto == NULL) {\n        goto err;\n    }\n\n    session->socket = ssh_socket_new(session);\n    if (session->socket == NULL) {\n        goto err;\n    }\n\n    session->out_buffer = ssh_buffer_new();\n    if (session->out_buffer == NULL) {\n        goto err;\n    }\n\n    session->in_buffer = ssh_buffer_new();\n    if (session->in_buffer == NULL) {\n        goto err;\n    }\n\n    session->out_queue = ssh_list_new();\n    if (session->out_queue == NULL) {\n        goto err;\n    }\n\n    session->alive = 0;\n    session->auth.supported_methods = 0;\n    ssh_set_blocking(session, 1);\n    session->maxchannel = FIRST_CHANNEL;\n\n    session->agent = ssh_agent_new(session);\n    if (session->agent == NULL) {\n        goto err;\n    }\n\n    \n    session->opts.StrictHostKeyChecking = 1;\n    session->opts.port = 22;\n    session->opts.fd = -1;\n    session->opts.compressionlevel = 7;\n    session->opts.nodelay = 0;\n    session->opts.identities_only = false;\n    session->opts.control_master = SSH_CONTROL_MASTER_NO;\n\n    session->opts.flags = SSH_OPT_FLAG_PASSWORD_AUTH |\n                          SSH_OPT_FLAG_PUBKEY_AUTH |\n                          SSH_OPT_FLAG_KBDINT_AUTH |\n                          SSH_OPT_FLAG_GSSAPI_AUTH;\n\n    session->opts.exp_flags = 0;\n\n    session->opts.identity = ssh_list_new();\n    if (session->opts.identity == NULL) {\n        goto err;\n    }\n    session->opts.identity_non_exp = ssh_list_new();\n    if (session->opts.identity_non_exp == NULL) {\n        goto err;\n    }\n\n    session->opts.certificate = ssh_list_new();\n    if (session->opts.certificate == NULL) {\n        goto err;\n    }\n    session->opts.certificate_non_exp = ssh_list_new();\n    if (session->opts.certificate_non_exp == NULL) {\n        goto err;\n    }\n    \n\n    id = strdup(\"%d/id_ed25519\");\n    if (id == NULL) {\n        goto err;\n    }\n\n    rc = ssh_list_append(session->opts.identity_non_exp, id);\n    if (rc == SSH_ERROR) {\n        goto err;\n    }\n\n#ifdef HAVE_ECC\n    id = strdup(\"%d/id_ecdsa\");\n    if (id == NULL) {\n        goto err;\n    }\n    rc = ssh_list_append(session->opts.identity_non_exp, id);\n    if (rc == SSH_ERROR) {\n        goto err;\n    }\n#endif\n\n    id = strdup(\"%d/id_rsa\");\n    if (id == NULL) {\n        goto err;\n    }\n    rc = ssh_list_append(session->opts.identity_non_exp, id);\n    if (rc == SSH_ERROR) {\n        goto err;\n    }\n\n    \n    session->session_state = SSH_SESSION_STATE_NONE;\n    session->pending_call_state = SSH_PENDING_CALL_NONE;\n    session->packet_state = PACKET_STATE_INIT;\n    session->dh_handshake_state = DH_STATE_INIT;\n    session->global_req_state = SSH_CHANNEL_REQ_STATE_NONE;\n\n    session->auth.state = SSH_AUTH_STATE_NONE;\n    session->auth.service_state = SSH_AUTH_SERVICE_NONE;\n\n    return session;\n\nerr:\n    free(id);\n    ssh_free(session);\n    return NULL;\n", "Selected Statement": "session->next_crypto = crypto_new();", "Function Input": {}, "Variable Values Before Statement": {}, "Value After Statement Execution": "NULL", "Function Name": "crypto_new", "Project Information": "libssh"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "}\n\nstruct ssh_crypto_struct *crypto_new(void)\n{\n    struct ssh_crypto_struct *crypto;\n\n    crypto = malloc(sizeof(struct ssh_crypto_struct));\n    if (crypto == NULL) {\n        return NULL;\n    }\n    ZERO_STRUCTP(crypto);\n    return crypto;\n", "Selected Statement": "crypto = malloc(sizeof(struct ssh_crypto_struct));", "Function Input": {}, "Variable Values Before Statement": {}, "Value After Statement Execution": {"shared_secret": null, "dh_ctx": null, "dh_pmin": "0", "dh_pn": "0", "dh_pmax": "0", "ecdh_privkey": null, "ecdh_client_pubkey": null, "ecdh_server_pubkey": null, "curve25519_privkey": "\"\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\"", "curve25519_client_pubkey": "\"\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\"", "curve25519_server_pubkey": "\"\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\"", "dh_server_signature": null, "session_id_len": "0", "session_id": null, "digest_len": "0", "secret_hash": null, "encryptIV": null, "decryptIV": null, "decryptkey": null, "encryptkey": null, "encryptMAC": null, "decryptMAC": null, "hmacbuf": "\"\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\"", "in_cipher": null, "out_cipher": null, "in_hmac": "0", "out_hmac": "0", "in_hmac_etm": "false", "out_hmac_etm": "false", "server_pubkey": null, "do_compress_out": "0", "do_compress_in": "0", "delayed_compress_in": "0", "delayed_compress_out": "0", "compress_out_ctx": null, "compress_in_ctx": null, "server_kex": null, "client_kex": null, "kex_methods": [{"type_category": "string", "concrete_type": "NULL"}, {"type_category": "string", "concrete_type": "NULL"}, {"type_category": "string", "concrete_type": "NULL"}, {"type_category": "string", "concrete_type": "NULL"}, {"type_category": "string", "concrete_type": "NULL"}, {"type_category": "string", "concrete_type": "NULL"}, {"type_category": "string", "concrete_type": "NULL"}, {"type_category": "string", "concrete_type": "NULL"}, {"type_category": "string", "concrete_type": "NULL"}, {"type_category": "string", "concrete_type": "NULL"}], "kex_type": "0", "digest_type": "0", "used": "0"}, "Function Name": "malloc", "Project Information": "libssh"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": " * \\brief creates a new Socket object\n */\nssh_socket ssh_socket_new(ssh_session session)\n{\n    ssh_socket s;\n\n    s = calloc(1, sizeof(struct ssh_socket_struct));\n    if (s == NULL) {\n        ssh_set_error_oom(session);\n        return NULL;\n    }\n    s->fd = SSH_INVALID_SOCKET;\n    s->last_errno = -1;\n    s->fd_is_socket = 1;\n    s->session = session;\n    s->in_buffer = ssh_buffer_new();\n    if (s->in_buffer == NULL) {\n        ssh_set_error_oom(session);\n        SAFE_FREE(s);\n        return NULL;\n    }\n    s->out_buffer=ssh_buffer_new();\n    if (s->out_buffer == NULL) {\n        ssh_set_error_oom(session);\n        SSH_BUFFER_FREE(s->in_buffer);\n        SAFE_FREE(s);\n        return NULL;\n    }\n    s->read_wontblock = 0;\n    s->write_wontblock = 0;\n    s->data_except = 0;\n    s->poll_handle = NULL;\n    s->state=SSH_SOCKET_NONE;\n    return s;\n", "Selected Statement": "s = calloc(1, sizeof(struct ssh_socket_struct));", "Function Input": {}, "Variable Values Before Statement": {"1": "1"}, "Value After Statement Execution": "ssh_socket", "Function Name": "calloc", "Project Information": "libssh"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "    }\n}\n\nssh_agent ssh_agent_new(struct ssh_session_struct *session) {\n  ssh_agent agent = NULL;\n\n  agent = malloc(sizeof(struct ssh_agent_struct));\n  if (agent == NULL) {\n    return NULL;\n  }\n  ZERO_STRUCTP(agent);\n\n  agent->count = 0;\n  agent->sock = ssh_socket_new(session);\n  if (agent->sock == NULL) {\n    SAFE_FREE(agent);\n    return NULL;\n  }\n  agent->channel = NULL;\n  return agent;\n", "Selected Statement": "agent->sock = ssh_socket_new(session);", "Function Input": {"agent": {"value": "0x510b29 <ssh_set_blocking+105>"}}, "Variable Values Before Statement": {"session": {"common": null, "socket": null, "serverbanner": null, "clientbanner": null, "protoversion": "0", "server": "0", "client": "0", "openssh": "0", "send_seq": "0", "recv_seq": "0", "last_rekey_time": null, "connected": "0", "alive": "0", "flags": "1", "extensions": "0", "banner": null, "peer_discon_msg": null, "disconnect_message": null, "in_buffer": "0x125aaa0", "in_packet": null, "out_buffer": "0x125aa30", "out_queue": null, "pending_call_state": "SSH_PENDING_CALL_NONE", "session_state": "SSH_SESSION_STATE_NONE", "packet_state": "PACKET_STATE_INIT", "dh_handshake_state": "DH_STATE_INIT", "global_req_state": "SSH_CHANNEL_REQ_STATE_NONE", "agent_state": null, "auth": null, "send_first_kex_follows": "false", "first_kex_follows_guess_wrong": "false", "in_hashbuf": null, "out_hashbuf": null, "current_crypto": null, "next_crypto": null, "channels": null, "maxchannel": "42", "agent": null, "kbdint": null, "gssapi": null, "srv": null, "ssh_message_list": null, "ssh_message_callback": null, "ssh_message_callback_data": null, "server_callbacks": null, "ssh_connection_callback": null, "default_packet_callbacks": null, "packet_callbacks": null, "socket_callbacks": null, "default_poll_ctx": null, "pcap_ctx": null, "opts": null, "socket_counter": null, "raw_counter": null}}, "Value After Statement Execution": "NULL", "Function Name": "ssh_socket_new", "Project Information": "libssh"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": " */\nchar *ssh_find_all_matching(const char *available_list,\n                            const char *preferred_list)\n{\n    struct ssh_tokens_st *a_tok = NULL, *p_tok = NULL;\n    int i, j;\n    char *ret = NULL;\n    size_t max, len, pos = 0;\n    int match;\n\n    if ((available_list == NULL) || (preferred_list == NULL)) {\n        return NULL;\n    }\n\n    max = MAX(strlen(available_list), strlen(preferred_list));\n\n    ret = calloc(1, max + 1);\n    if (ret == NULL) {\n        return NULL;\n    }\n\n    a_tok = ssh_tokenize(available_list, ',');\n    if (a_tok == NULL) {\n        SAFE_FREE(ret);\n        goto out;\n    }\n\n    p_tok = ssh_tokenize(preferred_list, ',');\n    if (p_tok == NULL) {\n        SAFE_FREE(ret);\n        goto out;\n    }\n\n    for (i = 0; p_tok->tokens[i] ; i++) {\n        for (j = 0; a_tok->tokens[j]; j++) {\n            match = !strcmp(a_tok->tokens[j], p_tok->tokens[i]);\n            if (match) {\n                if (pos != 0) {\n                    ret[pos] = ',';\n                    pos++;\n                }\n\n                len = strlen(a_tok->tokens[j]);\n                memcpy(&ret[pos], a_tok->tokens[j], len);\n                pos += len;\n                ret[pos] = '\\0';\n            }\n        }\n    }\n\n    if (ret[0] == '\\0') {\n        SAFE_FREE(ret);\n    }\n\nout:\n    ssh_tokens_free(a_tok);\n    ssh_tokens_free(p_tok);\n    return ret;\n", "Selected Statement": "p_tok = ssh_tokenize(preferred_list, ',');", "Function Input": {}, "Variable Values Before Statement": {"preferred_list": "0x72f94d \"none\""}, "Value After Statement Execution": {"buffer": "0x125b5c0 \"none\"", "tokens": "0x125b5c0 \"none\""}, "Function Name": "ssh_tokenize", "Project Information": "libssh"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nssh_poll_handle\nssh_poll_new(socket_t fd, short events, ssh_poll_callback cb, void *userdata)\n{\n    ssh_poll_handle p;\n\n    p = malloc(sizeof(struct ssh_poll_handle_struct));\n    if (p == NULL) {\n        return NULL;\n    }\n    ZERO_STRUCTP(p);\n\n    p->x.fd = fd;\n    p->events = events;\n    p->cb = cb;\n    p->cb_data = userdata;\n\n    return p;\n", "Selected Statement": "p = malloc(sizeof(struct ssh_poll_handle_struct));", "Function Input": {}, "Variable Values Before Statement": {}, "Value After Statement Execution": "ssh_poll_handle", "Function Name": "malloc", "Project Information": "libssh"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": " * @return 0 on success, < 0 on error.\n */\nint ssh_send_banner(ssh_session session, int server)\n{\n    const char *banner = CLIENT_BANNER_SSH2;\n    const char *terminator = \"\\r\\n\";\n    \n    char buffer[256] = {0};\n    size_t len;\n    int rc = SSH_ERROR;\n\n    if (server == 1) {\n        if (session->opts.custombanner == NULL){\n            session->serverbanner = strdup(banner);\n            if (session->serverbanner == NULL) {\n                goto end;\n            }\n        } else {\n            len = strlen(session->opts.custombanner);\n            session->serverbanner = malloc(len + 8 + 1);\n            if(session->serverbanner == NULL) {\n                goto end;\n            }\n            snprintf(session->serverbanner,\n                     len + 8 + 1,\n                     \"SSH-2.0-%s\",\n                     session->opts.custombanner);\n        }\n\n        snprintf(buffer,\n                 sizeof(buffer),\n                 \"%s%s\",\n                 session->serverbanner,\n                 terminator);\n    } else {\n        session->clientbanner = strdup(banner);\n        if (session->clientbanner == NULL) {\n            goto end;\n        }\n\n        snprintf(buffer,\n                 sizeof(buffer),\n                 \"%s%s\",\n                 session->clientbanner,\n                 terminator);\n    }\n\n    rc = ssh_socket_write(session->socket, buffer, strlen(buffer));\n    if (rc == SSH_ERROR) {\n        goto end;\n    }\n#ifdef WITH_PCAP\n    if (session->pcap_ctx != NULL) {\n        ssh_pcap_context_write(session->pcap_ctx,\n                               SSH_PCAP_DIR_OUT,\n                               buffer,\n                               strlen(buffer),\n                               strlen(buffer));\n    }\n#endif\n\n    rc = SSH_OK;\nend:\n", "Selected Statement": "rc = ssh_socket_write(session->socket, buffer, strlen(buffer));", "Function Input": {}, "Variable Values Before Statement": {"session->socket": "NULL", "buffer": "\"SSH-2.0-libssh_0.10.90\\r\\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\""}, "Value After Statement Execution": "int", "Function Name": "ssh_socket_write", "Project Information": "libssh"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "}\n\nunsigned char *ssh_packet_encrypt(ssh_session session, void *data, size_t len)\n{\n  struct ssh_crypto_struct *crypto = NULL;\n  struct ssh_cipher_struct *cipher = NULL;\n  HMACCTX ctx = NULL;\n  char *out = NULL;\n  int etm_packet_offset = 0, rc;\n  unsigned int blocksize;\n  size_t finallen = DIGEST_MAX_LEN;\n  uint32_t seq, lenfield_blocksize;\n  enum ssh_hmac_e type;\n  bool etm;\n\n  assert(len);\n\n  crypto = ssh_packet_get_current_crypto(session, SSH_DIRECTION_OUT);\n  if (crypto == NULL) {\n      return NULL; \n  }\n\n  blocksize = crypto->out_cipher->blocksize;\n  lenfield_blocksize = crypto->out_cipher->lenfield_blocksize;\n\n  type = crypto->out_hmac;\n  etm = crypto->out_hmac_etm;\n\n  if (etm) {\n      etm_packet_offset = sizeof(uint32_t);\n  }\n\n  if ((len - lenfield_blocksize - etm_packet_offset) % blocksize != 0) {\n      ssh_set_error(session, SSH_FATAL, \"Cryptographic functions must be set\"\n                    \" on at least one blocksize (received %zu)\", len);\n      return NULL;\n  }\n  out = calloc(1, len);\n  if (out == NULL) {\n    return NULL;\n  }\n\n  seq = ntohl(session->send_seq);\n  cipher = crypto->out_cipher;\n\n  if (cipher->aead_encrypt != NULL) {\n      cipher->aead_encrypt(cipher, data, out, len,\n            crypto->hmacbuf, session->send_seq);\n      memcpy(data, out, len);\n  } else {\n      if (type != SSH_HMAC_NONE) {\n          ctx = hmac_init(crypto->encryptMAC, hmac_digest_len(type), type);\n          if (ctx == NULL) {\n              SAFE_FREE(out);\n              return NULL;\n          }\n\n          if (!etm) {\n              rc = hmac_update(ctx, (unsigned char *)&seq, sizeof(uint32_t));\n              if (rc != 1) {\n                  SAFE_FREE(out);\n                  return NULL;\n              }\n              rc = hmac_update(ctx, data, len);\n              if (rc != 1) {\n                  SAFE_FREE(out);\n                  return NULL;\n              }\n              rc = hmac_final(ctx, crypto->hmacbuf, &finallen);\n              if (rc != 1) {\n                  SAFE_FREE(out);\n                  return NULL;\n              }\n          }\n      }\n\n      cipher->encrypt(cipher, (uint8_t*)data + etm_packet_offset, out, len - etm_packet_offset);\n      memcpy((uint8_t*)data + etm_packet_offset, out, len - etm_packet_offset);\n\n      if (type != SSH_HMAC_NONE) {\n          if (etm) {\n              PUSH_BE_U32(data, 0, len - etm_packet_offset);\n              rc = hmac_update(ctx, (unsigned char *)&seq, sizeof(uint32_t));\n              if (rc != 1) {\n                  SAFE_FREE(out);\n                  return NULL;\n              }\n              rc = hmac_update(ctx, data, len);\n              if (rc != 1) {\n                  SAFE_FREE(out);\n                  return NULL;\n              }\n              rc = hmac_final(ctx, crypto->hmacbuf, &finallen);\n              if (rc != 1) {\n                  SAFE_FREE(out);\n                  return NULL;\n              }\n          }\n#ifdef DEBUG_CRYPTO\n          ssh_log_hexdump(\"mac: \", data, len);\n          if (finallen != hmac_digest_len(type)) {\n              printf(\"Final len is %zu\\n\", finallen);\n          }\n          ssh_log_hexdump(\"Packet hmac\", crypto->hmacbuf, hmac_digest_len(type));\n#endif\n      }\n  }\n  explicit_bzero(out, len);\n  SAFE_FREE(out);\n\n  return crypto->hmacbuf;\n", "Selected Statement": "crypto = ssh_packet_get_current_crypto(session, SSH_DIRECTION_OUT);", "Function Input": {"session": {"value": "0x7fffffffd4a0"}}, "Variable Values Before Statement": {"session": "ssh_session", "SSH_DIRECTION_OUT": "NULL"}, "Value After Statement Execution": "NULL", "Function Name": "ssh_packet_get_current_crypto", "Project Information": "libssh"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "                         char **hostname,\n                         char **port,\n                         bool ignore_port)\n{\n    char *endp = NULL;\n    long port_n;\n    int rc;\n\n    \n    if (username != NULL) {\n        *username = NULL;\n    }\n    if (hostname != NULL) {\n        *hostname = NULL;\n    }\n    if (port != NULL) {\n        *port = NULL;\n    }\n\n    \n    endp = strrchr(tok, '@');\n    if (endp != NULL) {\n        \n        if (tok == endp) {\n            goto error;\n        }\n        if (username != NULL) {\n            *username = strndup(tok, endp - tok);\n            if (*username == NULL) {\n                goto error;\n            }\n            rc = ssh_check_username_syntax(*username);\n            if (rc != SSH_OK) {\n                goto error;\n            }\n        }\n        tok = endp + 1;\n        \n        endp = strchr(tok, '@');\n        if (endp != NULL) {\n            goto error;\n        }\n    }\n\n    \n    if (*tok == '[') {\n        \n        tok++;\n        endp = strchr(tok, ']');\n        if (endp == NULL) {\n            goto error;\n        }\n    } else if (!ignore_port) {\n        \n        endp = strrchr(tok, ':');\n        if (endp == NULL) {\n            endp = strchr(tok, '\\0');\n        }\n    } else {\n        \n        endp = strchr(tok, '\\0');\n    }\n    if (tok == endp) {\n        \n        goto error;\n    }\n    if (hostname != NULL) {\n        *hostname = strndup(tok, endp - tok);\n        if (*hostname == NULL) {\n            goto error;\n        }\n        \n        rc = ssh_is_ipaddr(*hostname);\n        if (rc == 0) {\n            rc = ssh_check_hostname_syntax(*hostname);\n            if (rc != SSH_OK) {\n                goto error;\n            }\n        }\n    }\n    \n    if (*endp == ']') {\n        endp++;\n    }\n\n    \n    if (*endp != '\\0') {\n        char *port_end = NULL;\n\n        \n        port_n = strtol(endp + 1, &port_end, 10);\n        if (port_n < 1 || *port_end != '\\0') {\n            SSH_LOG(SSH_LOG_TRACE, \"Failed to parse port number.\"\n                    \" The value '%ld' is invalid or there are some\"\n                    \" trailing characters: '%s'\", port_n, port_end);\n            goto error;\n        }\n        if (port != NULL) {\n            *port = strdup(endp + 1);\n            if (*port == NULL) {\n                goto error;\n            }\n        }\n    }\n\n    return SSH_OK;\n\nerror:\n    if (username != NULL) {\n        SAFE_FREE(*username);\n    }\n    if (hostname != NULL) {\n        SAFE_FREE(*hostname);\n    }\n    if (port != NULL) {\n        SAFE_FREE(*port);\n    }\n    return SSH_ERROR;\n", "Selected Statement": "*hostname = strndup(tok, endp - tok);", "Function Input": {}, "Variable Values Before Statement": {"tok": "0x72995f \"example.com\""}, "Value After Statement Execution": "NULL", "Function Name": "strndup", "Project Information": "libssh"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": " *             SSH_ERROR on error\n */\nint ssh_config_parse_string(ssh_session session, const char *input)\n{\n    char line[MAX_LINE_SIZE] = {0};\n    const char *c = input, *line_start = input;\n    unsigned int line_num = 0, line_len;\n    int parsing, rv;\n\n    SSH_LOG(SSH_LOG_DEBUG, \"Reading configuration data from string:\");\n    SSH_LOG(SSH_LOG_DEBUG, \"START\\n%s\\nEND\", input);\n\n    parsing = 1;\n    while (1) {\n        line_num++;\n        line_start = c;\n        c = strchr(line_start, '\\n');\n        if (c == NULL) {\n            \n            c = strchr(line_start, '\\0');\n        }\n        if (c == NULL) {\n            \n            SSH_LOG(SSH_LOG_TRACE, \"No trailing '\\\\0' in config string\");\n            return SSH_ERROR;\n        }\n        line_len = c - line_start;\n        if (line_len > MAX_LINE_SIZE - 1) {\n            SSH_LOG(SSH_LOG_TRACE, \"Line %u too long: %u characters\",\n                    line_num, line_len);\n            return SSH_ERROR;\n        }\n        memcpy(line, line_start, line_len);\n        line[line_len] = '\\0';\n        SSH_LOG(SSH_LOG_DEBUG, \"Line %u: %s\", line_num, line);\n        rv = ssh_config_parse_line(session, line, line_num, &parsing, 0, false);\n        if (rv < 0) {\n            return SSH_ERROR;\n        }\n        if (*c == '\\0') {\n            break;\n        }\n        c++;\n    }\n\n    return SSH_OK;\n", "Selected Statement": "c = strchr(line_start, '\\n');", "Function Input": {}, "Variable Values Before Statement": {"line_start": "0x12548a0 \"\""}, "Value After Statement Execution": "NULL", "Function Name": "strchr", "Project Information": "libssh"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": " *             SSH_ERROR on error\n */\nint ssh_bind_config_parse_string(ssh_bind bind, const char *input)\n{\n    char line[MAX_LINE_SIZE] = {0};\n    const char *c = input, *line_start = input;\n    unsigned int line_num = 0, line_len;\n    uint32_t parser_flags;\n    int rv;\n\n    \n    uint8_t seen[BIND_CFG_MAX] = {0};\n\n    SSH_LOG(SSH_LOG_DEBUG, \"Reading bind configuration data from string:\");\n    SSH_LOG(SSH_LOG_DEBUG, \"START\\n%s\\nEND\", input);\n\n    parser_flags = PARSING;\n    while (1) {\n        line_num++;\n        line_start = c;\n        c = strchr(line_start, '\\n');\n        if (c == NULL) {\n            \n            c = strchr(line_start, '\\0');\n        }\n        if (c == NULL) {\n            \n            SSH_LOG(SSH_LOG_WARN, \"No trailing '\\\\0' in config string\");\n            return SSH_ERROR;\n        }\n        line_len = c - line_start;\n        if (line_len > MAX_LINE_SIZE - 1) {\n            SSH_LOG(SSH_LOG_WARN, \"Line %u too long: %u characters\",\n                    line_num, line_len);\n            return SSH_ERROR;\n        }\n        memcpy(line, line_start, line_len);\n        line[line_len] = '\\0';\n        SSH_LOG(SSH_LOG_DEBUG, \"Line %u: %s\", line_num, line);\n        rv = ssh_bind_config_parse_line(bind, line, line_num, &parser_flags, seen, 0);\n        if (rv < 0) {\n            return SSH_ERROR;\n        }\n        if (*c == '\\0') {\n            break;\n        }\n        c++;\n    }\n\n    return SSH_OK;\n", "Selected Statement": "c = strchr(line_start, '\\n');", "Function Input": {"parser_flags": {"value": "8347536"}}, "Variable Values Before Statement": {"line_start": "0x12578a0 \"\""}, "Value After Statement Execution": "NULL", "Function Name": "strchr", "Project Information": "libssh"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": " */\nkrb5_error_code\nndr_dec_delegation_info(krb5_data *data, struct pac_s4u_delegation_info **out)\n{\n    krb5_error_code ret;\n    struct pac_s4u_delegation_info *di = NULL;\n    struct k5input in;\n    uint32_t i, object_buffer_length, nservices;\n    uint8_t version, endianness, common_header_length;\n\n    *out = NULL;\n\n    di = k5alloc(sizeof(*di), &ret);\n    if (di == NULL)\n        return ret;\n\n    k5_input_init(&in, data->data, data->length);\n\n    \n    version = k5_input_get_byte(&in);\n    endianness = k5_input_get_byte(&in);\n    common_header_length = k5_input_get_uint16_le(&in);\n    (void)k5_input_get_uint32_le(&in); \n    if (version != 1 || endianness != 0x10 || common_header_length != 8) {\n        ret = EINVAL;\n        goto error;\n    }\n\n    \n    object_buffer_length = k5_input_get_uint32_le(&in);\n    if (data->length < 16 || object_buffer_length != data->length - 16) {\n        ret = EINVAL;\n        goto error;\n    }\n\n    (void)k5_input_get_uint32_le(&in); \n\n    \n\n    \n    (void)k5_input_get_uint32_le(&in);\n    \n    (void)k5_input_get_uint16_le(&in);\n    \n    (void)k5_input_get_uint16_le(&in);\n    \n    (void)k5_input_get_uint32_le(&in);\n\n    \n    (void)k5_input_get_uint32_le(&in);\n\n    \n    (void)k5_input_get_uint32_le(&in);\n\n    ret = dec_wchar_pointer(&in, &di->proxy_target);\n    if (ret)\n        goto error;\n    nservices = k5_input_get_uint32_le(&in);\n\n    \n    if (nservices > data->length / 8) {\n        ret = ERANGE;\n        goto error;\n    }\n    (void)k5_input_get_bytes(&in, 8 * nservices);\n\n    \n    di->transited_services = k5calloc(nservices + 1, sizeof(char *), &ret);\n    if (di->transited_services == NULL)\n        goto error;\n\n    for (i = 0; i < nservices; i++) {\n        ret = dec_wchar_pointer(&in, &di->transited_services[i]);\n        if (ret)\n            goto error;\n        di->transited_services_length++;\n    }\n\n    ret = in.status;\n    if (ret)\n        goto error;\n\n    *out = di;\n    return 0;\n\nerror:\n    ndr_free_delegation_info(di);\n    return ret;\n", "Selected Statement": "di = k5alloc(sizeof(*di), &ret);", "Function Input": {"in": {"value": {"ptr": {"type_category": "string", "concrete_type": "NULL"}, "len": {"type_category": "unknown", "concrete_type": "size_t", "value": "4242681"}, "status": {"type_category": "unknown", "concrete_type": "int32_t", "value": "5350024"}}}, "out": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf3bbe0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x1332bcc00081001\n", "message": "Cannot access memory at address 0x1332bcc00081001"}}}}, "Variable Values Before Statement": {}, "Value After Statement Execution": {"proxy_target": null, "transited_services_length": "0", "transited_services": null}, "Function Name": "k5alloc", "Project Information": "krb5"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nint\nk5_utf16le_to_utf8(const uint8_t *utf16bytes, size_t nbytes, char **utf8_out)\n{\n    struct k5buf buf;\n    struct k5input in;\n    uint16_t ch1, ch2;\n    krb5_ucs4 ch;\n    size_t chlen;\n    void *p;\n\n    *utf8_out = NULL;\n\n    if (nbytes % 2 != 0)\n        return EINVAL;\n\n    k5_buf_init_dynamic(&buf);\n    k5_input_init(&in, utf16bytes, nbytes);\n    while (!in.status && in.len > 0) {\n        \n        ch1 = k5_input_get_uint16_le(&in);\n        if (IS_LOW_SURROGATE(ch1))\n            goto invalid;\n        if (IS_HIGH_SURROGATE(ch1)) {\n            \n            ch2 = k5_input_get_uint16_le(&in);\n            if (!IS_LOW_SURROGATE(ch2))\n                goto invalid;\n            ch = COMPOSE(ch1, ch2);\n        } else {\n            ch = ch1;\n        }\n\n        chlen = krb5int_ucs4_to_utf8(ch, NULL);\n        p = k5_buf_get_space(&buf, chlen);\n        if (p == NULL)\n            return ENOMEM;\n        (void)krb5int_ucs4_to_utf8(ch, p);\n    }\n\n    if (in.status)\n        goto invalid;\n\n    *utf8_out = k5_buf_cstring(&buf);\n    return (*utf8_out == NULL) ? ENOMEM : 0;\n\ninvalid:\n    k5_buf_free(&buf);\n    return EINVAL;\n", "Selected Statement": "ch1 = k5_input_get_uint16_le(&in);", "Function Input": {}, "Variable Values Before Statement": {}, "Value After Statement Execution": "12", "Function Name": "k5_input_get_uint16_le", "Project Information": "krb5"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nvoid\nk5_buf_init_dynamic(struct k5buf *buf)\n{\n    buf->buftype = K5BUF_DYNAMIC;\n    buf->space = 128;\n    buf->data = malloc(buf->space);\n    if (buf->data == NULL) {\n        set_error(buf);\n        return;\n    }\n    buf->len = 0;\n", "Selected Statement": "buf->data = malloc(buf->space);", "Function Input": {"buf": {"value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x65cc6ead\n", "message": "Cannot access memory at address 0x65cc6ead"}}}, "Variable Values Before Statement": {"buf->space": "128"}, "Value After Statement Execution": "NULL", "Function Name": "malloc", "Project Information": "krb5"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "}\n\nvoid data_stack_init(void)\n{\n\tif (data_stack_initialized) {\n\t\t\n\t\treturn;\n\t}\n\tdata_stack_initialized = TRUE;\n\tdata_stack_frame_id = 1;\n\n\toutofmem_area.block.size = outofmem_area.block.left =\n\t\tsizeof(outofmem_area) - sizeof(outofmem_area.block);\n\toutofmem_area.block.canary = BLOCK_CANARY;\n\n\tcurrent_block = mem_block_alloc(INITIAL_STACK_SIZE);\n\tcurrent_frame = NULL;\n\n\tlast_buffer_block = NULL;\n\tlast_buffer_size = 0;\n\n\troot_frame_id = t_push(\"data_stack_init\");\n", "Selected Statement": "current_block = mem_block_alloc(INITIAL_STACK_SIZE);", "Function Input": {}, "Variable Values Before Statement": {"INITIAL_STACK_SIZE": "NULL"}, "Value After Statement Execution": {"prev": null, "next": null, "size": "32768", "left": "32768", "canary": null, "data": [{"type_category": "int", "concrete_type": "unsigned char", "value": "57 '9'"}]}, "Function Name": "mem_block_alloc", "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "static char *my_domain = NULL;\n\nvoid hostpid_init(void)\n{\n\tstatic char pid[MAX_INT_STRLEN];\n\tchar hostname[256];\n\tconst char *value;\n\n\t\n\ti_free_and_null(my_hostname_dup);\n\ti_free_and_null(my_domain);\n\n\tvalue = getenv(MY_HOSTNAME_ENV);\n\tif (value == NULL) {\n\t\tif (gethostname(hostname, sizeof(hostname)-1) < 0)\n\t\t\ti_fatal(\"gethostname() failed: %m\");\n\t\thostname[sizeof(hostname)-1] = '\\0';\n\t\tvalue = hostname;\n\t}\n\n\tif (value[0] == '\\0' ||\n\t    strcspn(value, HOSTNAME_DISALLOWED_CHARS) != strlen(value))\n\t\ti_fatal(\"Invalid system hostname: '%s'\", value);\n\tmy_hostname_dup = i_strdup(value);\n\tmy_hostname = my_hostname_dup;\n\n\ti_snprintf(pid, sizeof(pid), \"%lld\", (long long)getpid());\n\tmy_pid = pid;\n", "Selected Statement": "value = getenv(MY_HOSTNAME_ENV);", "Function Input": {}, "Variable Values Before Statement": {"MY_HOSTNAME_ENV": "NULL"}, "Value After Statement Execution": "NULL", "Function Name": "getenv", "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "}\n\nchar *p_strdup(pool_t pool, const char *str)\n{\n\tvoid *mem;\n\tsize_t len;\n\n\tif (str == NULL)\n                return NULL;\n\n\tlen = strlen(str) + 1;\n\tmem = p_malloc(pool, len);\n\tmemcpy(mem, str, len);\n\treturn mem;\n", "Selected Statement": "mem = p_malloc(pool, len);", "Function Input": {}, "Variable Values Before Statement": {"pool": "pool_t", "len": "13"}, "Value After Statement Execution": "VOID", "Function Name": "p_malloc", "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "}\n\nstatic void *pool_system_malloc(pool_t pool ATTR_UNUSED, size_t size)\n{\n\tvoid *mem;\n#ifdef DEBUG\n\tint old_errno = errno;\n#endif\n\n\tmem = calloc(size, 1);\n\tif (unlikely(mem == NULL)) {\n\t\ti_fatal_status(FATAL_OUTOFMEM, \"pool_system_malloc(%zu): \"\n\t\t\t       \"Out of memory\", size);\n\t}\n#ifdef DEBUG\n\t\n\ti_assert(errno == old_errno);\n#endif\n", "Selected Statement": "mem = calloc(size, 1);", "Function Input": {}, "Variable Values Before Statement": {"size": "13", "1": "1"}, "Value After Statement Execution": "VOID", "Function Name": "calloc", "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "#include <sys/un.h>\n\nvoid fd_close_on_exec(int fd, bool set)\n{\n\tint flags;\n\n\tflags = fcntl(fd, F_GETFD, 0);\n\tif (flags < 0)\n\t\ti_fatal(\"fcntl(F_GETFD, %d) failed: %m\", fd);\n\n\tflags = set ? (flags | FD_CLOEXEC) : (flags & ~FD_CLOEXEC);\n\tif (fcntl(fd, F_SETFD, flags) < 0)\n\t\ti_fatal(\"fcntl(F_SETFD, %d) failed: %m\", fd);\n", "Selected Statement": "flags = fcntl(fd, F_GETFD, 0);", "Function Input": {"fd": {"value": "32767"}, "set": {"value": "255"}}, "Variable Values Before Statement": {"fd": "int", "F_GETFD": "NULL", "0": "0"}, "Value After Statement Execution": "int", "Function Name": "fcntl", "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "\nbuffer_t *buffer_create_dynamic_max(pool_t pool, size_t init_size,\n\t\t\t\t    size_t max_size)\n{\n\tstruct real_buffer *buf;\n\n#ifdef DEBUG\n\t\n\ti_assert(init_size < SIZE_MAX);\n#endif\n\n\tbuf = p_new(pool, struct real_buffer, 1);\n\tbuf->pool = pool;\n\tbuf->dynamic = TRUE;\n\tbuf->max_size = max_size;\n\t\n\tbuffer_alloc(buf, init_size+1);\n", "Selected Statement": "buf = p_new(pool, struct real_buffer, 1);", "Function Input": {"buf": {"value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x30\n", "message": "Cannot access memory at address 0x30"}}}, "Variable Values Before Statement": {"pool": "pool_t", "real_buffer": "NULL", "1": "1"}, "Value After Statement Execution": "NULL", "Function Name": "p_new", "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "}\n\nvoid var_expand_extensions_init(void)\n{\n\ti_array_init(&var_expand_extensions, 32);\n\n\t\n\tfor(const struct hash_method **meth = hash_methods;\n\t    *meth != NULL;\n\t    meth++) {\n\t\tstruct var_expand_extension_func_table *func =\n\t\t\tarray_append_space(&var_expand_extensions);\n\t\tfunc->key = (*meth)->name;\n\t\tfunc->func = var_expand_hash;\n\t}\n\n\t\n\tstruct var_expand_extension_func_table *func =\n\t\tarray_append_space(&var_expand_extensions);\n\tfunc->key = \"pkcs5\";\n\tfunc->func = var_expand_hash;\n\n\t\n\tfunc = array_append_space(&var_expand_extensions);\n\tfunc->key = \"if\";\n\tfunc->func = var_expand_if;\n\n\t\n\tfunc = array_append_space(&var_expand_extensions);\n\tfunc->key = \"system\";\n\tfunc->func = var_expand_system;\n\n\t\n\tfunc = array_append_space(&var_expand_extensions);\n\tfunc->key = \"process\";\n\tfunc->func = var_expand_process;\n", "Selected Statement": "func = array_append_space(&var_expand_extensions);", "Function Input": {}, "Variable Values Before Statement": {}, "Value After Statement Execution": {"key": null, "func": null}, "Function Name": "array_append_space", "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "}\n\nstruct istream *test_istream_create_data(const void *data, size_t size)\n{\n\tstruct test_istream *tstream;\n\n\ttstream = i_new(struct test_istream, 1);\n\ttstream->orig_buffer = data;\n\n\ttstream->istream.read = test_read;\n\ttstream->istream.seek = test_seek;\n\n\ttstream->istream.istream.blocking = FALSE;\n\ttstream->istream.istream.seekable = TRUE;\n\ti_stream_create(&tstream->istream, NULL, -1, 0);\n\ttstream->istream.statbuf.st_size = tstream->max_pos = size;\n\ttstream->allow_eof = TRUE;\n\ttstream->istream.max_buffer_size = SIZE_MAX;\n", "Selected Statement": "tstream = i_new(struct test_istream, 1);", "Function Input": {}, "Variable Values Before Statement": {"test_istream": "NULL", "1": "1"}, "Value After Statement Execution": {"istream": null, "orig_buffer": null, "skip_diff": "0", "max_pos": "0", "allow_eof": "false"}, "Function Name": "i_new", "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "json_istream_create(struct istream *input, enum json_istream_type type,\n\t\t    const struct json_limits *limits,\n\t\t    enum json_parser_flags parser_flags)\n{\n\tstruct json_istream *stream;\n\n\tstream = i_new(struct json_istream, 1);\n\tstream->refcount = 1;\n\tstream->type = type;\n\n\tstream->input = input; \n\tstream->parser = json_parser_init(input, limits, parser_flags,\n\t\t\t\t\t  &parser_callbacks, (void *)stream);\n\n", "Selected Statement": "stream = i_new(struct json_istream, 1);", "Function Input": {"stream": {"value": null}}, "Variable Values Before Statement": {"json_istream": "NULL", "1": "1"}, "Value After Statement Execution": {"refcount": "0", "input": null, "type": "JSON_ISTREAM_TYPE_NORMAL", "parser": null, "node": null, "node_level": "0", "read_node_level": "0", "skip_nodes": "0", "value_stream": null, "seekable_stream": null, "tree": null, "tree_node": null, "tree_node_level": "0", "error": null, "opened": "false", "closed": "false", "node_parsed": "false", "member_parsed": "false", "read_member": "false", "end_of_list": "false", "end_of_input": "false", "skip_to_end": "false", "deref_value": "false"}, "Function Name": "i_new", "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "json_parser_init(struct istream *input, const struct json_limits *limits,\n\t\t enum json_parser_flags flags,\n\t\t const struct json_parser_callbacks *callbacks, void *context)\n{\n\tstruct json_parser *parser;\n\n\tparser = i_new(struct json_parser, 1);\n\tparser->flags = flags;\n\n\ti_array_init(&parser->level_stack, 8);\n\n\tparser->input = input;\n\ti_stream_ref(input);\n\tparser->input_offset = input->v_offset;\n\n\tif (limits != NULL)\n\t\tparser->limits = *limits;\n\tif (parser->limits.max_string_size == 0)\n\t\tparser->limits.max_string_size = JSON_DEFAULT_MAX_STRING_SIZE;\n\tif (parser->limits.max_name_size == 0)\n\t\tparser->limits.max_name_size = JSON_DEFAULT_MAX_NAME_SIZE;\n\tif (parser->limits.max_nesting == 0)\n\t\tparser->limits.max_nesting = JSON_DEFAULT_MAX_NESTING;\n\tif (parser->limits.max_list_items == 0)\n\t\tparser->limits.max_list_items = JSON_DEFAULT_MAX_LIST_ITEMS;\n\n\tparser->callbacks = callbacks;\n\tparser->context = context;\n\n\tparser->loc.line_number = 1;\n\n", "Selected Statement": "parser = i_new(struct json_parser, 1);", "Function Input": {"parser": {"value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x88\n", "message": "Cannot access memory at address 0x88"}}}, "Variable Values Before Statement": {"json_parser": "NULL", "1": "1"}, "Value After Statement Execution": {"flags": "0", "limits": null, "callbacks": null, "context": null, "level_stack": null, "level_stack_pos": "0", "call_stack_depth": "0", "input": null, "input_offset": "0", "begin": null, "cur": null, "end": null, "current_char": "0", "current_char_len": "0", "loc": null, "buffer": null, "object_member": null, "content_data": null, "str_stream": null, "str_stream_threshold": "0", "str_stream_max_buffer_size": "0", "error": null, "parsed_nul_char": "false", "parsed_control_char": "false", "parsed_float": "false", "streaming_string": "false", "callback_interrupted": "false", "callback_running": "false", "finished_level": "false", "end_of_input": "false", "started": "false", "have_object_member": "false"}, "Function Name": "i_new", "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "}\n\nstruct json_tree *json_tree_create(void)\n{\n\tstruct json_tree *jtree;\n\tpool_t pool;\n\n\tpool = pool_alloconly_create(\"json tree\", 1024);\n\tjtree = json_tree_create_pool(pool);\n\tpool_unref(&pool);\n\n", "Selected Statement": "pool = pool_alloconly_create(\"json tree\", 1024);", "Function Input": {}, "Variable Values Before Statement": {"\"json tree\"": "\"json tree\"", "1024": "1024"}, "Value After Statement Execution": "pool_t", "Function Name": "pool_alloconly_create", "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "#endif\n\npool_t pool_alloconly_create(const char *name ATTR_UNUSED, size_t size)\n{\n\tstruct alloconly_pool apool, *new_apool;\n\tsize_t min_alloc = SIZEOF_POOLBLOCK +\n\t\tMEM_ALIGN(sizeof(struct alloconly_pool) + SENTRY_COUNT);\n\n\t(void) COMPILE_ERROR_IF_TRUE(POOL_ALLOCONLY_MAX_EXTRA >\n\t\t\t\t     (SSIZE_T_MAX - POOL_MAX_ALLOC_SIZE));\n\n#ifdef DEBUG\n\tmin_alloc += MEM_ALIGN(strlen(name) + 1 + SENTRY_COUNT) +\n\t\tsizeof(size_t)*2;\n#endif\n\n\t\n\ti_zero(&apool);\n\tapool.pool = static_alloconly_pool;\n\tapool.refcount = 1;\n\n\tif (size < min_alloc)\n\t\tsize = nearest_power(size + min_alloc);\n\tblock_alloc(&apool, size);\n\n\t\n\tnew_apool = p_new(&apool.pool, struct alloconly_pool, 1);\n\t*new_apool = apool;\n#ifdef DEBUG\n\tif (str_begins(name, MEMPOOL_GROWING, &name) ||\n\t    getenv(\"DEBUG_SILENT\") != NULL)\n\t\tnew_apool->disable_warning = TRUE;\n\tnew_apool->name = p_strdup(&new_apool->pool, name);\n\n\t\n\tnew_apool->base_size = new_apool->block->size - new_apool->block->left;\n\tnew_apool->block->last_alloc_size = 0;\n#endif\n\t\n\ti_assert(new_apool->block->prev == NULL);\n\n", "Selected Statement": "size = nearest_power(size + min_alloc);", "Function Input": {}, "Variable Values Before Statement": {}, "Value After Statement Execution": "1024", "Function Name": "nearest_power", "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "};\n\npool_t pool_datastack_create(void)\n{\n\tstruct datastack_pool *dpool;\n\n\tdpool = t_new(struct datastack_pool, 1);\n\tdpool->pool = static_data_stack_pool;\n\tdpool->refcount = 1;\n\tdpool->data_stack_frame = data_stack_frame_id;\n", "Selected Statement": "dpool = t_new(struct datastack_pool, 1);", "Function Input": {}, "Variable Values Before Statement": {"datastack_pool": "NULL", "1": "1"}, "Value After Statement Execution": {"pool": null, "refcount": "0", "data_stack_frame": "0"}, "Function Name": "t_new", "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "int imap_bodystructure_parse_full(const char *bodystructure,\n\tpool_t pool, struct message_part **parts,\n\tconst char **error_r)\n{\n\tstruct istream *input;\n\tstruct imap_parser *parser;\n\tconst struct imap_arg *args;\n\tint ret;\n\n\ti_assert(*parts == NULL || (*parts)->next == NULL);\n\n\tinput = i_stream_create_from_data(bodystructure, strlen(bodystructure));\n\t(void)i_stream_read(input);\n\n\tparser = imap_parser_create(input, NULL, SIZE_MAX);\n\tret = imap_parser_finish_line(parser, 0,\n\t\t\t\t      IMAP_PARSE_FLAG_LITERAL_TYPE, &args);\n\tif (ret < 0) {\n\t\t*error_r = t_strdup_printf(\"IMAP parser failed: %s\",\n\t\t\t\t\t   imap_parser_get_error(parser, NULL));\n\t} else if (ret == 0) {\n\t\t*error_r = \"Empty bodystructure\";\n\t\tret = -1;\n\t} else {\n\t\tT_BEGIN {\n\t\t\tret = imap_bodystructure_parse_args\n\t\t\t\t(args, pool, parts, error_r);\n\t\t} T_END_PASS_STR_IF(ret < 0, error_r);\n\t}\n\n\tif (ret < 0) {\n\t\t\n\t\timap_bodystructure_reset_data(*parts);\n\t}\n\n\timap_parser_unref(&parser);\n\ti_stream_destroy(&input);\n", "Selected Statement": "input = i_stream_create_from_data(bodystructure, strlen(bodystructure));", "Function Input": {}, "Variable Values Before Statement": {"bodystructure": "0x103c098 \"\""}, "Value After Statement Execution": {"v_offset": "0", "stream_errno": "0", "mmaped": "false", "blocking": "true", "closed": "false", "readable_fd": "false", "seekable": "true", "eof": "false", "real_stream": null}, "Function Name": "i_stream_create_from_data", "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "struct imap_parser *\nimap_parser_create(struct istream *input, struct ostream *output,\n\t\t   size_t max_line_size)\n{\n\tstruct imap_parser *parser;\n\n\tparser = i_new(struct imap_parser, 1);\n\tparser->refcount = 1;\n\tparser->pool = pool_alloconly_create(MEMPOOL_GROWING\"IMAP parser\",\n\t\t\t\t\t     1024);\n\tparser->input = input;\n\tparser->output = output;\n\tparser->max_line_size = max_line_size;\n\n\tp_array_init(&parser->root_list, parser->pool, LIST_INIT_COUNT);\n\tparser->cur_list = &parser->root_list;\n", "Selected Statement": "parser = i_new(struct imap_parser, 1);", "Function Input": {}, "Variable Values Before Statement": {"imap_parser": "NULL", "1": "1"}, "Value After Statement Execution": {"refcount": "0", "pool": null, "input": null, "output": null, "max_line_size": "0", "flags": "0", "line_size": "0", "root_list": null, "cur_list": null, "list_arg": null, "cur_type": "ARG_PARSE_NONE", "cur_pos": "0", "cur_resp_text": "false", "str_first_escape": "0", "literal_size": "0", "error": "IMAP_PARSE_ERROR_NONE", "error_msg": null, "literal_minus": "false", "literal_skip_crlf": "false", "literal_nonsync": "false", "literal8": "false", "literal_size_return": "false", "eol": "false", "args_added_extra_eol": "false", "fatal_error": "false"}, "Function Name": "i_new", "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "struct message_parser_ctx *\nmessage_parser_init(pool_t part_pool, struct istream *input,\n\t\t    const struct message_parser_settings *set)\n{\n\tstruct message_parser_ctx *ctx;\n\n\tctx = message_parser_init_int(input, set);\n\tctx->part_pool = part_pool;\n\tctx->parts = ctx->part = p_new(part_pool, struct message_part, 1);\n\tctx->next_part = &ctx->part->children;\n\tctx->parse_next_block = parse_next_header_init;\n\tctx->total_parts_count = 1;\n\ti_array_init(&ctx->next_part_stack, 4);\n", "Selected Statement": "ctx = message_parser_init_int(input, set);", "Function Input": {}, "Variable Values Before Statement": {"input": {"v_offset": "0", "stream_errno": "0", "mmaped": "false", "blocking": "false", "closed": "false", "readable_fd": "false", "seekable": "true", "eof": "false", "real_stream": null}, "set": {"hdr_flags": "0", "flags": "MESSAGE_PARSER_FLAG_INCLUDE_MULTIPART_BLOCKS", "max_nested_mime_parts": "0", "max_total_mime_parts": "0"}}, "Value After Statement Execution": {"part_pool": null, "input": null, "parts": null, "part": null, "broken_reason": null, "nested_parts_count": "0", "total_parts_count": "0", "hdr_flags": "0", "flags": "MESSAGE_PARSER_FLAG_INCLUDE_MULTIPART_BLOCKS", "max_nested_mime_parts": "100", "max_total_mime_parts": "10000", "last_boundary": null, "boundaries": null, "next_part": null, "next_part_stack": null, "skip": "0", "last_chr": "0 '\\000'", "want_count": "0", "hdr_parser_ctx": null, "prev_hdr_newline_size": "0", "parse_next_block": null, "part_seen_content_type": "false", "multipart": "false", "preparsed": "false", "eof": "false"}, "Function Name": "message_parser_init_int", "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "struct message_header_parser_ctx *\nmessage_parse_header_init(struct istream *input, struct message_size *hdr_size,\n\t\t\t  enum message_header_parser_flags flags)\n{\n\tstruct message_header_parser_ctx *ctx;\n\n\tctx = i_new(struct message_header_parser_ctx, 1);\n\tctx->input = input;\n\tctx->hdr_size = hdr_size;\n\tctx->name = str_new(default_pool, 128);\n\tctx->flags = flags;\n\tctx->value_buf = buffer_create_dynamic(default_pool, 4096);\n\ti_stream_ref(input);\n\n\tif (hdr_size != NULL)\n\t\ti_zero(hdr_size);\n", "Selected Statement": "ctx->name = str_new(default_pool, 128);", "Function Input": {}, "Variable Values Before Statement": {"default_pool": "NULL", "128": "128"}, "Value After Statement Execution": "NULL", "Function Name": "str_new", "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Function Call", "Source Code": "int\nk5_utf16le_to_utf8(const uint8_t *utf16bytes, size_t nbytes, char **utf8_out)\n{\n    struct k5buf buf;\n    struct k5input in;\n    uint16_t ch1, ch2;\n    krb5_ucs4 ch;\n    size_t chlen;\n    void *p;\n\n    *utf8_out = NULL;\n\n    if (nbytes % 2 != 0)\n        return EINVAL;\n\n    k5_buf_init_dynamic(&buf);\n    k5_input_init(&in, utf16bytes, nbytes);\n    while (!in.status && in.len > 0) {\n        \n        ch1 = k5_input_get_uint16_le(&in);\n        if (IS_LOW_SURROGATE(ch1))\n            goto invalid;\n        if (IS_HIGH_SURROGATE(ch1)) {\n            \n            ch2 = k5_input_get_uint16_le(&in);\n            if (!IS_LOW_SURROGATE(ch2))\n                goto invalid;\n            ch = COMPOSE(ch1, ch2);\n        } else {\n            ch = ch1;\n        }\n\n        chlen = krb5int_ucs4_to_utf8(ch, NULL);\n        p = k5_buf_get_space(&buf, chlen);\n        if (p == NULL)\n            return ENOMEM;\n        (void)krb5int_ucs4_to_utf8(ch, p);\n    }\n\n    if (in.status)\n        goto invalid;\n\n    *utf8_out = k5_buf_cstring(&buf);\n    return (*utf8_out == NULL) ? ENOMEM : 0;\n\ninvalid:\n    k5_buf_free(&buf);\n    return EINVAL;\n}", "Selected Statement": "*utf8_out = k5_buf_cstring(&buf);", "Function Input": {}, "Variable Values Before Statement": {}, "Value After Statement Execution": "NULL", "Function Name": "k5_buf_cstring", "Project Information": "krb5"}
