{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nvoid\nfiber_init(int (*invoke)(fiber_func f, va_list ap))\n{\n\tpage_size = small_getpagesize();\n\tstack_direction = check_stack_direction(__builtin_frame_address(0));\n\tfiber_invoke = invoke;\n\tmain_thread_id = pthread_self();\n\tmain_cord.loop = ev_default_loop(EVFLAG_AUTO | EVFLAG_ALLOCFD);\n\tif (main_cord.loop == NULL)\n\t\tpanic(\"can't init event loop\");\n\tcord_create(&main_cord, \"main\");\n", "Selected Statement": "fiber_invoke = invoke;", "Function Input": {}, "Variable Values Before Statement": {"invoke": "{int (fiber_func, struct __va_list_tag *)} 0x363400 <fiber_c_invoke>"}, "Value After Statement Execution": "{int (fiber_func, struct __va_list_tag *)} 0x363400 <fiber_c_invoke>", "Project Information": "tarantool"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "void\nmempool_create_with_order(struct mempool *pool, struct slab_cache *cache,\n\t\t\t  uint32_t objsize, uint8_t order)\n{\n\tassert(order <= cache->order_max);\n\tpool->cache = cache;\n\tslab_list_create(&pool->slabs);\n\tmslab_tree_new(&pool->hot_slabs);\n\tpool->first_hot_slab = NULL;\n\trlist_create(&pool->cold_slabs);\n\tpool->spare = NULL;\n\tpool->objsize = objsize;\n\tpool->slab_order = order;\n\t\n\tuint32_t slab_size = slab_order_size(pool->cache, pool->slab_order);\n\t\n\tpool->objcount = (slab_size - mslab_sizeof()) / objsize;\n\tassert(pool->objcount);\n\tpool->offset = slab_size - pool->objcount * pool->objsize;\n\tpool->slab_ptr_mask = ~(slab_order_size(cache, order) - 1);\n\tpool->small_mempool = NULL;\n", "Selected Statement": "pool->objsize = objsize;", "Function Input": {}, "Variable Values Before Statement": {"objsize": "440"}, "Value After Statement Execution": "440", "Project Information": "tarantool"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nvoid\nclock_lowres_signal_init(void)\n{\n#ifndef NDEBUG\n\towner = pthread_self();\n#endif\n\tclock_lowres_monotonic_clock_value = clock_monotonic();\n\tstruct sigaction sa;\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_handler = clock_lowres_tick;\n\tsa.sa_flags = SA_RESTART;\n\tif (tt_sigaction(SIGALRM, &sa, NULL) == -1)\n\t\tpanic_syserror(\"cannot set low resolution clock timer signal\");\n\n\tstruct itimerval timer;\n\ttimer.it_interval = resolution;\n\ttimer.it_value = resolution;\n\tif (setitimer(ITIMER_REAL, &timer, NULL) == -1)\n\t\tpanic_syserror(\"cannot set low resolution clock timer\");\n", "Selected Statement": "sa.sa_handler = clock_lowres_tick;", "Function Input": {}, "Variable Values Before Statement": {"clock_lowres_tick": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "tarantool"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nint\ntt_sigaction(int signum, struct sigaction *sa, struct sigaction *osa)\n{\n\tassert(signum < SIGMAX);\n\tassert(sa != NULL);\n\n\t\n\tif (!main_thread_initialized) {\n\t\tmain_thread_id = pthread_self();\n\t\tmain_thread_initialized = true;\n\t}\n\n\tvoid (*old_handler)(int) = sighandlers[signum];\n\tif (sa->sa_handler == SIG_DFL || sa->sa_handler == SIG_IGN) {\n\t\tsighandlers[signum] = NULL;\n\t} else {\n\t\tsighandlers[signum] = sa->sa_handler;\n\t\tsa->sa_handler = sighandler_dispatcher;\n\t}\n\tint rc = sigaction(signum, sa, osa);\n\tif (osa != NULL && old_handler != NULL)\n\t\tosa->sa_handler = old_handler;\n", "Selected Statement": "osa->sa_handler = old_handler;", "Function Input": {"signum": {"value": "0"}}, "Variable Values Before Statement": {"old_handler": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "tarantool"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nvoid\ncsv_create(struct csv *csv)\n{\n\tmemset(csv, 0, sizeof(struct csv));\n\tcsv->delimiter= ',';\n\tcsv->quote_char = '\\\"';\n\tcsv->realloc = realloc;\n\tcsv->emit_field = csv_emit_field_empty;\n\tcsv->emit_row = csv_emit_row_empty;\n", "Selected Statement": "csv->emit_field = csv_emit_field_empty;", "Function Input": {}, "Variable Values Before Statement": {"csv_emit_field_empty": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "tarantool"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\n\nconst char * decNumberFromString(decNumber *dn, const char chars[],\n                                 decContext *set) {\n  Int   exponent=0;                \n  uByte bits=0;                    \n  Unit  *res;                      \n  Unit  resbuff[SD2U(DECBUFFER+9)];\n                                   \n  Unit  *allocres=NULL;            \n  Int   d=0;                       \n  const char *dotchar=NULL;        \n  const char *cfirst=chars;        \n  const char *last=NULL;           \n  const char *end=chars;\n  const char *c;                   \n  Unit  *up;                       \n  #if DECDPUN>1\n  Int   cut, out;                  \n  #endif\n  Int   residue;                   \n  uInt  status=0;                  \n\n  #if DECCHECK\n  if (decCheckOperands(DECUNRESU, DECUNUSED, DECUNUSED, set))\n    return decNumberZero(dn);\n  #endif\n\n  do {                             \n    for (c=chars;; c++) {          \n      if (*c>='0' && *c<='9') {    \n        last=c;\n        d++;                       \n        continue;                  \n        }\n      if (*c=='.' && dotchar==NULL) { \n        dotchar=c;                 \n        if (c==cfirst) cfirst++;   \n        continue;}\n      if (c==chars) {              \n        if (*c=='-') {             \n          cfirst++;\n          bits=DECNEG;\n          continue;}\n        if (*c=='+') {             \n          cfirst++;\n          continue;}\n        }\n      \n      break;\n      } \n\n    if (last==NULL) {              \n      status=DEC_Conversion_syntax;\n      if (*c=='\\0') break;         \n      #if DECSUBSET\n      \n      if (!set->extended) break;   \n      #endif\n      \n      if (dotchar!=NULL) break;    \n      decNumberZero(dn);           \n      if (decBiStr(c, \"infinity\", \"INFINITY\")\n       || decBiStr(c, \"inf\", \"INF\")) {\n        dn->bits=bits | DECINF;\n        status=0;                  \n        break; \n        }\n      \n      \n      dn->bits=bits | DECNAN;      \n      if (*c=='s' || *c=='S') {    \n        c++;\n        dn->bits=bits | DECSNAN;\n        }\n      if (*c!='n' && *c!='N') break;    \n      c++;\n      if (*c!='a' && *c!='A') break;    \n      c++;\n      if (*c!='n' && *c!='N') break;    \n      c++;\n      \n      \n      for (cfirst=c; *cfirst=='0';) cfirst++;\n      if (*cfirst=='\\0') {         \n        status=0;                  \n        break;                     \n        }\n      \n      for (c=cfirst;; c++, d++) {\n        if (*c<'0' || *c>'9') break; \n        last=c;\n        }\n      if (*c!='\\0') break;         \n      if (d>set->digits-1) {\n        \n        \n        if (set->clamp) break;\n        if (d>set->digits) break;\n        } \n      \n      status=0;                    \n      bits=dn->bits;               \n      } \n\n     else if (*c!='\\0') {          \n      \n      status=0;                    \n      end=c;                       \n      Flag nege;                   \n      const char *firstexp;        \n      if (*c!='e' && *c!='E') goto finalize;\n      \n      \n      nege=0;\n      c++;                         \n      if (*c=='-') {nege=1; c++;}\n       else if (*c=='+') c++;\n      if (*c<'0' || *c>'9') goto finalize;\n\n      for (; *c=='0' && *(c+1)!='\\0';) c++;  \n      firstexp=c;                            \n      for (; ;c++) {\n        if (*c<'0' || *c>'9') break;         \n        exponent=X10(exponent)+(Int)*c-(Int)'0';\n        } \n\n      end=c;\n\n      \n      \n      \n      if (c>=firstexp+9+1) {\n        if (c>firstexp+9+1 || *firstexp>'1') exponent=DECNUMMAXE*2;\n        \n        }\n      if (nege) exponent=-exponent;     \n      } \n\n      else end=c;\nfinalize:\n    \n    \n\n    \n    if (*cfirst=='0') {                 \n      for (c=cfirst; c<last; c++, cfirst++) {\n        if (*c=='.') continue;          \n        if (*c!='0') break;             \n        d--;                            \n        } \n      #if DECSUBSET\n      \n      if (*cfirst=='0' && !set->extended) {\n        decNumberZero(dn);              \n        break;                          \n        }\n      #endif\n      } \n\n    \n    if (dotchar!=NULL && dotchar<last)  \n      exponent-=(last-dotchar);         \n    \n\n    \n    \n    if (d<=set->digits) res=dn->lsu;    \n     else {                             \n      Int needbytes=D2U(d)*sizeof(Unit);\n      res=resbuff;                      \n      if (needbytes>(Int)sizeof(resbuff)) { \n        allocres=(Unit *)malloc(needbytes);\n        if (allocres==NULL) {status|=DEC_Insufficient_storage; break;}\n        res=allocres;\n        }\n      }\n    \n\n    \n    \n    #if DECDPUN>1\n    out=0;                         \n    up=res+D2U(d)-1;               \n    cut=d-(up-res)*DECDPUN;        \n    for (c=cfirst;; c++) {         \n      if (*c=='.') continue;       \n      out=X10(out)+(Int)*c-(Int)'0';\n      if (c==last) break;          \n      cut--;\n      if (cut>0) continue;         \n      *up=(Unit)out;               \n      up--;                        \n      cut=DECDPUN;                 \n      out=0;                       \n      } \n    *up=(Unit)out;                 \n\n    #else\n    \n    up=res;                        \n    for (c=last; c>=cfirst; c--) { \n      if (*c=='.') continue;       \n      *up=(Unit)((Int)*c-(Int)'0');\n      up++;\n      } \n    #endif\n\n    dn->bits=bits;\n    dn->exponent=exponent;\n    dn->digits=d;\n\n    \n    if (d>set->digits) {\n      residue=0;\n      decSetCoeff(dn, set, res, d, &residue, &status);\n      \n      decFinalize(dn, set, &residue, &status);\n      }\n     else { \n      \n      if ((dn->exponent-1<set->emin-dn->digits)\n       || (dn->exponent-1>set->emax-set->digits)) {\n        residue=0;\n        decFinalize(dn, set, &residue, &status);\n        }\n      }\n    \n    } while(0);                         \n\n  if (allocres!=NULL) free(allocres);   \n  if (status!=0) decStatus(dn, status, set);\n", "Selected Statement": "dn->bits=bits;", "Function Input": {"dn": {"value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x6d80\n", "message": "Cannot access memory at address 0x6d80"}}, "set": {"value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xb1f70292cecd0000\n", "message": "Cannot access memory at address 0xb1f70292cecd0000"}}}, "Variable Values Before Statement": {"bits": "0 '\\000'"}, "Value After Statement Execution": "0 '\\000'", "Project Information": "tarantool"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "                  int port,\n                  int use_ssl,\n                  char *error_buffer,\n                  size_t error_buffer_size)\n{\n\tstruct mg_client_options opts;\n\tstruct mg_init_data init;\n\tstruct mg_error_data error;\n\n\tmemset(&init, 0, sizeof(init));\n\n\tmemset(&error, 0, sizeof(error));\n\terror.text_buffer_size = error_buffer_size;\n\terror.text = error_buffer;\n\n\tmemset(&opts, 0, sizeof(opts));\n\topts.host = host;\n\topts.port = port;\n\tif (use_ssl) {\n\t\topts.host_name = host;\n\t}\n", "Selected Statement": "error.text = error_buffer;", "Function Input": {}, "Variable Values Before Statement": {"error_buffer": "0x7fffffffddf0 \"\\370\\261\\357\""}, "Value After Statement Execution": "0x7fffffffddf0 \"\\370\\261\\357\"", "Project Information": "civetweb"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\t\t\t\t\t\t\t  Size minContextSize,\n\t\t\t\t\t\t\t  Size initBlockSize,\n\t\t\t\t\t\t\t  Size maxBlockSize)\n{\n\tint\t\t\tfreeListIndex;\n\tSize\t\tfirstBlockSize;\n\tAllocSet\tset;\n\tAllocBlock\tblock;\n\n\t\n\tStaticAssertDecl(ALLOC_CHUNKHDRSZ == MAXALIGN(ALLOC_CHUNKHDRSZ),\n\t\t\t\t\t \"sizeof(MemoryChunk) is not maxaligned\");\n\t\n\tStaticAssertDecl(sizeof(AllocFreeListLink) <= (1 << ALLOC_MINBITS),\n\t\t\t\t\t \"sizeof(AllocFreeListLink) larger than minimum allocation size\");\n\n\t\n\tAssert(initBlockSize == MAXALIGN(initBlockSize) &&\n\t\t   initBlockSize >= 1024);\n\tAssert(maxBlockSize == MAXALIGN(maxBlockSize) &&\n\t\t   maxBlockSize >= initBlockSize &&\n\t\t   AllocHugeSizeIsValid(maxBlockSize)); \n\tAssert(minContextSize == 0 ||\n\t\t   (minContextSize == MAXALIGN(minContextSize) &&\n\t\t\tminContextSize >= 1024 &&\n\t\t\tminContextSize <= maxBlockSize));\n\tAssert(maxBlockSize <= MEMORYCHUNK_MAX_BLOCKOFFSET);\n\n\t\n\tif (minContextSize == ALLOCSET_DEFAULT_MINSIZE &&\n\t\tinitBlockSize == ALLOCSET_DEFAULT_INITSIZE)\n\t\tfreeListIndex = 0;\n\telse if (minContextSize == ALLOCSET_SMALL_MINSIZE &&\n\t\t\t initBlockSize == ALLOCSET_SMALL_INITSIZE)\n\t\tfreeListIndex = 1;\n\telse\n\t\tfreeListIndex = -1;\n\n\t\n\tif (freeListIndex >= 0)\n\t{\n\t\tAllocSetFreeList *freelist = &context_freelists[freeListIndex];\n\n\t\tif (freelist->first_free != NULL)\n\t\t{\n\t\t\t\n\t\t\tset = freelist->first_free;\n\t\t\tfreelist->first_free = (AllocSet) set->header.nextchild;\n\t\t\tfreelist->num_free--;\n\n\t\t\t\n\t\t\tset->maxBlockSize = maxBlockSize;\n\n\t\t\t\n\t\t\tMemoryContextCreate((MemoryContext) set,\n\t\t\t\t\t\t\t\tT_AllocSetContext,\n\t\t\t\t\t\t\t\tMCTX_ASET_ID,\n\t\t\t\t\t\t\t\tparent,\n\t\t\t\t\t\t\t\tname);\n\n\t\t\t((MemoryContext) set)->mem_allocated =\n\t\t\t\tset->keeper->endptr - ((char *) set);\n\n\t\t\treturn (MemoryContext) set;\n\t\t}\n\t}\n\n\t\n\tfirstBlockSize = MAXALIGN(sizeof(AllocSetContext)) +\n\t\tALLOC_BLOCKHDRSZ + ALLOC_CHUNKHDRSZ;\n\tif (minContextSize != 0)\n\t\tfirstBlockSize = Max(firstBlockSize, minContextSize);\n\telse\n\t\tfirstBlockSize = Max(firstBlockSize, initBlockSize);\n\n\t\n\tset = (AllocSet) malloc(firstBlockSize);\n\tif (set == NULL)\n\t{\n\t\tif (TopMemoryContext)\n\t\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed while creating memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   name)));\n\t}\n\n\t\n\n\t\n\tblock = (AllocBlock) (((char *) set) + MAXALIGN(sizeof(AllocSetContext)));\n\tblock->aset = set;\n\tblock->freeptr = ((char *) block) + ALLOC_BLOCKHDRSZ;\n\tblock->endptr = ((char *) set) + firstBlockSize;\n\tblock->prev = NULL;\n\tblock->next = NULL;\n\n\t\n\tVALGRIND_MAKE_MEM_NOACCESS(block->freeptr, block->endptr - block->freeptr);\n\n\t\n\tset->blocks = block;\n\t\n\tset->keeper = block;\n\n\t\n\tMemSetAligned(set->freelist, 0, sizeof(set->freelist));\n\n\tset->initBlockSize = initBlockSize;\n\tset->maxBlockSize = maxBlockSize;\n\tset->nextBlockSize = initBlockSize;\n\tset->freeListIndex = freeListIndex;\n\n\t\n\tStaticAssertStmt(ALLOC_CHUNK_LIMIT == ALLOCSET_SEPARATE_THRESHOLD,\n\t\t\t\t\t \"ALLOC_CHUNK_LIMIT != ALLOCSET_SEPARATE_THRESHOLD\");\n\n\t\n\tset->allocChunkLimit = ALLOC_CHUNK_LIMIT;\n\twhile ((Size) (set->allocChunkLimit + ALLOC_CHUNKHDRSZ) >\n\t\t   (Size) ((maxBlockSize - ALLOC_BLOCKHDRSZ) / ALLOC_CHUNK_FRACTION))\n\t\tset->allocChunkLimit >>= 1;\n\n\t\n\tMemoryContextCreate((MemoryContext) set,\n\t\t\t\t\t\tT_AllocSetContext,\n\t\t\t\t\t\tMCTX_ASET_ID,\n\t\t\t\t\t\tparent,\n\t\t\t\t\t\tname);\n\n\t((MemoryContext) set)->mem_allocated = firstBlockSize;\n\n\treturn (MemoryContext) set;\n", "Selected Statement": "set->initBlockSize = initBlockSize;", "Function Input": {}, "Variable Values Before Statement": {"initBlockSize": "Size"}, "Value After Statement Execution": "Size", "Project Information": "libpg_query"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": " */\nvoid\ninitStringInfo(StringInfo str)\n{\n\tint\t\t\tsize = 1024;\t\n\n\tstr->data = (char *) palloc(size);\n\tstr->maxlen = size;\n\tresetStringInfo(str);\n", "Selected Statement": "str->maxlen = size;", "Function Input": {"str": {"value": "<optimized out>"}}, "Variable Values Before Statement": {"size": "int"}, "Value After Statement Execution": "int", "Project Information": "libpg_query"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nint\npg_vsnprintf(char *str, size_t count, const char *fmt, va_list args)\n{\n\tPrintfTarget target;\n\tchar\t\tonebyte[1];\n\n\t\n\tif (count == 0)\n\t{\n\t\tstr = onebyte;\n\t\tcount = 1;\n\t}\n\ttarget.bufstart = target.bufptr = str;\n\ttarget.bufend = str + count - 1;\n\ttarget.stream = NULL;\n\ttarget.nchars = 0;\n\ttarget.failed = false;\n\tdopr(&target, fmt, args);\n\t*(target.bufptr) = '\\0';\n", "Selected Statement": "target.bufstart = target.bufptr = str;", "Function Input": {"count": {"value": "<optimized out>"}, "fmt": {"value": "<optimized out>"}, "str": {"value": "<optimized out>"}}, "Variable Values Before Statement": {"str": "0x11ad798 \"\""}, "Value After Statement Execution": "0x11ad798 \"\"", "Project Information": "libpg_query"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": " * error.\n */\nblkid_probe blkid_new_probe_from_filename(const char *filename)\n{\n\tint fd;\n\tblkid_probe pr = NULL;\n\n\tfd = open(filename, O_RDONLY|O_CLOEXEC|O_NONBLOCK);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tpr = blkid_new_probe();\n\tif (!pr)\n\t\tgoto err;\n\n\tif (blkid_probe_set_device(pr, fd, 0, 0))\n\t\tgoto err;\n\n\tpr->flags |= BLKID_FL_PRIVATE_FD;\n\treturn pr;\nerr:\n\tclose(fd);\n\tblkid_free_probe(pr);\n\treturn NULL;\n", "Selected Statement": "pr->flags |= BLKID_FL_PRIVATE_FD;", "Function Input": {}, "Variable Values Before Statement": {"BLKID_FL_PRIVATE_FD": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "util-linux"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": " * Returns: 0 on success, or -1 in case of error.\n */\nint blkid_probe_enable_partitions(blkid_probe pr, int enable)\n{\n\tpr->chains[BLKID_CHAIN_PARTS].enabled = enable;\n", "Selected Statement": "pr->chains[BLKID_CHAIN_PARTS].enabled = enable;", "Function Input": {"enable": {"value": "32767"}, "pr": {"value": "0xff0320"}}, "Variable Values Before Statement": {"enable": "int"}, "Value After Statement Execution": "int", "Project Information": "util-linux"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": " * Returns: 0 on success, or -1 in case of error.\n */\nint blkid_probe_enable_superblocks(blkid_probe pr, int enable)\n{\n\tpr->chains[BLKID_CHAIN_SUBLKS].enabled = enable;\n", "Selected Statement": "pr->chains[BLKID_CHAIN_SUBLKS].enabled = enable;", "Function Input": {"enable": {"value": "0"}, "pr": {"value": "0xff0320"}}, "Variable Values Before Statement": {"enable": "int"}, "Value After Statement Execution": "int", "Project Information": "util-linux"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": " * allocates BSD label driver\n */\nstruct fdisk_label *fdisk_new_bsd_label(struct fdisk_context *cxt __attribute__ ((__unused__)))\n{\n\tstruct fdisk_label *lb;\n\tstruct fdisk_bsd_label *bsd;\n\n\tbsd = calloc(1, sizeof(*bsd));\n\tif (!bsd)\n\t\treturn NULL;\n\n\t\n\tlb = (struct fdisk_label *) bsd;\n\tlb->name = \"bsd\";\n\tlb->id = FDISK_DISKLABEL_BSD;\n\tlb->op = &bsd_operations;\n\tlb->parttypes = bsd_fstypes;\n\tlb->nparttypes = ARRAY_SIZE(bsd_fstypes) - 1;\n\n\tlb->fields = bsd_fields;\n\tlb->nfields = ARRAY_SIZE(bsd_fields);\n\n\tlb->flags |= FDISK_LABEL_FL_INCHARS_PARTNO;\n\tlb->flags |= FDISK_LABEL_FL_REQUIRE_GEOMETRY;\n\n\t\n\treturn (struct fdisk_label *) bsd;\n", "Selected Statement": "lb->fields = bsd_fields;", "Function Input": {}, "Variable Values Before Statement": {"bsd_fields": "fdisk_field"}, "Value After Statement Execution": "fdisk_field", "Project Information": "util-linux"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": " * Returns: 0 on success, negative number in case of error.\n */\nint mnt_table_parse_stream(struct libmnt_table *tb, FILE *f, const char *filename)\n{\n\tint rc = -1;\n\tint flags = 0;\n\tpid_t tid = -1;\n\tstruct libmnt_parser pa = { .line = 0 };\n\n\tassert(tb);\n\tassert(f);\n\tassert(filename);\n\n\tDBG(TAB, ul_debugobj(tb, \"%s: start parsing [entries=%d, filter=%s]\",\n\t\t\t\tfilename, mnt_table_get_nents(tb),\n\t\t\t\ttb->fltrcb ? \"yes\" : \"not\"));\n\n\tpa.filename = filename;\n\tpa.f = f;\n\n\t\n\tif (tb->fmt == MNT_FMT_SWAPS)\n\t\tflags = MNT_FS_SWAP;\n\telse if (filename && strcmp(filename, _PATH_PROC_MOUNTS) == 0)\n\t\tflags = MNT_FS_KERNEL;\n\n\tdo {\n\t\tstruct libmnt_fs *fs;\n\n\t\tif (feof(f)) {\n\t\t\tDBG(TAB, ul_debugobj(tb, \"end-of-file\"));\n\t\t\tbreak;\n\t\t}\n\t\tfs = mnt_new_fs();\n\t\tif (!fs)\n\t\t\tgoto err;\n\n\t\t\n\t\trc = mnt_table_parse_next(&pa, tb, fs);\n\n\t\tif (rc == 0 && tb->fltrcb && tb->fltrcb(fs, tb->fltrcb_data))\n\t\t\trc = 1;\t\n\n\t\tif (rc == 0 && mnt_table_is_noautofs(tb)) {\n\t\t\tconst char *fstype = mnt_fs_get_fstype(fs);\n\n\t\t\tif (fstype && strcmp(fstype, \"autofs\") == 0 &&\n\t\t\t    mnt_fs_get_option(fs, \"ignore\", NULL, NULL) == 0)\n\t\t\t\trc = 1; \n\t\t}\n\n\t\t\n\t\tif (rc == 0) {\n\t\t\trc = mnt_table_add_fs(tb, fs);\n\t\t\tfs->flags |= flags;\n\n\t\t\tif (rc == 0 && tb->fmt == MNT_FMT_MOUNTINFO) {\n\t\t\t\trc = kernel_fs_postparse(&pa, tb, fs, &tid);\n\t\t\t\tif (rc)\n\t\t\t\t\tmnt_table_remove_fs(tb, fs);\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tmnt_unref_fs(fs);\n\n\t\t\n\t\tif (rc > 0) {\n\t\t\tDBG(TAB, ul_debugobj(tb, \"recoverable error (continue)\"));\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (rc < 0 && !feof(f)) {\n\t\t\tDBG(TAB, ul_debugobj(tb, \"fatal error\"));\n\t\t\tgoto err;\n\t\t}\n\t} while (1);\n\n\tDBG(TAB, ul_debugobj(tb, \"%s: stop parsing (%d entries)\",\n\t\t\t\tfilename, mnt_table_get_nents(tb)));\n\tparser_cleanup(&pa);\n\treturn 0;\nerr:\n\tDBG(TAB, ul_debugobj(tb, \"%s: parse error (rc=%d)\", filename, rc));\n\tparser_cleanup(&pa);\n\treturn rc;\n", "Selected Statement": "pa.filename = filename;", "Function Input": {}, "Variable Values Before Statement": {"filename": "0x5cd211 \"mountinfo\""}, "Value After Statement Execution": "0x5cd211 \"mountinfo\"", "Project Information": "util-linux"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": " * Returns mallocated buffer or NULL in case of error.\n */\nchar *unmangle(const char *s, const char **end)\n{\n\tchar *buf;\n\tconst char *e;\n\tsize_t sz;\n\n\tif (!s)\n\t\treturn NULL;\n\n\te = skip_nonspaces(s);\n\tsz = e - s + 1;\n\n\tif (end)\n\t\t*end = e;\n\tif (e == s)\n\t\treturn NULL;\t\n\n\tbuf = malloc(sz);\n\tif (!buf)\n\t\treturn NULL;\n\n\tunmangle_to_buffer(s, buf, sz);\n\treturn buf;\n", "Selected Statement": "*end = e;", "Function Input": {"buf": {"value": "0x655800 <fuzzer::TPC> \"\""}, "s": {"value": "0x1055340 \"\\210$\\255\\373\""}}, "Variable Values Before Statement": {"e": "0x1056ca1 \"\""}, "Value After Statement Execution": "0x1056ca1 \"\"", "Project Information": "util-linux"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "APR_DECLARE(apr_status_t) apr_thread_mutex_create(apr_thread_mutex_t **mutex,\n                                                  unsigned int flags,\n                                                  apr_pool_t *pool)\n{\n    apr_thread_mutex_t *new_mutex;\n    apr_status_t rv;\n\n#ifndef HAVE_PTHREAD_MUTEX_RECURSIVE\n    if (flags & APR_THREAD_MUTEX_NESTED) {\n        return APR_ENOTIMPL;\n    }\n#endif\n\n    new_mutex = apr_pcalloc(pool, sizeof(apr_thread_mutex_t));\n    new_mutex->pool = pool;\n\n#ifdef HAVE_PTHREAD_MUTEX_RECURSIVE\n    if (flags & APR_THREAD_MUTEX_NESTED) {\n        pthread_mutexattr_t mattr;\n\n        rv = pthread_mutexattr_init(&mattr);\n        if (rv) return rv;\n\n        rv = pthread_mutexattr_settype(&mattr, PTHREAD_MUTEX_RECURSIVE);\n        if (rv) {\n            pthread_mutexattr_destroy(&mattr);\n            return rv;\n        }\n\n        rv = pthread_mutex_init(&new_mutex->mutex, &mattr);\n\n        pthread_mutexattr_destroy(&mattr);\n    } else\n#endif\n    {\n#if defined(APR_THREAD_DEBUG)\n        pthread_mutexattr_t mattr;\n\n        rv = pthread_mutexattr_init(&mattr);\n        if (rv) return rv;\n\n        rv = pthread_mutexattr_settype(&mattr, PTHREAD_MUTEX_ERRORCHECK);\n        if (rv) {\n            pthread_mutexattr_destroy(&mattr);\n            return rv;\n        }\n\n        rv = pthread_mutex_init(&new_mutex->mutex, &mattr);\n\n        pthread_mutexattr_destroy(&mattr);\n#else\n        rv = pthread_mutex_init(&new_mutex->mutex, NULL);\n#endif\n    }\n\n    if (rv) {\n#ifdef HAVE_ZOS_PTHREADS\n        rv = errno;\n#endif\n        return rv;\n    }\n\n#ifndef HAVE_PTHREAD_MUTEX_TIMEDLOCK\n    if (flags & APR_THREAD_MUTEX_TIMED) {\n        rv = apr_thread_cond_create(&new_mutex->cond, pool);\n        if (rv) {\n#ifdef HAVE_ZOS_PTHREADS\n            rv = errno;\n#endif\n            pthread_mutex_destroy(&new_mutex->mutex);\n            return rv;\n        }\n    }\n#endif\n\n    apr_pool_cleanup_register(new_mutex->pool,\n                              new_mutex, thread_mutex_cleanup,\n                              apr_pool_cleanup_null);\n\n    *mutex = new_mutex;\n    return APR_SUCCESS;\n", "Selected Statement": "*mutex = new_mutex;", "Function Input": {}, "Variable Values Before Statement": {"new_mutex": {"pool": null, "mutex": "{__data = {__lock = 0, __count = 0, __owner = 0, __nusers = 0, __kind = 1, __spins = 0, __elision = 0, __list = {__prev = 0x0, __next = 0x0}}, __size = '\\000' &lt;repeats 16 times&gt;, \"\\001\", '\\000' &lt;repeats 22 times&gt;, __align = 0}"}}, "Value After Statement Execution": {"pool": null, "mutex": "{__data = {__lock = 0, __count = 0, __owner = 0, __nusers = 0, __kind = 1, __spins = 0, __elision = 0, __list = {__prev = 0x0, __next = 0x0}}, __size = '\\000' &lt;repeats 16 times&gt;, \"\\001\", '\\000' &lt;repeats 22 times&gt;, __align = 0}"}, "Project Information": "apache-httpd"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "APR_DECLARE(apr_status_t) apr_tokenize_to_argv(const char *arg_str,\n                                            char ***argv_out,\n                                            apr_pool_t *token_context)\n{\n    const char *cp;\n    const char *ct;\n    char *cleaned, *dirty;\n    int escaped;\n    int isquoted, numargs = 0, argnum;\n\n#define SKIP_WHITESPACE(cp) \\\n    for ( ; *cp == ' ' || *cp == '\\t'; ) { \\\n        cp++; \\\n    };\n\n#define CHECK_QUOTATION(cp,isquoted) \\\n    isquoted = 0; \\\n    if (*cp == '\"') { \\\n        isquoted = 1; \\\n        cp++; \\\n    } \\\n    else if (*cp == '\\'') { \\\n        isquoted = 2; \\\n        cp++; \\\n    }\n\n\n#define DETERMINE_NEXTSTRING(cp,isquoted) \\\n    for ( ; *cp != '\\0'; cp++) { \\\n        if (   (*cp == '\\\\' && (*(cp+1) == ' ' || *(cp+1) == '\\t' || \\\n                                *(cp+1) == '\"' || *(cp+1) == '\\''))) { \\\n            cp++; \\\n            continue; \\\n        } \\\n        if (   (!isquoted && (*cp == ' ' || *cp == '\\t')) \\\n            || (isquoted == 1 && *cp == '\"') \\\n            || (isquoted == 2 && *cp == '\\'')                 ) { \\\n            break; \\\n        } \\\n    }\n\n\n#define REMOVE_ESCAPE_CHARS(cleaned, dirty, escaped) \\\n    escaped = 0; \\\n    while(*dirty) { \\\n        if (!escaped && *dirty == '\\\\') { \\\n            escaped = 1; \\\n        } \\\n        else { \\\n            escaped = 0; \\\n            *cleaned++ = *dirty; \\\n        } \\\n        ++dirty; \\\n    } \\\n    *cleaned = 0;        \n\n    cp = arg_str;\n    SKIP_WHITESPACE(cp);\n    ct = cp;\n\n    \n    numargs = 1;\n    while (*ct != '\\0') {\n        CHECK_QUOTATION(ct, isquoted);\n        DETERMINE_NEXTSTRING(ct, isquoted);\n        if (*ct != '\\0') {\n            ct++;\n        }\n        numargs++;\n        SKIP_WHITESPACE(ct);\n    }\n    *argv_out = apr_palloc(token_context, numargs * sizeof(char*));\n\n    \n    for (argnum = 0; argnum < (numargs-1); argnum++) {\n        SKIP_WHITESPACE(cp);\n        CHECK_QUOTATION(cp, isquoted);\n        ct = cp;\n        DETERMINE_NEXTSTRING(cp, isquoted);\n        cp++;\n        (*argv_out)[argnum] = apr_palloc(token_context, cp - ct);\n        apr_cpystrn((*argv_out)[argnum], ct, cp - ct);\n        cleaned = dirty = (*argv_out)[argnum];\n        REMOVE_ESCAPE_CHARS(cleaned, dirty, escaped);\n    }\n    (*argv_out)[argnum] = NULL;\n\n", "Selected Statement": "cp = arg_str;", "Function Input": {}, "Variable Values Before Statement": {"arg_str": "0x11a1670 \"\""}, "Value After Statement Execution": "0x11a1670 \"\"", "Project Information": "apache-httpd"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "nxt_mp_t *\nnxt_mp_create(size_t cluster_size, size_t page_alignment, size_t page_size,\n    size_t min_chunk_size)\n{\n    nxt_mp_t     *mp;\n    uint32_t     pages, chunk_size_shift, page_size_shift;\n    nxt_queue_t  *chunk_pages;\n\n    chunk_size_shift = nxt_lg2(min_chunk_size);\n    page_size_shift = nxt_lg2(page_size);\n\n    pages = page_size_shift - chunk_size_shift;\n\n    mp = nxt_zalloc(sizeof(nxt_mp_t) + pages * sizeof(nxt_queue_t));\n\n    if (nxt_fast_path(mp != NULL)) {\n        mp->retain = 1;\n        mp->chunk_size_shift = chunk_size_shift;\n        mp->page_size_shift = page_size_shift;\n        mp->page_size = page_size;\n        mp->page_alignment = nxt_max(page_alignment, NXT_MAX_ALIGNMENT);\n        mp->cluster_size = cluster_size;\n\n        chunk_pages = mp->chunk_pages;\n\n        while (pages != 0) {\n            nxt_queue_init(chunk_pages);\n            chunk_pages++;\n            pages--;\n        }\n\n        nxt_queue_init(&mp->free_pages);\n        nxt_queue_init(&mp->nget_pages);\n        nxt_queue_init(&mp->get_pages);\n\n        nxt_rbtree_init(&mp->blocks, nxt_mp_rbtree_compare);\n    }\n\n    nxt_debug_alloc(\"mp %p create(%uz, %uz, %uz, %uz)\", mp, cluster_size,\n                    page_alignment, page_size, min_chunk_size);\n\n", "Selected Statement": "mp->page_size_shift = page_size_shift;", "Function Input": {}, "Variable Values Before Statement": {"page_size_shift": "8"}, "Value After Statement Execution": "8", "Project Information": "unit"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nvoid nxt_cdecl\nnxt_log_handler(nxt_uint_t level, nxt_log_t *log, const char *fmt, ...)\n{\n    u_char   *p, *end;\n#if 0\n    u_char   *syslogmsg;\n#endif\n    va_list  args;\n    u_char   msg[NXT_MAX_ERROR_STR];\n\n    p = msg;\n    end = msg + NXT_MAX_ERROR_STR;\n\n    if (nxt_log_prefix != NULL) {\n        p = nxt_cpystrn(p, nxt_log_prefix, end - p);\n        *p++ = ':';\n        *p++ = ' ';\n    }\n\n#if 0\n    syslogmsg = p;\n#endif\n\n    p = nxt_sprintf(p, end, (log->ident != 0) ? \"[%V] *%D \" : \"[%V] \",\n                    &nxt_log_levels[level], log->ident);\n\n    va_start(args, fmt);\n    p = nxt_vsprintf(p, end, fmt, args);\n    va_end(args);\n\n    if (level != NXT_LOG_DEBUG && log->ctx_handler != NULL) {\n        p = log->ctx_handler(log->ctx, p, end);\n    }\n\n    if (p > end - nxt_length(\"\\n\")) {\n        p = end - nxt_length(\"\\n\");\n    }\n\n    *p++ = '\\n';\n\n    (void) nxt_write_console(nxt_stderr, msg, p - msg);\n\n#if 0\n    if (level == NXT_LOG_ALERT) {\n        *(p - nxt_length(\"\\n\")) = '\\0';\n\n        \n        nxt_write_syslog(LOG_ALERT, syslogmsg);\n    }\n#endif\n", "Selected Statement": "p = msg;", "Function Input": {}, "Variable Values Before Statement": {"msg": "\"x\\000\\000\\000\\000\\000\\000\\000\\346o\\254\\367\\377\\177\\000\\000\\002\\000\\000\\000\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\240\\210\\303\\367\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000r\\334\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\377\\000\\377\\377\\377\\377\\377\\377\\377\\377\\000\\000\\000\\000\\000\\000\\000\\000\\001\\000\\000\\000\\000\\000\\000\\000\\020\\000\\000\\000\\000\\000\\000\\000\\225\\000\\000\\000\\000\\000\\000\\000 \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\377\\177\\000\\000\\002\\000\\000\\000\\000\\000\\000\\000r\\334\\377\\377\\377\\177\\000\\000\\002\\000\\000\\000\\000\\000\\000\\000\\002\\000\\000\\000\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\240\\210\\303\\367\\377\\177\\000\\000h\\r\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000p\\334\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000dir, corpus)\\000rb\\000\\000\\000\\000\\000\\000\\000\\000\\000 \\000\\000\\0000\\000\\000\\000`\\334\\377\\377\\377\\177\\000\\000\\200\\333\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\002\\000\\000\\000\\000\\000\\000\\000\\356\\000\\000\\000\\000\\000\\000\\200\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\002\\000\\000\\000\\000\\000\\000\\000\\356\\000\\000\\000\\000\\000\\000\\200\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\002\\000\\000\\000\\000\\000\\000\\000\\356\\000\\000\\000\\000\\000\\000\\200\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\327\\377\\365\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\327\\377\\365\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000G\\000\\000\\000H\\000\\000\\000M\\000\\000\\000\\001\\000\\000\\000\\000\\000\\000\\000\\000\\200\\037\\000\\000\\377\\377\\000\\000side use -detect\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\002\\000\\000\\000\\000\\000\\000\\000\\356\\000\\000\\000\\000\\000\\000\\200\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\323G\\366TPf)\\002\\000\\000\\000\\000\\000\\000\\000\\360\\334\\377\\377\\377\\177\\000\\000\\300\\325\\303\\367\\377\\177\\000\\000\\234`[\\000\\000\\000\\000\\000\\260\\335\\377\\377\\377\\177\\000\\000$m\\254\\367\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\020\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\200\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\020\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000G\\000\\000\\000H\\000\\000\\000M\\000\\000\\000\\001\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000dside use\\000\\323G\\366TPf)\\002\\000\\000\\000\\000\\000\\000\\000\\220\\335\\377\\377\\377\\177\\000\\000\\300\\325\\303\\367\\377\\177\\000\\000\\3113[\\000\\000\\000\\000\\000P\\336\\377\\377\\377\\177\\000\\000$m\\254\\367\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\377\\177\\000\\000g\\333\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000g\\333\\377\\377\\377\\177\\000\\000\\260\\330\\377\\377\\377\\17795\\000\\323G\\366TPf)P\\333\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\027\\000\\000\\000\\000\\000\\000\\000\\260\\330\\377\\377\\377\\177\\000\\000@\\333\\377\\377\\377\\177\\000\\0000\\332\\377\\377\\377\\177\\000\\000P\\333\\377\\377\\377\\177\\000\\000\\232\\277\\255\\367\\377\\177\\000\\000\\000 \\304\\367\\377\\177\\000\\000\\240\\331\\377\\377\\377\\177\\000\\000\\001\\200\\255\\373\\000\\000\\000\\000P\\333\\377\\377\\377\\177\\000\\000P\\333\\377\\377\\377\\177\\000\\000P\\333\\377\\377\\377\\177\\000\\000\\360\\333\\377\\377\\377\\177\\000\\000\\a\\334\\377\\377\\377\\177\\000\\000g\\333\\377\\377\\377\\177\\000\\000\\a\\334\\377\\377\\377\\177\\000\\000P\\331\\377\\377\\377\\17795\\000\\323G\\366TPf)\\360\\333\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\027\\000\\000\\000\\000\\000\\000\\000P\\331\\377\\377\\377\\177\\000\\000\\340\\333\\377\\377\\377\\177\\000\\000\\320\\332\\377\\377\\377\\177\\000\\000\\360\\333\\377\\377\\377\\177\\000\\000\\232\\277\\255\\367\\377\\177\\000\\000\\300\\325\\303\\367\\377\\177\\000\\000@\\332\\377\\377\\377\\177\\000\\000\\001\\200\\255\\373\\377\\377\\377\\377\\360\\333\\377\\377\\377\\177\\000\\000\\200\\334\\377\\377\\377\\177\\000\\000\\227\\334\\377\\377\\377\\177\\000\\000\\360\\333\\377\\377\\377\\177\\000\\000\\227\\334\\377\\377\\377\\177\\000\\000\\340\\331\\377\\377\\377\\17795\\000\\323G\\366TPf)\\200\\334\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\027\\000\\000\\000\\000\\000\\000\\000\\340\\331\\377\\377\\377\\177\\000\\000p\\334\\377\\377\\377\\177\\000\\000`\\333\\377\\377\\377\\177\\000\\000\\200\\334\\377\\377\\377\\177\\000\\000\\232\\277\\255\\367\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\320\\332\\377\\377\\377\\177\\000\\000\\001\\200\\255\\373\\000\\000\\000\\000\\200\\334\\377\\377\\377\\177\\000\\000\\200\\334\\377\\377\\377\\177\\000\\000\\200\\334\\377\\377\\377\\177\\000\\000\\200\\334\\377\\377\\377\\177\\000\\000\\202\\334\\377\\377\\377\\177\\000\\000\\227\\334\\377\\377\\377\\177\\000\\000\\200\\334\\377\\377\\377\\177\\000\\000\\227\\334\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000H7b\\000\\200\\000\\000\\000\\240\\332\\377\\377\\377\\177\\000\\000\\000\\000i\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\0000\\000\\000\\000\\000\\000\\000\\0000\\000\\000\\000\\000\\000\\000\\000\\377\\377\\377\\377\\377\\377\\377\\377\\000\\000\\000\\000\\000\\000\\000\\000,\\000\\000\\000\\000\\000\\000\\000\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\177\\000\\000\\360\\333\\377\\377\\377\\177\\000\\000X\\335\\377\\377\\377\\177\\000\\000\\240\\221\\303\\367\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\n\\204\\256\\367\\377\\177\\000\\000\\020\\302\\a\\001\\000\\000\\000\\000\\340\\313\\303\\367\\377\\177\\000\\000\\a\\000\\000\\000\\000\\000\\000\\000\\016\\242\\005\\001\\000\\000\\000\\000\\000\\020\\000\\000\\000\\000\\000\\000c\\000\\000\\000\\377\\177\\000\\000\\b\\250\\005\\001\\000\\000\\000\\0000\\020\\000\\000\\000\\000\\000\\000@\\000\\000\\000\\000\\000\\000\\000\\001\\001\\000\\000p\\000\\000\\000\\b\\000\\000\\000\\000\\000\\000\\000\\001\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000|\\000\\000\\000w\\000\\000\\000o\\000\\000\\000c\\000\\000\\000p\\334\\377\\377\\377\\177\\000\\000\\030\\000\\000\\000\\000\\000\\000\\000\\377\\000\\000\\000\\000\\000\\000\\000\\000\\020\\000\\000\\000\\000\\000\\000\\200\\313\\303\\367\\377\\177\\000\\000\\002\\000\\000\\000\\000\\000\\000\\000\\377\\377\\377\\377\\377\\377\\377\\377 \\302\\a\\001\\000\\000\\000\\000 \\322\\a\\001\\000\\000\\000\\000\\000\\020\\000\\000\\000\\000\\000\\000\\000\\020\\000\\000\\000\\000\\000\\000\\240Q\\a\\001\\000\\000\\000\\000\\035\\035\\255\\367\\377\\177\\000\\000\\000\\375\\000\\000\\000\\000\\000\\000q\\002T\\006\\000\\000\\000\\000\\001\\000\\000\\000\\000\\000\\000\\000\\244\\201\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\002\\000\\000\\000\\000\\000\\000\\000\\000\\020\\000\\000\\000\\000\\000\\000\\b\\000\\000\\000\\000\\000\\000\\000\\203\\023@f\\000\\000\\000\\000h\\315\\323\\t\\000\\000\\000\\000\\203\\023@f\\000\\000\\000\\000\\177rq\\a\\000\\000\\000\\000\\203\\023@f\\000\\000\\000\\000\\177rq\\a\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\""}, "Value After Statement Execution": "\"x\\000\\000\\000\\000\\000\\000\\000\\346o\\254\\367\\377\\177\\000\\000\\002\\000\\000\\000\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\240\\210\\303\\367\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000r\\334\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\377\\000\\377\\377\\377\\377\\377\\377\\377\\377\\000\\000\\000\\000\\000\\000\\000\\000\\001\\000\\000\\000\\000\\000\\000\\000\\020\\000\\000\\000\\000\\000\\000\\000\\225\\000\\000\\000\\000\\000\\000\\000 \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\377\\177\\000\\000\\002\\000\\000\\000\\000\\000\\000\\000r\\334\\377\\377\\377\\177\\000\\000\\002\\000\\000\\000\\000\\000\\000\\000\\002\\000\\000\\000\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\240\\210\\303\\367\\377\\177\\000\\000h\\r\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000p\\334\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000dir, corpus)\\000rb\\000\\000\\000\\000\\000\\000\\000\\000\\000 \\000\\000\\0000\\000\\000\\000`\\334\\377\\377\\377\\177\\000\\000\\200\\333\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\002\\000\\000\\000\\000\\000\\000\\000\\356\\000\\000\\000\\000\\000\\000\\200\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\002\\000\\000\\000\\000\\000\\000\\000\\356\\000\\000\\000\\000\\000\\000\\200\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\002\\000\\000\\000\\000\\000\\000\\000\\356\\000\\000\\000\\000\\000\\000\\200\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\327\\377\\365\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\327\\377\\365\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000G\\000\\000\\000H\\000\\000\\000M\\000\\000\\000\\001\\000\\000\\000\\000\\000\\000\\000\\000\\200\\037\\000\\000\\377\\377\\000\\000side use -detect\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\002\\000\\000\\000\\000\\000\\000\\000\\356\\000\\000\\000\\000\\000\\000\\200\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\323G\\366TPf)\\002\\000\\000\\000\\000\\000\\000\\000\\360\\334\\377\\377\\377\\177\\000\\000\\300\\325\\303\\367\\377\\177\\000\\000\\234`[\\000\\000\\000\\000\\000\\260\\335\\377\\377\\377\\177\\000\\000$m\\254\\367\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\020\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\200\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\020\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000G\\000\\000\\000H\\000\\000\\000M\\000\\000\\000\\001\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000dside use\\000\\323G\\366TPf)\\002\\000\\000\\000\\000\\000\\000\\000\\220\\335\\377\\377\\377\\177\\000\\000\\300\\325\\303\\367\\377\\177\\000\\000\\3113[\\000\\000\\000\\000\\000P\\336\\377\\377\\377\\177\\000\\000$m\\254\\367\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\377\\177\\000\\000g\\333\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000g\\333\\377\\377\\377\\177\\000\\000\\260\\330\\377\\377\\377\\17795\\000\\323G\\366TPf)P\\333\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\027\\000\\000\\000\\000\\000\\000\\000\\260\\330\\377\\377\\377\\177\\000\\000@\\333\\377\\377\\377\\177\\000\\0000\\332\\377\\377\\377\\177\\000\\000P\\333\\377\\377\\377\\177\\000\\000\\232\\277\\255\\367\\377\\177\\000\\000\\000 \\304\\367\\377\\177\\000\\000\\240\\331\\377\\377\\377\\177\\000\\000\\001\\200\\255\\373\\000\\000\\000\\000P\\333\\377\\377\\377\\177\\000\\000P\\333\\377\\377\\377\\177\\000\\000P\\333\\377\\377\\377\\177\\000\\000\\360\\333\\377\\377\\377\\177\\000\\000\\a\\334\\377\\377\\377\\177\\000\\000g\\333\\377\\377\\377\\177\\000\\000\\a\\334\\377\\377\\377\\177\\000\\000P\\331\\377\\377\\377\\17795\\000\\323G\\366TPf)\\360\\333\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\027\\000\\000\\000\\000\\000\\000\\000P\\331\\377\\377\\377\\177\\000\\000\\340\\333\\377\\377\\377\\177\\000\\000\\320\\332\\377\\377\\377\\177\\000\\000\\360\\333\\377\\377\\377\\177\\000\\000\\232\\277\\255\\367\\377\\177\\000\\000\\300\\325\\303\\367\\377\\177\\000\\000@\\332\\377\\377\\377\\177\\000\\000\\001\\200\\255\\373\\377\\377\\377\\377\\360\\333\\377\\377\\377\\177\\000\\000\\200\\334\\377\\377\\377\\177\\000\\000\\227\\334\\377\\377\\377\\177\\000\\000\\360\\333\\377\\377\\377\\177\\000\\000\\227\\334\\377\\377\\377\\177\\000\\000\\340\\331\\377\\377\\377\\17795\\000\\323G\\366TPf)\\200\\334\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\027\\000\\000\\000\\000\\000\\000\\000\\340\\331\\377\\377\\377\\177\\000\\000p\\334\\377\\377\\377\\177\\000\\000`\\333\\377\\377\\377\\177\\000\\000\\200\\334\\377\\377\\377\\177\\000\\000\\232\\277\\255\\367\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\320\\332\\377\\377\\377\\177\\000\\000\\001\\200\\255\\373\\000\\000\\000\\000\\200\\334\\377\\377\\377\\177\\000\\000\\200\\334\\377\\377\\377\\177\\000\\000\\200\\334\\377\\377\\377\\177\\000\\000\\200\\334\\377\\377\\377\\177\\000\\000\\202\\334\\377\\377\\377\\177\\000\\000\\227\\334\\377\\377\\377\\177\\000\\000\\200\\334\\377\\377\\377\\177\\000\\000\\227\\334\\377\\377\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000H7b\\000\\200\\000\\000\\000\\240\\332\\377\\377\\377\\177\\000\\000\\000\\000i\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\0000\\000\\000\\000\\000\\000\\000\\0000\\000\\000\\000\\000\\000\\000\\000\\377\\377\\377\\377\\377\\377\\377\\377\\000\\000\\000\\000\\000\\000\\000\\000,\\000\\000\\000\\000\\000\\000\\000\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\177\\000\\000\\360\\333\\377\\377\\377\\177\\000\\000X\\335\\377\\377\\377\\177\\000\\000\\240\\221\\303\\367\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\n\\204\\256\\367\\377\\177\\000\\000\\020\\302\\a\\001\\000\\000\\000\\000\\340\\313\\303\\367\\377\\177\\000\\000\\a\\000\\000\\000\\000\\000\\000\\000\\016\\242\\005\\001\\000\\000\\000\\000\\000\\020\\000\\000\\000\\000\\000\\000c\\000\\000\\000\\377\\177\\000\\000\\b\\250\\005\\001\\000\\000\\000\\0000\\020\\000\\000\\000\\000\\000\\000@\\000\\000\\000\\000\\000\\000\\000\\001\\001\\000\\000p\\000\\000\\000\\b\\000\\000\\000\\000\\000\\000\\000\\001\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000|\\000\\000\\000w\\000\\000\\000o\\000\\000\\000c\\000\\000\\000p\\334\\377\\377\\377\\177\\000\\000\\030\\000\\000\\000\\000\\000\\000\\000\\377\\000\\000\\000\\000\\000\\000\\000\\000\\020\\000\\000\\000\\000\\000\\000\\200\\313\\303\\367\\377\\177\\000\\000\\002\\000\\000\\000\\000\\000\\000\\000\\377\\377\\377\\377\\377\\377\\377\\377 \\302\\a\\001\\000\\000\\000\\000 \\322\\a\\001\\000\\000\\000\\000\\000\\020\\000\\000\\000\\000\\000\\000\\000\\020\\000\\000\\000\\000\\000\\000\\240Q\\a\\001\\000\\000\\000\\000\\035\\035\\255\\367\\377\\177\\000\\000\\000\\375\\000\\000\\000\\000\\000\\000q\\002T\\006\\000\\000\\000\\000\\001\\000\\000\\000\\000\\000\\000\\000\\244\\201\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\002\\000\\000\\000\\000\\000\\000\\000\\000\\020\\000\\000\\000\\000\\000\\000\\b\\000\\000\\000\\000\\000\\000\\000\\203\\023@f\\000\\000\\000\\000h\\315\\323\\t\\000\\000\\000\\000\\203\\023@f\\000\\000\\000\\000\\177rq\\a\\000\\000\\000\\000\\203\\023@f\\000\\000\\000\\000\\177rq\\a\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\"", "Project Information": "unit"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nvoid\nnxt_rbtree_init(nxt_rbtree_t *tree, nxt_rbtree_compare_t compare)\n{\n    \n\n    \n    tree->sentinel.left = &tree->sentinel;\n\n    \n    tree->sentinel.right = (void *) compare;\n\n    \n    tree->sentinel.color = NXT_RBTREE_BLACK;\n", "Selected Statement": "tree->sentinel.color = NXT_RBTREE_BLACK;", "Function Input": {"compare": {"value": "0x1074ed0"}, "tree": {"value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xa8\n", "message": "Cannot access memory at address 0xa8"}}}, "Variable Values Before Statement": {"NXT_RBTREE_BLACK": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "unit"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nnxt_int_t\nnxt_lib_start(const char *app, char **argv, char ***envp)\n{\n    int           n;\n    nxt_int_t     flags;\n    nxt_bool_t    update;\n    nxt_thread_t  *thread;\n\n    flags = nxt_stderr_start();\n\n    nxt_log_start(app);\n\n    nxt_pid = getpid();\n    nxt_ppid = getppid();\n    nxt_euid = geteuid();\n    nxt_egid = getegid();\n\n#if (NXT_DEBUG)\n\n    nxt_main_log.level = NXT_LOG_DEBUG;\n\n#if (NXT_HAVE_MALLOPT)\n    \n    mallopt(M_PERTURB, 0x55);\n#endif\n\n#if (NXT_MACOSX)\n    \n    setenv(\"MallocScribble\", \"1\", 0);\n#endif\n\n#endif \n\n    \n\n    nxt_thread_init_data(nxt_thread_context);\n    thread = nxt_thread();\n    thread->log = &nxt_main_log;\n\n    thread->handle = nxt_thread_handle();\n    thread->time.signal = -1;\n    nxt_thread_time_update(thread);\n\n    nxt_main_task.thread = thread;\n    nxt_main_task.log = thread->log;\n    nxt_main_task.ident = nxt_task_next_ident();\n\n    if (nxt_strerror_start() != NXT_OK) {\n        return NXT_ERROR;\n    }\n\n    if (flags != -1) {\n        nxt_debug(&nxt_main_task, \"stderr flags: 0x%04Xd\", flags);\n    }\n\n#ifdef _SC_NPROCESSORS_ONLN\n    \n    n = sysconf(_SC_NPROCESSORS_ONLN);\n\n#elif (NXT_HPUX)\n    n = mpctl(MPC_GETNUMSPUS, NULL, NULL);\n\n#else\n    n = 0;\n\n#endif\n\n    nxt_debug(&nxt_main_task, \"ncpu: %d\", n);\n\n    if (n > 1) {\n        nxt_ncpu = n;\n    }\n\n    nxt_thread_spin_init(nxt_ncpu, 0);\n\n    nxt_random_init(&thread->random);\n\n    nxt_pagesize = getpagesize();\n\n    nxt_debug(&nxt_main_task, \"pagesize: %ui\", nxt_pagesize);\n\n    if (argv != NULL) {\n        update = (argv[0] == app);\n\n        nxt_process_arguments(&nxt_main_task, argv, envp);\n\n        if (update) {\n            nxt_log_start(nxt_process_argv[0]);\n        }\n    }\n\n    return NXT_OK;\n", "Selected Statement": "nxt_main_task.thread = thread;", "Function Input": {"app": {"value": "0x622e00 <vtable for std::__Fuzzer::ios_base::failure+8> \"\\260.b\""}, "argv": {"value": {"type_category": "string", "concrete_type": "string", "value": "0x8c48348707e8b49 <error: Cannot access memory at address 0x8c48348707e8b49>"}}, "envp": {"value": null}}, "Variable Values Before Statement": {"thread": {"log": null, "main_log": null, "task": null, "tid": "0", "handle": "140737348164032", "link": null, "thread_pool": null, "time": null, "runtime": null, "engine": null, "data": null, "random": null}}, "Value After Statement Execution": {"log": null, "main_log": null, "task": null, "tid": "0", "handle": "140737348164032", "link": null, "thread_pool": null, "time": null, "runtime": null, "engine": null, "data": null, "random": null}, "Project Information": "unit"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nnxt_int_t\nnxt_strerror_start(void)\n{\n    char        *msg;\n    u_char      *p;\n    size_t      size, length, n;\n    nxt_uint_t  err, invalid;\n\n    \n    size = nxt_length(\"Unknown error\");\n\n    \n\n    for (invalid = 0; invalid < 100 && nxt_sys_nerr < 65536; nxt_sys_nerr++) {\n\n        nxt_set_errno(0);\n        msg = strerror((int) nxt_sys_nerr);\n\n        \n\n        if (msg == NULL) {\n            invalid++;\n            continue;\n        }\n\n        length = nxt_strlen(msg);\n        size += length;\n\n        if (length == 0  \n            || nxt_errno == NXT_EINVAL\n            || memcmp(msg, \"Unknown error\", 13) == 0)\n        {\n            invalid++;\n            continue;\n        }\n\n#if (NXT_AIX)\n\n        if (memcmp(msg, \"Error \", 6) == 0\n            && memcmp(msg + length - 10, \" occurred.\", 9) == 0)\n        {\n            invalid++;\n            continue;\n        }\n\n#endif\n    }\n\n    nxt_sys_nerr -= invalid;\n\n    nxt_main_log_debug(\"sys_nerr: %d\", nxt_sys_nerr);\n\n    n = (nxt_sys_nerr + 1) * sizeof(nxt_str_t);\n\n    nxt_sys_errlist = nxt_malloc(n + size);\n    if (nxt_sys_errlist == NULL) {\n        return NXT_ERROR;\n    }\n\n    p = nxt_pointer_to(nxt_sys_errlist, n);\n\n    for (err = 0; err < nxt_sys_nerr; err++) {\n        msg = strerror((int) err);\n        length = nxt_strlen(msg);\n\n        nxt_sys_errlist[err].length = length;\n        nxt_sys_errlist[err].start = p;\n\n        p = nxt_cpymem(p, msg, length);\n    }\n\n    nxt_sys_errlist[err].length = 13;\n    nxt_sys_errlist[err].start = p;\n    nxt_memcpy(p, \"Unknown error\", 13);\n\n    nxt_strerror = nxt_runtime_strerror;\n\n    return NXT_OK;\n", "Selected Statement": "nxt_sys_errlist[err].length = length;", "Function Input": {}, "Variable Values Before Statement": {"length": "21"}, "Value After Statement Execution": "21", "Project Information": "unit"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nstruct window *\nwindow_create(u_int sx, u_int sy, u_int xpixel, u_int ypixel)\n{\n\tstruct window\t*w;\n\n\tif (xpixel == 0)\n\t\txpixel = DEFAULT_XPIXEL;\n\tif (ypixel == 0)\n\t\typixel = DEFAULT_YPIXEL;\n\n\tw = xcalloc(1, sizeof *w);\n\tw->name = xstrdup(\"\");\n\tw->flags = 0;\n\n\tTAILQ_INIT(&w->panes);\n\tTAILQ_INIT(&w->last_panes);\n\tw->active = NULL;\n\n\tw->lastlayout = -1;\n\tw->layout_root = NULL;\n\n\tw->sx = sx;\n\tw->sy = sy;\n\tw->manual_sx = sx;\n\tw->manual_sy = sy;\n\tw->xpixel = xpixel;\n\tw->ypixel = ypixel;\n\n\tw->options = options_create(global_w_options);\n\n\tw->references = 0;\n\tTAILQ_INIT(&w->winlinks);\n\n\tw->id = next_window_id++;\n\tRB_INSERT(windows, &windows, w);\n\n\twindow_set_fill_character(w);\n", "Selected Statement": "xpixel = DEFAULT_XPIXEL;", "Function Input": {}, "Variable Values Before Statement": {"DEFAULT_XPIXEL": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "tmux"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nstruct options *\noptions_create(struct options *parent)\n{\n\tstruct options\t*oo;\n\n\too = xcalloc(1, sizeof *oo);\n\tRB_INIT(&oo->tree);\n\too->parent = parent;\n", "Selected Statement": "oo->parent = parent;", "Function Input": {}, "Variable Values Before Statement": {"parent": {"tree": null, "parent": null}}, "Value After Statement Execution": {"tree": null, "parent": null}, "Project Information": "tmux"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nvoid\nscreen_init(struct screen *s, u_int sx, u_int sy, u_int hlimit)\n{\n\ts->grid = grid_create(sx, sy, hlimit);\n\ts->saved_grid = NULL;\n\n\ts->title = xstrdup(\"\");\n\ts->titles = NULL;\n\ts->path = NULL;\n\n\ts->cstyle = SCREEN_CURSOR_DEFAULT;\n\ts->default_cstyle = SCREEN_CURSOR_DEFAULT;\n\ts->mode = MODE_CURSOR;\n\ts->default_mode = 0;\n\ts->ccolour = -1;\n\ts->default_ccolour = -1;\n\ts->tabs = NULL;\n\ts->sel = NULL;\n\n#ifdef ENABLE_SIXEL\n\tTAILQ_INIT(&s->images);\n#endif\n\n\ts->write_list = NULL;\n\ts->hyperlinks = NULL;\n\n\tscreen_reinit(s);\n", "Selected Statement": "s->mode = MODE_CURSOR;", "Function Input": {"s": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"title": {"type_category": "string", "concrete_type": "string", "value": "0x800000008 <error: Cannot access memory at address 0x800000008>"}, "path": {"type_category": "string", "concrete_type": "NULL"}, "titles": {"type_category": "pointer", "concrete_type": "NULL"}, "grid": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x26ebb10", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xffffffff\n", "message": "Cannot access memory at address 0xffffffff"}}, "cx": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "cy": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "cstyle": {"type_category": "unknown", "concrete_type": "screen_cursor_style", "value": "SCREEN_CURSOR_DEFAULT"}, "default_cstyle": {"type_category": "unknown", "concrete_type": "screen_cursor_style", "value": "SCREEN_CURSOR_DEFAULT"}, "ccolour": {"type_category": "int", "concrete_type": "int", "value": "0"}, "default_ccolour": {"type_category": "int", "concrete_type": "int", "value": "0"}, "rupper": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "rlower": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "mode": {"type_category": "int", "concrete_type": "int", "value": "0"}, "default_mode": {"type_category": "int", "concrete_type": "int", "value": "0"}, "saved_cx": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "saved_cy": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "saved_grid": {"type_category": "pointer", "concrete_type": "NULL"}, "saved_cell": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"data": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"data": {"type_category": "string", "concrete_type": "string", "value": "\"\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\""}, "have": {"type_category": "unknown", "concrete_type": "u_char", "value": "0 '\\000'"}, "size": {"type_category": "unknown", "concrete_type": "u_char", "value": "0 '\\000'"}, "width": {"type_category": "unknown", "concrete_type": "u_char", "value": "0 '\\000'"}}}, "attr": {"type_category": "unknown", "concrete_type": "u_short", "value": "0"}, "flags": {"type_category": "unknown", "concrete_type": "u_char", "value": "0 '\\000'"}, "fg": {"type_category": "int", "concrete_type": "int", "value": "0"}, "bg": {"type_category": "int", "concrete_type": "int", "value": "0"}, "us": {"type_category": "int", "concrete_type": "int", "value": "0"}, "link": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}}}, "saved_flags": {"type_category": "int", "concrete_type": "int", "value": "0"}, "tabs": {"type_category": "string", "concrete_type": "NULL"}, "sel": {"type_category": "pointer", "concrete_type": "NULL"}, "write_list": {"type_category": "pointer", "concrete_type": "NULL"}, "hyperlinks": {"type_category": "pointer", "concrete_type": "NULL"}}}}}, "Variable Values Before Statement": {"MODE_CURSOR": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "tmux"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nstruct grid *\ngrid_create(u_int sx, u_int sy, u_int hlimit)\n{\n\tstruct grid\t*gd;\n\n\tgd = xmalloc(sizeof *gd);\n\tgd->sx = sx;\n\tgd->sy = sy;\n\n\tif (hlimit != 0)\n\t\tgd->flags = GRID_HISTORY;\n\telse\n\t\tgd->flags = 0;\n\n\tgd->hscrolled = 0;\n\tgd->hsize = 0;\n\tgd->hlimit = hlimit;\n\n\tif (gd->sy != 0)\n\t\tgd->linedata = xcalloc(gd->sy, sizeof *gd->linedata);\n\telse\n\t\tgd->linedata = NULL;\n\n", "Selected Statement": "gd->sx = sx;", "Function Input": {}, "Variable Values Before Statement": {"sx": "u_int"}, "Value After Statement Execution": "u_int", "Project Information": "tmux"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\tint tmp_options;\n\n\toptions |= BEV_OPT_DEFER_CALLBACKS;\n", "Selected Statement": "options |= BEV_OPT_DEFER_CALLBACKS;", "Function Input": {}, "Variable Values Before Statement": {"BEV_OPT_DEFER_CALLBACKS": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "tmux"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "static int\nalloc_exec(OnigEncoding enc, OnigOptionType options, OnigSyntaxType* syntax,\n           int backward, int pattern_size, size_t rem_size, unsigned char *data)\n{\n  extern int onig_detect_can_be_slow_pattern(const UChar* pattern, const UChar* pattern_end, OnigOptionType option, OnigEncoding enc, OnigSyntaxType* syntax);\n\n  int r;\n  int sl;\n  int data_pattern_size;\n  unsigned char *pattern;\n  unsigned char *pattern_end;\n  unsigned char *data_pattern;\n  unsigned char *data_pattern_end;\n  unsigned char *str_null_end;\n\n#ifdef TEST_PATTERN\n  pattern = (unsigned char *)malloc(sizeof(TestPattern));\n  memcpy(pattern, TestPattern, sizeof(TestPattern));\n  pattern_end = pattern + sizeof(TestPattern);\n#else\n  pattern = (unsigned char *)malloc(pattern_size != 0 ? pattern_size : 1);\n  pattern_end = pattern + pattern_size;\n  memcpy(pattern, data, pattern_size);\n#endif\n\n  sl = onig_detect_can_be_slow_pattern(pattern, pattern_end, options, enc, syntax);\n#ifdef STANDALONE\n  fprintf(stdout, \"sl: %d\\n\", sl);\n#endif\n\n  data_pattern_size = fix_size(pattern_size, enc, sl, backward);\n\n  if (\n#ifdef TEST_PATTERN\n      1 ||\n#endif\n      data_pattern_size != pattern_size) {\n    data_pattern = (unsigned char *)malloc(data_pattern_size != 0\n                                           ? data_pattern_size : 1);\n    data_pattern_end = data_pattern + data_pattern_size;\n    memcpy(data_pattern, data, data_pattern_size);\n  }\n  else {\n    data_pattern     = pattern;\n    data_pattern_end = pattern_end;\n  }\n\n  data += pattern_size;\n  rem_size -= pattern_size;\n  rem_size = fix_size(rem_size, enc, sl, backward);\n#ifdef STANDALONE\n  fprintf(stdout, \"rem_size: %ld\\n\", rem_size);\n#endif\n\n  unsigned char *str = (unsigned char*)malloc(rem_size != 0 ? rem_size : 1);\n  memcpy(str, data, rem_size);\n  str_null_end = str + rem_size;\n\n  r = exec(enc, options, syntax,\n           (char* )pattern,      (char* )pattern_end,\n           (char* )data_pattern, (char* )data_pattern_end,\n           (char* )str, str_null_end, backward, sl);\n\n  if (data_pattern != pattern)\n    free(data_pattern);\n\n  free(pattern);\n  free(str);\n  return r;\n}\n\n#ifdef PREV_CONTROL\n#ifdef SYNTAX_TEST\n#define NUM_CONTROL_BYTES      7\n#else\n#define NUM_CONTROL_BYTES      6\n#endif\n#else\n#ifdef SYNTAX_TEST\n#define NUM_CONTROL_BYTES      8\n#else\n#define NUM_CONTROL_BYTES      7\n#endif\n#endif\n\nint LLVMFuzzerTestOneInput(const uint8_t * Data, size_t Size)\n{\n#if !defined(UTF16_BE) && !defined(UTF16_LE)\n  static OnigEncoding encodings[] = {\n    ONIG_ENCODING_UTF8,\n    ONIG_ENCODING_UTF8,\n    ONIG_ENCODING_UTF8,\n    ONIG_ENCODING_UTF8,\n    ONIG_ENCODING_UTF8,\n    ONIG_ENCODING_UTF8,\n    ONIG_ENCODING_UTF8,\n    ONIG_ENCODING_UTF8,\n    ONIG_ENCODING_ASCII,\n    ONIG_ENCODING_EUC_JP,\n    ONIG_ENCODING_EUC_TW,\n    ONIG_ENCODING_EUC_KR,\n    ONIG_ENCODING_EUC_CN,\n    ONIG_ENCODING_SJIS,\n    ONIG_ENCODING_KOI8_R,\n    ONIG_ENCODING_CP1251,\n    ONIG_ENCODING_BIG5,\n    ONIG_ENCODING_GB18030,\n    ONIG_ENCODING_UTF16_BE,\n    ONIG_ENCODING_UTF16_LE,\n    ONIG_ENCODING_UTF16_BE,\n    ONIG_ENCODING_UTF16_LE,\n    ONIG_ENCODING_UTF32_BE,\n    ONIG_ENCODING_UTF32_LE,\n    ONIG_ENCODING_UTF32_BE,\n    ONIG_ENCODING_UTF32_LE,\n    ONIG_ENCODING_ISO_8859_1,\n    ONIG_ENCODING_ISO_8859_2,\n    ONIG_ENCODING_ISO_8859_3,\n    ONIG_ENCODING_ISO_8859_4,\n    ONIG_ENCODING_ISO_8859_5,\n    ONIG_ENCODING_ISO_8859_6,\n    ONIG_ENCODING_ISO_8859_7,\n    ONIG_ENCODING_ISO_8859_8,\n    ONIG_ENCODING_ISO_8859_9,\n    ONIG_ENCODING_ISO_8859_10,\n    ONIG_ENCODING_ISO_8859_11,\n    ONIG_ENCODING_ISO_8859_13,\n    ONIG_ENCODING_ISO_8859_14,\n    ONIG_ENCODING_ISO_8859_15,\n    ONIG_ENCODING_ISO_8859_16\n  };\n  unsigned char encoding_choice;\n#endif\n\n#ifdef SYNTAX_TEST\n  static OnigSyntaxType* syntaxes[] = {\n    ONIG_SYNTAX_POSIX_EXTENDED,\n    ONIG_SYNTAX_EMACS,\n    ONIG_SYNTAX_GREP,\n    ONIG_SYNTAX_GNU_REGEX,\n    ONIG_SYNTAX_JAVA,\n    ONIG_SYNTAX_PERL_NG,\n    ONIG_SYNTAX_PYTHON,\n    ONIG_SYNTAX_ONIGURUMA\n  };\n\n#ifdef STANDALONE\n  static char* syntax_names[] = {\n    \"Posix Extended\",\n    \"Emacs\",\n    \"Grep\",\n    \"GNU Regex\",\n    \"Java\",\n    \"Perl+NG\",\n    \"Python\",\n    \"Oniguruma\"\n  };\n#endif\n\n  unsigned char syntax_choice;\n#endif\n\n  int r;\n  int backward;\n  int pattern_size;\n  size_t rem_size;\n  unsigned char *data;\n  unsigned char pattern_size_choice;\n  OnigOptionType  options;\n  OnigEncoding    enc;\n  OnigSyntaxType* syntax;\n\n#ifndef STANDALONE\n#ifdef EXEC_PRINT_INTERVAL\n  static FILE* STAT_FP;\n#endif\n#endif\n\n  INPUT_COUNT++;\n\n#ifdef DUMP_DATA_INTERVAL\n  if (INPUT_COUNT % DUMP_DATA_INTERVAL == 0) {\n    char path[20];\n    sprintf(path, \"dump-%ld\", INPUT_COUNT);\n    dump_file(path, (unsigned char* )Data, Size);\n  }\n#endif\n\n  if (Size < NUM_CONTROL_BYTES) return 0;\n\n  rem_size = Size;\n  data = (unsigned char* )(Data);\n\n#ifdef UTF16_BE\n  enc = ONIG_ENCODING_UTF16_BE;\n#else\n#ifdef UTF16_LE\n  enc = ONIG_ENCODING_UTF16_LE;\n#else\n  encoding_choice = data[0];\n  data++;\n  rem_size--;\n\n  int num_encodings = sizeof(encodings)/sizeof(encodings[0]);\n  enc = encodings[encoding_choice % num_encodings];\n#endif\n#endif\n\n#ifdef SYNTAX_TEST\n  syntax_choice = data[0];\n  data++;\n  rem_size--;\n\n  int num_syntaxes = sizeof(syntaxes)/sizeof(syntaxes[0]);\n  syntax = syntaxes[syntax_choice % num_syntaxes];\n#else\n  syntax = ONIG_SYNTAX_DEFAULT;\n#endif\n\n#ifdef PREV_CONTROL\n  if ((data[2] & 0xc0) == 0)\n    options = data[0] | (data[1] << 8) | (data[2] << 16);\n#else\n  if ((data[3] & 0xc0) == 0)\n    options = data[0] | (data[1] << 8) | (data[2] << 16) | (data[3] << 24);\n#endif\n  else\n    options = data[0] & ONIG_OPTION_IGNORECASE;\n\n  data++; rem_size--;\n  data++; rem_size--;\n  data++; rem_size--;\n#ifndef PREV_CONTROL\n  data++; rem_size--;\n#endif\n\n  pattern_size_choice = data[0];\n  data++; rem_size--;\n\n  backward = (data[0] == 0xbb);\n  data++; rem_size--;\n\n  if (backward != 0) {\n    options = options & ~ONIG_OPTION_FIND_LONGEST;\n  }\n\n  if (rem_size == 0)\n    pattern_size = 0;\n  else {\n    pattern_size = (int )pattern_size_choice % rem_size;\n    ADJUST_LEN(enc, pattern_size);\n  }\n\n#ifdef STANDALONE\n  {\n    char soptions[33];\n\n    dump_data(stdout, data, pattern_size);\n    to_binary(options, soptions);\n#ifdef SYNTAX_TEST\n    fprintf(stdout,\n            \"enc: %s, syntax: %s, pattern_size: %d, back:%d\\noptions: %s\\n\",\n            ONIGENC_NAME(enc),\n            syntax_names[syntax_choice % num_syntaxes],\n            pattern_size, backward, soptions);\n#else\n    fprintf(stdout, \"enc: %s, pattern_size: %d, back:%d\\noptions: %s\\n\",\n            ONIGENC_NAME(enc), pattern_size, backward, soptions);\n#endif\n\n    print_options(stdout, options);\n    fprintf(stdout, \"\\n\");\n  }\n#endif\n\n#ifdef DUMP_INPUT\n  dump_input((unsigned char* )Data, Size);\n#endif\n\n", "Selected Statement": "rem_size -= pattern_size;", "Function Input": {}, "Variable Values Before Statement": {"pattern_size": "int"}, "Value After Statement Execution": "int", "Project Information": "oniguruma"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "                         OnigCalloutFunc end_func,\n                         int arg_num, unsigned int arg_types[],\n                         int opt_arg_num, OnigValue opt_defaults[])\n{\n  int r;\n  int i;\n  int j;\n  int id;\n  int is_not_single;\n  CalloutNameEntry* e;\n  CalloutNameListEntry* fe;\n\n  if (callout_type != ONIG_CALLOUT_TYPE_SINGLE)\n    return ONIGERR_INVALID_ARGUMENT;\n\n  if (arg_num < 0 || arg_num > ONIG_CALLOUT_MAX_ARGS_NUM)\n    return ONIGERR_INVALID_CALLOUT_ARG;\n\n  if (opt_arg_num < 0 || opt_arg_num > arg_num)\n    return ONIGERR_INVALID_CALLOUT_ARG;\n\n  if (start_func == 0 && end_func == 0)\n    return ONIGERR_INVALID_CALLOUT_ARG;\n\n  if ((in & ONIG_CALLOUT_IN_PROGRESS) == 0 && (in & ONIG_CALLOUT_IN_RETRACTION) == 0)\n    return ONIGERR_INVALID_CALLOUT_ARG;\n\n  for (i = 0; i < arg_num; i++) {\n    unsigned int t = arg_types[i];\n    if (t == ONIG_TYPE_VOID)\n      return ONIGERR_INVALID_CALLOUT_ARG;\n    else {\n      if (i >= arg_num - opt_arg_num) {\n        if (t != ONIG_TYPE_LONG && t != ONIG_TYPE_CHAR && t != ONIG_TYPE_STRING &&\n            t != ONIG_TYPE_TAG)\n          return ONIGERR_INVALID_CALLOUT_ARG;\n      }\n      else {\n        if (t != ONIG_TYPE_LONG) {\n          t = t & ~ONIG_TYPE_LONG;\n          if (t != ONIG_TYPE_CHAR && t != ONIG_TYPE_STRING && t != ONIG_TYPE_TAG)\n            return ONIGERR_INVALID_CALLOUT_ARG;\n        }\n      }\n    }\n  }\n\n  if (! is_allowed_callout_name(enc, name, name_end)) {\n    return ONIGERR_INVALID_CALLOUT_NAME;\n  }\n\n  is_not_single = (callout_type != ONIG_CALLOUT_TYPE_SINGLE);\n  id = callout_name_entry(&e, enc, is_not_single, name, name_end);\n  if (id < 0) return id;\n\n  r = ONIG_NORMAL;\n  if (IS_NULL(GlobalCalloutNameList)) {\n    r = make_callout_func_list(&GlobalCalloutNameList, 10);\n    if (r != ONIG_NORMAL) return r;\n  }\n\n  while (id >= GlobalCalloutNameList->n) {\n    int rid;\n    r = callout_func_list_add(GlobalCalloutNameList, &rid);\n    if (r != ONIG_NORMAL) return r;\n  }\n\n  fe = GlobalCalloutNameList->v + id;\n  fe->type         = callout_type;\n  fe->in           = in;\n  fe->start_func   = start_func;\n  fe->end_func     = end_func;\n  fe->arg_num      = arg_num;\n  fe->opt_arg_num  = opt_arg_num;\n  fe->name         = e->name;\n\n  for (i = 0; i < arg_num; i++) {\n    fe->arg_types[i] = arg_types[i];\n  }\n  for (i = arg_num - opt_arg_num, j = 0; i < arg_num; i++, j++) {\n    if (IS_NULL(opt_defaults)) return ONIGERR_INVALID_ARGUMENT;\n    if (fe->arg_types[i] == ONIG_TYPE_STRING) {\n      OnigValue* val;\n      UChar* ds;\n\n      val = opt_defaults + j;\n      ds = onigenc_strdup(enc, val->s.start, val->s.end);\n      CHECK_NULL_RETURN_MEMERR(ds);\n\n      fe->opt_defaults[i].s.start = ds;\n      fe->opt_defaults[i].s.end   = ds + (val->s.end - val->s.start);\n    }\n    else {\n      fe->opt_defaults[i] = opt_defaults[j];\n    }\n  }\n\n  r = id;\n  return r;\n", "Selected Statement": "fe->start_func   = start_func;", "Function Input": {}, "Variable Values Before Statement": {"start_func": "OnigCalloutFunc"}, "Value After Statement Execution": "OnigCalloutFunc", "Project Information": "oniguruma"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nextern st_table*\nst_init_table_with_size(struct st_hash_type* type, int size)\n{\n  st_table *tbl;\n\n#ifdef HASH_LOG\n  if (init_st == 0) {\n    init_st = 1;\n    atexit(stat_col);\n  }\n#endif\n\n  size = new_size(size);\t\n  if (size <= 0) return 0;\n\n  tbl = alloc(st_table);\n  if (tbl == 0) return 0;\n\n  tbl->type = type;\n  tbl->num_entries = 0;\n  tbl->num_bins = size;\n  tbl->bins = (st_table_entry **)Calloc(size, sizeof(st_table_entry*));\n  if (tbl->bins == 0) {\n    free(tbl);\n    return 0;\n  }\n\n  return tbl;\n", "Selected Statement": "tbl->type = type;", "Function Input": {"size": {"value": "0"}}, "Variable Values Before Statement": {"type": {"compare": "{int (st_data_t, st_data_t)} 0x4c2000 <callout_name_table_cmp>", "hash": "{int (st_data_t)} 0x4c21c0 <callout_name_table_hash>"}}, "Value After Statement Execution": {"compare": "{int (st_data_t, st_data_t)} 0x4c2000 <callout_name_table_cmp>", "hash": "{int (st_data_t)} 0x4c21c0 <callout_name_table_hash>"}, "Project Information": "oniguruma"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nextern int\nonig_set_progress_callout(OnigCalloutFunc f)\n{\n  DefaultProgressCallout = f;\n", "Selected Statement": "DefaultProgressCallout = f;", "Function Input": {}, "Variable Values Before Statement": {"f": "OnigCalloutFunc"}, "Value After Statement Execution": "OnigCalloutFunc", "Project Information": "oniguruma"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nvoid dds_cdrstream_desc_init (struct dds_cdrstream_desc *desc, const struct dds_cdrstream_allocator * __restrict allocator,\n    uint32_t size, uint32_t align, uint32_t flagset, const uint32_t *ops, const dds_key_descriptor_t *keys, uint32_t nkeys)\n{\n  desc->size = size;\n  desc->align = align;\n\n  \n  desc->keys.nkeys = nkeys;\n  copy_desc_keys (&desc->keys.keys, allocator, keys, nkeys);\n  copy_desc_keys (&desc->keys.keys_definition_order, allocator, keys, nkeys);\n  if (desc->keys.nkeys > 0)\n    qsort (desc->keys.keys_definition_order, nkeys, sizeof (*desc->keys.keys_definition_order), key_cmp_idx);\n\n", "Selected Statement": "desc->size = size;", "Function Input": {"size": {"value": "<optimized out>"}}, "Variable Values Before Statement": {"size": "80"}, "Value After Statement Execution": "80", "Project Information": "cyclonedds"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nstruct ucl_parser*\nucl_parser_new (int flags)\n{\n\tstruct ucl_parser *parser;\n\n\tparser = UCL_ALLOC (sizeof (struct ucl_parser));\n\tif (parser == NULL) {\n\t\treturn NULL;\n\t}\n\n\tmemset (parser, 0, sizeof (struct ucl_parser));\n\n\tUPRM_SAFE(ucl_parser_register_macro, parser, \"include\", ucl_include_handler, e0);\n\tUPRM_SAFE(ucl_parser_register_macro, parser, \"try_include\", ucl_try_include_handler, e0);\n\tUPRM_SAFE(ucl_parser_register_macro, parser, \"includes\", ucl_includes_handler, e0);\n\tUPRM_SAFE(ucl_parser_register_macro, parser, \"priority\", ucl_priority_handler, e0);\n\tUPRM_SAFE(ucl_parser_register_macro, parser, \"load\", ucl_load_handler, e0);\n\tUPRM_SAFE(ucl_parser_register_context_macro, parser, \"inherit\", ucl_inherit_handler, e0);\n\n\tparser->flags = flags;\n\tparser->includepaths = NULL;\n\n\tif (flags & UCL_PARSER_SAVE_COMMENTS) {\n\t\tparser->comments = ucl_object_typed_new (UCL_OBJECT);\n\t}\n\n\tif (!(flags & UCL_PARSER_NO_FILEVARS)) {\n\t\t\n\t\tucl_parser_set_filevars (parser, NULL, false);\n\t}\n\n\treturn parser;\ne0:\n\tucl_parser_free(parser);\n\treturn NULL;\n", "Selected Statement": "parser->flags = flags;", "Function Input": {"parser": {"value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x1\n", "message": "Cannot access memory at address 0x1"}}}, "Variable Values Before Statement": {"flags": "int"}, "Value After Statement Execution": "int", "Project Information": "libucl"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nucl_hash_t*\nucl_hash_create (bool ignore_case)\n{\n\tucl_hash_t *new;\n\n\tnew = UCL_ALLOC (sizeof (ucl_hash_t));\n\tif (new != NULL) {\n\t\tvoid *h;\n\t\tnew->head = NULL;\n\t\tnew->caseless = ignore_case;\n\t\tif (ignore_case) {\n\t\t\th = (void *)kh_init (ucl_hash_caseless_node);\n\t\t}\n\t\telse {\n\t\t\th = (void *)kh_init (ucl_hash_node);\n\t\t}\n\t\tif (h == NULL) {\n\t\t\tUCL_FREE (sizeof (ucl_hash_t), new);\n\t\t\treturn NULL;\n\t\t}\n\t\tnew->hash = h;\n\t}\n\treturn new;\n", "Selected Statement": "new->caseless = ignore_case;", "Function Input": {}, "Variable Values Before Statement": {"ignore_case": "_Bool"}, "Value After Statement Execution": "_Bool", "Project Information": "libucl"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nvoid\nWS_Init(struct ws *ws, const char *id, void *space, unsigned len)\n{\n\tstruct ws_emu *we;\n\n\tDSLb(DBG_WORKSPACE,\n\t    \"WS_Init(%p, \\\"%s\\\", %p, %u)\", ws, id, space, len);\n\tassert(space != NULL);\n\tassert(PAOK(space));\n\tassert(len >= sizeof *we);\n\n\tlen = PRNDDN(len - 1);\n\tINIT_OBJ(ws, WS_MAGIC);\n\tws->s = space;\n\tws->e = ws->s + len;\n\n\tassert(id[0] & 0x20);\t\t\n\tbstrcpy(ws->id, id);\n\n\twe = space;\n\tINIT_OBJ(we, WS_EMU_MAGIC);\n\tVTAILQ_INIT(&we->head);\n\twe->len = len;\n\n\tWS_Assert(ws);\n", "Selected Statement": "ws->s = space;", "Function Input": {"ws": {"value": null}}, "Variable Values Before Statement": {"space": "VOID"}, "Value After Statement Execution": "VOID", "Project Information": "varnish"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "CxPlatSystemLoad(\n    void\n    )\n{\n#if defined(CX_PLATFORM_DARWIN)\n    \n    \n    \n    \n    CxPlatProcessorCount = 1;\n#else\n    CxPlatProcessorCount = (uint32_t)sysconf(_SC_NPROCESSORS_ONLN);\n#endif\n\n#ifdef CXPLAT_NUMA_AWARE\n    if (numa_available() >= 0) {\n        CxPlatNumaNodeCount = (uint32_t)numa_num_configured_nodes();\n        CxPlatNumaNodeMasks =\n            CXPLAT_ALLOC_NONPAGED(sizeof(cpu_set_t) * CxPlatNumaNodeCount, QUIC_POOL_PLATFORM_PROC);\n        CXPLAT_FRE_ASSERT(CxPlatNumaNodeMasks);\n        for (uint32_t n = 0; n < CxPlatNumaNodeCount; ++n) {\n            CPU_ZERO(&CxPlatNumaNodeMasks[n]);\n            CXPLAT_FRE_ASSERT(numa_node_to_cpus_compat((int)n, CxPlatNumaNodeMasks[n].__bits, sizeof(cpu_set_t)) >= 0);\n        }\n    } else {\n        CxPlatNumaNodeCount = 0;\n    }\n#endif \n\n#ifdef DEBUG\n    CxPlatform.AllocFailDenominator = 0;\n    CxPlatform.AllocCounter = 0;\n#endif\n\n    \n    \n    \n    \n\n    \n    \n    \n    \n\n    long ShouldLoad = 1;\n\n    \n    \n    \n    char *DisableValue = getenv(\"QUIC_LTTng\");\n    if (DisableValue != NULL) {\n        ShouldLoad = strtol(DisableValue, NULL, 10);\n    }\n\n    if (!ShouldLoad) {\n        goto Exit;\n    }\n\n    \n    \n    \n    Dl_info Info;\n    int Succeeded = dladdr((void *)CxPlatSystemLoad, &Info);\n    if (!Succeeded) {\n        goto Exit;\n    }\n\n    size_t PathLen = strlen(Info.dli_fname);\n\n    \n    \n    \n    int LastTrailingSlashLen = -1;\n    for (int i = PathLen; i >= 0; i--) {\n        if (Info.dli_fname[i] == '/') {\n            LastTrailingSlashLen = i + 1;\n            break;\n        }\n    }\n\n    if (LastTrailingSlashLen == -1) {\n        goto Exit;\n    }\n\n    size_t TpLibNameLen = strlen(TpLibName);\n    size_t ProviderFullPathLength = TpLibNameLen + LastTrailingSlashLen + 1;\n\n    char* ProviderFullPath = CXPLAT_ALLOC_PAGED(ProviderFullPathLength, QUIC_POOL_PLATFORM_TMP_ALLOC);\n    if (ProviderFullPath == NULL) {\n        goto Exit;\n    }\n\n    CxPlatCopyMemory(ProviderFullPath, Info.dli_fname, LastTrailingSlashLen);\n    CxPlatCopyMemory(ProviderFullPath + LastTrailingSlashLen, TpLibName, TpLibNameLen);\n    ProviderFullPath[LastTrailingSlashLen + TpLibNameLen] = '\\0';\n\n    \n    \n    \n    \n    dlopen(ProviderFullPath, RTLD_NOW | RTLD_GLOBAL);\n\n    CXPLAT_FREE(ProviderFullPath, QUIC_POOL_PLATFORM_TMP_ALLOC);\n\nExit:\n\n    QuicTraceLogInfo(\n        PosixLoaded,\n        \"[ dso] Loaded\");\n", "Selected Statement": "for (int i = PathLen; i >= 0; i--) {", "Function Input": {}, "Variable Values Before Statement": {"PathLen": "<optimized out>"}, "Value After Statement Execution": "<optimized out>", "Project Information": "msquic"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "#include \"cmsys/FStream.hxx\"\n\ncmXMLParser::cmXMLParser()\n{\n  this->Parser = nullptr;\n  this->ParseError = 0;\n  this->ReportCallback = nullptr;\n  this->ReportCallbackData = nullptr;\n", "Selected Statement": "this->ReportCallbackData = nullptr;", "Function Input": {}, "Variable Values Before Statement": {"nullptr": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "cmake"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nMmsValue*\nMmsValue_createEmptyArray(int size)\n{\n    MmsValue* self = (MmsValue*) GLOBAL_CALLOC(1, sizeof(MmsValue));\n\n    if (self == NULL)\n        goto exit_function;\n\n    self->type = MMS_ARRAY;\n    self->value.structure.size = size;\n    self->value.structure.components = (MmsValue**) GLOBAL_CALLOC(size, sizeof(MmsValue*));\n\n    if (self->value.structure.components == NULL) {\n        GLOBAL_FREEMEM(self);\n        self = NULL;\n        goto exit_function;\n    }\n\n    int i;\n    for (i = 0; i < size; i++) {\n        self->value.structure.components[i] = NULL;\n    }\n\nexit_function:\n", "Selected Statement": "self->value.structure.size = size;", "Function Input": {}, "Variable Values Before Statement": {"size": "int"}, "Value After Statement Execution": "int", "Project Information": "libiec61850"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nvoid\nlog_register(void (*cb)(int, const char *))\n{\n\tlogh = cb;\n", "Selected Statement": "logh = cb;", "Function Input": {}, "Variable Values Before Statement": {"cb": "{void (int, const char *)} 0x55555564e5c0 <donothing>"}, "Value After Statement Execution": "{void (int, const char *)} 0x55555564e5c0 <donothing>", "Project Information": "lldpd"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "int\nsonmp_decode(struct lldpd *cfg, char *frame, int s, struct lldpd_hardware *hardware,\n    struct lldpd_chassis **newchassis, struct lldpd_port **newport)\n{\n\tconst u_int8_t mcastaddr[] = SONMP_MULTICAST_ADDR;\n\tstruct lldpd_chassis *chassis;\n\tstruct lldpd_port *port;\n\tstruct lldpd_mgmt *mgmt;\n\tint length, i;\n\tu_int8_t *pos;\n\tu_int8_t seg[3], rchassis;\n\tstruct in_addr address;\n\n\tlog_debug(\"sonmp\", \"decode SONMP PDU from %s\", hardware->h_ifname);\n\n\tif ((chassis = calloc(1, sizeof(struct lldpd_chassis))) == NULL) {\n\t\tlog_warn(\"sonmp\", \"failed to allocate remote chassis\");\n\t\treturn -1;\n\t}\n\tTAILQ_INIT(&chassis->c_mgmt);\n\tif ((port = calloc(1, sizeof(struct lldpd_port))) == NULL) {\n\t\tlog_warn(\"sonmp\", \"failed to allocate remote port\");\n\t\tfree(chassis);\n\t\treturn -1;\n\t}\n#  ifdef ENABLE_DOT1\n\tTAILQ_INIT(&port->p_vlans);\n#  endif\n\n\tlength = s;\n\tpos = (u_int8_t *)frame;\n\tif (length < SONMP_SIZE + 2 * ETHER_ADDR_LEN + sizeof(u_int16_t)) {\n\t\tlog_warnx(\"sonmp\", \"too short SONMP frame received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tif (PEEK_CMP(mcastaddr, sizeof(mcastaddr)) != 0)\n\t\t\n\t\tgoto malformed;\n\t\n\tPEEK_DISCARD(ETHER_ADDR_LEN);\n\tPEEK_DISCARD_UINT16;\n\tPEEK_DISCARD(6);\n\tif (PEEK_UINT16 != LLC_PID_SONMP_HELLO) {\n\t\tlog_debug(\"sonmp\", \"incorrect LLC protocol ID received for SONMP on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\n\tchassis->c_id_subtype = LLDP_CHASSISID_SUBTYPE_ADDR;\n\tif ((chassis->c_id = calloc(1, sizeof(struct in_addr) + 1)) == NULL) {\n\t\tlog_warn(\"sonmp\", \"unable to allocate memory for chassis id on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tchassis->c_id_len = sizeof(struct in_addr) + 1;\n\tchassis->c_id[0] = 1;\n\tPEEK_BYTES(&address, sizeof(struct in_addr));\n\tmemcpy(chassis->c_id + 1, &address, sizeof(struct in_addr));\n\tif (asprintf(&chassis->c_name, \"%s\", inet_ntoa(address)) == -1) {\n\t\tlog_warnx(\"sonmp\", \"unable to write chassis name for %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tPEEK_BYTES(seg, sizeof(seg));\n\trchassis = PEEK_UINT8;\n\tfor (i = 0; sonmp_chassis_types[i].type != 0; i++) {\n\t\tif (sonmp_chassis_types[i].type == rchassis) break;\n\t}\n\tif (asprintf(&chassis->c_descr, \"%s\", sonmp_chassis_types[i].description) ==\n\t    -1) {\n\t\tlog_warnx(\"sonmp\", \"unable to write chassis description for %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tmgmt = lldpd_alloc_mgmt(LLDPD_AF_IPV4, &address, sizeof(struct in_addr), 0);\n\tif (mgmt == NULL) {\n\t\tif (errno == ENOMEM)\n\t\t\tlog_warn(\"sonmp\",\n\t\t\t    \"unable to allocate memory for management address\");\n\t\telse\n\t\t\tlog_warn(\"sonmp\", \"too large management address received on %s\",\n\t\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tTAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries);\n\tport->p_ttl =\n\t    cfg ? (cfg->g_config.c_tx_interval * cfg->g_config.c_tx_hold) : LLDPD_TTL;\n\tport->p_ttl = (port->p_ttl + 999) / 1000;\n\n\tport->p_id_subtype = LLDP_PORTID_SUBTYPE_LOCAL;\n\n\tport->p_id_len =\n\t    asprintf(&port->p_id, \"%02x-%02x-%02x\", seg[0], seg[1], seg[2]);\n\tif (port->p_id_len == -1) {\n\t\tlog_warn(\"sonmp\", \"unable to allocate memory for port id on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\n\t\n\tif ((seg[0] == 0) && (seg[1] == 0)) {\n\t\tif (asprintf(&port->p_descr, \"port %d\", seg[2]) == -1) {\n\t\t\tlog_warnx(\"sonmp\", \"unable to write port description for %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t} else if (seg[0] == 0) {\n\t\tif (asprintf(&port->p_descr, \"port %d/%d\", seg[1], seg[2]) == -1) {\n\t\t\tlog_warnx(\"sonmp\", \"unable to write port description for %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t} else {\n\t\tif (asprintf(&port->p_descr, \"port %x:%x:%x\", seg[0], seg[1], seg[2]) ==\n\t\t    -1) {\n\t\t\tlog_warnx(\"sonmp\", \"unable to write port description for %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t}\n\t*newchassis = chassis;\n\t*newport = port;\n\treturn 1;\n\nmalformed:\n\tlldpd_chassis_cleanup(chassis, 1);\n\tlldpd_port_cleanup(port, 1);\n\tfree(port);\n\treturn -1;\n", "Selected Statement": "*newchassis = chassis;", "Function Input": {"hardware": {"value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x18\n", "message": "Cannot access memory at address 0x18"}}}, "Variable Values Before Statement": {"chassis": {"c_entries": null, "c_refcount": "0", "c_index": "0", "c_protocol": "0 '\\000'", "c_id_subtype": "5 '\\005'", "c_id": "0x5555560f23b0 \"\\001\\254\\020e\\250\"", "c_id_len": "5", "c_name": "0x5555560e9440 \"172.16.101.168\"", "c_descr": "0x5555560f0f30 \"Nortel Ethernet Routing Switch 5530-24TFD\"", "c_cap_available": "0", "c_cap_enabled": "0", "c_mgmt": null, "c_med_cap_available": "0", "c_med_type": "0 '\\000'", "c_med_hw": null, "c_med_fw": null, "c_med_sw": null, "c_med_sn": null, "c_med_manuf": null, "c_med_model": null, "c_med_asset": null}}, "Value After Statement Execution": {"c_entries": null, "c_refcount": "0", "c_index": "0", "c_protocol": "0 '\\000'", "c_id_subtype": "5 '\\005'", "c_id": "0x5555560f23b0 \"\\001\\254\\020e\\250\"", "c_id_len": "5", "c_name": "0x5555560e9440 \"172.16.101.168\"", "c_descr": "0x5555560f0f30 \"Nortel Ethernet Routing Switch 5530-24TFD\"", "c_cap_available": "0", "c_cap_enabled": "0", "c_mgmt": null, "c_med_cap_available": "0", "c_med_type": "0 '\\000'", "c_med_hw": null, "c_med_fw": null, "c_med_sw": null, "c_med_sn": null, "c_med_manuf": null, "c_med_model": null, "c_med_asset": null}, "Project Information": "lldpd"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nstruct lldpd_mgmt *\nlldpd_alloc_mgmt(int family, void *addrptr, size_t addrsize, u_int32_t iface)\n{\n\tstruct lldpd_mgmt *mgmt;\n\n\tlog_debug(\"alloc\", \"allocate a new management address (family: %d)\", family);\n\n\tif (family <= LLDPD_AF_UNSPEC || family >= LLDPD_AF_LAST) {\n\t\terrno = EAFNOSUPPORT;\n\t\treturn NULL;\n\t}\n\tif (addrsize > LLDPD_MGMT_MAXADDRSIZE) {\n\t\terrno = EOVERFLOW;\n\t\treturn NULL;\n\t}\n\tmgmt = calloc(1, sizeof(struct lldpd_mgmt));\n\tif (mgmt == NULL) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\tmgmt->m_family = family;\n\tmemcpy(&mgmt->m_addr, addrptr, addrsize);\n\tmgmt->m_addrsize = addrsize;\n\tmgmt->m_iface = iface;\n\treturn mgmt;\n", "Selected Statement": "mgmt->m_addrsize = addrsize;", "Function Input": {}, "Variable Values Before Statement": {"addrsize": "4"}, "Value After Statement Execution": "4", "Project Information": "lldpd"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\t\t\t\t\tconst_hashtab_key_t key1,\n\t\t\t\t\tconst_hashtab_key_t key2),\n\t\t\t unsigned int size)\n{\n\n\thashtab_t p;\n\n\tp = (hashtab_t) malloc(sizeof(hashtab_val_t));\n\tif (p == NULL)\n\t\treturn p;\n\n\tmemset(p, 0, sizeof(hashtab_val_t));\n\tp->size = size;\n\tp->nel = 0;\n\tp->hash_value = hash_value;\n\tp->keycmp = keycmp;\n\tp->htable = (hashtab_ptr_t *) calloc(size, sizeof(hashtab_ptr_t));\n\tif (p->htable == NULL) {\n\t\tfree(p);\n\t\treturn NULL;\n\t}\n\n\treturn p;\n", "Selected Statement": "p->size = size;", "Function Input": {"size": {"value": "32767"}}, "Variable Values Before Statement": {"size": "unsigned int"}, "Value After Statement Execution": "unsigned int", "Project Information": "selinux"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": " * NULL then this function will create a new array (*cnt is reset to\n * 0).  Return 0 on success, -1 on out of memory. */\nint add_i_to_a(uint32_t i, uint32_t * cnt, uint32_t ** a)\n{\n\tuint32_t *new;\n\n\tif (cnt == NULL || *cnt == UINT32_MAX || a == NULL)\n\t\treturn -1;\n\n\t\n\tif (*a != NULL)\n\t\tnew = (uint32_t *) reallocarray(*a, *cnt + 1, sizeof(uint32_t));\n\telse {\t\t\t\n\n\t\t*cnt = 0;\n\t\tnew = (uint32_t *) malloc(sizeof(uint32_t));\n\t}\n\tif (new == NULL) {\n\t\treturn -1;\n\t}\n\tnew[*cnt] = i;\n\t(*cnt)++;\n\t*a = new;\n\treturn 0;\n", "Selected Statement": "*a = new;", "Function Input": {"a": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x10a7570", "value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x725f7463656a626f\n", "message": "Cannot access memory at address 0x725f7463656a626f"}}}, "cnt": {"value": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "17455024"}}, "i": {"value": "4294956832"}}, "Variable Values Before Statement": {"new": "1"}, "Value After Statement Execution": "1", "Project Information": "selinux"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "}\n\nstatic int read_source_policy(policydb_t *p, const uint8_t *data, size_t size)\n{\n\tint fd, rc;\n\tssize_t wr;\n\n\tfd = memfd_create(\"fuzz-input\", MFD_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\twr = full_write(fd, data, size);\n\tif (wr < 0 || (size_t)wr != size) {\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\tfsync(fd);\n\n\tyynerrs = 0;\n\n\tyyin = fdopen(fd, \"r\");\n\tif (!yyin) {\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\trewind(yyin);\n\n\tset_source_file(\"fuzz-input\");\n\n\tid_queue = queue_create();\n\tif (id_queue == NULL) {\n\t\tfclose(yyin);\n\t\tyylex_destroy();\n\t\treturn -1;\n\t}\n\n\tpolicydbp = p;\n\tmlspol = p->mls;\n\n\tinit_parser(1);\n\n\tif (!setjmp(fuzzing_pre_parse_stack_state)) {\n\t\tqueue_destroy(id_queue);\n\t\tfclose(yyin);\n\t\tyylex_destroy();\n\t\treturn -1;\n\t}\n\n\trc = yyparse();\n\t\n\tassert(rc || !policydb_errors);\n\tif (rc || policydb_errors) {\n\t\tqueue_destroy(id_queue);\n\t\tfclose(yyin);\n\t\tyylex_destroy();\n\t\treturn -1;\n\t}\n\n\trewind(yyin);\n\tinit_parser(2);\n\tset_source_file(\"fuzz-input\");\n\tyyrestart(yyin);\n\n\trc = yyparse();\n\tassert(rc || !policydb_errors);\n\tif (rc || policydb_errors) {\n\t\tqueue_destroy(id_queue);\n\t\tfclose(yyin);\n\t\tyylex_destroy();\n\t\treturn -1;\n\t}\n\n\tqueue_destroy(id_queue);\n\tfclose(yyin);\n\tyylex_destroy();\n\n\treturn 0;\n}\n\nstatic int write_binary_policy(FILE *outfp, policydb_t *p)\n{\n\tstruct policy_file pf;\n\n\tpolicy_file_init(&pf);\n\tpf.type = PF_USE_STDIO;\n\tpf.fp = outfp;\n\treturn policydb_write(p, &pf);\n}\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n\tpolicydb_t parsepolicydb = {};\n\tpolicydb_t kernpolicydb = {};\n\tpolicydb_t *finalpolicydb;\n\tsidtab_t sidtab = {};\n\tFILE *devnull = NULL;\n\tint mls, platform, policyvers;\n\n\tsepol_debug(VERBOSE);\n\n\t\n\tif (size < 3)\n\t\treturn 0;\n\tswitch (data[0]) {\n\tcase 'S':\n\t\tplatform = SEPOL_TARGET_SELINUX;\n\t\tbreak;\n\tcase 'X':\n\t\tplatform = SEPOL_TARGET_XEN;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tswitch (data[1]) {\n\tcase '0':\n\t\tmls = 0;\n\t\tbreak;\n\tcase '1':\n\t\tmls = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tstatic_assert(0x7F - 'A' >= POLICYDB_VERSION_MAX, \"Max policy version should be representable\");\n\tpolicyvers = data[2] - 'A';\n\tif (policyvers < POLICYDB_VERSION_MIN || policyvers > POLICYDB_VERSION_MAX)\n\t\treturn 0;\n\tdata += 3;\n\tsize -= 3;\n\n\tif (policydb_init(&parsepolicydb))\n\t\tgoto exit;\n\n\tparsepolicydb.policy_type = POLICY_BASE;\n\tparsepolicydb.mls = mls;\n\tparsepolicydb.handle_unknown = DENY_UNKNOWN;\n\tparsepolicydb.policyvers = policyvers;\n\tpolicydb_set_target_platform(&parsepolicydb, platform);\n\n", "Selected Statement": "policydbp = p;", "Function Input": {"fd": {"value": "0"}}, "Variable Values Before Statement": {"p": {"policy_type": "1", "name": null, "version": null, "target_platform": "1", "unsupported_format": "0", "mls": "0", "symtab": [{"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x10a42f0"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x10a4340"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x10a4480"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "1"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x10a4540"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x109da90"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x109d2d0"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x10aaa90"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x109e4c0"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}], "sym_val_to_name": [{"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}], "class_val_to_struct": null, "role_val_to_struct": null, "user_val_to_struct": null, "type_val_to_struct": null, "scope": [{"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x10a5610"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x10a5640"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x10a5780"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x10a5840"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x10aab50"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x10a6c90"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x10a6d50"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x10a6e10"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}], "global": null, "decl_val_to_struct": null, "te_avtab": null, "bool_val_to_struct": null, "te_cond_avtab": null, "cond_list": null, "role_tr": null, "role_allow": null, "ocontexts": [{"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}], "genfs": null, "range_tr": "0x10a7620", "filename_trans": "0x10a75f0", "filename_trans_count": "0", "type_attr_map": null, "attr_type_map": null, "policycaps": null, "permissive_map": null, "policyvers": "33", "handle_unknown": "0", "process_class": "0", "dir_class": "0", "process_trans": "0", "process_trans_dyntrans": "0"}}, "Value After Statement Execution": {"policy_type": "1", "name": null, "version": null, "target_platform": "1", "unsupported_format": "0", "mls": "0", "symtab": [{"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x10a42f0"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x10a4340"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x10a4480"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "1"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x10a4540"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x109da90"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x109d2d0"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x10aaa90"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x109e4c0"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}], "sym_val_to_name": [{"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}], "class_val_to_struct": null, "role_val_to_struct": null, "user_val_to_struct": null, "type_val_to_struct": null, "scope": [{"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x10a5610"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x10a5640"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x10a5780"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x10a5840"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x10aab50"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x10a6c90"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x10a6d50"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"table": {"type_category": "unknown", "concrete_type": "hashtab_t", "value": "0x10a6e10"}, "nprim": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}], "global": null, "decl_val_to_struct": null, "te_avtab": null, "bool_val_to_struct": null, "te_cond_avtab": null, "cond_list": null, "role_tr": null, "role_allow": null, "ocontexts": [{"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}], "genfs": null, "range_tr": "0x10a7620", "filename_trans": "0x10a75f0", "filename_trans_count": "0", "type_attr_map": null, "attr_type_map": null, "policycaps": null, "permissive_map": null, "policyvers": "33", "handle_unknown": "0", "process_class": "0", "dir_class": "0", "process_trans": "0", "process_trans_dyntrans": "0"}, "Project Information": "selinux"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\n\nvoid init_parser(int pass_number)\n{\n\tpolicydb_lineno = 1;\n\tsource_lineno = 1;\n\tpolicydb_errors = 0;\n\tpass = pass_number;\n", "Selected Statement": "pass = pass_number;", "Function Input": {"pass_number": {"value": "0"}}, "Variable Values Before Statement": {"pass_number": "int"}, "Value After Statement Execution": "int", "Project Information": "selinux"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\n\nint next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tsize_t nread;\n\n\tswitch (fp->type) {\n\tcase PF_USE_STDIO:\n\t\tnread = fread(buf, bytes, 1, fp->fp);\n\n\t\tif (nread != 1)\n\t\t\treturn -1;\n\t\tbreak;\n\tcase PF_USE_MEMORY:\n\t\tif (bytes > fp->len) {\n\t\t\terrno = EOVERFLOW;\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy(buf, fp->data, bytes);\n\t\tfp->data += bytes;\n\t\tfp->len -= bytes;\n\t\tbreak;\n\tdefault:\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\treturn 0;\n", "Selected Statement": "errno = EOVERFLOW;", "Function Input": {}, "Variable Values Before Statement": {"EOVERFLOW": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "selinux"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nint parse_msg(\n\t\tchar *const buf, const unsigned int len, struct sip_msg *const msg)\n{\n\n\tchar *tmp;\n\tchar *rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor(tmp = buf; (tmp - buf < len)\n\t\t\t\t   && (*tmp == '\\n' || *tmp == '\\r' || *tmp == '\\0'\n\t\t\t\t\t\t   || *tmp == '\\t' || *tmp == ' ');\n\t\t\ttmp++)\n\t\t;\n\toffset = tmp - buf;\n\tfl = &(msg->first_line);\n\trest = parse_first_line(tmp, len - offset, fl);\n\toffset += rest - tmp;\n\ttmp = rest;\n\tswitch(fl->type) {\n\t\tcase SIP_INVALID:\n\t\t\tDBG(\"invalid message\\n\");\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tDBG(\"SIP Request:\\n\");\n\t\t\tDBG(\" method:  <%.*s>\\n\", fl->u.request.method.len,\n\t\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tDBG(\" uri:     <%.*s>\\n\", fl->u.request.uri.len,\n\t\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tDBG(\" version: <%.*s>\\n\", fl->u.request.version.len,\n\t\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags = HDR_VIA_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tDBG(\"SIP Reply  (status):\\n\");\n\t\t\tDBG(\" version: <%.*s>\\n\", fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tDBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tDBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\t\n\t\t\t\n\t\t\tflags = HDR_VIA_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDBG(\"unknown type %d\\n\", fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed = tmp;\n\t\n\tif(parse_headers(msg, flags, 0) == -1)\n\t\tgoto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif(msg->via1) {\n\t\tDBG(\"first via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\", msg->via1->name.len,\n\t\t\t\tZSW(msg->via1->name.s), msg->via1->version.len,\n\t\t\t\tZSW(msg->via1->version.s), msg->via1->transport.len,\n\t\t\t\tZSW(msg->via1->transport.s), msg->via1->host.len,\n\t\t\t\tZSW(msg->via1->host.s), msg->via1->port_str.len,\n\t\t\t\tZSW(msg->via1->port_str.s), msg->via1->port);\n\t\tif(msg->via1->params.s)\n\t\t\tDBG(\";<%.*s>\", msg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif(msg->via1->comment.s)\n\t\t\tDBG(\" <%.*s>\", msg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tDBG(\"\\n\");\n\t}\n\tif(msg->via2) {\n\t\tDBG(\"second via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\", msg->via2->name.len,\n\t\t\t\tZSW(msg->via2->name.s), msg->via2->version.len,\n\t\t\t\tZSW(msg->via2->version.s), msg->via2->transport.len,\n\t\t\t\tZSW(msg->via2->transport.s), msg->via2->host.len,\n\t\t\t\tZSW(msg->via2->host.s), msg->via2->port_str.len,\n\t\t\t\tZSW(msg->via2->port_str.s), msg->via2->port);\n\t\tif(msg->via2->params.s)\n\t\t\tDBG(\";<%.*s>\", msg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif(msg->via2->comment.s)\n\t\t\tDBG(\" <%.*s>\", msg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tDBG(\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tDBG(\"exiting parse_msg\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLOG(cfg_get(core, core_cfg, sip_parser_log),\n\t\t\t\"ERROR: parse_msg: message=<%.*s>\\n\", (int)msg->len,\n\t\t\tZSW(ksr_buf_oneline(msg->buf, (int)msg->len)));\n\treturn -1;\n", "Selected Statement": "for(tmp = buf; (tmp - buf < len)", "Function Input": {"flags": {"value": "140737322669824"}, "msg": {"value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xffff00001f80\n", "message": "Cannot access memory at address 0xffff00001f80"}}}, "Variable Values Before Statement": {"buf": "0x1b7b2f0 \"\""}, "Value After Statement Execution": "0x1b7b2f0 \"\"", "Project Information": "kamailio"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": " * Returns: 1 if successful, 0 if unsuccessful.\n */\nint mdb_set_default_backend(MdbHandle *mdb, const char *backend_name)\n{\n\tMdbBackend *backend;\n\n    if (!mdb->backends) {\n        mdb_init_backends(mdb);\n    }\n\tbackend = (MdbBackend *) g_hash_table_lookup(mdb->backends, backend_name);\n\tif (backend) {\n\t\tmdb->default_backend = backend;\n\t\tg_free(mdb->backend_name); \n\t\tmdb->backend_name = (char *) g_strdup(backend_name);\n\t\tmdb->relationships_table = NULL;\n\t\tif (backend->date_fmt) {\n\t\t\tmdb_set_date_fmt(mdb, backend->date_fmt);\n\t\t} else {\n\t\t\tmdb_set_date_fmt(mdb, \"%x %X\");\n\t\t}\n\t\tif (backend->shortdate_fmt) {\n\t\t\tmdb_set_shortdate_fmt(mdb, backend->shortdate_fmt);\n\t\t} else {\n\t\t\tmdb_set_shortdate_fmt(mdb, \"%x\");\n\t\t}\n\t}\n", "Selected Statement": "mdb->default_backend = backend;", "Function Input": {}, "Variable Values Before Statement": {"backend": {"capabilities": "19", "types_table": null, "type_shortdate": null, "type_autonum": null, "short_now": "0x52f2b0 \"Date()\"", "long_now": "0x52f2b0 \"Date()\"", "date_fmt": null, "shortdate_fmt": null, "charset_statement": "0x52f2b7 \"-- That file uses encoding %s\\n\"", "drop_statement": "0x52f2d6 \"DROP TABLE %s;\\n\"", "constaint_not_empty_statement": null, "column_comment_statement": null, "per_column_comment_statement": null, "table_comment_statement": null, "per_table_comment_statement": null, "quote_schema_name": "{gchar *(const gchar *, const gchar *)} 0x4caac0 <quote_schema_name_bracket_merge>", "create_table_statement": "0x52f418 \"CREATE TABLE %s\\n\"", "normalise_case": "{gchar *(const gchar *)} 0x4cb1a0 <passthrough_unchanged>"}}, "Value After Statement Execution": {"capabilities": "19", "types_table": null, "type_shortdate": null, "type_autonum": null, "short_now": "0x52f2b0 \"Date()\"", "long_now": "0x52f2b0 \"Date()\"", "date_fmt": null, "shortdate_fmt": null, "charset_statement": "0x52f2b7 \"-- That file uses encoding %s\\n\"", "drop_statement": "0x52f2d6 \"DROP TABLE %s;\\n\"", "constaint_not_empty_statement": null, "column_comment_statement": null, "per_column_comment_statement": null, "table_comment_statement": null, "per_table_comment_statement": null, "quote_schema_name": "{gchar *(const gchar *, const gchar *)} 0x4caac0 <quote_schema_name_bracket_merge>", "create_table_statement": "0x52f418 \"CREATE TABLE %s\\n\"", "normalise_case": "{gchar *(const gchar *)} 0x4cb1a0 <passthrough_unchanged>"}, "Project Information": "mdbtools"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "    return found;\n}\n\nGHashTable *g_hash_table_new(GHashFunc hashes, GEqualFunc equals) {\n    GHashTable *table = calloc(1, sizeof(GHashTable));\n    table->array = g_ptr_array_new();\n    table->compare = equals;\n", "Selected Statement": "table->compare = equals;", "Function Input": {}, "Variable Values Before Statement": {"equals": "GEqualFunc"}, "Value After Statement Execution": "GEqualFunc", "Project Information": "mdbtools"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "      int error_code,\n      const char *,\n      format_string )\n{\n\tva_list argument_list;\n\n\tlibcerror_internal_error_t *internal_error = NULL;\n\tsystem_character_t *error_string           = NULL;\n\tsystem_character_t *system_format_string   = NULL;\n\tvoid *reallocation                         = NULL;\n\tsize_t error_string_size                   = 0;\n\tsize_t format_string_length                = 0;\n\tsize_t message_size                        = 0;\n\tsize_t next_message_size                   = LIBCERROR_MESSAGE_INCREMENT_SIZE;\n\tint message_index                          = 0;\n\tint print_count                            = 0;\n\n\tif( error == NULL )\n\t{\n\t\treturn;\n\t}\n\tif( format_string == NULL )\n\t{\n\t\treturn;\n\t}\n\tformat_string_length = narrow_string_length(\n\t                        format_string );\n\n#if defined( HAVE_WIDE_SYSTEM_CHARACTER )\n\tlibcerror_error_get_system_format_string(\n\t format_string,\n\t format_string_length,\n\t &system_format_string );\n\n\tif( system_format_string == NULL )\n\t{\n\t\treturn;\n\t}\n#else\n\tsystem_format_string = (system_character_t *) format_string;\n#endif\n\tif( *error == NULL )\n\t{\n\t\tif( libcerror_error_initialize(\n\t\t     error,\n\t\t     error_domain,\n\t\t     error_code ) != 1 )\n\t\t{\n\t\t\tgoto on_error;\n\t\t}\n\t}\n\tinternal_error = (libcerror_internal_error_t *) *error;\n\n\tif( libcerror_error_resize(\n\t     internal_error ) != 1 )\n\t{\n\t\tgoto on_error;\n\t}\n\tif( format_string_length > next_message_size )\n\t{\n\t\tnext_message_size = ( ( format_string_length / LIBCERROR_MESSAGE_INCREMENT_SIZE ) + 1 )\n\t\t                  * LIBCERROR_MESSAGE_INCREMENT_SIZE;\n\t}\n\tdo\n\t{\n\t\tif( next_message_size >= LIBCERROR_MESSAGE_MAXIMUM_SIZE )\n\t\t{\n\t\t\tnext_message_size = LIBCERROR_MESSAGE_MAXIMUM_SIZE;\n\t\t}\n\t\treallocation = memory_reallocate(\n\t\t                error_string,\n\t\t                sizeof( system_character_t ) * next_message_size );\n\n\t\tif( reallocation == NULL )\n\t\t{\n\t\t\tmemory_free(\n\t\t\t error_string );\n\n\t\t\tgoto on_error;\n\t\t}\n\t\terror_string = (system_character_t *) reallocation;\n\n\t\tmessage_size = next_message_size;\n\n\t\t\n\t\tVASTART(\n\t\t argument_list,\n\t\t const char *,\n\t\t format_string );\n\n\t\tprint_count = system_string_vsnprintf(\n\t\t               error_string,\n\t\t               message_size,\n\t\t               system_format_string,\n\t\t               argument_list );\n\n\t\tVAEND(\n\t\t argument_list );\n\n\t\tif( print_count <= -1 )\n\t\t{\n\t\t\tnext_message_size += LIBCERROR_MESSAGE_INCREMENT_SIZE;\n\t\t}\n\t\telse if( ( (size_t) print_count >= message_size )\n\t\t      || ( error_string[ print_count ] != (system_character_t) 0 ) )\n\t\t{\n\t\t\tnext_message_size = (size_t) ( print_count + 1 );\n\t\t\tprint_count       = -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\terror_string_size = (size_t) print_count + 1;\n\t\t}\n\t\tif( message_size >= LIBCERROR_MESSAGE_MAXIMUM_SIZE )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\twhile( print_count <= -1 );\n\n\tif( message_size >= LIBCERROR_MESSAGE_MAXIMUM_SIZE )\n\t{\n\t\terror_string[ LIBCERROR_MESSAGE_MAXIMUM_SIZE - 4 ] = (system_character_t) '.';\n\t\terror_string[ LIBCERROR_MESSAGE_MAXIMUM_SIZE - 3 ] = (system_character_t) '.';\n\t\terror_string[ LIBCERROR_MESSAGE_MAXIMUM_SIZE - 2 ] = (system_character_t) '.';\n\t\terror_string[ LIBCERROR_MESSAGE_MAXIMUM_SIZE - 1 ] = 0;\n\t\terror_string_size                                  = (size_t) LIBCERROR_MESSAGE_MAXIMUM_SIZE;\n\t}\n\tmessage_index = internal_error->number_of_messages - 1;\n\n\tinternal_error->messages[ message_index ] = error_string;\n\tinternal_error->sizes[ message_index ]    = error_string_size;\n\n#if defined( HAVE_WIDE_SYSTEM_CHARACTER )\n\tmemory_free(\n\t system_format_string );\n\n\tsystem_format_string = NULL;\n#endif\n\treturn;\n\non_error:\n#if defined( HAVE_WIDE_SYSTEM_CHARACTER )\n\tif( system_format_string != NULL )\n\t{\n\t\tmemory_free(\n\t\t system_format_string );\n\t}\n#endif\n\treturn;\n", "Selected Statement": "size_t next_message_size                   = LIBCERROR_MESSAGE_INCREMENT_SIZE;", "Function Input": {"error": {"value": null}, "error_code": {"value": "5"}, "error_domain": {"value": "97"}}, "Variable Values Before Statement": {"LIBCERROR_MESSAGE_INCREMENT_SIZE": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "             libcerror_error_t **error ),\n      uint8_t flags,\n      libcerror_error_t **error )\n{\n\tlibbfio_internal_handle_t *internal_handle = NULL;\n\tstatic char *function                      = \"libbfio_handle_initialize\";\n\n\tif( handle == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid handle.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *handle != NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\n\t\t \"%s: invalid handle value already set.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tinternal_handle = memory_allocate_structure(\n\t                   libbfio_internal_handle_t );\n\n\tif( internal_handle == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create handle.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     internal_handle,\n\t     0,\n\t     sizeof( libbfio_internal_handle_t ) ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear handle.\",\n\t\t function );\n\n\t\tmemory_free(\n\t\t internal_handle );\n\n\t\treturn( -1 );\n\t}\n\tif( libcdata_range_list_initialize(\n\t     &( internal_handle->offsets_read ),\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create read offsets list.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n#if defined( HAVE_MULTI_THREAD_SUPPORT ) && !defined( HAVE_LOCAL_LIBBFIO )\n\tif( libcthreads_read_write_lock_initialize(\n\t     &( internal_handle->read_write_lock ),\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to intialize read/write lock.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n#endif\n\tinternal_handle->io_handle       = io_handle;\n\tinternal_handle->flags           = flags;\n\tinternal_handle->free_io_handle  = free_io_handle;\n\tinternal_handle->clone_io_handle = clone_io_handle;\n\tinternal_handle->open            = open;\n\tinternal_handle->close           = close;\n\tinternal_handle->read            = read;\n\tinternal_handle->write           = write;\n\tinternal_handle->seek_offset     = seek_offset;\n\tinternal_handle->exists          = exists;\n\tinternal_handle->is_open         = is_open;\n\tinternal_handle->get_size        = get_size;\n\n\t*handle = (libbfio_handle_t *) internal_handle;\n\n\treturn( 1 );\n\non_error:\n\tif( internal_handle != NULL )\n\t{\n\t\tif( internal_handle->offsets_read != NULL )\n\t\t{\n\t\t\tlibcdata_range_list_free(\n\t\t\t &( internal_handle->offsets_read ),\n\t\t\t NULL,\n\t\t\t NULL );\n\t\t}\n\t\tmemory_free(\n\t\t internal_handle );\n\t}\n\treturn( -1 );\n", "Selected Statement": "internal_handle->seek_offset     = seek_offset;", "Function Input": {"error": {"value": {"type_category": "pointer", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x1060fe1a\n", "message": "Cannot access memory at address 0x1060fe1a"}}, "flags": {"value": "0 '\\000'"}, "handle": {"value": {"type_category": "pointer", "concrete_type": "NULL"}}, "io_handle": {"value": null}}, "Variable Values Before Statement": {"seek_offset": "{off64_t (intptr_t *, off64_t, int, libcerror_error_t **)} 0x4c6d60 <libbfio_memory_range_io_handle_seek_offset>"}, "Value After Statement Execution": "{off64_t (intptr_t *, off64_t, int, libcerror_error_t **)} 0x4c6d60 <libbfio_memory_range_io_handle_seek_offset>", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "     const uint8_t *data,\n     size_t data_size,\n     libcerror_error_t **error )\n{\n\tstatic char *function                 = \"libfshfs_extents_record_read_data\";\n\tsize_t data_offset                    = 0;\n\tuint32_t physical_extent_block_number = 0;\n\tuint16_t extent_block_number          = 0;\n\tuint16_t extent_number_of_blocks      = 0;\n\tint extent_index                      = 0;\n\n\tif( fork_descriptor == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid fork descriptor.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( data == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_MISSING,\n\t\t \"%s: invalid data.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( data_size > (size_t) SSIZE_MAX )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: invalid data size value out of bounds.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n#if defined( HAVE_DEBUG_OUTPUT )\n\tif( libcnotify_verbose != 0 )\n\t{\n\t\tlibcnotify_printf(\n\t\t \"%s: extents records data:\\n\",\n\t\t function );\n\t\tlibcnotify_print_data(\n\t\t data,\n\t\t data_size,\n\t\t LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA );\n\t}\n#endif\n\tif( data_size != 12 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_UNSUPPORTED_VALUE,\n\t\t \"%s: unsupported extents record data size: %\" PRIzd \"\\n\",\n\t\t function,\n\t\t data_size );\n\n\t\treturn( -1 );\n\t}\n\twhile( data_offset < 12 )\n\t{\n\t\tbyte_stream_copy_to_uint16_big_endian(\n\t\t &( data[ data_offset ] ),\n\t\t extent_block_number );\n\n\t\tdata_offset += 2;\n\n\t\tbyte_stream_copy_to_uint16_big_endian(\n\t\t &( data[ data_offset ] ),\n\t\t extent_number_of_blocks );\n\n\t\tdata_offset += 2;\n\n\t\tphysical_extent_block_number = extent_block_number;\n\n\t\tif( extent_number_of_blocks > 0 )\n\t\t{\n\t\t\tphysical_extent_block_number += extents_start_block_number;\n\t\t}\n#if defined( HAVE_DEBUG_OUTPUT )\n\t\tif( libcnotify_verbose != 0 )\n\t\t{\n\t\t\tlibcnotify_printf(\n\t\t\t \"%s: extent: %d block number\\t\\t: %\" PRIu32 \" (%\" PRIu16 \")\\n\",\n\t\t\t function,\n\t\t\t extent_index,\n\t\t\t physical_extent_block_number,\n\t\t\t extent_block_number );\n\n\t\t\tlibcnotify_printf(\n\t\t\t \"%s: extent: %d number of blocks\\t\\t: %\" PRIu16 \"\\n\",\n\t\t\t function,\n\t\t\t extent_index,\n\t\t\t extent_number_of_blocks );\n\t\t}\n#endif \n\n\t\tfork_descriptor->extents[ extent_index ][ 0 ] = physical_extent_block_number;\n\t\tfork_descriptor->extents[ extent_index ][ 1 ] = extent_number_of_blocks;\n\n\t\tfork_descriptor->number_of_blocks_in_extents += extent_number_of_blocks;\n\n\t\textent_index++;\n\t}\n#if defined( HAVE_DEBUG_OUTPUT )\n\tif( libcnotify_verbose != 0 )\n\t{\n\t\tlibcnotify_printf(\n\t\t \"\\n\" );\n\t}\n#endif\n\treturn( 1 );\n", "Selected Statement": "fork_descriptor->extents[ extent_index ][ 0 ] = physical_extent_block_number;", "Function Input": {"data": {"value": "0x600 <error: Cannot access memory at address 0x600>"}, "data_size": {"value": "4809124"}, "error": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd8e0", "value": {"type_category": "unknown", "concrete_type": "libcerror_error_t", "value": "140737488346128"}}}, "extents_start_block_number": {"value": "0"}, "fork_descriptor": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"size": {"type_category": "unknown", "concrete_type": "uint64_t", "value": "0"}, "number_of_blocks": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, "extents": {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}]}, "number_of_blocks_in_extents": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}}}, "Variable Values Before Statement": {"physical_extent_block_number": "1"}, "Value After Statement Execution": "1", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "     libcdata_array_t **array,\n     int number_of_entries,\n     libcerror_error_t **error )\n{\n\tlibcdata_internal_array_t *internal_array = NULL;\n\tstatic char *function                     = \"libcdata_array_initialize\";\n\tsize_t entries_size                       = 0;\n\tint number_of_allocated_entries           = 0;\n\n\tif( array == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid array.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *array != NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\n\t\t \"%s: invalid array value already set.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( number_of_entries < 0 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_LESS_THAN_ZERO,\n\t\t \"%s: invalid number of entries value less than zero.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tinternal_array = memory_allocate_structure(\n\t                  libcdata_internal_array_t );\n\n\tif( internal_array == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create array.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     internal_array,\n\t     0,\n\t     sizeof( libcdata_internal_array_t ) ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear array.\",\n\t\t function );\n\n\t\tmemory_free(\n\t\t internal_array );\n\n\t\treturn( -1 );\n\t}\n\t\n\tif( number_of_entries >= (int) ( INT_MAX - 16 ) )\n\t{\n\t\tnumber_of_allocated_entries = INT_MAX;\n\t}\n\telse\n\t{\n\t\tnumber_of_allocated_entries = ( number_of_entries & ~( 15 ) ) + 16;\n\t}\n#if SIZEOF_INT <= SIZEOF_SIZE_T\n\tif( (size_t) number_of_allocated_entries > (size_t) ( SSIZE_MAX / sizeof( intptr_t * ) ) )\n#else\n\tif( number_of_allocated_entries > (int) ( SSIZE_MAX / sizeof( intptr_t * ) ) )\n#endif\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_EXCEEDS_MAXIMUM,\n\t\t \"%s: invalid number of allocated entries value exceeds maximum.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tentries_size = sizeof( intptr_t * ) * number_of_allocated_entries;\n\n\tif( entries_size > (size_t) LIBCDATA_ARRAY_ENTRIES_MEMORY_LIMIT )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_EXCEEDS_MAXIMUM,\n\t\t \"%s: invalid entries size value exceeds maximum.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tinternal_array->entries = (intptr_t **) memory_allocate(\n\t                                         entries_size );\n\n\tif( internal_array->entries == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create array entries.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     internal_array->entries,\n\t     0,\n\t     entries_size ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear array entries.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tinternal_array->number_of_allocated_entries = number_of_allocated_entries;\n\tinternal_array->number_of_entries           = number_of_entries;\n\n#if defined( HAVE_MULTI_THREAD_SUPPORT ) && !defined( HAVE_LOCAL_LIBCDATA )\n\tif( libcthreads_read_write_lock_initialize(\n\t     &( internal_array->read_write_lock ),\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to initialize read/write lock.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n#endif\n\t*array = (libcdata_array_t *) internal_array;\n\n\treturn( 1 );\n\non_error:\n\tif( internal_array != NULL )\n\t{\n\t\tif( internal_array->entries != NULL )\n\t\t{\n\t\t\tmemory_free(\n\t\t\t internal_array->entries );\n\t\t}\n\t\tmemory_free(\n\t\t internal_array );\n\t}\n\treturn( -1 );\n", "Selected Statement": "internal_array->number_of_allocated_entries = number_of_allocated_entries;", "Function Input": {"array": {"value": {"type_category": "pointer", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x200\n", "message": "Cannot access memory at address 0x200"}}, "error": {"value": {"type_category": "pointer", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x7366780800000200\n", "message": "Cannot access memory at address 0x7366780800000200"}}, "number_of_entries": {"value": "116"}}, "Variable Values Before Statement": {"number_of_allocated_entries": "int"}, "Value After Statement Execution": "int", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "     const uint8_t *byte_stream,\n     size_t byte_stream_size,\n     libcerror_error_t **error )\n{\n\tstatic char *function = \"libfwnt_bit_stream_initialize\";\n\n\tif( bit_stream == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid bit stream.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *bit_stream != NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\n\t\t \"%s: invalid bit stream value already set.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( byte_stream == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid byte stream value.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( byte_stream_size > (size_t) SSIZE_MAX )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM,\n\t\t \"%s: byte stream size value exceeds maximum.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\t*bit_stream = memory_allocate_structure(\n\t               libfwnt_bit_stream_t );\n\n\tif( *bit_stream == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create bit stream.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     *bit_stream,\n\t     0,\n\t     sizeof( libfwnt_bit_stream_t ) ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear bit stream.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\t( *bit_stream )->byte_stream      = byte_stream;\n\t( *bit_stream )->byte_stream_size = byte_stream_size;\n\n\treturn( 1 );\n\non_error:\n\tif( *bit_stream != NULL )\n\t{\n\t\tmemory_free(\n\t\t *bit_stream );\n\n\t\t*bit_stream = NULL;\n\t}\n\treturn( -1 );\n", "Selected Statement": "( *bit_stream )->byte_stream      = byte_stream;", "Function Input": {"bit_stream": {"value": {"type_category": "pointer", "concrete_type": "NULL"}}, "byte_stream": {"value": null}, "byte_stream_size": {"value": "140737488279872"}, "error": {"value": null}}, "Variable Values Before Statement": {"byte_stream": "0x10bed00 \"\\377\\246\\365\""}, "Value After Statement Execution": "0x10bed00 \"\\377\\246\\365\"", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "            libcerror_error_t **error ),\n     uint8_t flags,\n     libcerror_error_t **error )\n{\n\tlibfdata_internal_list_t *internal_list = NULL;\n\tstatic char *function                   = \"libfdata_list_initialize\";\n\n\tif( list == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid list.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *list != NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\n\t\t \"%s: invalid list value already set.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( ( flags & 0xfe ) != 0 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\n\t\t \"%s: unsupported flags: 0x%02\" PRIx8 \".\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tinternal_list = memory_allocate_structure(\n\t                 libfdata_internal_list_t );\n\n\tif( internal_list == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create list.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     internal_list,\n\t     0,\n\t     sizeof( libfdata_internal_list_t ) ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear list.\",\n\t\t function );\n\n\t\tmemory_free(\n\t\t internal_list );\n\n\t\treturn( -1 );\n\t}\n\tif( libcdata_array_initialize(\n\t     &( internal_list->elements_array ),\n\t     0,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create elements array.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( libcdata_array_initialize(\n\t     &( internal_list->mapped_ranges_array ),\n\t     0,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create mapped ranges array.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tinternal_list->flags             |= flags;\n\tinternal_list->data_handle        = data_handle;\n\tinternal_list->free_data_handle   = free_data_handle;\n\tinternal_list->clone_data_handle  = clone_data_handle;\n\tinternal_list->read_element_data  = read_element_data;\n\tinternal_list->write_element_data = write_element_data;\n\n\t*list = (libfdata_list_t *) internal_list;\n\n\treturn( 1 );\n\non_error:\n\tif( internal_list != NULL )\n\t{\n\t\tif( internal_list->elements_array != NULL )\n\t\t{\n\t\t\tlibcdata_array_free(\n\t\t\t &( internal_list->elements_array ),\n\t\t\t NULL,\n\t\t\t NULL );\n\t\t}\n\t\tmemory_free(\n\t\t internal_list );\n\t}\n\treturn( -1 );\n", "Selected Statement": "internal_list->clone_data_handle  = clone_data_handle;", "Function Input": {"data_handle": {"value": null}, "error": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x4d7bac <libevt_io_handle_initialize+364>", "value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xf88348c8458b48\n", "message": "Cannot access memory at address 0xf88348c8458b48"}}}, "flags": {"value": "0 '\\000'"}, "list": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x12ea8a0", "value": {"type_category": "unknown", "concrete_type": "libfdata_list_t", "value": "0"}}}}, "Variable Values Before Statement": {"clone_data_handle": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "     size_t size,\n     uint32_t initial_value,\n     libcerror_error_t **error )\n{\n\tlibesedb_aligned_t *aligned_buffer_iterator = NULL;\n\tuint8_t *buffer_iterator                    = NULL;\n\tstatic char *function                       = \"libesedb_checksum_calculate_little_endian_xor32\";\n\tlibesedb_aligned_t value_aligned            = 0;\n\tuint32_t big_endian_value_32bit             = 0;\n\tuint32_t safe_checksum_value                = 0;\n\tuint32_t value_32bit                        = 0;\n\tuint8_t alignment_count                     = 0;\n\tuint8_t alignment_size                      = 0;\n\tuint8_t byte_count                          = 0;\n\tuint8_t byte_order                          = 0;\n\tuint8_t byte_size                           = 0;\n\n\tif( checksum_value == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid checksum value.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( buffer == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid buffer.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( size > (size_t) SSIZE_MAX )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM,\n\t\t \"%s: invalid size value exceeds maximum.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tsafe_checksum_value = initial_value;\n\n\tbuffer_iterator = (uint8_t *) buffer;\n\n\t\n\tif( ( ( sizeof( libesedb_aligned_t ) % 4 ) == 0 )\n\t && ( size > ( 2 * sizeof( libesedb_aligned_t ) ) ) )\n\t{\n\t\t\n\t\talignment_size = (uint8_t) ( (intptr_t) buffer_iterator % sizeof( libesedb_aligned_t ) );\n\n\t\tif( alignment_size > 0 )\n\t\t{\n\t\t\tbyte_size = sizeof( libesedb_aligned_t ) - alignment_size;\n\n\t\t\t\n\t\t\twhile( byte_size != 0 )\n\t\t\t{\n\t\t\t\tvalue_32bit = 0;\n\t\t\t\tbyte_count  = 1;\n\n\t\t\t\tif( byte_size >= 4 )\n\t\t\t\t{\n\t\t\t\t\tvalue_32bit |= buffer_iterator[ 3 ];\n\t\t\t\t\tvalue_32bit <<= 8;\n\n\t\t\t\t\tbyte_count++;\n\t\t\t\t}\n\t\t\t\tif( byte_size >= 3 )\n\t\t\t\t{\n\t\t\t\t\tvalue_32bit |= buffer_iterator[ 2 ];\n\t\t\t\t\tvalue_32bit <<= 8;\n\n\t\t\t\t\tbyte_count++;\n\t\t\t\t}\n\t\t\t\tif( byte_size >= 2 )\n\t\t\t\t{\n\t\t\t\t\tvalue_32bit |= buffer_iterator[ 1 ];\n\t\t\t\t\tvalue_32bit <<= 8;\n\n\t\t\t\t\tbyte_count++;\n\t\t\t\t}\n\t\t\t\tvalue_32bit |= buffer_iterator[ 0 ];\n\n\t\t\t\tbuffer_iterator += byte_count;\n\t\t\t\tbyte_size       -= byte_count;\n\n\t\t\t\tsafe_checksum_value ^= value_32bit;\n\t\t\t}\n\t\t\tsize -= byte_count;\n\t\t}\n\t\taligned_buffer_iterator = (libesedb_aligned_t *) buffer_iterator;\n\n\t\tif( *buffer_iterator != (uint8_t) ( *aligned_buffer_iterator & 0xff ) )\n\t\t{\n\t\t\tbyte_order = _BYTE_STREAM_ENDIAN_BIG;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbyte_order = _BYTE_STREAM_ENDIAN_LITTLE;\n\t\t}\n\t\t\n\t\twhile( size > sizeof( libesedb_aligned_t ) )\n\t\t{\n\t\t\tvalue_aligned ^= *aligned_buffer_iterator;\n\n\t\t\taligned_buffer_iterator++;\n\n\t\t\tsize -= sizeof( libesedb_aligned_t );\n\t\t}\n\t\t\n\t\tif( alignment_size > 0 )\n\t\t{\n\t\t\tbyte_count      = ( alignment_size % 4 ) * 8;\n\t\t\talignment_count = ( sizeof( libesedb_aligned_t ) - alignment_size ) * 8;\n\n\t\t\tif( byte_order == _BYTE_STREAM_ENDIAN_BIG )\n\t\t\t{\n\t\t\t\t\n\t\t\t\tbig_endian_value_32bit = (uint32_t) ( ( value_aligned >> alignment_count ) << byte_count );\n\n\t\t\t\t\n\t\t\t\tvalue_32bit = ( ( big_endian_value_32bit & 0x000000ffUL ) << 24 )\n\t\t\t\t            | ( ( big_endian_value_32bit & 0x0000ff00UL ) << 8 )\n\t\t\t\t            | ( ( big_endian_value_32bit >> 8 ) & 0x0000ff00UL )\n\t\t\t\t            | ( ( big_endian_value_32bit >> 24 ) & 0x000000ffUL );\n\n\t\t\t\t\n\t\t\t\tvalue_aligned <<= alignment_count;\n\t\t\t}\n\t\t\telse if( byte_order == _BYTE_STREAM_ENDIAN_LITTLE )\n\t\t\t{\n\t\t\t\tvalue_32bit = (uint32_t) ( value_aligned << byte_count );\n\n\t\t\t\t\n\t\t\t\tvalue_aligned >>= alignment_count;\n\t\t\t}\n\t\t\tsafe_checksum_value ^= value_32bit;\n\t\t}\n\t\t\n\t\tbyte_size = (uint8_t) sizeof( libesedb_aligned_t );\n\n\t\twhile( byte_size != 0 )\n\t\t{\n\t\t\tbyte_count = ( ( byte_size / 4 ) - 1 ) * 32;\n\n\t\t\tif( byte_order == _BYTE_STREAM_ENDIAN_BIG )\n\t\t\t{\n\t\t\t\tbig_endian_value_32bit = (uint32_t) ( ( value_aligned >> byte_count ) & 0xffffffffUL );\n\n\t\t\t\t\n\t\t\t\tvalue_32bit = ( ( big_endian_value_32bit & 0x000000ffUL ) << 24 )\n\t\t\t\t            | ( ( big_endian_value_32bit & 0x0000ff00UL ) << 8 )\n\t\t\t\t            | ( ( big_endian_value_32bit >> 8 ) & 0x0000ff00UL )\n\t\t\t\t            | ( ( big_endian_value_32bit >> 24 ) & 0x000000ffUL );\n\t\t\t}\n\t\t\telse if( byte_order == _BYTE_STREAM_ENDIAN_LITTLE )\n\t\t\t{\n\t\t\t\tvalue_32bit = (uint32_t) value_aligned;\n\n\t\t\t\tvalue_aligned >>= byte_count;\n\t\t\t}\n\t\t\tbyte_size -= 4;\n\n\t\t\tsafe_checksum_value ^= value_32bit;\n\t\t}\n\t\t\n\t\tbuffer_iterator = (uint8_t *) aligned_buffer_iterator;\n\n\t\tbyte_size = 4 - ( alignment_size % 4 );\n\n\t\tif( byte_size != 4 )\n\t\t{\n\t\t\tvalue_32bit   = buffer_iterator[ 0 ];\n\t\t\tvalue_32bit <<= 8;\n\n\t\t\tif( byte_size >= 2 )\n\t\t\t{\n\t\t\t\tvalue_32bit |= buffer_iterator[ 1 ];\n\t\t\t}\n\t\t\tvalue_32bit <<= 8;\n\n\t\t\tif( byte_size >= 3 )\n\t\t\t{\n\t\t\t\tvalue_32bit |= buffer_iterator[ 2 ];\n\t\t\t}\n\t\t\tvalue_32bit <<= 8;\n\n\t\t\tbuffer_iterator += byte_size;\n\t\t\tsize            -= byte_size;\n\n\t\t\tsafe_checksum_value ^= value_32bit;\n\t\t}\n\t}\n\twhile( size > 0 )\n\t{\n\t\tvalue_32bit = 0;\n\t\tbyte_count  = 1;\n\n\t\tif( size >= 4 )\n\t\t{\n\t\t\tvalue_32bit |= buffer_iterator[ 3 ];\n\t\t\tvalue_32bit <<= 8;\n\n\t\t\tbyte_count++;\n\t\t}\n\t\tif( size >= 3 )\n\t\t{\n\t\t\tvalue_32bit |= buffer_iterator[ 2 ];\n\t\t\tvalue_32bit <<= 8;\n\n\t\t\tbyte_count++;\n\t\t}\n\t\tif( size >= 2 )\n\t\t{\n\t\t\tvalue_32bit |= buffer_iterator[ 1 ];\n\t\t\tvalue_32bit <<= 8;\n\n\t\t\tbyte_count++;\n\t\t}\n\t\tvalue_32bit |= buffer_iterator[ 0 ];\n\n\t\tbuffer_iterator += byte_count;\n\t\tsize            -= byte_count;\n\n\t\tsafe_checksum_value ^= value_32bit;\n\t}\n\t*checksum_value = safe_checksum_value;\n\n\treturn( 1 );\n", "Selected Statement": "buffer_iterator += byte_count;", "Function Input": {"buffer": {"value": "0x117ca50 \"\""}, "error": {"value": {"type_category": "pointer", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x29c\n", "message": "Cannot access memory at address 0x29c"}}, "initial_value": {"value": "0"}, "size": {"value": "672"}}, "Variable Values Before Statement": {"byte_count": "4 '\\004'"}, "Value After Statement Execution": "4 '\\004'", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "     int number_of_handles,\n     int maximum_number_of_open_handles,\n     libcerror_error_t **error )\n{\n\tlibbfio_internal_pool_t *internal_pool = NULL;\n\tstatic char *function                  = \"libbfio_pool_initialize\";\n\n\tif( pool == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid pool.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *pool != NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\n\t\t \"%s: invalid pool value already set.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( number_of_handles < 0 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_LESS_THAN_ZERO,\n\t\t \"%s: invalid number of handles value less than zero.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( maximum_number_of_open_handles < 0 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_LESS_THAN_ZERO,\n\t\t \"%s: invalid maximum number of open handles value less than zero.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tinternal_pool = memory_allocate_structure(\n\t                 libbfio_internal_pool_t );\n\n\tif( internal_pool == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create pool.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     internal_pool,\n\t     0,\n\t     sizeof( libbfio_internal_pool_t ) ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear pool.\",\n\t\t function );\n\n\t\tmemory_free(\n\t\t internal_pool );\n\n\t\treturn( -1 );\n\t}\n\tif( libcdata_array_initialize(\n\t     &( internal_pool->handles_array ),\n\t     number_of_handles,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create handles array.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( libcdata_list_initialize(\n\t     &( internal_pool->last_used_list ),\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create last used list.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n#if defined( HAVE_MULTI_THREAD_SUPPORT ) && !defined( HAVE_LOCAL_LIBBFIO )\n\tif( libcthreads_read_write_lock_initialize(\n\t     &( internal_pool->read_write_lock ),\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to initialize read/write lock.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n#endif\n\tinternal_pool->maximum_number_of_open_handles = maximum_number_of_open_handles;\n\tinternal_pool->current_entry                  = -1;\n\n\t*pool = (libbfio_pool_t *) internal_pool;\n\n\treturn( 1 );\n\non_error:\n\tif( internal_pool != NULL )\n\t{\n\t\tif( internal_pool->last_used_list != NULL )\n\t\t{\n\t\t\tlibcdata_list_free(\n\t\t\t &( internal_pool->last_used_list ),\n\t\t\t NULL,\n\t\t\t NULL );\n\t\t}\n\t\tif( internal_pool->handles_array != NULL )\n\t\t{\n\t\t\tlibcdata_array_free(\n\t\t\t &( internal_pool->handles_array ),\n\t\t\t (int (*)(intptr_t **, libcerror_error_t **)) &libbfio_handle_free,\n\t\t\t NULL );\n\t\t}\n\t\tmemory_free(\n\t\t internal_pool );\n\t}\n\treturn( -1 );\n", "Selected Statement": "internal_pool->maximum_number_of_open_handles = maximum_number_of_open_handles;", "Function Input": {"error": {"value": null}, "maximum_number_of_open_handles": {"value": "20312240"}, "number_of_handles": {"value": "0"}, "pool": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x135f1d0", "value": {"type_category": "unknown", "concrete_type": "libbfio_pool_t", "value": "20312240"}}}}, "Variable Values Before Statement": {"maximum_number_of_open_handles": "int"}, "Value After Statement Execution": "int", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "     uint8_t *buffer,\n     size_t buffer_size,\n     libcerror_error_t **error )\n{\n\tlibfplist_xml_parser_state_t parser_state;\n\t\n\tYY_BUFFER_STATE buffer_state = NULL;\n\tstatic char *function        = \"libfplist_xml_parser_parse_buffer\";\n\tint result                   = -1;\n\n\tif( buffer == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid buffer.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tbuffer_state = libfplist_xml_scanner__scan_buffer(\n\t                (char *) buffer,\n\t                buffer_size );\n\n\tlibfplist_xml_scanner_buffer_offset = 0;\n\n\tif( buffer_state != NULL )\n\t{\n\t\tparser_state.property_list = property_list;\n\t\tparser_state.error         = error;\n\t\tparser_state.root_tag      = NULL;\n\t\tparser_state.current_tag   = NULL;\n\t\tparser_state.parent_tag    = NULL;\n\n\t\tif( libfplist_xml_scanner_parse(\n\t\t     &parser_state ) == 0 )\n\t\t{\n\t\t\tif( libfplist_property_list_set_root_tag(\n\t\t\t     property_list,\n\t\t\t     parser_state.root_tag,\n\t\t\t     error ) != 1 )\n\t\t\t{\n\t\t\t\tlibcerror_error_set(\n\t\t\t\t error,\n\t\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t\t LIBCERROR_RUNTIME_ERROR_GET_FAILED,\n\t\t\t\t \"%s: unable to set root tag.\",\n\t\t\t\t function );\n\n\t\t\t\tresult = -1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tparser_state.root_tag = NULL;\n\n\t\t\t\tresult = 1;\n\t\t\t}\n\t\t}\n\t\tlibfplist_xml_scanner__delete_buffer(\n\t\t buffer_state );\n\t}\n\tlibfplist_xml_scanner_lex_destroy();\n\n\tif( parser_state.root_tag != NULL )\n\t{\n\t\tlibfplist_xml_tag_free(\n\t\t &( parser_state.root_tag ),\n\t\t NULL );\n\t}\n\treturn( result );\n", "Selected Statement": "parser_state.error         = error;", "Function Input": {"buffer": {"value": "0x11f6eb0 \"\\340\\v\\342\\367\\377\\177\""}, "buffer_size": {"value": "4096"}, "error": {"value": {"type_category": "pointer", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x1000\n", "message": "Cannot access memory at address 0x1000"}}, "property_list": {"value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x2\n", "message": "Cannot access memory at address 0x2"}}}, "Variable Values Before Statement": {"error": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": " * @return the newly allocated buffer state object.\n */\nYY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )\n{\n\tYY_BUFFER_STATE b;\n    \n\tif ( size < 2 ||\n\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n\t\t\n\t\treturn NULL;\n\n\tb = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_buffer()\" );\n\n\tb->yy_buf_size = (int) (size - 2);\t\n\tb->yy_buf_pos = b->yy_ch_buf = base;\n\tb->yy_is_our_buffer = 0;\n\tb->yy_input_file = NULL;\n\tb->yy_n_chars = b->yy_buf_size;\n\tb->yy_is_interactive = 0;\n\tb->yy_at_bol = 1;\n\tb->yy_fill_buffer = 0;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tyy_switch_to_buffer( b  );\n\n\treturn b;\n", "Selected Statement": "b->yy_buf_pos = b->yy_ch_buf = base;", "Function Input": {}, "Variable Values Before Statement": {"base": "0x11f6e90 \"\\n-\""}, "Value After Statement Execution": "0x11f6e90 \"\\n-\"", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "int libewf_handle_initialize(\n     libewf_handle_t **handle,\n     libcerror_error_t **error )\n{\n\tlibewf_internal_handle_t *internal_handle = NULL;\n\tstatic char *function                     = \"libewf_handle_initialize\";\n\n\tif( handle == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid handle.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *handle != NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\n\t\t \"%s: invalid handle value already set.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tinternal_handle = memory_allocate_structure(\n\t                   libewf_internal_handle_t );\n\n\tif( internal_handle == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create handle.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     internal_handle,\n\t     0,\n\t     sizeof( libewf_internal_handle_t ) ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear handle.\",\n\t\t function );\n\n\t\tmemory_free(\n\t\t internal_handle );\n\n\t\treturn( -1 );\n\t}\n\tif( libewf_io_handle_initialize(\n\t     &( internal_handle->io_handle ),\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create IO handle.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( libewf_media_values_initialize(\n\t     &( internal_handle->media_values ),\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create media values.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( libcdata_array_initialize(\n\t     &( internal_handle->sessions ),\n\t     0,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create sessions array.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( libcdata_array_initialize(\n\t     &( internal_handle->tracks ),\n\t     0,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create tracks array.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( libcdata_range_list_initialize(\n\t     &( internal_handle->acquiry_errors ),\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create acquiry errors range list.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( libewf_segment_table_initialize(\n\t     &( internal_handle->segment_table ),\n\t     internal_handle->io_handle,\n\t     LIBEWF_DEFAULT_SEGMENT_FILE_SIZE,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create segment table.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n#if defined( HAVE_LIBEWF_MULTI_THREAD_SUPPORT )\n\tif( libcthreads_read_write_lock_initialize(\n\t     &( internal_handle->read_write_lock ),\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to initialize read/write lock.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n#endif\n\tinternal_handle->date_format                    = LIBEWF_DATE_FORMAT_CTIME;\n\tinternal_handle->maximum_number_of_open_handles = LIBBFIO_POOL_UNLIMITED_NUMBER_OF_OPEN_HANDLES;\n\n\t*handle = (libewf_handle_t *) internal_handle;\n\n\treturn( 1 );\n\non_error:\n\tif( internal_handle != NULL )\n\t{\n\t\tif( internal_handle->acquiry_errors != NULL )\n\t\t{\n\t\t\tlibcdata_range_list_free(\n\t\t\t &( internal_handle->acquiry_errors ),\n\t\t\t NULL,\n\t\t\t NULL );\n\t\t}\n\t\tif( internal_handle->tracks != NULL )\n\t\t{\n\t\t\tlibcdata_array_free(\n\t\t\t &( internal_handle->tracks ),\n\t\t\t NULL,\n\t\t\t NULL );\n\t\t}\n\t\tif( internal_handle->sessions != NULL )\n\t\t{\n\t\t\tlibcdata_array_free(\n\t\t\t &( internal_handle->sessions ),\n\t\t\t NULL,\n\t\t\t NULL );\n\t\t}\n\t\tif( internal_handle->media_values != NULL )\n\t\t{\n\t\t\tlibewf_media_values_free(\n\t\t\t &( internal_handle->media_values ),\n\t\t\t NULL );\n\t\t}\n\t\tif( internal_handle->io_handle != NULL )\n\t\t{\n\t\t\tlibewf_io_handle_free(\n\t\t\t &( internal_handle->io_handle ),\n\t\t\t NULL );\n\t\t}\n\t\tmemory_free(\n\t\t internal_handle );\n\t}\n\treturn( -1 );\n", "Selected Statement": "internal_handle->date_format                    = LIBEWF_DATE_FORMAT_CTIME;", "Function Input": {"error": {"value": {"type_category": "pointer", "concrete_type": "NULL"}}, "handle": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x124a0b0", "value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x1\n", "message": "Cannot access memory at address 0x1"}}}}, "Variable Values Before Statement": {"LIBEWF_DATE_FORMAT_CTIME": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "int libewf_io_handle_initialize(\n     libewf_io_handle_t **io_handle,\n     libcerror_error_t **error )\n{\n\tstatic char *function = \"libewf_io_handle_initialize\";\n\n\tif( io_handle == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid IO handle.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *io_handle != NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\n\t\t \"%s: invalid IO handle value already set.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\t*io_handle = memory_allocate_structure(\n\t              libewf_io_handle_t );\n\n\tif( *io_handle == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create IO handle.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     *io_handle,\n\t     0,\n\t     sizeof( libewf_io_handle_t ) ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear IO handle.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\t( *io_handle )->segment_file_type  = LIBEWF_SEGMENT_FILE_TYPE_UNDEFINED;\n\t( *io_handle )->format             = LIBEWF_FORMAT_ENCASE6;\n\t( *io_handle )->major_version      = 1;\n\t( *io_handle )->minor_version      = 0;\n\t( *io_handle )->compression_method = LIBEWF_COMPRESSION_METHOD_DEFLATE;\n\t( *io_handle )->compression_level  = LIBEWF_COMPRESSION_LEVEL_NONE;\n\t( *io_handle )->zero_on_error      = 1;\n\t( *io_handle )->header_codepage    = LIBEWF_CODEPAGE_ASCII;\n\n\treturn( 1 );\n\non_error:\n\tif( *io_handle != NULL )\n\t{\n\t\tmemory_free(\n\t\t *io_handle );\n\n\t\t*io_handle = NULL;\n\t}\n\treturn( -1 );\n", "Selected Statement": "( *io_handle )->segment_file_type  = LIBEWF_SEGMENT_FILE_TYPE_UNDEFINED;", "Function Input": {"error": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7ffff7cce299 <malloc+441>", "value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x840fc08548c08949\n", "message": "Cannot access memory at address 0x840fc08548c08949"}}}, "io_handle": {"value": null}}, "Variable Values Before Statement": {"LIBEWF_SEGMENT_FILE_TYPE_UNDEFINED": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "int libewf_media_values_initialize(\n     libewf_media_values_t **media_values,\n     libcerror_error_t **error )\n{\n\tstatic char *function = \"libewf_media_values_initialize\";\n\n\tif( media_values == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid media values.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *media_values != NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\n\t\t \"%s: invalid media values value already set.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\t*media_values = memory_allocate_structure(\n\t                 libewf_media_values_t );\n\n\tif( *media_values == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create media values.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     *media_values,\n\t     0,\n\t     sizeof( libewf_media_values_t ) ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear media values.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\t( *media_values )->chunk_size        = LIBEWF_MINIMUM_CHUNK_SIZE;\n\t( *media_values )->sectors_per_chunk = 64;\n\t( *media_values )->bytes_per_sector  = 512;\n\t( *media_values )->media_flags       = 0x01;\n\n\treturn( 1 );\n\non_error:\n\tif( *media_values != NULL )\n\t{\n\t\tmemory_free(\n\t\t *media_values );\n\n\t\t*media_values = NULL;\n\t}\n\treturn( -1 );\n", "Selected Statement": "( *media_values )->chunk_size        = LIBEWF_MINIMUM_CHUNK_SIZE;", "Function Input": {"error": {"value": null}, "media_values": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x124a380", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"media_size": {"type_category": "unknown", "concrete_type": "size64_t", "value": "288072046477312"}, "chunk_size": {"type_category": "unknown", "concrete_type": "size32_t", "value": "1"}, "sectors_per_chunk": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, "bytes_per_sector": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, "number_of_chunks": {"type_category": "unknown", "concrete_type": "uint64_t", "value": "20127"}, "number_of_sectors": {"type_category": "unknown", "concrete_type": "uint64_t", "value": "48"}, "error_granularity": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "81"}, "media_type": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "0 '\\000'"}, "media_flags": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "0 '\\000'"}, "set_identifier": {"type_category": "string", "concrete_type": "string", "value": "\"\\000\\000/testcase/8800\""}}}}}}, "Variable Values Before Statement": {"LIBEWF_MINIMUM_CHUNK_SIZE": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "           libcerror_error_t **error ),\n     uint8_t flags,\n     libcerror_error_t **error )\n{\n\tlibfvalue_internal_value_t *internal_value = NULL;\n\tstatic char *function                      = \"libfvalue_value_initialize\";\n\n\tif( value == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid value.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *value != NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\n\t\t \"%s: invalid value value already set.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( type_string == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid type string\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tinternal_value = memory_allocate_structure(\n\t                  libfvalue_internal_value_t );\n\n\tif( internal_value == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create value.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     internal_value,\n\t     0,\n\t     sizeof( libfvalue_internal_value_t ) ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear value.\",\n\t\t function );\n\n\t\tmemory_free(\n\t\t internal_value );\n\n\t\treturn( -1 );\n\t}\n\tif( free_instance != NULL )\n\t{\n\t\tif( libcdata_array_initialize(\n\t\t     &( internal_value->value_instances ),\n\t\t     1,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t\t \"%s: unable to create value instances array.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t}\n\tif( data_handle == NULL )\n\t{\n\n\t\tif( libfvalue_data_handle_initialize(\n\t\t     &( internal_value->data_handle ),\n\t\t     NULL,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t\t \"%s: unable to create data handle.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t\tinternal_value->flags |= LIBFVALUE_VALUE_FLAG_DATA_HANDLE_MANAGED;\n\t}\n\telse\n\t{\n\t\tinternal_value->data_handle = data_handle;\n\t}\n\tinternal_value->type_string                       = type_string;\n\tinternal_value->type_description                  = type_description;\n\n\tinternal_value->initialize_instance               = initialize_instance;\n\tinternal_value->free_instance                     = free_instance;\n\tinternal_value->clone_instance                    = clone_instance;\n\n\tinternal_value->copy_from_byte_stream             = copy_from_byte_stream;\n\tinternal_value->copy_to_byte_stream               = copy_to_byte_stream;\n\n\tinternal_value->copy_from_integer                 = copy_from_integer;\n\tinternal_value->copy_to_integer                   = copy_to_integer;\n\n\tinternal_value->copy_from_floating_point          = copy_from_floating_point;\n\tinternal_value->copy_to_floating_point            = copy_to_floating_point;\n\n\tinternal_value->copy_from_utf8_string_with_index  = copy_from_utf8_string_with_index;\n\tinternal_value->get_utf8_string_size              = get_utf8_string_size;\n\tinternal_value->copy_to_utf8_string_with_index    = copy_to_utf8_string_with_index;\n\n\tinternal_value->copy_from_utf16_string_with_index = copy_from_utf16_string_with_index;\n\tinternal_value->get_utf16_string_size             = get_utf16_string_size;\n\tinternal_value->copy_to_utf16_string_with_index   = copy_to_utf16_string_with_index;\n\n\tinternal_value->copy_from_utf32_string_with_index = copy_from_utf32_string_with_index;\n\tinternal_value->get_utf32_string_size             = get_utf32_string_size;\n\tinternal_value->copy_to_utf32_string_with_index   = copy_to_utf32_string_with_index;\n\n\tinternal_value->flags                            |= flags;\n\n\t*value = (libfvalue_value_t *) internal_value;\n\n\treturn( 1 );\n\non_error:\n\tif( internal_value != NULL )\n\t{\n\t\tif( internal_value->value_instances != NULL )\n\t\t{\n\t\t\tlibcdata_array_free(\n\t\t\t &( internal_value->value_instances ),\n\t\t\t NULL,\n\t\t\t NULL );\n\t\t}\n\t\tmemory_free(\n\t\t internal_value );\n\t}\n\treturn( -1 );\n", "Selected Statement": "internal_value->copy_from_integer                 = copy_from_integer;", "Function Input": {"data_handle": {"value": {"type_category": "unknown", "concrete_type": "libfvalue_data_handle_t", "value": "21718765"}}, "error": {"value": null}, "flags": {"value": "0 '\\000'"}, "type_description": {"value": "0x7ffff7caad24 \"A\\211\\301\\351\\202\\376\\377\\377\\017\\037@\""}, "type_string": {"value": null}, "value": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffda50", "value": {"type_category": "unknown", "concrete_type": "libfvalue_value_t", "value": "66570244592322645"}}}}, "Variable Values Before Statement": {"copy_from_integer": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "     libewf_segment_file_t **segment_file,\n     libewf_io_handle_t *io_handle,\n     libcerror_error_t **error )\n{\n\tstatic char *function = \"libewf_segment_file_initialize\";\n\n\tif( segment_file == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid segment file.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *segment_file != NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\n\t\t \"%s: invalid segment file value already set.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( io_handle == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid IO handle.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\t*segment_file = memory_allocate_structure(\n\t                 libewf_segment_file_t );\n\n\tif( *segment_file == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create segment file.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     *segment_file,\n\t     0,\n\t     sizeof( libewf_segment_file_t ) ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear segment file.\",\n\t\t function );\n\n\t\tmemory_free(\n\t\t *segment_file );\n\n\t\t*segment_file = NULL;\n\n\t\treturn( -1 );\n\t}\n\tif( libfdata_list_initialize(\n\t     &( ( *segment_file )->sections_list ),\n\t     (intptr_t *) *segment_file,\n\t     NULL,\n\t     NULL,\n\t     (int (*)(intptr_t *, intptr_t *, libfdata_list_element_t *, libfdata_cache_t *, int, off64_t, size64_t, uint32_t, uint8_t, libcerror_error_t **)) &libewf_segment_file_read_section_element_data,\n\t     NULL,\n\t     LIBFDATA_DATA_HANDLE_FLAG_NON_MANAGED,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create sections list.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( libfdata_list_initialize(\n\t     &( ( *segment_file )->chunk_groups_list ),\n\t     (intptr_t *) *segment_file,\n\t     NULL,\n\t     NULL,\n\t     (int (*)(intptr_t *, intptr_t *, libfdata_list_element_t *, libfdata_cache_t *, int, off64_t, size64_t, uint32_t, uint8_t, libcerror_error_t **)) &libewf_segment_file_read_chunk_group_element_data,\n\t     NULL,\n\t     LIBFDATA_DATA_HANDLE_FLAG_NON_MANAGED,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create chunk groups list.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( libfcache_cache_initialize(\n\t     &( ( *segment_file )->chunk_groups_cache ),\n\t     LIBEWF_MAXIMUM_CACHE_ENTRIES_CHUNK_GROUPS,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create chunk groups cache.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\t( *segment_file )->io_handle                        = io_handle;\n\t( *segment_file )->device_information_section_index = -1;\n\t( *segment_file )->previous_last_chunk_filled       = -1;\n\t( *segment_file )->last_chunk_filled                = -1;\n\t( *segment_file )->last_chunk_compared              = -1;\n\n\treturn( 1 );\n\non_error:\n\tif( *segment_file != NULL )\n\t{\n\t\tif( ( *segment_file )->chunk_groups_list != NULL )\n\t\t{\n\t\t\tlibfdata_list_free(\n\t\t\t &( ( *segment_file )->chunk_groups_list ),\n\t\t\t NULL );\n\t\t}\n\t\tif( ( *segment_file )->sections_list != NULL )\n\t\t{\n\t\t\tlibfdata_list_free(\n\t\t\t &( ( *segment_file )->sections_list ),\n\t\t\t NULL );\n\t\t}\n\t\tmemory_free(\n\t\t *segment_file );\n\n\t\t*segment_file = NULL;\n\t}\n\treturn( -1 );\n", "Selected Statement": "( *segment_file )->io_handle                        = io_handle;", "Function Input": {"error": {"value": null}, "io_handle": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"access_flags": {"type_category": "int", "concrete_type": "int", "value": "1"}, "segment_file_type": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "0 '\\000'"}, "format": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "0 '\\000'"}, "major_version": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "0 '\\000'"}, "minor_version": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "0 '\\000'"}, "compression_method": {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, "compression_level": {"type_category": "unknown", "concrete_type": "int8_t", "value": "0 '\\000'"}, "compression_flags": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "0 '\\000'"}, "is_encrypted": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "0 '\\000'"}, "chunk_size": {"type_category": "unknown", "concrete_type": "size32_t", "value": "0"}, "zero_on_error": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "0 '\\000'"}, "header_codepage": {"type_category": "int", "concrete_type": "int", "value": "0"}, "abort": {"type_category": "int", "concrete_type": "int", "value": "0"}}}}, "segment_file": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x124a0b0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x1\n", "message": "Cannot access memory at address 0x1"}}}}, "Variable Values Before Statement": {"io_handle": {"access_flags": "0", "segment_file_type": "0 '\\000'", "format": "6 '\\006'", "major_version": "1 '\\001'", "minor_version": "0 '\\000'", "compression_method": "1", "compression_level": "0 '\\000'", "compression_flags": "0 '\\000'", "is_encrypted": "0 '\\000'", "chunk_size": "0", "zero_on_error": "1 '\\001'", "header_codepage": "20127", "abort": "0"}}, "Value After Statement Execution": {"access_flags": "0", "segment_file_type": "0 '\\000'", "format": "6 '\\006'", "major_version": "1 '\\001'", "minor_version": "0 '\\000'", "compression_method": "1", "compression_level": "0 '\\000'", "compression_flags": "0 '\\000'", "is_encrypted": "0 '\\000'", "chunk_size": "0", "zero_on_error": "1 '\\001'", "header_codepage": "20127", "abort": "0"}, "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "     size64_t size,\n     size64_t leaf_value_size,\n     libcerror_error_t **error )\n{\n\tstatic char *function  = \"libfsfat_block_tree_node_initialize\";\n\tsize64_t sub_node_size = 0;\n\n\tif( block_tree_node == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid block tree node.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *block_tree_node != NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\n\t\t \"%s: invalid block tree node value already set.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( offset < 0 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: invalid offset value out of bounds.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( ( size == 0 )\n\t || ( size > (size64_t) ( INT64_MAX - offset ) ) )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: invalid size value out of bounds.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( leaf_value_size == 0 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: invalid leaf value size value out of bounds.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\t*block_tree_node = memory_allocate_structure(\n\t                    libfsfat_block_tree_node_t );\n\n\tif( *block_tree_node == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create block tree node.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     *block_tree_node,\n\t     0,\n\t     sizeof( libfsfat_block_tree_node_t ) ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear block tree node.\",\n\t\t function );\n\n\t\tmemory_free(\n\t\t *block_tree_node );\n\n\t\t*block_tree_node = NULL;\n\n\t\treturn( -1 );\n\t}\n\tif( libcdata_array_initialize(\n\t     &( ( *block_tree_node )->sub_nodes_array ),\n\t     LIBFSFAT_BLOCK_TREE_NUMBER_OF_SUB_NODES,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create sub nodes array.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tsub_node_size = leaf_value_size;\n\n\twhile( ( size / sub_node_size ) > LIBFSFAT_BLOCK_TREE_NUMBER_OF_SUB_NODES )\n\t{\n\t\tsub_node_size *= LIBFSFAT_BLOCK_TREE_NUMBER_OF_SUB_NODES;\n\t}\n\t( *block_tree_node )->start_offset  = offset;\n\t( *block_tree_node )->end_offset    = offset + size;\n\t( *block_tree_node )->size          = size;\n\t( *block_tree_node )->sub_node_size = sub_node_size;\n\n\tif( sub_node_size == leaf_value_size )\n\t{\n\t\t( *block_tree_node )->is_leaf_node = 1;\n\t}\n\treturn( 1 );\n\non_error:\n\tif( *block_tree_node != NULL )\n\t{\n\t\tmemory_free(\n\t\t *block_tree_node );\n\n\t\t*block_tree_node = NULL;\n\t}\n\treturn( -1 );\n", "Selected Statement": "( *block_tree_node )->start_offset  = offset;", "Function Input": {"block_tree_node": {"value": {"type_category": "pointer", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x204\n", "message": "Cannot access memory at address 0x204"}}, "error": {"value": null}, "leaf_value_size": {"value": "140737488345584"}, "offset": {"value": "2199023255553"}, "size": {"value": "262144"}}, "Variable Values Before Statement": {"offset": "off64_t"}, "Value After Statement Execution": "off64_t", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "int libexe_io_handle_initialize(\n     libexe_io_handle_t **io_handle,\n     libcerror_error_t **error )\n{\n\tstatic char *function = \"libexe_io_handle_initialize\";\n\n\tif( io_handle == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid IO handle.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *io_handle != NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\n\t\t \"%s: invalid IO handle value already set.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\t*io_handle = memory_allocate_structure(\n\t              libexe_io_handle_t );\n\n\tif( *io_handle == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create IO handle.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     *io_handle,\n\t     0,\n\t     sizeof( libexe_io_handle_t ) ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear file.\",\n\t\t function );\n\n\t\tmemory_free(\n\t\t *io_handle );\n\n\t\t*io_handle = NULL;\n\n\t\treturn( -1 );\n\t}\n\t( *io_handle )->executable_type = LIBEXE_EXECUTABLE_TYPE_MZ;\n\t( *io_handle )->ascii_codepage  = LIBEXE_CODEPAGE_WINDOWS_1252;\n\n\treturn( 1 );\n\non_error:\n\tif( *io_handle != NULL )\n\t{\n\t\tmemory_free(\n\t\t *io_handle );\n\n\t\t*io_handle = NULL;\n\t}\n\treturn( -1 );\n", "Selected Statement": "( *io_handle )->executable_type = LIBEXE_EXECUTABLE_TYPE_MZ;", "Function Input": {"error": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x4c6f00 <libbfio_memory_range_io_handle_get_size>", "value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x40ec8348e5894855\n", "message": "Cannot access memory at address 0x40ec8348e5894855"}}}, "io_handle": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x10735d8", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"executable_type": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "16 '\\020'"}, "coff_header": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x1069808", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"number_of_sections": {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, "creation_time": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, "optional_header_size": {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}}}}, "coff_optional_header": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x1069810", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x230\n", "message": "Cannot access memory at address 0x230"}}, "ascii_codepage": {"type_category": "int", "concrete_type": "int", "value": "33"}, "abort": {"type_category": "int", "concrete_type": "int", "value": "0"}}}}}}, "Variable Values Before Statement": {"LIBEXE_EXECUTABLE_TYPE_MZ": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "                libcerror_error_t **error ),\n     uint8_t flags,\n     libcerror_error_t **error )\n{\n\tlibfdata_internal_stream_t *internal_stream = NULL;\n\tstatic char *function                       = \"libfdata_stream_initialize\";\n\n\tif( stream == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid stream.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *stream != NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\n\t\t \"%s: invalid stream value already set.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( ( flags & 0xfe ) != 0 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\n\t\t \"%s: unsupported flags: 0x%02\" PRIx8 \".\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tinternal_stream = memory_allocate_structure(\n\t                   libfdata_internal_stream_t );\n\n\tif( internal_stream == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create stream.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     internal_stream,\n\t     0,\n\t     sizeof( libfdata_internal_stream_t ) ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear stream.\",\n\t\t function );\n\n\t\tmemory_free(\n\t\t internal_stream );\n\n\t\treturn( -1 );\n\t}\n\tif( libcdata_array_initialize(\n\t     &( internal_stream->segments_array ),\n\t     0,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create segments array.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( libcdata_array_initialize(\n\t     &( internal_stream->mapped_ranges_array ),\n\t     0,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create mapped ranges array.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tinternal_stream->segment_offset      = -1;\n\tinternal_stream->flags              |= flags;\n\tinternal_stream->data_handle         = data_handle;\n\tinternal_stream->free_data_handle    = free_data_handle;\n\tinternal_stream->clone_data_handle   = clone_data_handle;\n\tinternal_stream->create_segment      = create_segment;\n\tinternal_stream->read_segment_data   = read_segment_data;\n\tinternal_stream->write_segment_data  = write_segment_data;\n\tinternal_stream->seek_segment_offset = seek_segment_offset;\n\n\t*stream = (libfdata_stream_t *) internal_stream;\n\n\treturn( 1 );\n\non_error:\n\tif( internal_stream != NULL )\n\t{\n\t\tif( internal_stream->segments_array != NULL )\n\t\t{\n\t\t\tlibcdata_array_free(\n\t\t\t &( internal_stream->segments_array ),\n\t\t\t NULL,\n\t\t\t NULL );\n\t\t}\n\t\tmemory_free(\n\t\t internal_stream );\n\t}\n\treturn( -1 );\n", "Selected Statement": "internal_stream->read_segment_data   = read_segment_data;", "Function Input": {"data_handle": {"value": {"type_category": "unknown", "concrete_type": "intptr_t", "value": "17218720"}}, "error": {"value": {"type_category": "pointer", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x5b0000006e\n", "message": "Cannot access memory at address 0x5b0000006e"}}, "flags": {"value": "0 '\\000'"}, "stream": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7ffff7cce299 <malloc+441>", "value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x840fc08548c08949\n", "message": "Cannot access memory at address 0x840fc08548c08949"}}}}, "Variable Values Before Statement": {"read_segment_data": "{ssize_t (intptr_t *, intptr_t *, int, int, uint8_t *, size_t, uint32_t, uint8_t, libcerror_error_t **)} 0x4d81a0 <libexe_io_handle_read_segment_data>"}, "Value After Statement Execution": "{ssize_t (intptr_t *, intptr_t *, int, int, uint8_t *, size_t, uint32_t, uint8_t, libcerror_error_t **)} 0x4d81a0 <libexe_io_handle_read_segment_data>", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "     libfdata_list_t *compressed_blocks_list,\n     libfcache_cache_t *compressed_blocks_cache,\n     libcerror_error_t **error )\n{\n\tlibagdb_compressed_blocks_stream_data_handle_t *data_handle = NULL;\n\tstatic char *function                                       = \"libagdb_compressed_blocks_stream_initialize\";\n\toff64_t segment_offset                                      = 0;\n\tsize64_t segment_size                                       = 0;\n\tint element_index                                           = 0;\n\tint number_of_elements                                      = 0;\n\tint segment_index                                           = 0;\n\n\tif( compressed_blocks_stream == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid compressed block stream.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( compressed_blocks_list == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid compressed blocks list.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( libagdb_compressed_blocks_stream_data_handle_initialize(\n\t     &data_handle,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create data handle.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( data_handle == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_MISSING,\n\t\t \"%s: missing data handle.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tdata_handle->compressed_blocks_list  = compressed_blocks_list;\n\tdata_handle->compressed_blocks_cache = compressed_blocks_cache;\n\n\tif( libfdata_stream_initialize(\n\t     compressed_blocks_stream,\n\t     (intptr_t *) data_handle,\n\t     (int (*)(intptr_t **, libcerror_error_t **)) &libagdb_compressed_blocks_stream_data_handle_free,\n\t     NULL,\n\t     NULL,\n\t     (ssize_t (*)(intptr_t *, intptr_t *, int, int, uint8_t *, size_t, uint32_t, uint8_t, libcerror_error_t **)) &libagdb_compressed_blocks_stream_data_handle_read_segment_data,\n\t     NULL,\n\t     (off64_t (*)(intptr_t *, intptr_t *, int, int, off64_t, libcerror_error_t **)) &libagdb_compressed_blocks_stream_data_handle_seek_segment_offset,\n\t     LIBFDATA_DATA_HANDLE_FLAG_MANAGED,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create stream.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( libfdata_list_get_number_of_elements(\n\t     compressed_blocks_list,\n\t     &number_of_elements,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_GET_FAILED,\n\t\t \"%s: unable to retrieve number of compressed blocks list elements.\",\n\t\t function );\n\n\t\tdata_handle = NULL;\n\n\t\tgoto on_error;\n\t}\n\tfor( element_index = 0;\n\t     element_index < number_of_elements;\n\t     element_index++ )\n\t{\n\t\tif( libfdata_list_get_mapped_size_by_index(\n\t\t     compressed_blocks_list,\n\t\t     element_index,\n\t\t     &segment_size,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_GET_FAILED,\n\t\t\t \"%s: unable to retrieve compressed blocks list element: %d mapped size.\",\n\t\t\t function,\n\t\t\t element_index );\n\n\t\t\tdata_handle = NULL;\n\n\t\t\tgoto on_error;\n\t\t}\n\t\tif( libfdata_stream_append_segment(\n\t\t     *compressed_blocks_stream,\n\t\t     &segment_index,\n\t\t     0,\n\t\t     segment_offset,\n\t\t     segment_size,\n\t\t     0,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_APPEND_FAILED,\n\t\t\t \"%s: unable to append compressed blocks stream segment: %d.\",\n\t\t\t function,\n\t\t\t element_index );\n\n\t\t\tdata_handle = NULL;\n\n\t\t\tgoto on_error;\n\t\t}\n\t\tsegment_offset += segment_size;\n\t}\n\treturn( 1 );\n\non_error:\n\tif( *compressed_blocks_stream != NULL )\n\t{\n\t\tlibfdata_stream_free(\n\t\t compressed_blocks_stream,\n\t\t NULL );\n\t}\n\tif( data_handle != NULL )\n\t{\n\t\tlibagdb_compressed_blocks_stream_data_handle_free(\n\t\t &data_handle,\n\t\t NULL );\n\t}\n\treturn( -1 );\n", "Selected Statement": "data_handle->compressed_blocks_list  = compressed_blocks_list;", "Function Input": {"compressed_blocks_cache": {"value": null}, "compressed_blocks_list": {"value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x801087060\n", "message": "Cannot access memory at address 0x801087060"}}, "compressed_blocks_stream": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x11e6400", "value": {"type_category": "unknown", "concrete_type": "libfdata_stream_t", "value": "17303920"}}}, "error": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x108a300", "value": {"type_category": "unknown", "concrete_type": "libcerror_error_t", "value": "34359738384"}}}}, "Variable Values Before Statement": {"compressed_blocks_list": "0"}, "Value After Statement Execution": "0", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "void\ninit_parse_tree(struct sudoers_parse_tree *parse_tree, char *lhost, char *shost,\n    struct sudoers_context *ctx, struct sudo_nss *nss)\n{\n    TAILQ_INIT(&parse_tree->userspecs);\n    TAILQ_INIT(&parse_tree->defaults);\n    parse_tree->aliases = NULL;\n    parse_tree->shost = shost;\n    parse_tree->lhost = lhost;\n    parse_tree->ctx = ctx;\n    parse_tree->nss = nss;\n", "Selected Statement": "parse_tree->shost = shost;", "Function Input": {}, "Variable Values Before Statement": {"shost": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "sudoers"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\n#if !defined(HAVE_STRLCPY)\nsize_t\nstrlcpy(char *dst, const char *src, size_t size) {\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = size;\n\n\t\n\tif (n != 0U && --n != 0U) {\n\t\tdo {\n\t\t\tif ((*d++ = *s++) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (--n != 0U);\n\t}\n\n\t\n\tif (n == 0U) {\n\t\tif (size != 0U) {\n\t\t\t*d = '\\0'; \n\t\t}\n\t\twhile (*s++) {\n\t\t}\n\t}\n\n", "Selected Statement": "const char *s = src;", "Function Input": {}, "Variable Values Before Statement": {"src": "0x7fffffffde00 \"buffer-0x7fffffffdee8\""}, "Value After Statement Execution": "0x7fffffffde00 \"buffer-0x7fffffffdee8\"", "Project Information": "bind9"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "void\ndns_message_create(isc_mem_t *mctx, isc_mempool_t *namepool,\n\t\t   isc_mempool_t *rdspool, dns_message_intent_t intent,\n\t\t   dns_message_t **msgp) {\n\tREQUIRE(mctx != NULL);\n\tREQUIRE(msgp != NULL);\n\tREQUIRE(*msgp == NULL);\n\tREQUIRE(intent == DNS_MESSAGE_INTENTPARSE ||\n\t\tintent == DNS_MESSAGE_INTENTRENDER);\n\tREQUIRE((namepool != NULL && rdspool != NULL) ||\n\t\t(namepool == NULL && rdspool == NULL));\n\n\tdns_message_t *msg = isc_mem_get(mctx, sizeof(dns_message_t));\n\t*msg = (dns_message_t){\n\t\t.from_to_wire = intent,\n\t\t.references = ISC_REFCOUNT_INITIALIZER(1),\n\t\t.scratchpad = ISC_LIST_INITIALIZER,\n\t\t.cleanup = ISC_LIST_INITIALIZER,\n\t\t.rdatas = ISC_LIST_INITIALIZER,\n\t\t.rdatalists = ISC_LIST_INITIALIZER,\n\t\t.offsets = ISC_LIST_INITIALIZER,\n\t\t.freerdata = ISC_LIST_INITIALIZER,\n\t\t.freerdatalist = ISC_LIST_INITIALIZER,\n\t\t.magic = DNS_MESSAGE_MAGIC,\n\t\t.namepool = namepool,\n\t\t.rdspool = rdspool,\n\t\t.free_pools = (namepool == NULL && rdspool == NULL),\n\t};\n\n\tisc_mem_attach(mctx, &msg->mctx);\n\n\tif (msg->free_pools) {\n\t\tdns_message_createpools(mctx, &msg->namepool, &msg->rdspool);\n\t}\n\n\tmsginit(msg);\n\n\tfor (size_t i = 0; i < DNS_SECTION_MAX; i++) {\n\t\tISC_LIST_INIT(msg->sections[i]);\n\t}\n\n\tisc_buffer_t *dynbuf = NULL;\n\tisc_buffer_allocate(mctx, &dynbuf, SCRATCHPAD_SIZE);\n\tISC_LIST_APPEND(msg->scratchpad, dynbuf, link);\n\n\t*msgp = msg;\n", "Selected Statement": ".namepool = namepool,", "Function Input": {}, "Variable Values Before Statement": {"namepool": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "bind9"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\tdns_rdatacallbacks_initcommon(callbacks);\n\tcallbacks->error = isclog_error_callback;\n\tcallbacks->warn = isclog_warn_callback;\n}\n\nvoid\ndns_rdatacallbacks_init_stdio(dns_rdatacallbacks_t *callbacks) {\n", "Selected Statement": "callbacks->warn = isclog_warn_callback;", "Function Input": {"callbacks": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"magic": {"type_category": "int", "concrete_type": "unsigned int", "value": "1114990113"}, "add": {"type_category": "unknown", "concrete_type": "dns_addrdatasetfunc_t", "value": "0x183ea20"}, "rawdata": {"type_category": "unknown", "concrete_type": "dns_rawdatafunc_t"}, "zone": {"type_category": "pointer", "concrete_type": "NULL"}, "error": {"type_category": "pointer", "concrete_type": "NULL"}, "warn": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdf00", "value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xffffffffffffffff\n", "message": "Cannot access memory at address 0xffffffffffffffff"}}, "add_private": {"type_category": "pointer", "concrete_type": "VOID"}, "error_private": {"type_category": "pointer", "concrete_type": "NULL"}, "warn_private": {"type_category": "pointer", "concrete_type": "NULL"}}}}}, "Variable Values Before Statement": {"isclog_warn_callback": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "bind9"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "#include <isc/result.h>\n\nisc_result_t\nisc_parse_uint32(uint32_t *uip, const char *string, int base) {\n\tunsigned long n;\n\tuint32_t r;\n\tchar *e;\n\tif (!isalnum((unsigned char)(string[0]))) {\n\t\treturn (ISC_R_BADNUMBER);\n\t}\n\terrno = 0;\n\tn = strtoul(string, &e, base);\n\tif (*e != '\\0') {\n\t\treturn (ISC_R_BADNUMBER);\n\t}\n\t\n\tr = (uint32_t)n;\n\tif ((n == ULONG_MAX && errno == ERANGE) || (n != (unsigned long)r)) {\n\t\treturn (ISC_R_RANGE);\n\t}\n\t*uip = r;\n\treturn (ISC_R_SUCCESS);\n", "Selected Statement": "*uip = r;", "Function Input": {"base": {"value": "-1"}, "string": {"value": "0x7ffffffed9b0 \"\\260\\334\\376\\377\\377\\177\""}, "uip": {"value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xffffffff00000000\n", "message": "Cannot access memory at address 0xffffffff00000000"}}}, "Variable Values Before Statement": {"r": "8"}, "Value After Statement Execution": "8", "Project Information": "bind9"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "    Dwarf_Handler errhand,\n    Dwarf_Ptr errarg,\n    Dwarf_Debug *dbg,Dwarf_Error *error)\n{\n    Dwarf_Obj_Access_Interface_a *binary_interface = 0;\n    dwarf_macho_object_access_internals_t *intfc = 0;\n    int res = DW_DLV_OK;\n    int localerrnum = 0;\n    unsigned universalbinary_count = 0;\n\n    res = _dwarf_macho_object_access_init(\n        fd,\n        universalnumber,\n        ftype,endian,offsetsize,\n        &universalbinary_count,\n        filesize,\n        &binary_interface,\n        &localerrnum);\n    if (res != DW_DLV_OK) {\n        if (res == DW_DLV_NO_ENTRY) {\n            return res;\n        }\n        _dwarf_error(NULL, error, localerrnum);\n        return DW_DLV_ERROR;\n    }\n    \n    res = dwarf_object_init_b(binary_interface, errhand, errarg,\n        groupnumber, dbg, error);\n    if (res != DW_DLV_OK){\n        _dwarf_destruct_macho_access(binary_interface);\n        return res;\n    }\n    intfc = binary_interface->ai_object;\n    intfc->mo_path = strdup(true_path);\n    (*dbg)->de_obj_flags = intfc->mo_flags;\n    (*dbg)->de_obj_machine = intfc->mo_machine;\n    (*dbg)->de_universalbinary_index = universalnumber;\n    (*dbg)->de_universalbinary_count = universalbinary_count;\n    return res;\n", "Selected Statement": "int res = DW_DLV_OK;", "Function Input": {}, "Variable Values Before Statement": {"DW_DLV_OK": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "libdwarf"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "    Dwarf_Handler errhand,\n    Dwarf_Ptr errarg,\n    Dwarf_Debug *dbg,Dwarf_Error *error)\n{\n    Dwarf_Obj_Access_Interface_a *binary_interface = 0;\n    dwarf_elf_object_access_internals_t *intfc = 0;\n    int res = DW_DLV_OK;\n    int localerrnum = 0;\n\n    res = _dwarf_elf_object_access_init(\n        fd,\n        ftype,endian,offsetsize,filesize,\n        &binary_interface,\n        &localerrnum);\n    if (res != DW_DLV_OK) {\n        if (res == DW_DLV_NO_ENTRY) {\n            return res;\n        }\n        _dwarf_error(NULL, error, localerrnum);\n        return DW_DLV_ERROR;\n    }\n    \n    res = dwarf_object_init_b(binary_interface, errhand, errarg,\n        groupnumber, dbg, error);\n    if (res != DW_DLV_OK){\n        _dwarf_destruct_elf_nlaccess(binary_interface);\n        return res;\n    }\n    intfc = binary_interface->ai_object;\n    intfc->f_path = strdup(true_path);\n    (*dbg)->de_obj_machine = intfc->f_machine;\n    (*dbg)->de_obj_flags = intfc->f_flags;\n    return res;\n", "Selected Statement": "int res = DW_DLV_OK;", "Function Input": {}, "Variable Values Before Statement": {"DW_DLV_OK": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "libdwarf"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "    Dwarf_Debug dbg,\n    Dwarf_Unsigned *rnglists_count,\n    Dwarf_Error *error)\n{\n    int res = DW_DLV_ERROR;\n    Dwarf_Rnglists_Context *cxt = 0;\n    Dwarf_Unsigned count = 0;\n\n    CHECK_DBG(dbg,error,\"dwarf_load_rnglists\");\n    if (dbg->de_rnglists_context) {\n        if (rnglists_count) {\n            *rnglists_count = dbg->de_rnglists_context_count;\n        }\n        return DW_DLV_OK;\n    }\n    if (!dbg->de_debug_rnglists.dss_size) {\n        \n        return DW_DLV_NO_ENTRY;\n    }\n    if (!dbg->de_debug_rnglists.dss_data) {\n        res = _dwarf_load_section(dbg, &dbg->de_debug_rnglists,\n            error);\n        if (res != DW_DLV_OK) {\n            return res;\n        }\n    }\n    res = internal_load_rnglists_contexts(dbg,&cxt,&count,error);\n    if (res == DW_DLV_ERROR) {\n        return res;\n    }\n    dbg->de_rnglists_context = cxt;\n    dbg->de_rnglists_context_count = count;\n    if (rnglists_count) {\n        *rnglists_count = count;\n    }\n    return DW_DLV_OK;\n", "Selected Statement": "int res = DW_DLV_ERROR;", "Function Input": {}, "Variable Values Before Statement": {"DW_DLV_ERROR": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "libdwarf"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "}\n\n\nint luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud) {\n  l_uint32 oldnCcalls = L->nCcalls;\n  struct lua_longjmp lj;\n  lj.status = LUA_OK;\n  lj.previous = L->errorJmp;  \n  L->errorJmp = &lj;\n  LUAI_TRY(L, &lj,\n    (*f)(L, ud);\n  );\n  L->errorJmp = lj.previous;  \n  L->nCcalls = oldnCcalls;\n", "Selected Statement": "L->nCcalls = oldnCcalls;", "Function Input": {"L": {"value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3000000040\n", "message": "Cannot access memory at address 0x3000000040"}}}, "Variable Values Before Statement": {"oldnCcalls": "l_uint32"}, "Value After Statement Execution": "l_uint32", "Project Information": "lua"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "}\n\n\nvoid *luaM_malloc_ (lua_State *L, size_t size, int tag) {\n  if (size == 0)\n    return NULL;  \n  else {\n    global_State *g = G(L);\n    void *newblock = firsttry(g, NULL, tag, size);\n    if (l_unlikely(newblock == NULL)) {\n      newblock = tryagain(L, NULL, tag, size);\n      if (newblock == NULL)\n        luaM_error(L);\n    }\n    g->totalbytes += size;\n    return newblock;\n  }\n", "Selected Statement": "g->totalbytes += size;", "Function Input": {"L": {"value": null}}, "Variable Values Before Statement": {"size": "720"}, "Value After Statement Execution": "720", "Project Information": "lua"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "                SNDFILE **sndfile, \n                VIO_DATA *vio_data, \n                SF_VIRTUAL_IO *vio, SF_INFO *sndfile_info)\n{\n   \n   vio->get_filelen = vfget_filelen ;\n   vio->seek = vfseek ;\n   vio->read = vfread ;\n   vio->write = vfwrite ;\n   vio->tell = vftell ;\n\n   \n   vio_data->data = data ;\n   vio_data->length = size ;\n   vio_data->offset = 0 ;\n\n   memset(sndfile_info, 0, sizeof(SF_INFO)) ;\n\n   \n   *sndfile = sf_open_virtual(vio, SFM_READ, sndfile_info, vio_data) ;\n\n   if (sndfile_info->channels == 0)\n\t\t return -1 ;\n\n   if (sndfile_info->channels > 1024 * 1024)\n\t\t return -1 ;\n\n   return 0;\n", "Selected Statement": "vio_data->data = data ;", "Function Input": {}, "Variable Values Before Statement": {"data": "0x105a061 \"\""}, "Value After Statement Execution": "0x105a061 \"\"", "Project Information": "libsndfile"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nSNDFILE*\nsf_open_virtual\t(SF_VIRTUAL_IO *sfvirtual, int mode, SF_INFO *sfinfo, void *user_data)\n{\tSF_PRIVATE \t*psf ;\n\n\t\n\tif (sfvirtual->get_filelen == NULL)\n\t{\tsf_errno = SFE_BAD_VIRTUAL_IO ;\n\t\tsnprintf (sf_parselog, sizeof (sf_parselog), \"Bad vio_get_filelen in SF_VIRTUAL_IO struct.\\n\") ;\n\t\treturn NULL ;\n\t\t} ;\n\n\tif ((sfvirtual->seek == NULL || sfvirtual->tell == NULL) && sfinfo->seekable)\n\t{\tsf_errno = SFE_BAD_VIRTUAL_IO ;\n\t\tsnprintf (sf_parselog, sizeof (sf_parselog), \"Bad vio_seek / vio_tell in SF_VIRTUAL_IO struct.\\n\") ;\n\t\treturn NULL ;\n\t\t} ;\n\n\tif ((mode == SFM_READ || mode == SFM_RDWR) && sfvirtual->read == NULL)\n\t{\tsf_errno = SFE_BAD_VIRTUAL_IO ;\n\t\tsnprintf (sf_parselog, sizeof (sf_parselog), \"Bad vio_read in SF_VIRTUAL_IO struct.\\n\") ;\n\t\treturn NULL ;\n\t\t} ;\n\n\tif ((mode == SFM_WRITE || mode == SFM_RDWR) && sfvirtual->write == NULL)\n\t{\tsf_errno = SFE_BAD_VIRTUAL_IO ;\n\t\tsnprintf (sf_parselog, sizeof (sf_parselog), \"Bad vio_write in SF_VIRTUAL_IO struct.\\n\") ;\n\t\treturn NULL ;\n\t\t} ;\n\n\tif ((psf = psf_allocate ()) == NULL)\n\t{\tsf_errno = SFE_MALLOC_FAILED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tpsf_init_files (psf) ;\n\n\tpsf->virtual_io = SF_TRUE ;\n\tpsf->vio = *sfvirtual ;\n\tpsf->vio_user_data = user_data ;\n\n\tpsf->file.mode = mode ;\n\n\treturn psf_open_file (psf, sfinfo) ;\n", "Selected Statement": "psf->virtual_io = SF_TRUE ;", "Function Input": {}, "Variable Values Before Statement": {"SF_TRUE": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "libsndfile"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\n\nvoid test_deflate(unsigned char *compr, size_t comprLen)\n{\n    z_stream c_stream; \n    int err;\n    unsigned long len = dataLen;\n\n    c_stream.zalloc = zalloc;\n    c_stream.zfree = zfree;\n    c_stream.opaque = NULL;\n\n", "Selected Statement": "c_stream.zfree = zfree;", "Function Input": {"compr": {"value": "0xf77f80 \"=\""}, "comprLen": {"value": "140737488346736"}}, "Variable Values Before Statement": {"zfree": "mz_free_func"}, "Value After Statement Execution": "mz_free_func", "Project Information": "miniz"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nvoid test_large_deflate(unsigned char *compr, size_t comprLen,\n                        unsigned char *uncompr, size_t uncomprLen)\n{\n    z_stream c_stream; \n    int err;\n\n    c_stream.zalloc = zalloc;\n    c_stream.zfree = zfree;\n    c_stream.opaque = NULL;\n\n", "Selected Statement": "c_stream.zalloc = zalloc;", "Function Input": {"compr": {"value": "0xf77f80 \"\\n\""}, "comprLen": {"value": "140737488346736"}, "uncompr": {"value": "0x1 <error: Cannot access memory at address 0x1>"}, "uncomprLen": {"value": "16325344"}}, "Variable Values Before Statement": {"zalloc": "mz_alloc_func"}, "Value After Statement Execution": "mz_alloc_func", "Project Information": "miniz"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\n\nvoid test_flush(unsigned char *compr, size_t *comprLen)\n{\n    z_stream c_stream; \n    int err;\n    unsigned int len = dataLen;\n\n    c_stream.zalloc = zalloc;\n    c_stream.zfree = zfree;\n    c_stream.opaque = NULL;\n\n", "Selected Statement": "c_stream.zalloc = zalloc;", "Function Input": {"compr": {"value": "0xf77f80 \"\\a\""}, "comprLen": {"value": {"type_category": "unknown", "concrete_type": "size_t", "value": "140737488346800"}}}, "Variable Values Before Statement": {"zalloc": "mz_alloc_func"}, "Value After Statement Execution": "mz_alloc_func", "Project Information": "miniz"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nstatic logcallback logCallbackFunction = defaultLogCallback;\nvoid EXPORT_CALL\nlou_registerLogCallback(logcallback callback) {\n\tif (callback == NULL)\n\t\tlogCallbackFunction = defaultLogCallback;\n\telse\n\t\tlogCallbackFunction = callback;\n", "Selected Statement": "logCallbackFunction = callback;", "Function Input": {}, "Variable Values Before Statement": {"callback": "logcallback"}, "Value After Statement Execution": "logcallback", "Project Information": "liblouis"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "void\nrpl_free (void *p)\n# undef free\n{\n# if defined __GNUC__ && !defined __clang__\n  \n  int err[2];\n  err[0] = errno;\n  err[1] = errno;\n  errno = 0;\n  free (p);\n  errno = err[errno == 0];\n# else\n  int err = errno;\n  free (p);\n  errno = err;\n# endif\n", "Selected Statement": "int err = errno;", "Function Input": {}, "Variable Values Before Statement": {"errno": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "liblouis"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nvoid\nsldns_buffer_init_frm_data(sldns_buffer *buffer, void *data, size_t size)\n{\n\tmemset(buffer, 0, sizeof(*buffer));\n\tbuffer->_data = data;\n\tbuffer->_capacity = buffer->_limit = size;\n\tbuffer->_fixed = 1;\n", "Selected Statement": "buffer->_capacity = buffer->_limit = size;", "Function Input": {"buffer": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"_position": {"type_category": "unknown", "concrete_type": "size_t", "value": "0"}, "_limit": {"type_category": "unknown", "concrete_type": "size_t", "value": "18767888"}, "_capacity": {"type_category": "unknown", "concrete_type": "size_t", "value": "0"}, "_data": {"type_category": "string", "concrete_type": "NULL"}, "_fixed": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}, "_status_err": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}}}}, "data": {"value": null}, "size": {"value": "105810743"}}, "Variable Values Before Statement": {"size": "12"}, "Value After Statement Execution": "12", "Project Information": "unbound"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nvoid\nlog_init(const char* filename, int use_syslog, const char* chrootdir)\n{\n\tFILE *f;\n\tif(!key_created) {\n\t\tkey_created = 1;\n\t\tub_thread_key_create(&logkey, NULL);\n\t\tlock_basic_init(&log_lock);\n\t}\n\tlock_basic_lock(&log_lock);\n\tif(logfile \n#if defined(HAVE_SYSLOG_H) || defined(UB_ON_WINDOWS)\n\t|| logging_to_syslog\n#endif\n\t) {\n\t\tlock_basic_unlock(&log_lock); \n\t\tverbose(VERB_QUERY, \"switching log to %s\", \n\t\t\tuse_syslog?\"syslog\":(filename&&filename[0]?filename:\"stderr\"));\n\t\tlock_basic_lock(&log_lock);\n\t}\n\tif(logfile && logfile != stderr) {\n\t\tFILE* cl = logfile;\n\t\tlogfile = NULL; \n\t\tfclose(cl);\n\t}\n#ifdef HAVE_SYSLOG_H\n\tif(logging_to_syslog) {\n\t\tcloselog();\n\t\tlogging_to_syslog = 0;\n\t}\n\tif(use_syslog) {\n\t\t\n\t\t\n\t\topenlog(ident, LOG_NDELAY, UB_SYSLOG_FACILITY);\n\t\tlogging_to_syslog = 1;\n\t\tlock_basic_unlock(&log_lock);\n\t\treturn;\n\t}\n#elif defined(UB_ON_WINDOWS)\n\tif(logging_to_syslog) {\n\t\tlogging_to_syslog = 0;\n\t}\n\tif(use_syslog) {\n\t\tlogging_to_syslog = 1;\n\t\tlock_basic_unlock(&log_lock);\n\t\treturn;\n\t}\n#endif \n\tif(!filename || !filename[0]) {\n\t\tlogfile = stderr;\n\t\tlock_basic_unlock(&log_lock);\n\t\treturn;\n\t}\n\t\n\tif(chrootdir && chrootdir[0] && strncmp(filename, chrootdir,\n\t\tstrlen(chrootdir)) == 0) \n\t\tfilename += strlen(chrootdir);\n\tf = fopen(filename, \"a\");\n\tif(!f) {\n\t\tlock_basic_unlock(&log_lock);\n\t\tlog_err(\"Could not open logfile %s: %s\", filename, \n\t\t\tstrerror(errno));\n\t\treturn;\n\t}\n#ifndef UB_ON_WINDOWS\n\t\n\tsetvbuf(f, NULL, (int)_IOLBF, 0);\n#endif\n\tlogfile = f;\n\tlock_basic_unlock(&log_lock);\n", "Selected Statement": "logfile = f;", "Function Input": {"chrootdir": {"value": "0x1ee000 <error: Cannot access memory at address 0x1ee000>"}, "filename": {"value": "0x1f1660 <error: Cannot access memory at address 0x1f1660>"}, "use_syslog": {"value": "0"}}, "Variable Values Before Statement": {"f": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "unbound"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nint client(Fuzzer *fuzzer);\n\nvoid fuzzinit(Fuzzer *fuzzer){\n    struct sockaddr_in server_addr;\n    fuzzer->socket = socket(AF_INET, SOCK_STREAM, 0);\n\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(fuzzer->port);\n    server_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n\n    setsockopt(fuzzer->socket, SOL_SOCKET, SO_REUSEADDR, &(int){1}, sizeof(int));\n\n    bind(fuzzer->socket, (struct sockaddr*)&server_addr, sizeof(server_addr));\n    listen(fuzzer->socket,1);\n}\n\nvoid *Server(void *args){\n\n    Fuzzer *fuzzer = (Fuzzer*)args;\n    {\n        int client;\n        char clientData[10240];\n        struct sockaddr_in clientAddr;\n        uint32_t clientSZ = sizeof(clientAddr);\n\n        client = accept(fuzzer->socket, (struct sockaddr*)&clientAddr, &clientSZ);\n\n        send(client, fuzzer->buffer, fuzzer->size, 0);\n        recv(client, clientData, sizeof(clientData), 0);\n\n        send(client, fuzzer->buffer, fuzzer->size, 0);\n        recv(client, clientData, sizeof(clientData), 0);\n\n        shutdown(client,SHUT_RDWR);\n        close(client);\n    }\n    pthread_exit(NULL);\n}\n\nvoid clean(Fuzzer *fuzzer){\n    {\n        shutdown(fuzzer->socket,SHUT_RDWR);\n        close(fuzzer->socket);\n    }\n    free(fuzzer);\n}\n\nextern int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\n    if (size < kMinInputLength || size > kMaxInputLength){\n        return 0;\n    }\n\n    Fuzzer *fuzzer = (Fuzzer*)malloc(sizeof(Fuzzer));\n    fuzzer->port = PORT;\n    fuzzer->size = size;\n    fuzzer->buffer = data;\n\n    fuzzinit(fuzzer);\n\n", "Selected Statement": "server_addr.sin_family = AF_INET;", "Function Input": {}, "Variable Values Before Statement": {"AF_INET": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "libmodbus"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\t\n\tint file)\n{\n\tint rc = IXML_SUCCESS;\n\tParser *xmlParser = NULL;\n\n\txmlParser = Parser_init();\n\tif (xmlParser == NULL) {\n\t\treturn IXML_INSUFFICIENT_MEMORY;\n\t}\n\n\trc = Parser_readFileOrBuffer(xmlParser, xmlFileName, file);\n\tif (rc != IXML_SUCCESS) {\n\t\tParser_free(xmlParser);\n\t\treturn rc;\n\t}\n\n\txmlParser->curPtr = xmlParser->dataBuffer;\n\trc = Parser_parseDocument(retDoc, xmlParser);\n\treturn rc;\n", "Selected Statement": "int rc = IXML_SUCCESS;", "Function Input": {}, "Variable Values Before Statement": {"IXML_SUCCESS": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "pupnp"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "}\n\nvoid ixml_membuf_init(ixml_membuf *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tm->buf = NULL;\n\tm->length = (size_t)0;\n\tm->capacity = (size_t)0;\n", "Selected Statement": "m->size_inc = MEMBUF_DEF_SIZE_INC;", "Function Input": {"m": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdc80 \"\\300\\334\\377\\377\\377\\177\""}, "length": {"type_category": "unknown", "concrete_type": "size_t", "value": "5004613"}, "capacity": {"type_category": "unknown", "concrete_type": "size_t", "value": "15507792"}, "size_inc": {"type_category": "unknown", "concrete_type": "size_t", "value": "140737488346344"}}}}}, "Variable Values Before Statement": {"MEMBUF_DEF_SIZE_INC": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "pupnp"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "}\n\nint ixmlDocument_createDocumentEx(IXML_Document **rtDoc)\n{\n\tIXML_Document *doc;\n\tint errCode = IXML_SUCCESS;\n\n\tdoc = NULL;\n\tdoc = (IXML_Document *)malloc(sizeof(IXML_Document));\n\tif (doc == NULL) {\n\t\terrCode = IXML_INSUFFICIENT_MEMORY;\n\t\tgoto ErrorHandler;\n\t}\n\n\tixmlDocument_init(doc);\n\n\tdoc->n.nodeName = strdup((const char *)DOCUMENTNODENAME);\n\tif (doc->n.nodeName == NULL) {\n\t\tixmlDocument_free(doc);\n\t\tdoc = NULL;\n\t\terrCode = IXML_INSUFFICIENT_MEMORY;\n\t\tgoto ErrorHandler;\n\t}\n\n\tdoc->n.nodeType = eDOCUMENT_NODE;\n\tdoc->n.ownerDocument = doc;\n\nErrorHandler:\n\t*rtDoc = doc;\n", "Selected Statement": "*rtDoc = doc;", "Function Input": {"doc": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"n": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"nodeName": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdc20 \"\\200\\334\\377\\377\\377\\177\""}, "nodeValue": {"type_category": "string", "concrete_type": "string", "value": "0x4c6354 <Parser_parseDocument+180> \"\\211\\205\\\\\\377\\377\\377\\213\\265\\\\\\377\\377\\377\\211\\2654\\377\\377\\3771\\377\\350Cw\\367\\377\\213\\2054\\377\\377\\377\\203\\370\""}, "nodeType": {"type_category": "unknown", "concrete_type": "IXML_NODE_TYPE", "value": "eINVALID_NODE"}, "namespaceURI": {"type_category": "string", "concrete_type": "NULL"}, "prefix": {"type_category": "string", "concrete_type": "string", "value": "0x539400 <fuzzer::TPC> \"\""}, "localName": {"type_category": "string", "concrete_type": "string", "value": "0xeeb830 \"<?\""}, "readOnly": {"type_category": "int", "concrete_type": "int", "value": "15472256"}, "parentNode": {"type_category": "unknown", "concrete_type": "Nodeptr", "value": "0x7ffff7ae1e75 <_IO_setb+85>"}, "firstChild": {"type_category": "unknown", "concrete_type": "Nodeptr"}, "prevSibling": {"type_category": "unknown", "concrete_type": "Nodeptr", "value": "0xb75c702cdf80b200"}, "nextSibling": {"type_category": "unknown", "concrete_type": "Nodeptr"}, "firstAttr": {"type_category": "unknown", "concrete_type": "Nodeptr", "value": "0x7fffffffdce8"}, "ownerDocument": {"type_category": "unknown", "concrete_type": "Docptr", "value": "0xecb6f0"}, "ctag": {"type_category": "pointer", "concrete_type": "VOID"}}}}}}}, "Variable Values Before Statement": {"doc": {"n": null}}, "Value After Statement Execution": {"n": null}, "Project Information": "pupnp"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\tconst char *FunctionName,\n\tconst char *FmtStr,\n\t...)\n{\n\tva_list ArgList;\n\n\tFILE *fp = stdout;\n\tfprintf(fp, \"(%s::%s), line %d\", DbgFileName, FunctionName, DbgLineNo);\n\tif (FmtStr) {\n\t\tfprintf(fp, \": \");\n\t\tva_start(ArgList, FmtStr);\n\t\tvfprintf(fp, FmtStr, ArgList);\n\t\tfflush(fp);\n\t\tva_end(ArgList);\n\t} else {\n\t\tfprintf(fp, \"\\n\");\n\t}\n", "Selected Statement": "FILE *fp = stdout;", "Function Input": {"DbgFileName": {"value": "0xeca330 \"\\260\\243\\354\""}, "DbgLineNo": {"value": "118"}, "FmtStr": {"value": "0x7fffffffd8a0 \"@\\331\\377\""}, "FunctionName": {"value": "0x4c82df <Parser_skipWhiteSpaces+175> \"H\\203\\370\""}}, "Variable Values Before Statement": {"stdout": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "pupnp"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "                  CK_X_FUNCTION_LIST *funcs,\n                  void *lower_module,\n                  p11_destroyer lower_destroy)\n{\n\tmemcpy (virt, funcs, sizeof (CK_X_FUNCTION_LIST));\n\tvirt->lower_module = lower_module;\n\tvirt->lower_destroy = lower_destroy;\n", "Selected Statement": "virt->lower_destroy = lower_destroy;", "Function Input": {}, "Variable Values Before Statement": {"lower_destroy": "p11_destroyer"}, "Value After Statement Execution": "p11_destroyer", "Project Information": "p11-kit"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "              p11_dict_equals equal_func,\n              p11_destroyer key_destroy_func,\n              p11_destroyer value_destroy_func)\n{\n\tp11_dict *dict;\n\n\tassert (hash_func);\n\tassert (equal_func);\n\n\tdict = malloc (sizeof (p11_dict));\n\tif (dict) {\n\t\tdict->hash_func = hash_func;\n\t\tdict->equal_func = equal_func;\n\t\tdict->key_destroy_func = key_destroy_func;\n\t\tdict->value_destroy_func = value_destroy_func;\n\n\t\tdict->num_buckets = 9;\n\t\tdict->buckets = (dictbucket **)calloc (dict->num_buckets, sizeof (dictbucket *));\n\t\tif (!dict->buckets) {\n\t\t\tfree (dict);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tdict->num_items = 0;\n\t}\n\n\treturn dict;\n", "Selected Statement": "dict->hash_func = hash_func;", "Function Input": {}, "Variable Values Before Statement": {"hash_func": "p11_dict_hasher"}, "Value After Statement Execution": "p11_dict_hasher", "Project Information": "p11-kit"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "p11_rpc_message_init (p11_rpc_message *msg,\n                      p11_buffer *input,\n                      p11_buffer *output)\n{\n\tassert (input != NULL);\n\tassert (output != NULL);\n\tassert (output->ffree != NULL);\n\tassert (output->frealloc != NULL);\n\n\tmemset (msg, 0, sizeof (*msg));\n\n\tmsg->output = output;\n\tmsg->input = input;\n", "Selected Statement": "msg->input = input;", "Function Input": {"input": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"data": {"type_category": "pointer", "concrete_type": "VOID"}, "len": {"type_category": "unknown", "concrete_type": "size_t", "value": "7171829"}, "flags": {"type_category": "int", "concrete_type": "int", "value": "0"}, "size": {"type_category": "unknown", "concrete_type": "size_t", "value": "140737488346912"}, "frealloc": {"type_category": "pointer", "concrete_type": "NULL"}, "ffree": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffde38", "value": {"type_category": "unknown", "concrete_type": "unknown", "value": "{void (void *)} 0x7fffffffde80"}}}}}, "msg": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"call_id": {"type_category": "int", "concrete_type": "int", "value": "0"}, "call_type": {"type_category": "unknown", "concrete_type": "p11_rpc_message_type", "value": "0"}, "signature": {"type_category": "string", "concrete_type": "NULL"}, "input": {"type_category": "pointer", "concrete_type": "NULL"}, "output": {"type_category": "pointer", "concrete_type": "NULL"}, "parsed": {"type_category": "unknown", "concrete_type": "size_t", "value": "0"}, "sigverify": {"type_category": "string", "concrete_type": "NULL"}, "extra": {"type_category": "pointer", "concrete_type": "NULL"}}}}, "output": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"data": {"type_category": "pointer", "concrete_type": "VOID"}, "len": {"type_category": "unknown", "concrete_type": "size_t", "value": "13906552813760349578"}, "flags": {"type_category": "int", "concrete_type": "int", "value": "-1570962040"}, "size": {"type_category": "unknown", "concrete_type": "size_t", "value": "13963209366481488104"}, "frealloc": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x6f4030 <thread_local_message+32>", "value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x98b4864fffffdd0\n", "message": "Cannot access memory at address 0x98b4864fffffdd0"}}, "ffree": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x6f4038 <thread_local_message+40>", "value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xf830fc83948\n", "message": "Cannot access memory at address 0xf830fc83948"}}}}}}, "Variable Values Before Statement": {"input": {"data": null, "len": "0", "flags": "0", "size": "0", "frealloc": "{void *(void *, size_t)} 0x7ffff7cc0e80 <realloc>", "ffree": "{void (void *)} 0x7ffff7cc06d0 <free>"}}, "Value After Statement Execution": {"data": null, "len": "0", "flags": "0", "size": "0", "frealloc": "{void *(void *, size_t)} 0x7ffff7cc0e80 <realloc>", "ffree": "{void (void *)} 0x7ffff7cc06d0 <free>"}, "Project Information": "p11-kit"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\n\nDLLEXPORT tjhandle tj3Init(int initType)\n{\n  static const char FUNCTION_NAME[] = \"tj3Init\";\n  tjinstance *this = NULL;\n  tjhandle retval = NULL;\n\n  if (initType < 0 || initType >= TJ_NUMINIT)\n    THROWG(\"Invalid argument\", NULL);\n\n  if ((this = (tjinstance *)malloc(sizeof(tjinstance))) == NULL)\n    THROWG(\"Memory allocation failure\", NULL);\n  memset(this, 0, sizeof(tjinstance));\n  SNPRINTF(this->errStr, JMSG_LENGTH_MAX, \"No error\");\n\n  this->quality = -1;\n  this->subsamp = TJSAMP_UNKNOWN;\n  this->jpegWidth = -1;\n  this->jpegHeight = -1;\n  this->precision = 8;\n  this->colorspace = -1;\n  this->losslessPSV = 1;\n  this->xDensity = 1;\n  this->yDensity = 1;\n  this->scalingFactor = TJUNSCALED;\n\n  switch (initType) {\n  case TJINIT_COMPRESS:  return _tjInitCompress(this);\n  case TJINIT_DECOMPRESS:  return _tjInitDecompress(this);\n  case TJINIT_TRANSFORM:\n    retval = _tjInitCompress(this);\n    if (!retval) return NULL;\n    retval = _tjInitDecompress(this);\n    return retval;\n  }\n\nbailout:\n  return retval;\n", "Selected Statement": "this->subsamp = TJSAMP_UNKNOWN;", "Function Input": {}, "Variable Values Before Statement": {"TJSAMP_UNKNOWN": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nGLOBAL(struct jpeg_error_mgr *)\njpeg_std_error(struct jpeg_error_mgr *err)\n{\n  err->error_exit = error_exit;\n  err->emit_message = emit_message;\n  err->output_message = output_message;\n  err->format_message = format_message;\n  err->reset_error_mgr = reset_error_mgr;\n\n  err->trace_level = 0;         \n  err->num_warnings = 0;        \n  err->msg_code = 0;            \n\n  \n  err->jpeg_message_table = jpeg_std_message_table;\n  err->last_jpeg_message = (int)JMSG_LASTMSGCODE - 1;\n\n  err->addon_message_table = NULL;\n  err->first_addon_message = 0; \n  err->last_addon_message = 0;\n\n", "Selected Statement": "err->error_exit = error_exit;", "Function Input": {}, "Variable Values Before Statement": {"error_exit": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nGLOBAL(void)\njpeg_CreateCompress(j_compress_ptr cinfo, int version, size_t structsize)\n{\n  int i;\n\n  \n  cinfo->mem = NULL;            \n  if (version != JPEG_LIB_VERSION)\n    ERREXIT2(cinfo, JERR_BAD_LIB_VERSION, JPEG_LIB_VERSION, version);\n  if (structsize != sizeof(struct jpeg_compress_struct))\n    ERREXIT2(cinfo, JERR_BAD_STRUCT_SIZE,\n             (int)sizeof(struct jpeg_compress_struct), (int)structsize);\n\n  \n  {\n    struct jpeg_error_mgr *err = cinfo->err;\n    void *client_data = cinfo->client_data; \n    memset(cinfo, 0, sizeof(struct jpeg_compress_struct));\n    cinfo->err = err;\n    cinfo->client_data = client_data;\n  }\n  cinfo->is_decompressor = FALSE;\n\n  \n  jinit_memory_mgr((j_common_ptr)cinfo);\n\n  \n  cinfo->progress = NULL;\n  cinfo->dest = NULL;\n\n  cinfo->comp_info = NULL;\n\n  for (i = 0; i < NUM_QUANT_TBLS; i++) {\n    cinfo->quant_tbl_ptrs[i] = NULL;\n#if JPEG_LIB_VERSION >= 70\n    cinfo->q_scale_factor[i] = 100;\n#endif\n  }\n\n  for (i = 0; i < NUM_HUFF_TBLS; i++) {\n    cinfo->dc_huff_tbl_ptrs[i] = NULL;\n    cinfo->ac_huff_tbl_ptrs[i] = NULL;\n  }\n\n#if JPEG_LIB_VERSION >= 80\n  \n  cinfo->block_size = DCTSIZE;\n  cinfo->natural_order = jpeg_natural_order;\n  cinfo->lim_Se = DCTSIZE2 - 1;\n#endif\n\n  cinfo->script_space = NULL;\n\n  cinfo->input_gamma = 1.0;     \n\n  cinfo->data_precision = BITS_IN_JSAMPLE;\n\n  \n  cinfo->global_state = CSTATE_START;\n\n  \n  cinfo->master = (struct jpeg_comp_master *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,\n                                  sizeof(my_comp_master));\n  memset(cinfo->master, 0, sizeof(my_comp_master));\n", "Selected Statement": "cinfo->err = err;", "Function Input": {"cinfo": {"value": "0x7ffff7ffe190"}, "structsize": {"value": "511101108348"}, "version": {"value": "0"}}, "Variable Values Before Statement": {"err": {"error_exit": "{void (j_common_ptr)} 0x4c0a00 <my_error_exit>", "emit_message": "{void (j_common_ptr, int)} 0x4e0180 <my_emit_message>", "output_message": "{void (j_common_ptr)} 0x4e00f0 <my_output_message>", "format_message": "{void (j_common_ptr, char *)} 0x5425c0 <format_message>", "reset_error_mgr": "{void (j_common_ptr)} 0x542990 <reset_error_mgr>", "msg_code": "0", "msg_parm": null, "trace_level": "0", "num_warnings": "0", "jpeg_message_table": "0x6780e4 \"Bogus message code %d\"", "last_jpeg_message": "129", "addon_message_table": null, "first_addon_message": "1000", "last_addon_message": "1028"}}, "Value After Statement Execution": {"error_exit": "{void (j_common_ptr)} 0x4c0a00 <my_error_exit>", "emit_message": "{void (j_common_ptr, int)} 0x4e0180 <my_emit_message>", "output_message": "{void (j_common_ptr)} 0x4e00f0 <my_output_message>", "format_message": "{void (j_common_ptr, char *)} 0x5425c0 <format_message>", "reset_error_mgr": "{void (j_common_ptr)} 0x542990 <reset_error_mgr>", "msg_code": "0", "msg_parm": null, "trace_level": "0", "num_warnings": "0", "jpeg_message_table": "0x6780e4 \"Bogus message code %d\"", "last_jpeg_message": "129", "addon_message_table": null, "first_addon_message": "1000", "last_addon_message": "1028"}, "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nGLOBAL(void)\njinit_memory_mgr(j_common_ptr cinfo)\n{\n  my_mem_ptr mem;\n  long max_to_use;\n  int pool;\n  size_t test_mac;\n\n  cinfo->mem = NULL;            \n\n  \n  if ((ALIGN_SIZE & (ALIGN_SIZE - 1)) != 0)\n    ERREXIT(cinfo, JERR_BAD_ALIGN_TYPE);\n  \n  test_mac = (size_t)MAX_ALLOC_CHUNK;\n  if ((long)test_mac != MAX_ALLOC_CHUNK ||\n      (MAX_ALLOC_CHUNK % ALIGN_SIZE) != 0)\n    ERREXIT(cinfo, JERR_BAD_ALLOC_CHUNK);\n\n  max_to_use = jpeg_mem_init(cinfo); \n\n  \n  mem = (my_mem_ptr)jpeg_get_small(cinfo, sizeof(my_memory_mgr));\n\n  if (mem == NULL) {\n    jpeg_mem_term(cinfo);       \n    ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, 0);\n  }\n\n  \n  mem->pub.alloc_small = alloc_small;\n  mem->pub.alloc_large = alloc_large;\n  mem->pub.alloc_sarray = alloc_sarray;\n  mem->pub.alloc_barray = alloc_barray;\n  mem->pub.request_virt_sarray = request_virt_sarray;\n  mem->pub.request_virt_barray = request_virt_barray;\n  mem->pub.realize_virt_arrays = realize_virt_arrays;\n  mem->pub.access_virt_sarray = access_virt_sarray;\n  mem->pub.access_virt_barray = access_virt_barray;\n  mem->pub.free_pool = free_pool;\n  mem->pub.self_destruct = self_destruct;\n\n  \n  mem->pub.max_alloc_chunk = MAX_ALLOC_CHUNK;\n\n  \n  mem->pub.max_memory_to_use = max_to_use;\n\n  for (pool = JPOOL_NUMPOOLS - 1; pool >= JPOOL_PERMANENT; pool--) {\n    mem->small_list[pool] = NULL;\n    mem->large_list[pool] = NULL;\n  }\n  mem->virt_sarray_list = NULL;\n  mem->virt_barray_list = NULL;\n\n  mem->total_space_allocated = sizeof(my_memory_mgr);\n\n  \n  cinfo->mem = &mem->pub;\n\n  \n#ifndef NO_GETENV\n  {\n    char memenv[30] = { 0 };\n\n    if (!GETENV_S(memenv, 30, \"JPEGMEM\") && strlen(memenv) > 0) {\n      char ch = 'x';\n\n#ifdef _MSC_VER\n      if (sscanf_s(memenv, \"%ld%c\", &max_to_use, &ch, 1) > 0) {\n#else\n      if (sscanf(memenv, \"%ld%c\", &max_to_use, &ch) > 0) {\n#endif\n        if (ch == 'm' || ch == 'M')\n          max_to_use *= 1000L;\n        mem->pub.max_memory_to_use = max_to_use * 1000L;\n      }\n    }\n  }\n#endif\n\n", "Selected Statement": "mem->pub.alloc_large = alloc_large;", "Function Input": {}, "Variable Values Before Statement": {"alloc_large": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "GLOBAL(void)\njpeg_mem_dest_tj(j_compress_ptr cinfo, unsigned char **outbuffer,\n                 size_t *outsize, boolean alloc)\n{\n  boolean reused = FALSE;\n  my_mem_dest_ptr dest;\n\n  if (outbuffer == NULL || outsize == NULL)     \n    ERREXIT(cinfo, JERR_BUFFER_SIZE);\n\n  \n  if (cinfo->dest == NULL) {    \n    cinfo->dest = (struct jpeg_destination_mgr *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,\n                                  sizeof(my_mem_destination_mgr));\n    dest = (my_mem_dest_ptr)cinfo->dest;\n    dest->newbuffer = NULL;\n    dest->buffer = NULL;\n  } else if (cinfo->dest->init_destination != init_mem_destination) {\n    \n    ERREXIT(cinfo, JERR_BUFFER_SIZE);\n  }\n\n  dest = (my_mem_dest_ptr)cinfo->dest;\n  dest->pub.init_destination = init_mem_destination;\n  dest->pub.empty_output_buffer = empty_mem_output_buffer;\n  dest->pub.term_destination = term_mem_destination;\n  if (dest->buffer == *outbuffer && *outbuffer != NULL && alloc)\n    reused = TRUE;\n  dest->outbuffer = outbuffer;\n  dest->outsize = outsize;\n  dest->alloc = alloc;\n\n  if (*outbuffer == NULL || *outsize == 0) {\n    if (alloc) {\n      \n      dest->newbuffer = *outbuffer = (unsigned char *)malloc(OUTPUT_BUF_SIZE);\n      if (dest->newbuffer == NULL)\n        ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, 10);\n      *outsize = OUTPUT_BUF_SIZE;\n    } else\n      ERREXIT(cinfo, JERR_BUFFER_SIZE);\n  }\n\n  dest->pub.next_output_byte = dest->buffer = *outbuffer;\n  if (!reused)\n    dest->bufsize = *outsize;\n  dest->pub.free_in_buffer = dest->bufsize;\n", "Selected Statement": "dest->pub.init_destination = init_mem_destination;", "Function Input": {"cinfo": {"value": "0x110a050"}}, "Variable Values Before Statement": {"init_mem_destination": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\n\nDLLEXPORT tjhandle tjInitCompress(void)\n{\n  tjinstance *this = NULL;\n\n  if ((this = (tjinstance *)malloc(sizeof(tjinstance))) == NULL) {\n    SNPRINTF(errStr, JMSG_LENGTH_MAX,\n             \"tjInitCompress(): Memory allocation failure\");\n    return NULL;\n  }\n  memset(this, 0, sizeof(tjinstance));\n  SNPRINTF(this->errStr, JMSG_LENGTH_MAX, \"No error\");\n  return _tjInitCompress(this);\n", "Selected Statement": "if (height == 0) height = jpegheight;", "Function Input": {}, "Variable Values Before Statement": {"jpegheight": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nGLOBAL(void)\njpeg_CreateCompress(j_compress_ptr cinfo, int version, size_t structsize)\n{\n  int i;\n\n  \n  cinfo->mem = NULL;            \n  if (version != JPEG_LIB_VERSION)\n    ERREXIT2(cinfo, JERR_BAD_LIB_VERSION, JPEG_LIB_VERSION, version);\n  if (structsize != sizeof(struct jpeg_compress_struct))\n    ERREXIT2(cinfo, JERR_BAD_STRUCT_SIZE,\n             (int)sizeof(struct jpeg_compress_struct), (int)structsize);\n\n  \n  {\n    struct jpeg_error_mgr *err = cinfo->err;\n    void *client_data = cinfo->client_data; \n    memset(cinfo, 0, sizeof(struct jpeg_compress_struct));\n    cinfo->err = err;\n    cinfo->client_data = client_data;\n  }\n  cinfo->is_decompressor = FALSE;\n\n  \n  jinit_memory_mgr((j_common_ptr)cinfo);\n\n  \n  cinfo->progress = NULL;\n  cinfo->dest = NULL;\n\n  cinfo->comp_info = NULL;\n\n  for (i = 0; i < NUM_QUANT_TBLS; i++) {\n    cinfo->quant_tbl_ptrs[i] = NULL;\n#if JPEG_LIB_VERSION >= 70\n    cinfo->q_scale_factor[i] = 100;\n#endif\n  }\n\n  for (i = 0; i < NUM_HUFF_TBLS; i++) {\n    cinfo->dc_huff_tbl_ptrs[i] = NULL;\n    cinfo->ac_huff_tbl_ptrs[i] = NULL;\n  }\n\n#if JPEG_LIB_VERSION >= 80\n  \n  cinfo->block_size = DCTSIZE;\n  cinfo->natural_order = jpeg_natural_order;\n  cinfo->lim_Se = DCTSIZE2 - 1;\n#endif\n\n  cinfo->script_space = NULL;\n\n  cinfo->input_gamma = 1.0;     \n\n  \n  cinfo->global_state = CSTATE_START;\n", "Selected Statement": "cinfo->err = err;", "Function Input": {"cinfo": {"value": "0x7ffff7ffe190"}, "structsize": {"value": "511101108348"}, "version": {"value": "0"}}, "Variable Values Before Statement": {"err": {"error_exit": "{void (j_common_ptr)} 0x4c0a20 <my_error_exit>", "emit_message": "{void (j_common_ptr, int)} 0x4d2fe0 <my_emit_message>", "output_message": "{void (j_common_ptr)} 0x4d2f50 <my_output_message>", "format_message": "{void (j_common_ptr, char *)} 0x5239c0 <format_message>", "reset_error_mgr": "{void (j_common_ptr)} 0x523d90 <reset_error_mgr>", "msg_code": "0", "msg_parm": null, "trace_level": "0", "num_warnings": "0", "jpeg_message_table": "0x5f4660 \"Bogus message code %d\"", "last_jpeg_message": "128", "addon_message_table": null, "first_addon_message": "1000", "last_addon_message": "1028"}}, "Value After Statement Execution": {"error_exit": "{void (j_common_ptr)} 0x4c0a20 <my_error_exit>", "emit_message": "{void (j_common_ptr, int)} 0x4d2fe0 <my_emit_message>", "output_message": "{void (j_common_ptr)} 0x4d2f50 <my_output_message>", "format_message": "{void (j_common_ptr, char *)} 0x5239c0 <format_message>", "reset_error_mgr": "{void (j_common_ptr)} 0x523d90 <reset_error_mgr>", "msg_code": "0", "msg_parm": null, "trace_level": "0", "num_warnings": "0", "jpeg_message_table": "0x5f4660 \"Bogus message code %d\"", "last_jpeg_message": "128", "addon_message_table": null, "first_addon_message": "1000", "last_addon_message": "1028"}, "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nGLOBAL(void)\njinit_memory_mgr(j_common_ptr cinfo)\n{\n  my_mem_ptr mem;\n  long max_to_use;\n  int pool;\n  size_t test_mac;\n\n  cinfo->mem = NULL;            \n\n  \n  if ((ALIGN_SIZE & (ALIGN_SIZE - 1)) != 0)\n    ERREXIT(cinfo, JERR_BAD_ALIGN_TYPE);\n  \n  test_mac = (size_t)MAX_ALLOC_CHUNK;\n  if ((long)test_mac != MAX_ALLOC_CHUNK ||\n      (MAX_ALLOC_CHUNK % ALIGN_SIZE) != 0)\n    ERREXIT(cinfo, JERR_BAD_ALLOC_CHUNK);\n\n  max_to_use = jpeg_mem_init(cinfo); \n\n  \n  mem = (my_mem_ptr)jpeg_get_small(cinfo, sizeof(my_memory_mgr));\n\n  if (mem == NULL) {\n    jpeg_mem_term(cinfo);       \n    ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, 0);\n  }\n\n  \n  mem->pub.alloc_small = alloc_small;\n  mem->pub.alloc_large = alloc_large;\n  mem->pub.alloc_sarray = alloc_sarray;\n  mem->pub.alloc_barray = alloc_barray;\n  mem->pub.request_virt_sarray = request_virt_sarray;\n  mem->pub.request_virt_barray = request_virt_barray;\n  mem->pub.realize_virt_arrays = realize_virt_arrays;\n  mem->pub.access_virt_sarray = access_virt_sarray;\n  mem->pub.access_virt_barray = access_virt_barray;\n  mem->pub.free_pool = free_pool;\n  mem->pub.self_destruct = self_destruct;\n\n  \n  mem->pub.max_alloc_chunk = MAX_ALLOC_CHUNK;\n\n  \n  mem->pub.max_memory_to_use = max_to_use;\n\n  for (pool = JPOOL_NUMPOOLS - 1; pool >= JPOOL_PERMANENT; pool--) {\n    mem->small_list[pool] = NULL;\n    mem->large_list[pool] = NULL;\n  }\n  mem->virt_sarray_list = NULL;\n  mem->virt_barray_list = NULL;\n\n  mem->total_space_allocated = sizeof(my_memory_mgr);\n\n  \n  cinfo->mem = &mem->pub;\n\n  \n#ifndef NO_GETENV\n  {\n    char memenv[30] = { 0 };\n\n    if (!GETENV_S(memenv, 30, \"JPEGMEM\") && strlen(memenv) > 0) {\n      char ch = 'x';\n\n#ifdef _MSC_VER\n      if (sscanf_s(memenv, \"%ld%c\", &max_to_use, &ch, 1) > 0) {\n#else\n      if (sscanf(memenv, \"%ld%c\", &max_to_use, &ch) > 0) {\n#endif\n        if (ch == 'm' || ch == 'M')\n          max_to_use *= 1000L;\n        mem->pub.max_memory_to_use = max_to_use * 1000L;\n      }\n    }\n  }\n#endif\n\n", "Selected Statement": "mem->pub.request_virt_barray = request_virt_barray;", "Function Input": {}, "Variable Values Before Statement": {"request_virt_barray": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "GLOBAL(void)\njpeg_mem_dest_tj(j_compress_ptr cinfo, unsigned char **outbuffer,\n                 unsigned long *outsize, boolean alloc)\n{\n  boolean reused = FALSE;\n  my_mem_dest_ptr dest;\n\n  if (outbuffer == NULL || outsize == NULL)     \n    ERREXIT(cinfo, JERR_BUFFER_SIZE);\n\n  \n  if (cinfo->dest == NULL) {    \n    cinfo->dest = (struct jpeg_destination_mgr *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,\n                                  sizeof(my_mem_destination_mgr));\n    dest = (my_mem_dest_ptr)cinfo->dest;\n    dest->newbuffer = NULL;\n    dest->buffer = NULL;\n  } else if (cinfo->dest->init_destination != init_mem_destination) {\n    \n    ERREXIT(cinfo, JERR_BUFFER_SIZE);\n  }\n\n  dest = (my_mem_dest_ptr)cinfo->dest;\n  dest->pub.init_destination = init_mem_destination;\n  dest->pub.empty_output_buffer = empty_mem_output_buffer;\n  dest->pub.term_destination = term_mem_destination;\n  if (dest->buffer == *outbuffer && *outbuffer != NULL && alloc)\n    reused = TRUE;\n  dest->outbuffer = outbuffer;\n  dest->outsize = outsize;\n  dest->alloc = alloc;\n\n  if (*outbuffer == NULL || *outsize == 0) {\n    if (alloc) {\n      \n      dest->newbuffer = *outbuffer = (unsigned char *)malloc(OUTPUT_BUF_SIZE);\n      if (dest->newbuffer == NULL)\n        ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, 10);\n      *outsize = OUTPUT_BUF_SIZE;\n    } else\n      ERREXIT(cinfo, JERR_BUFFER_SIZE);\n  }\n\n  dest->pub.next_output_byte = dest->buffer = *outbuffer;\n  if (!reused)\n    dest->bufsize = *outsize;\n  dest->pub.free_in_buffer = dest->bufsize;\n", "Selected Statement": "dest->outbuffer = outbuffer;", "Function Input": {"cinfo": {"value": "0x106b020"}}, "Variable Values Before Statement": {"outbuffer": "0x10687f8 <_tjInitCompress.buffer> \"\""}, "Value After Statement Execution": "0x10687f8 <_tjInitCompress.buffer> \"\"", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nGLOBAL(void)\njpeg_CreateDecompress(j_decompress_ptr cinfo, int version, size_t structsize)\n{\n  int i;\n\n  \n  cinfo->mem = NULL;            \n  if (version != JPEG_LIB_VERSION)\n    ERREXIT2(cinfo, JERR_BAD_LIB_VERSION, JPEG_LIB_VERSION, version);\n  if (structsize != sizeof(struct jpeg_decompress_struct))\n    ERREXIT2(cinfo, JERR_BAD_STRUCT_SIZE,\n             (int)sizeof(struct jpeg_decompress_struct), (int)structsize);\n\n  \n  {\n    struct jpeg_error_mgr *err = cinfo->err;\n    void *client_data = cinfo->client_data; \n    memset(cinfo, 0, sizeof(struct jpeg_decompress_struct));\n    cinfo->err = err;\n    cinfo->client_data = client_data;\n  }\n  cinfo->is_decompressor = TRUE;\n\n  \n  jinit_memory_mgr((j_common_ptr)cinfo);\n\n  \n  cinfo->progress = NULL;\n  cinfo->src = NULL;\n\n  for (i = 0; i < NUM_QUANT_TBLS; i++)\n    cinfo->quant_tbl_ptrs[i] = NULL;\n\n  for (i = 0; i < NUM_HUFF_TBLS; i++) {\n    cinfo->dc_huff_tbl_ptrs[i] = NULL;\n    cinfo->ac_huff_tbl_ptrs[i] = NULL;\n  }\n\n  \n  cinfo->marker_list = NULL;\n  jinit_marker_reader(cinfo);\n\n  \n  jinit_input_controller(cinfo);\n\n  \n  cinfo->global_state = DSTATE_START;\n\n  \n  cinfo->master = (struct jpeg_decomp_master *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,\n                                sizeof(my_decomp_master));\n  memset(cinfo->master, 0, sizeof(my_decomp_master));\n", "Selected Statement": "cinfo->err = err;", "Function Input": {"cinfo": {"value": "0x7ffff7ffe190"}, "structsize": {"value": "3"}, "version": {"value": "0"}}, "Variable Values Before Statement": {"err": {"error_exit": "{void (j_common_ptr)} 0x4c07e0 <my_error_exit>", "emit_message": "{void (j_common_ptr, int)} 0x4d2da0 <my_emit_message>", "output_message": "{void (j_common_ptr)} 0x4d2d10 <my_output_message>", "format_message": "{void (j_common_ptr, char *)} 0x523780 <format_message>", "reset_error_mgr": "{void (j_common_ptr)} 0x523b50 <reset_error_mgr>", "msg_code": "0", "msg_parm": null, "trace_level": "0", "num_warnings": "0", "jpeg_message_table": "0x5f4620 \"Bogus message code %d\"", "last_jpeg_message": "128", "addon_message_table": null, "first_addon_message": "1000", "last_addon_message": "1028"}}, "Value After Statement Execution": {"error_exit": "{void (j_common_ptr)} 0x4c07e0 <my_error_exit>", "emit_message": "{void (j_common_ptr, int)} 0x4d2da0 <my_emit_message>", "output_message": "{void (j_common_ptr)} 0x4d2d10 <my_output_message>", "format_message": "{void (j_common_ptr, char *)} 0x523780 <format_message>", "reset_error_mgr": "{void (j_common_ptr)} 0x523b50 <reset_error_mgr>", "msg_code": "0", "msg_parm": null, "trace_level": "0", "num_warnings": "0", "jpeg_message_table": "0x5f4620 \"Bogus message code %d\"", "last_jpeg_message": "128", "addon_message_table": null, "first_addon_message": "1000", "last_addon_message": "1028"}, "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nGLOBAL(void)\njinit_marker_reader(j_decompress_ptr cinfo)\n{\n  my_marker_ptr marker;\n  int i;\n\n  \n  marker = (my_marker_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,\n                                sizeof(my_marker_reader));\n  cinfo->marker = (struct jpeg_marker_reader *)marker;\n  \n  marker->pub.reset_marker_reader = reset_marker_reader;\n  marker->pub.read_markers = read_markers;\n  marker->pub.read_restart_marker = read_restart_marker;\n  \n  marker->process_COM = skip_variable;\n  marker->length_limit_COM = 0;\n  for (i = 0; i < 16; i++) {\n    marker->process_APPn[i] = skip_variable;\n    marker->length_limit_APPn[i] = 0;\n  }\n  marker->process_APPn[0] = get_interesting_appn;\n  marker->process_APPn[14] = get_interesting_appn;\n  \n  reset_marker_reader(cinfo);\n", "Selected Statement": "marker->process_COM = skip_variable;", "Function Input": {"cinfo": {"value": "0xffffdfd7"}}, "Variable Values Before Statement": {"skip_variable": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nGLOBAL(void)\njinit_input_controller(j_decompress_ptr cinfo)\n{\n  my_inputctl_ptr inputctl;\n\n  \n  inputctl = (my_inputctl_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,\n                                sizeof(my_input_controller));\n  cinfo->inputctl = (struct jpeg_input_controller *)inputctl;\n  \n  inputctl->pub.consume_input = consume_markers;\n  inputctl->pub.reset_input_controller = reset_input_controller;\n  inputctl->pub.start_input_pass = start_input_pass;\n  inputctl->pub.finish_input_pass = finish_input_pass;\n  \n  inputctl->pub.has_multiple_scans = FALSE; \n  inputctl->pub.eoi_reached = FALSE;\n  inputctl->inheaders = TRUE;\n", "Selected Statement": "inputctl->pub.start_input_pass = start_input_pass;", "Function Input": {"cinfo": {"value": "0x106b2a8"}}, "Variable Values Before Statement": {"start_input_pass": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "GLOBAL(void)\njpeg_mem_src_tj(j_decompress_ptr cinfo, const unsigned char *inbuffer,\n                unsigned long insize)\n{\n  struct jpeg_source_mgr *src;\n\n  if (inbuffer == NULL || insize == 0)  \n    ERREXIT(cinfo, JERR_INPUT_EMPTY);\n\n  \n  if (cinfo->src == NULL) {     \n    cinfo->src = (struct jpeg_source_mgr *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,\n                                  sizeof(struct jpeg_source_mgr));\n  } else if (cinfo->src->init_source != init_mem_source) {\n    \n    ERREXIT(cinfo, JERR_BUFFER_SIZE);\n  }\n\n  src = cinfo->src;\n  src->init_source = init_mem_source;\n  src->fill_input_buffer = fill_mem_input_buffer;\n  src->skip_input_data = skip_input_data;\n  src->resync_to_restart = jpeg_resync_to_restart; \n  src->term_source = term_source;\n  src->bytes_in_buffer = (size_t)insize;\n  src->next_input_byte = (const JOCTET *)inbuffer;\n", "Selected Statement": "src->term_source = term_source;", "Function Input": {"cinfo": {"value": "0x106b2a8"}}, "Variable Values Before Statement": {"term_source": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nGLOBAL(void)\njpeg_CreateDecompress(j_decompress_ptr cinfo, int version, size_t structsize)\n{\n  int i;\n\n  \n  cinfo->mem = NULL;            \n  if (version != JPEG_LIB_VERSION)\n    ERREXIT2(cinfo, JERR_BAD_LIB_VERSION, JPEG_LIB_VERSION, version);\n  if (structsize != sizeof(struct jpeg_decompress_struct))\n    ERREXIT2(cinfo, JERR_BAD_STRUCT_SIZE,\n             (int)sizeof(struct jpeg_decompress_struct), (int)structsize);\n\n  \n  {\n    struct jpeg_error_mgr *err = cinfo->err;\n    void *client_data = cinfo->client_data; \n    memset(cinfo, 0, sizeof(struct jpeg_decompress_struct));\n    cinfo->err = err;\n    cinfo->client_data = client_data;\n  }\n  cinfo->is_decompressor = TRUE;\n\n  \n  jinit_memory_mgr((j_common_ptr)cinfo);\n\n  \n  cinfo->progress = NULL;\n  cinfo->src = NULL;\n\n  for (i = 0; i < NUM_QUANT_TBLS; i++)\n    cinfo->quant_tbl_ptrs[i] = NULL;\n\n  for (i = 0; i < NUM_HUFF_TBLS; i++) {\n    cinfo->dc_huff_tbl_ptrs[i] = NULL;\n    cinfo->ac_huff_tbl_ptrs[i] = NULL;\n  }\n\n  \n  cinfo->marker_list = NULL;\n  jinit_marker_reader(cinfo);\n\n  \n  jinit_input_controller(cinfo);\n\n  cinfo->data_precision = BITS_IN_JSAMPLE;\n\n  \n  cinfo->global_state = DSTATE_START;\n\n  \n  cinfo->master = (struct jpeg_decomp_master *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,\n                                sizeof(my_decomp_master));\n  memset(cinfo->master, 0, sizeof(my_decomp_master));\n", "Selected Statement": "cinfo->err = err;", "Function Input": {"cinfo": {"value": "0x7ffff7ffe190"}, "structsize": {"value": "0"}, "version": {"value": "0"}}, "Variable Values Before Statement": {"err": {"error_exit": "{void (j_common_ptr)} 0x4c0c70 <my_error_exit>", "emit_message": "{void (j_common_ptr, int)} 0x4e03f0 <my_emit_message>", "output_message": "{void (j_common_ptr)} 0x4e0360 <my_output_message>", "format_message": "{void (j_common_ptr, char *)} 0x542830 <format_message>", "reset_error_mgr": "{void (j_common_ptr)} 0x542c00 <reset_error_mgr>", "msg_code": "0", "msg_parm": null, "trace_level": "0", "num_warnings": "0", "jpeg_message_table": "0x6780e4 \"Bogus message code %d\"", "last_jpeg_message": "129", "addon_message_table": null, "first_addon_message": "1000", "last_addon_message": "1028"}}, "Value After Statement Execution": {"error_exit": "{void (j_common_ptr)} 0x4c0c70 <my_error_exit>", "emit_message": "{void (j_common_ptr, int)} 0x4e03f0 <my_emit_message>", "output_message": "{void (j_common_ptr)} 0x4e0360 <my_output_message>", "format_message": "{void (j_common_ptr, char *)} 0x542830 <format_message>", "reset_error_mgr": "{void (j_common_ptr)} 0x542c00 <reset_error_mgr>", "msg_code": "0", "msg_parm": null, "trace_level": "0", "num_warnings": "0", "jpeg_message_table": "0x6780e4 \"Bogus message code %d\"", "last_jpeg_message": "129", "addon_message_table": null, "first_addon_message": "1000", "last_addon_message": "1028"}, "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nGLOBAL(void)\njinit_marker_reader(j_decompress_ptr cinfo)\n{\n  my_marker_ptr marker;\n  int i;\n\n  \n  marker = (my_marker_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,\n                                sizeof(my_marker_reader));\n  cinfo->marker = (struct jpeg_marker_reader *)marker;\n  \n  marker->pub.reset_marker_reader = reset_marker_reader;\n  marker->pub.read_markers = read_markers;\n  marker->pub.read_restart_marker = read_restart_marker;\n  \n  marker->process_COM = skip_variable;\n  marker->length_limit_COM = 0;\n  for (i = 0; i < 16; i++) {\n    marker->process_APPn[i] = skip_variable;\n    marker->length_limit_APPn[i] = 0;\n  }\n  marker->process_APPn[0] = get_interesting_appn;\n  marker->process_APPn[14] = get_interesting_appn;\n  \n  reset_marker_reader(cinfo);\n", "Selected Statement": "marker->pub.read_markers = read_markers;", "Function Input": {"cinfo": {"value": "0xffffdfe7"}}, "Variable Values Before Statement": {"read_markers": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nGLOBAL(void)\njinit_input_controller(j_decompress_ptr cinfo)\n{\n  my_inputctl_ptr inputctl;\n\n  \n  inputctl = (my_inputctl_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,\n                                sizeof(my_input_controller));\n  cinfo->inputctl = (struct jpeg_input_controller *)inputctl;\n  \n  inputctl->pub.consume_input = consume_markers;\n  inputctl->pub.reset_input_controller = reset_input_controller;\n  inputctl->pub.start_input_pass = start_input_pass;\n  inputctl->pub.finish_input_pass = finish_input_pass;\n  \n  inputctl->pub.has_multiple_scans = FALSE; \n  inputctl->pub.eoi_reached = FALSE;\n  inputctl->inheaders = TRUE;\n", "Selected Statement": "inputctl->pub.consume_input = consume_markers;", "Function Input": {"cinfo": {"value": "0x110a298"}}, "Variable Values Before Statement": {"consume_markers": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "GLOBAL(void)\njpeg_mem_src_tj(j_decompress_ptr cinfo, const unsigned char *inbuffer,\n                size_t insize)\n{\n  struct jpeg_source_mgr *src;\n\n  if (inbuffer == NULL || insize == 0)  \n    ERREXIT(cinfo, JERR_INPUT_EMPTY);\n\n  \n  if (cinfo->src == NULL) {     \n    cinfo->src = (struct jpeg_source_mgr *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,\n                                  sizeof(struct jpeg_source_mgr));\n  } else if (cinfo->src->init_source != init_mem_source) {\n    \n    ERREXIT(cinfo, JERR_BUFFER_SIZE);\n  }\n\n  src = cinfo->src;\n  src->init_source = init_mem_source;\n  src->fill_input_buffer = fill_mem_input_buffer;\n  src->skip_input_data = skip_input_data;\n  src->resync_to_restart = jpeg_resync_to_restart; \n  src->term_source = term_source;\n  src->bytes_in_buffer = insize;\n  src->next_input_byte = (const JOCTET *)inbuffer;\n", "Selected Statement": "src->init_source = init_mem_source;", "Function Input": {"cinfo": {"value": "0x110a298"}}, "Variable Values Before Statement": {"init_mem_source": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nGLOBAL(cjpeg_source_ptr)\njinit_read_targa(j_compress_ptr cinfo)\n{\n  tga_source_ptr source;\n\n  \n  source = (tga_source_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(tga_source_struct));\n  source->cinfo = cinfo;        \n  \n  source->pub.start_input = start_input_tga;\n  source->pub.finish_input = finish_input_tga;\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n  source->pub.max_pixels = 0;\n#endif\n\n", "Selected Statement": "source->pub.start_input = start_input_tga;", "Function Input": {}, "Variable Values Before Statement": {"start_input_tga": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nGLOBAL(cjpeg_source_ptr)\njinit_read_gif(j_compress_ptr cinfo)\n{\n  gif_source_ptr source;\n\n  \n  source = (gif_source_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(gif_source_struct));\n  source->cinfo = cinfo;        \n  \n  source->pub.start_input = start_input_gif;\n  source->pub.finish_input = finish_input_gif;\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n  source->pub.max_pixels = 0;\n#endif\n\n", "Selected Statement": "source->pub.start_input = start_input_gif;", "Function Input": {}, "Variable Values Before Statement": {"start_input_gif": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nGLOBAL(cjpeg_source_ptr)\njinit_read_bmp(j_compress_ptr cinfo, boolean use_inversion_array)\n{\n  bmp_source_ptr source;\n\n  \n  source = (bmp_source_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(bmp_source_struct));\n  source->cinfo = cinfo;        \n  \n  source->pub.start_input = start_input_bmp;\n  source->pub.finish_input = finish_input_bmp;\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n  source->pub.max_pixels = 0;\n#endif\n\n  source->use_inversion_array = use_inversion_array;\n\n", "Selected Statement": "source->pub.start_input = start_input_bmp;", "Function Input": {}, "Variable Values Before Statement": {"start_input_bmp": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nGLOBAL(cjpeg_source_ptr)\njinit_read_ppm(j_compress_ptr cinfo)\n{\n  ppm_source_ptr source;\n\n  \n  source = (ppm_source_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(ppm_source_struct));\n  \n  source->pub.start_input = start_input_ppm;\n  source->pub.finish_input = finish_input_ppm;\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n  source->pub.max_pixels = 0;\n#endif\n\n", "Selected Statement": "source->pub.start_input = start_input_ppm;", "Function Input": {}, "Variable Values Before Statement": {"start_input_ppm": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "}\n\nint device_alloc(struct crypt_device *cd, struct device **device, const char *path)\n{\n\tstruct device *dev;\n\tint r;\n\n\tr = device_alloc_no_check(&dev, path);\n\tif (r < 0)\n\t\treturn r;\n\n\tif (dev) {\n\t\tr = device_ready(cd, dev);\n\t\tif (!r) {\n\t\t\tdev->init_done = 1;\n\t\t} else if (r == -ENOTBLK) {\n\t\t\t\n\t\t} else if (r < 0) {\n\t\t\tfree(dev->path);\n\t\t\tfree(dev);\n\t\t\treturn -ENOTBLK;\n\t\t}\n\t}\n\n\t*device = dev;\n\treturn 0;\n", "Selected Statement": "*device = dev;", "Function Input": {}, "Variable Values Before Statement": {"dev": {"path": "0x1825970 \"/tmp/test-script-fuzz.o5sGzP\"", "file_path": null, "loop_fd": "-1", "ro_dev_fd": "-1", "dev_fd": "-1", "dev_fd_excl": "-1", "lh": null, "o_direct": "1", "init_done": "0", "alignment": "4096", "block_size": "4096", "loop_block_size": "0"}}, "Value After Statement Execution": {"path": "0x1825970 \"/tmp/test-script-fuzz.o5sGzP\"", "file_path": null, "loop_fd": "-1", "ro_dev_fd": "-1", "dev_fd": "-1", "dev_fd_excl": "-1", "lh": null, "o_direct": "1", "init_done": "0", "alignment": "4096", "block_size": "4096", "loop_block_size": "0"}, "Project Information": "cryptsetup"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": " * for computation\n */\nOSSL_METHOD_STORE *ossl_method_store_new(OSSL_LIB_CTX *ctx)\n{\n    OSSL_METHOD_STORE *res;\n\n    res = OPENSSL_zalloc(sizeof(*res));\n    if (res != NULL) {\n        res->ctx = ctx;\n        if ((res->algs = ossl_sa_ALGORITHM_new()) == NULL\n            || (res->lock = CRYPTO_THREAD_lock_new()) == NULL\n            || (res->biglock = CRYPTO_THREAD_lock_new()) == NULL) {\n            ossl_method_store_free(res);\n            return NULL;\n        }\n    }\n    return res;\n", "Selected Statement": "res->ctx = ctx;", "Function Input": {}, "Variable Values Before Statement": {"ctx": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "cryptsetup"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\n\nvoid    msg_vstream_init(const char *name, VSTREAM *vp)\n{\n    static int first_call = 1;\n\n    msg_tag = name;\n    msg_stream = vp;\n    if (first_call) {\n\tfirst_call = 0;\n\tmsg_output(msg_vstream_print);\n    }\n", "Selected Statement": "msg_tag = name;", "Function Input": {}, "Variable Values Before Statement": {"name": "0x53f941 \"fuzz_mime\""}, "Value After Statement Execution": "0x53f941 \"fuzz_mime\"", "Project Information": "postfix"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\t\t\t             MIME_STATE_ANY_END body_end,\n\t\t\t             MIME_STATE_ERR_PRINT err_print,\n\t\t\t             void *context)\n{\n    MIME_STATE *state;\n\n    state = (MIME_STATE *) mymalloc(sizeof(*state));\n\n    \n    state->err_flags = 0;\n    state->body_offset = 0;\t\t\t\n    SET_MIME_STATE(state, MIME_STATE_PRIMARY,\n\t\t   MIME_CTYPE_TEXT, MIME_STYPE_PLAIN,\n\t\t   MIME_ENC_7BIT, MIME_ENC_7BIT);\n    state->output_buffer = vstring_alloc(100);\n    state->prev_rec_type = 0;\n    state->stack = 0;\n    state->token_buffer = vstring_alloc(1);\n    state->nesting_level = -1;\t\t\t\n\n    \n    state->static_flags = flags;\n    state->head_out = head_out;\n    state->head_end = head_end;\n    state->body_out = body_out;\n    state->body_end = body_end;\n    state->err_print = err_print;\n    state->app_context = context;\n", "Selected Statement": "state->static_flags = flags;", "Function Input": {}, "Variable Values Before Statement": {"flags": "int"}, "Value After Statement Execution": "int", "Project Information": "postfix"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\n\nVSTRING *vstring_alloc(ssize_t len)\n{\n    VSTRING *vp;\n\n    \n    if (len < 1 || len > SSIZE_T_MAX - 1)\n\tmsg_panic(\"vstring_alloc: bad length %ld\", (long) len);\n    vp = (VSTRING *) mymalloc(sizeof(*vp));\n    vp->vbuf.flags = 0;\n    vp->vbuf.len = 0;\n    vp->vbuf.data = (unsigned char *) mymalloc(len + 1);\n    vp->vbuf.data[len] = 0;\n    vp->vbuf.len = len;\n    VSTRING_RESET(vp);\n    vp->vbuf.data[0] = 0;\n    vp->vbuf.get_ready = vstring_buf_get_ready;\n    vp->vbuf.put_ready = vstring_buf_put_ready;\n    vp->vbuf.space = vstring_buf_space;\n", "Selected Statement": "vp->vbuf.put_ready = vstring_buf_put_ready;", "Function Input": {}, "Variable Values Before Statement": {"vstring_buf_put_ready": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "postfix"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\n\nssize_t is_header_buf(const char *str, ssize_t str_len)\n{\n    const unsigned char *cp;\n    int     state;\n    int     c;\n    ssize_t len;\n\n#define INIT\t\t0\n#define IN_CHAR\t\t1\n#define IN_CHAR_SPACE\t2\n#define CU_CHAR_PTR(x)\t((const unsigned char *) (x))\n\n    \n    for (len = 0, state = INIT, cp = CU_CHAR_PTR(str); ; cp++) {\n\tif (str_len != IS_HEADER_NULL_TERMINATED && str_len-- <= 0)\n\t    return (0);\n\tswitch (c = *cp) {\n\tdefault:\n\t    if (c == 0 || !ISASCII(c) || ISCNTRL(c))\n\t\treturn (0);\n\t    if (state == INIT)\n\t\tstate = IN_CHAR;\n\t    if (state == IN_CHAR) {\n\t\tlen++;\n\t\tcontinue;\n\t    }\n\t    return (0);\n\tcase ' ':\n\tcase '\\t':\n\t    if (state == IN_CHAR)\n\t\tstate = IN_CHAR_SPACE;\n\t    if (state == IN_CHAR_SPACE)\n\t\tcontinue;\n\t    return (0);\n\tcase ':':\n\t    return ((state == IN_CHAR || state == IN_CHAR_SPACE) ? len : 0);\n\t}\n    }\n    \n    return (0);\n", "Selected Statement": "state = IN_CHAR;", "Function Input": {"str": {"value": "<optimized out>"}, "str_len": {"value": "<optimized out>"}}, "Variable Values Before Statement": {"IN_CHAR": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "postfix"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\n\nvoid    msg_output(MSG_OUTPUT_FN output_fn)\n{\n    int     i;\n\n    \n    if (msg_buffers[MSG_OUT_NESTING_LIMIT - 1] == 0) {\n\tfor (i = 0; i < MSG_OUT_NESTING_LIMIT; i++)\n\t    msg_buffers[i] = vstring_alloc(100);\n    }\n\n    \n    if (msg_output_fn_count == 0)\n\tmsg_output_fn = (MSG_OUTPUT_FN *) mymalloc(sizeof(*msg_output_fn));\n    else\n\tmsg_output_fn = (MSG_OUTPUT_FN *) myrealloc((void *) msg_output_fn,\n\t\t\t(msg_output_fn_count + 1) * sizeof(*msg_output_fn));\n    msg_output_fn[msg_output_fn_count++] = output_fn;\n", "Selected Statement": "msg_output_fn[msg_output_fn_count++] = output_fn;", "Function Input": {"output_fn": {"value": "<optimized out>"}}, "Variable Values Before Statement": {"output_fn": "MSG_OUTPUT_FN"}, "Value After Statement Execution": "MSG_OUTPUT_FN", "Project Information": "postfix"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\n\nTOK822 *tok822_alloc(int type, const char *strval)\n{\n    TOK822 *tp;\n\n#define CONTAINER_TOKEN(x) \\\n\t((x) == TOK822_ADDR || (x) == TOK822_STARTGRP)\n\n    tp = (TOK822 *) mymalloc(sizeof(*tp));\n    tp->type = type;\n    tp->next = tp->prev = tp->head = tp->tail = tp->owner = 0;\n    tp->vstr = (type < TOK822_MINTOK || CONTAINER_TOKEN(type) ? 0 :\n\t\tstrval == 0 ? vstring_alloc(10) :\n\t\tvstring_strcpy(vstring_alloc(strlen(strval) + 1), strval));\n", "Selected Statement": "tp->type = type;", "Function Input": {}, "Variable Values Before Statement": {"type": "int"}, "Value After Statement Execution": "int", "Project Information": "postfix"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\n\nVSTRING *quote_822_local_flags(VSTRING *dst, const char *mbox, int flags)\n{\n    const char *start;\t\t\t\n    const char *end;\t\t\t\n    const char *colon;\n\n    \n    if (mbox[0] == '@' && (colon = strchr(mbox, ':')) != 0)\n\tstart = colon + 1;\n    else\n\tstart = mbox;\n    if ((flags & QUOTE_FLAG_BARE_LOCALPART) != 0\n\t|| (end = strrchr(start, '@')) == 0)\n\tend = start + strlen(start);\n    if ((flags & QUOTE_FLAG_APPEND) == 0)\n\tVSTRING_RESET(dst);\n    if (is_822_dot_string(start, end, flags)) {\n\treturn (vstring_strcat(dst, mbox));\n    } else {\n\tvstring_strncat(dst, mbox, start - mbox);\n\tmake_822_quoted_string(dst, start, end, flags & QUOTE_FLAG_8BITCLEAN);\n\treturn (vstring_strcat(dst, end));\n    }\n", "Selected Statement": "start = mbox;", "Function Input": {"end": {"value": "<optimized out>"}, "flags": {"value": "<optimized out>"}}, "Variable Values Before Statement": {"mbox": "0xf5e2d0 \"[ ]\""}, "Value After Statement Execution": "0xf5e2d0 \"[ ]\"", "Project Information": "postfix"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "                                    const char *passphrase,\n                                    ssh_auth_callback auth_fn,\n                                    void *auth_data)\n{\n    BIO *mem = NULL;\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n    EC_KEY *ecdsa = NULL;\n#endif \n    uint8_t *ed25519 = NULL;\n    uint8_t *ed25519_pubkey = NULL;\n    ssh_key key = NULL;\n    enum ssh_keytypes_e type = SSH_KEYTYPE_UNKNOWN;\n    EVP_PKEY *pkey = NULL;\n\n    mem = BIO_new_mem_buf((void*)b64_key, -1);\n\n    if (passphrase == NULL) {\n        if (auth_fn) {\n            struct pem_get_password_struct pgp = { auth_fn, auth_data };\n\n            pkey = PEM_read_bio_PrivateKey(mem, NULL, pem_get_password, &pgp);\n        } else {\n            \n            pkey = PEM_read_bio_PrivateKey(mem, NULL, NULL, NULL);\n        }\n    } else {\n        pkey = PEM_read_bio_PrivateKey(mem, NULL, NULL, (void *) passphrase);\n    }\n\n    BIO_free(mem);\n\n    if (pkey == NULL) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Error parsing private key: %s\",\n                ERR_error_string(ERR_get_error(), NULL));\n        return NULL;\n    }\n    switch (EVP_PKEY_base_id(pkey)) {\n    case EVP_PKEY_RSA:\n        type = SSH_KEYTYPE_RSA;\n        break;\n    case EVP_PKEY_EC:\n#ifdef HAVE_OPENSSL_ECC\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n        ecdsa = EVP_PKEY_get0_EC_KEY(pkey);\n        if (ecdsa == NULL) {\n            SSH_LOG(SSH_LOG_TRACE,\n\t\t    \"Error parsing private key: %s\",\n                    ERR_error_string(ERR_get_error(), NULL));\n            goto fail;\n        }\n#endif \n\n        \n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n        type = pki_key_ecdsa_to_key_type(ecdsa);\n#else\n        type = pki_key_ecdsa_to_key_type(pkey);\n#endif \n        if (type == SSH_KEYTYPE_UNKNOWN) {\n            SSH_LOG(SSH_LOG_TRACE, \"Invalid private key.\");\n            goto fail;\n        }\n\n        break;\n#endif \n    case EVP_PKEY_ED25519:\n    {\n        size_t key_len;\n        int evp_rc = 0;\n\n        \n        evp_rc = EVP_PKEY_get_raw_private_key(pkey, NULL, &key_len);\n        if (evp_rc != 1) {\n            SSH_LOG(SSH_LOG_TRACE,\n                    \"Failed to get ed25519 raw private key length:  %s\",\n                    ERR_error_string(ERR_get_error(), NULL));\n            goto fail;\n        }\n\n        if (key_len != ED25519_KEY_LEN) {\n            goto fail;\n        }\n\n        ed25519 = malloc(key_len);\n        if (ed25519 == NULL) {\n            SSH_LOG(SSH_LOG_TRACE, \"Out of memory\");\n            goto fail;\n        }\n\n        evp_rc = EVP_PKEY_get_raw_private_key(pkey, (uint8_t *)ed25519,\n                                              &key_len);\n        if (evp_rc != 1) {\n            SSH_LOG(SSH_LOG_TRACE,\n                    \"Failed to get ed25519 raw private key:  %s\",\n                    ERR_error_string(ERR_get_error(), NULL));\n            goto fail;\n        }\n\n        \n        ed25519_pubkey = malloc(ED25519_KEY_LEN);\n        if (ed25519_pubkey == NULL) {\n            SSH_LOG(SSH_LOG_TRACE, \"Out of memory\");\n            goto fail;\n        }\n\n        evp_rc = EVP_PKEY_get_raw_public_key(pkey, (uint8_t *)ed25519_pubkey,\n                                             &key_len);\n        if (evp_rc != 1) {\n            SSH_LOG(SSH_LOG_TRACE,\n                    \"Failed to get ed25519 raw public key:  %s\",\n                    ERR_error_string(ERR_get_error(), NULL));\n            goto fail;\n        }\n        type = SSH_KEYTYPE_ED25519;\n\n    }\n    break;\n    default:\n        SSH_LOG(SSH_LOG_TRACE, \"Unknown or invalid private key type %d\",\n                EVP_PKEY_base_id(pkey));\n        EVP_PKEY_free(pkey);\n        return NULL;\n    }\n\n    key = ssh_key_new();\n    if (key == NULL) {\n        goto fail;\n    }\n\n    key->type = type;\n    key->type_c = ssh_key_type_to_char(type);\n    key->flags = SSH_KEY_FLAG_PRIVATE | SSH_KEY_FLAG_PUBLIC;\n    key->key = pkey;\n    key->ed25519_privkey = ed25519;\n    key->ed25519_pubkey = ed25519_pubkey;\n#ifdef HAVE_OPENSSL_ECC\n    if (is_ecdsa_key_type(key->type)) {\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n        key->ecdsa_nid = pki_key_ecdsa_to_nid(ecdsa);\n#else\n        key->ecdsa_nid = pki_key_ecdsa_to_nid(key->key);\n#endif \n    }\n#endif \n\n    return key;\nfail:\n    EVP_PKEY_free(pkey);\n    ssh_key_free(key);\n    SAFE_FREE(ed25519);\n    SAFE_FREE(ed25519_pubkey);\n    return NULL;\n", "Selected Statement": "enum ssh_keytypes_e type = SSH_KEYTYPE_UNKNOWN;", "Function Input": {}, "Variable Values Before Statement": {"SSH_KEYTYPE_UNKNOWN": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "libssh"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "    return s;\n}\n\nssh_bind ssh_bind_new(void) {\n    ssh_bind ptr;\n\n    ptr = calloc(1, sizeof(struct ssh_bind_struct));\n    if (ptr == NULL) {\n        return NULL;\n    }\n    ptr->bindfd = SSH_INVALID_SOCKET;\n    ptr->bindport = 22;\n    ptr->common.log_verbosity = 0;\n\n    return ptr;\n", "Selected Statement": "ptr->bindfd = SSH_INVALID_SOCKET;", "Function Input": {}, "Variable Values Before Statement": {"SSH_INVALID_SOCKET": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "libssh"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": " * @returns             A new ssh_session pointer, NULL on error.\n */\nssh_session ssh_new(void)\n{\n    ssh_session session;\n    char *id = NULL;\n    int rc;\n\n    session = calloc(1, sizeof (struct ssh_session_struct));\n    if (session == NULL) {\n        return NULL;\n    }\n\n    session->next_crypto = crypto_new();\n    if (session->next_crypto == NULL) {\n        goto err;\n    }\n\n    session->socket = ssh_socket_new(session);\n    if (session->socket == NULL) {\n        goto err;\n    }\n\n    session->out_buffer = ssh_buffer_new();\n    if (session->out_buffer == NULL) {\n        goto err;\n    }\n\n    session->in_buffer = ssh_buffer_new();\n    if (session->in_buffer == NULL) {\n        goto err;\n    }\n\n    session->out_queue = ssh_list_new();\n    if (session->out_queue == NULL) {\n        goto err;\n    }\n\n    session->alive = 0;\n    session->auth.supported_methods = 0;\n    ssh_set_blocking(session, 1);\n    session->maxchannel = FIRST_CHANNEL;\n\n    session->agent = ssh_agent_new(session);\n    if (session->agent == NULL) {\n        goto err;\n    }\n\n    \n    session->opts.StrictHostKeyChecking = 1;\n    session->opts.port = 22;\n    session->opts.fd = -1;\n    session->opts.compressionlevel = 7;\n    session->opts.nodelay = 0;\n    session->opts.identities_only = false;\n    session->opts.control_master = SSH_CONTROL_MASTER_NO;\n\n    session->opts.flags = SSH_OPT_FLAG_PASSWORD_AUTH |\n                          SSH_OPT_FLAG_PUBKEY_AUTH |\n                          SSH_OPT_FLAG_KBDINT_AUTH |\n                          SSH_OPT_FLAG_GSSAPI_AUTH;\n\n    session->opts.exp_flags = 0;\n\n    session->opts.identity = ssh_list_new();\n    if (session->opts.identity == NULL) {\n        goto err;\n    }\n    session->opts.identity_non_exp = ssh_list_new();\n    if (session->opts.identity_non_exp == NULL) {\n        goto err;\n    }\n\n    session->opts.certificate = ssh_list_new();\n    if (session->opts.certificate == NULL) {\n        goto err;\n    }\n    session->opts.certificate_non_exp = ssh_list_new();\n    if (session->opts.certificate_non_exp == NULL) {\n        goto err;\n    }\n    \n\n    id = strdup(\"%d/id_ed25519\");\n    if (id == NULL) {\n        goto err;\n    }\n\n    rc = ssh_list_append(session->opts.identity_non_exp, id);\n    if (rc == SSH_ERROR) {\n        goto err;\n    }\n\n#ifdef HAVE_ECC\n    id = strdup(\"%d/id_ecdsa\");\n    if (id == NULL) {\n        goto err;\n    }\n    rc = ssh_list_append(session->opts.identity_non_exp, id);\n    if (rc == SSH_ERROR) {\n        goto err;\n    }\n#endif\n\n    id = strdup(\"%d/id_rsa\");\n    if (id == NULL) {\n        goto err;\n    }\n    rc = ssh_list_append(session->opts.identity_non_exp, id);\n    if (rc == SSH_ERROR) {\n        goto err;\n    }\n\n    \n    session->session_state = SSH_SESSION_STATE_NONE;\n    session->pending_call_state = SSH_PENDING_CALL_NONE;\n    session->packet_state = PACKET_STATE_INIT;\n    session->dh_handshake_state = DH_STATE_INIT;\n    session->global_req_state = SSH_CHANNEL_REQ_STATE_NONE;\n\n    session->auth.state = SSH_AUTH_STATE_NONE;\n    session->auth.service_state = SSH_AUTH_SERVICE_NONE;\n\n    return session;\n\nerr:\n    free(id);\n    ssh_free(session);\n    return NULL;\n", "Selected Statement": "session->packet_state = PACKET_STATE_INIT;", "Function Input": {}, "Variable Values Before Statement": {"PACKET_STATE_INIT": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "libssh"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": " * \\brief creates a new Socket object\n */\nssh_socket ssh_socket_new(ssh_session session)\n{\n    ssh_socket s;\n\n    s = calloc(1, sizeof(struct ssh_socket_struct));\n    if (s == NULL) {\n        ssh_set_error_oom(session);\n        return NULL;\n    }\n    s->fd = SSH_INVALID_SOCKET;\n    s->last_errno = -1;\n    s->fd_is_socket = 1;\n    s->session = session;\n    s->in_buffer = ssh_buffer_new();\n    if (s->in_buffer == NULL) {\n        ssh_set_error_oom(session);\n        SAFE_FREE(s);\n        return NULL;\n    }\n    s->out_buffer=ssh_buffer_new();\n    if (s->out_buffer == NULL) {\n        ssh_set_error_oom(session);\n        SSH_BUFFER_FREE(s->in_buffer);\n        SAFE_FREE(s);\n        return NULL;\n    }\n    s->read_wontblock = 0;\n    s->write_wontblock = 0;\n    s->data_except = 0;\n    s->poll_handle = NULL;\n    s->state=SSH_SOCKET_NONE;\n    return s;\n", "Selected Statement": "s->state=SSH_SOCKET_NONE;", "Function Input": {}, "Variable Values Before Statement": {"SSH_SOCKET_NONE": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "libssh"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": " */\nchar *ssh_find_all_matching(const char *available_list,\n                            const char *preferred_list)\n{\n    struct ssh_tokens_st *a_tok = NULL, *p_tok = NULL;\n    int i, j;\n    char *ret = NULL;\n    size_t max, len, pos = 0;\n    int match;\n\n    if ((available_list == NULL) || (preferred_list == NULL)) {\n        return NULL;\n    }\n\n    max = MAX(strlen(available_list), strlen(preferred_list));\n\n    ret = calloc(1, max + 1);\n    if (ret == NULL) {\n        return NULL;\n    }\n\n    a_tok = ssh_tokenize(available_list, ',');\n    if (a_tok == NULL) {\n        SAFE_FREE(ret);\n        goto out;\n    }\n\n    p_tok = ssh_tokenize(preferred_list, ',');\n    if (p_tok == NULL) {\n        SAFE_FREE(ret);\n        goto out;\n    }\n\n    for (i = 0; p_tok->tokens[i] ; i++) {\n        for (j = 0; a_tok->tokens[j]; j++) {\n            match = !strcmp(a_tok->tokens[j], p_tok->tokens[i]);\n            if (match) {\n                if (pos != 0) {\n                    ret[pos] = ',';\n                    pos++;\n                }\n\n                len = strlen(a_tok->tokens[j]);\n                memcpy(&ret[pos], a_tok->tokens[j], len);\n                pos += len;\n                ret[pos] = '\\0';\n            }\n        }\n    }\n\n    if (ret[0] == '\\0') {\n        SAFE_FREE(ret);\n    }\n\nout:\n    ssh_tokens_free(a_tok);\n    ssh_tokens_free(p_tok);\n    return ret;\n", "Selected Statement": "pos += len;", "Function Input": {}, "Variable Values Before Statement": {"len": "4"}, "Value After Statement Execution": "4", "Project Information": "libssh"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nssh_poll_handle\nssh_poll_new(socket_t fd, short events, ssh_poll_callback cb, void *userdata)\n{\n    ssh_poll_handle p;\n\n    p = malloc(sizeof(struct ssh_poll_handle_struct));\n    if (p == NULL) {\n        return NULL;\n    }\n    ZERO_STRUCTP(p);\n\n    p->x.fd = fd;\n    p->events = events;\n    p->cb = cb;\n    p->cb_data = userdata;\n\n    return p;\n", "Selected Statement": "p->cb = cb;", "Function Input": {}, "Variable Values Before Statement": {"cb": "ssh_poll_callback"}, "Value After Statement Execution": "ssh_poll_callback", "Project Information": "libssh"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": " * @return 0 on success, < 0 on error.\n */\nint ssh_send_banner(ssh_session session, int server)\n{\n    const char *banner = CLIENT_BANNER_SSH2;\n    const char *terminator = \"\\r\\n\";\n    \n    char buffer[256] = {0};\n    size_t len;\n    int rc = SSH_ERROR;\n\n    if (server == 1) {\n        if (session->opts.custombanner == NULL){\n            session->serverbanner = strdup(banner);\n            if (session->serverbanner == NULL) {\n                goto end;\n            }\n        } else {\n            len = strlen(session->opts.custombanner);\n            session->serverbanner = malloc(len + 8 + 1);\n            if(session->serverbanner == NULL) {\n                goto end;\n            }\n            snprintf(session->serverbanner,\n                     len + 8 + 1,\n                     \"SSH-2.0-%s\",\n                     session->opts.custombanner);\n        }\n\n        snprintf(buffer,\n                 sizeof(buffer),\n                 \"%s%s\",\n                 session->serverbanner,\n                 terminator);\n    } else {\n        session->clientbanner = strdup(banner);\n        if (session->clientbanner == NULL) {\n            goto end;\n        }\n\n        snprintf(buffer,\n                 sizeof(buffer),\n                 \"%s%s\",\n                 session->clientbanner,\n                 terminator);\n    }\n\n    rc = ssh_socket_write(session->socket, buffer, strlen(buffer));\n    if (rc == SSH_ERROR) {\n        goto end;\n    }\n#ifdef WITH_PCAP\n    if (session->pcap_ctx != NULL) {\n        ssh_pcap_context_write(session->pcap_ctx,\n                               SSH_PCAP_DIR_OUT,\n                               buffer,\n                               strlen(buffer),\n                               strlen(buffer));\n    }\n#endif\n\n    rc = SSH_OK;\nend:\n", "Selected Statement": "const char *banner = CLIENT_BANNER_SSH2;", "Function Input": {}, "Variable Values Before Statement": {"CLIENT_BANNER_SSH2": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "libssh"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "                    int code,\n                    const char *function,\n                    const char *descr, ...)\n{\n    struct ssh_common_struct *err = error;\n    va_list va;\n\n    va_start(va, descr);\n    vsnprintf(err->error.error_buffer, ERROR_BUFFERLEN, descr, va);\n    va_end(va);\n\n    err->error.error_code = code;\n    if (ssh_get_log_level() == SSH_LOG_TRACE) {\n        ssh_log_function(SSH_LOG_TRACE,\n                         function,\n                         err->error.error_buffer);\n    }\n", "Selected Statement": "err->error.error_code = code;", "Function Input": {"code": {"value": "0"}, "descr": {"value": "0x7ffff7e1c8a0 \"\""}, "error": {"value": null}, "function": {"value": "0x733100 \"Socket exception callback: %d (%d)\""}}, "Variable Values Before Statement": {"code": "int"}, "Value After Statement Execution": "int", "Project Information": "libssh"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "}\n\nvoid ssh_packet_register_socket_callback(ssh_session session, ssh_socket s)\n{\n    struct ssh_socket_callbacks_struct *callbacks = &session->socket_callbacks;\n\n    callbacks->data = ssh_packet_socket_callback;\n    callbacks->connected = NULL;\n    callbacks->controlflow = ssh_packet_socket_controlflow_callback;\n    callbacks->userdata = session;\n    ssh_socket_set_callbacks(s, callbacks);\n", "Selected Statement": "callbacks->data = ssh_packet_socket_callback;", "Function Input": {"session": {"value": "0x222ed1fd0aa1f200"}}, "Variable Values Before Statement": {"ssh_packet_socket_callback": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "libssh"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": " *             SSH_ERROR on error\n */\nint ssh_config_parse_string(ssh_session session, const char *input)\n{\n    char line[MAX_LINE_SIZE] = {0};\n    const char *c = input, *line_start = input;\n    unsigned int line_num = 0, line_len;\n    int parsing, rv;\n\n    SSH_LOG(SSH_LOG_DEBUG, \"Reading configuration data from string:\");\n    SSH_LOG(SSH_LOG_DEBUG, \"START\\n%s\\nEND\", input);\n\n    parsing = 1;\n    while (1) {\n        line_num++;\n        line_start = c;\n        c = strchr(line_start, '\\n');\n        if (c == NULL) {\n            \n            c = strchr(line_start, '\\0');\n        }\n        if (c == NULL) {\n            \n            SSH_LOG(SSH_LOG_TRACE, \"No trailing '\\\\0' in config string\");\n            return SSH_ERROR;\n        }\n        line_len = c - line_start;\n        if (line_len > MAX_LINE_SIZE - 1) {\n            SSH_LOG(SSH_LOG_TRACE, \"Line %u too long: %u characters\",\n                    line_num, line_len);\n            return SSH_ERROR;\n        }\n        memcpy(line, line_start, line_len);\n        line[line_len] = '\\0';\n        SSH_LOG(SSH_LOG_DEBUG, \"Line %u: %s\", line_num, line);\n        rv = ssh_config_parse_line(session, line, line_num, &parsing, 0, false);\n        if (rv < 0) {\n            return SSH_ERROR;\n        }\n        if (*c == '\\0') {\n            break;\n        }\n        c++;\n    }\n\n    return SSH_OK;\n", "Selected Statement": "line_start = c;", "Function Input": {}, "Variable Values Before Statement": {"c": "0x12548a0 \"\""}, "Value After Statement Execution": "0x12548a0 \"\"", "Project Information": "libssh"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": " *             SSH_ERROR on error\n */\nint ssh_bind_config_parse_string(ssh_bind bind, const char *input)\n{\n    char line[MAX_LINE_SIZE] = {0};\n    const char *c = input, *line_start = input;\n    unsigned int line_num = 0, line_len;\n    uint32_t parser_flags;\n    int rv;\n\n    \n    uint8_t seen[BIND_CFG_MAX] = {0};\n\n    SSH_LOG(SSH_LOG_DEBUG, \"Reading bind configuration data from string:\");\n    SSH_LOG(SSH_LOG_DEBUG, \"START\\n%s\\nEND\", input);\n\n    parser_flags = PARSING;\n    while (1) {\n        line_num++;\n        line_start = c;\n        c = strchr(line_start, '\\n');\n        if (c == NULL) {\n            \n            c = strchr(line_start, '\\0');\n        }\n        if (c == NULL) {\n            \n            SSH_LOG(SSH_LOG_WARN, \"No trailing '\\\\0' in config string\");\n            return SSH_ERROR;\n        }\n        line_len = c - line_start;\n        if (line_len > MAX_LINE_SIZE - 1) {\n            SSH_LOG(SSH_LOG_WARN, \"Line %u too long: %u characters\",\n                    line_num, line_len);\n            return SSH_ERROR;\n        }\n        memcpy(line, line_start, line_len);\n        line[line_len] = '\\0';\n        SSH_LOG(SSH_LOG_DEBUG, \"Line %u: %s\", line_num, line);\n        rv = ssh_bind_config_parse_line(bind, line, line_num, &parser_flags, seen, 0);\n        if (rv < 0) {\n            return SSH_ERROR;\n        }\n        if (*c == '\\0') {\n            break;\n        }\n        c++;\n    }\n\n    return SSH_OK;\n", "Selected Statement": "line_start = c;", "Function Input": {"parser_flags": {"value": "8347536"}}, "Variable Values Before Statement": {"c": "0x12578a0 \"\""}, "Value After Statement Execution": "0x12578a0 \"\"", "Project Information": "libssh"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": " */\nkrb5_error_code\nndr_dec_delegation_info(krb5_data *data, struct pac_s4u_delegation_info **out)\n{\n    krb5_error_code ret;\n    struct pac_s4u_delegation_info *di = NULL;\n    struct k5input in;\n    uint32_t i, object_buffer_length, nservices;\n    uint8_t version, endianness, common_header_length;\n\n    *out = NULL;\n\n    di = k5alloc(sizeof(*di), &ret);\n    if (di == NULL)\n        return ret;\n\n    k5_input_init(&in, data->data, data->length);\n\n    \n    version = k5_input_get_byte(&in);\n    endianness = k5_input_get_byte(&in);\n    common_header_length = k5_input_get_uint16_le(&in);\n    (void)k5_input_get_uint32_le(&in); \n    if (version != 1 || endianness != 0x10 || common_header_length != 8) {\n        ret = EINVAL;\n        goto error;\n    }\n\n    \n    object_buffer_length = k5_input_get_uint32_le(&in);\n    if (data->length < 16 || object_buffer_length != data->length - 16) {\n        ret = EINVAL;\n        goto error;\n    }\n\n    (void)k5_input_get_uint32_le(&in); \n\n    \n\n    \n    (void)k5_input_get_uint32_le(&in);\n    \n    (void)k5_input_get_uint16_le(&in);\n    \n    (void)k5_input_get_uint16_le(&in);\n    \n    (void)k5_input_get_uint32_le(&in);\n\n    \n    (void)k5_input_get_uint32_le(&in);\n\n    \n    (void)k5_input_get_uint32_le(&in);\n\n    ret = dec_wchar_pointer(&in, &di->proxy_target);\n    if (ret)\n        goto error;\n    nservices = k5_input_get_uint32_le(&in);\n\n    \n    if (nservices > data->length / 8) {\n        ret = ERANGE;\n        goto error;\n    }\n    (void)k5_input_get_bytes(&in, 8 * nservices);\n\n    \n    di->transited_services = k5calloc(nservices + 1, sizeof(char *), &ret);\n    if (di->transited_services == NULL)\n        goto error;\n\n    for (i = 0; i < nservices; i++) {\n        ret = dec_wchar_pointer(&in, &di->transited_services[i]);\n        if (ret)\n            goto error;\n        di->transited_services_length++;\n    }\n\n    ret = in.status;\n    if (ret)\n        goto error;\n\n    *out = di;\n    return 0;\n\nerror:\n    ndr_free_delegation_info(di);\n    return ret;\n", "Selected Statement": "ret = ERANGE;", "Function Input": {"in": {"value": {"ptr": {"type_category": "string", "concrete_type": "NULL"}, "len": {"type_category": "unknown", "concrete_type": "size_t", "value": "4242681"}, "status": {"type_category": "unknown", "concrete_type": "int32_t", "value": "5350024"}}}, "out": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf3bbe0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x1332bcc00081001\n", "message": "Cannot access memory at address 0x1332bcc00081001"}}}}, "Variable Values Before Statement": {"ERANGE": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "krb5"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nvoid\nk5_buf_init_dynamic(struct k5buf *buf)\n{\n    buf->buftype = K5BUF_DYNAMIC;\n    buf->space = 128;\n    buf->data = malloc(buf->space);\n    if (buf->data == NULL) {\n        set_error(buf);\n        return;\n    }\n    buf->len = 0;\n", "Selected Statement": "buf->buftype = K5BUF_DYNAMIC;", "Function Input": {"buf": {"value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x65cc6ead\n", "message": "Cannot access memory at address 0x65cc6ead"}}}, "Variable Values Before Statement": {"K5BUF_DYNAMIC": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "krb5"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nOM_uint32\ngssint_get_mech_type(gss_OID OID, gss_buffer_t token)\n{\n    \n    if (token->length >= sizeof(NTLMSSP_SIGNATURE) &&\n\tmemcmp(token->value, NTLMSSP_SIGNATURE,\n\t       sizeof(NTLMSSP_SIGNATURE)) == 0) {\n\t*OID = gss_ntlm_mechanism_oid_desc;\n    } else if (token->length != 0 &&\n\t       ((char *)token->value)[0] == 0x6E) {\n \t\n\t*OID = gss_krb5_mechanism_oid_desc;\n    } else if (token->length == 0) {\n\t*OID = gss_spnego_mechanism_oid_desc;\n    } else {\n\treturn gssint_get_mech_type_oid(OID, token);\n    }\n\n    return (GSS_S_COMPLETE);\n", "Selected Statement": "*OID = gss_ntlm_mechanism_oid_desc;", "Function Input": {"token": {"value": "0x7fffffffde20"}}, "Variable Values Before Statement": {"gss_ntlm_mechanism_oid_desc": {"length": "10", "elements": null}}, "Value After Statement Execution": {"length": "10", "elements": null}, "Project Information": "krb5"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "static char *my_domain = NULL;\n\nvoid hostpid_init(void)\n{\n\tstatic char pid[MAX_INT_STRLEN];\n\tchar hostname[256];\n\tconst char *value;\n\n\t\n\ti_free_and_null(my_hostname_dup);\n\ti_free_and_null(my_domain);\n\n\tvalue = getenv(MY_HOSTNAME_ENV);\n\tif (value == NULL) {\n\t\tif (gethostname(hostname, sizeof(hostname)-1) < 0)\n\t\t\ti_fatal(\"gethostname() failed: %m\");\n\t\thostname[sizeof(hostname)-1] = '\\0';\n\t\tvalue = hostname;\n\t}\n\n\tif (value[0] == '\\0' ||\n\t    strcspn(value, HOSTNAME_DISALLOWED_CHARS) != strlen(value))\n\t\ti_fatal(\"Invalid system hostname: '%s'\", value);\n\tmy_hostname_dup = i_strdup(value);\n\tmy_hostname = my_hostname_dup;\n\n\ti_snprintf(pid, sizeof(pid), \"%lld\", (long long)getpid());\n\tmy_pid = pid;\n", "Selected Statement": "my_pid = pid;", "Function Input": {}, "Variable Values Before Statement": {"pid": "\"61\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\""}, "Value After Statement Execution": "\"61\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\"", "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "#include <sys/un.h>\n\nvoid fd_close_on_exec(int fd, bool set)\n{\n\tint flags;\n\n\tflags = fcntl(fd, F_GETFD, 0);\n\tif (flags < 0)\n\t\ti_fatal(\"fcntl(F_GETFD, %d) failed: %m\", fd);\n\n\tflags = set ? (flags | FD_CLOEXEC) : (flags & ~FD_CLOEXEC);\n\tif (fcntl(fd, F_SETFD, flags) < 0)\n\t\ti_fatal(\"fcntl(F_SETFD, %d) failed: %m\", fd);\n", "Selected Statement": "flags = set ? (flags | FD_CLOEXEC) : (flags & ~FD_CLOEXEC);", "Function Input": {"fd": {"value": "32767"}, "set": {"value": "255"}}, "Variable Values Before Statement": {"set": "_Bool"}, "Value After Statement Execution": "_Bool", "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "\nbuffer_t *buffer_create_dynamic_max(pool_t pool, size_t init_size,\n\t\t\t\t    size_t max_size)\n{\n\tstruct real_buffer *buf;\n\n#ifdef DEBUG\n\t\n\ti_assert(init_size < SIZE_MAX);\n#endif\n\n\tbuf = p_new(pool, struct real_buffer, 1);\n\tbuf->pool = pool;\n\tbuf->dynamic = TRUE;\n\tbuf->max_size = max_size;\n\t\n\tbuffer_alloc(buf, init_size+1);\n", "Selected Statement": "buf->pool = pool;", "Function Input": {"buf": {"value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x30\n", "message": "Cannot access memory at address 0x30"}}}, "Variable Values Before Statement": {"pool": "pool_t"}, "Value After Statement Execution": "pool_t", "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "}\n\nvoid var_expand_extensions_init(void)\n{\n\ti_array_init(&var_expand_extensions, 32);\n\n\t\n\tfor(const struct hash_method **meth = hash_methods;\n\t    *meth != NULL;\n\t    meth++) {\n\t\tstruct var_expand_extension_func_table *func =\n\t\t\tarray_append_space(&var_expand_extensions);\n\t\tfunc->key = (*meth)->name;\n\t\tfunc->func = var_expand_hash;\n\t}\n\n\t\n\tstruct var_expand_extension_func_table *func =\n\t\tarray_append_space(&var_expand_extensions);\n\tfunc->key = \"pkcs5\";\n\tfunc->func = var_expand_hash;\n\n\t\n\tfunc = array_append_space(&var_expand_extensions);\n\tfunc->key = \"if\";\n\tfunc->func = var_expand_if;\n\n\t\n\tfunc = array_append_space(&var_expand_extensions);\n\tfunc->key = \"system\";\n\tfunc->func = var_expand_system;\n\n\t\n\tfunc = array_append_space(&var_expand_extensions);\n\tfunc->key = \"process\";\n\tfunc->func = var_expand_process;\n", "Selected Statement": "for(const struct hash_method **meth = hash_methods;", "Function Input": {}, "Variable Values Before Statement": {"hash_methods": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "}\n\nstruct istream *test_istream_create_data(const void *data, size_t size)\n{\n\tstruct test_istream *tstream;\n\n\ttstream = i_new(struct test_istream, 1);\n\ttstream->orig_buffer = data;\n\n\ttstream->istream.read = test_read;\n\ttstream->istream.seek = test_seek;\n\n\ttstream->istream.istream.blocking = FALSE;\n\ttstream->istream.istream.seekable = TRUE;\n\ti_stream_create(&tstream->istream, NULL, -1, 0);\n\ttstream->istream.statbuf.st_size = tstream->max_pos = size;\n\ttstream->allow_eof = TRUE;\n\ttstream->istream.max_buffer_size = SIZE_MAX;\n", "Selected Statement": "tstream->istream.statbuf.st_size = tstream->max_pos = size;", "Function Input": {}, "Variable Values Before Statement": {"size": "0"}, "Value After Statement Execution": "0", "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "struct istream *\ni_stream_create(struct istream_private *_stream, struct istream *parent, int fd,\n\t\tenum istream_create_flag flags)\n{\n\tbool noop_snapshot = (flags & ISTREAM_CREATE_FLAG_NOOP_SNAPSHOT) != 0;\n\n\t_stream->fd = fd;\n\tif (parent != NULL)\n\t\ti_stream_init_parent(_stream, parent);\n\telse if (_stream->memarea == NULL && !noop_snapshot) {\n\t\t\n\t\t_stream->memarea = memarea_init_empty();\n\t}\n\t_stream->istream.real_stream = _stream;\n\n\tif (_stream->iostream.close == NULL)\n\t\t_stream->iostream.close = i_stream_default_close;\n\tif (_stream->iostream.destroy == NULL)\n\t\t_stream->iostream.destroy = i_stream_default_destroy;\n\tif (_stream->seek == NULL) {\n\t\t_stream->seek = _stream->istream.seekable ?\n\t\t\ti_stream_default_seek_seekable :\n\t\t\ti_stream_default_seek_nonseekable;\n\t}\n\tif (_stream->stat == NULL)\n\t\t_stream->stat = i_stream_default_stat;\n\tif (_stream->get_size == NULL)\n\t\t_stream->get_size = i_stream_default_get_size;\n\tif (_stream->snapshot == NULL) {\n\t\t_stream->snapshot = noop_snapshot ?\n\t\t\ti_stream_noop_snapshot :\n\t\t\ti_stream_default_snapshot;\n\t}\n\tif (_stream->iostream.set_max_buffer_size == NULL) {\n\t\t_stream->iostream.set_max_buffer_size =\n\t\t\ti_stream_default_set_max_buffer_size;\n\t}\n\tif (_stream->init_buffer_size == 0)\n\t\t_stream->init_buffer_size = I_STREAM_MIN_SIZE;\n\n\ti_zero(&_stream->statbuf);\n\t_stream->statbuf.st_size = -1;\n\t_stream->statbuf.st_atime =\n\t\t_stream->statbuf.st_mtime =\n\t\t_stream->statbuf.st_ctime = ioloop_time;\n\t_stream->cached_stream_size = UOFF_T_MAX;\n\n\tio_stream_init(&_stream->iostream);\n\n\tif (_stream->istream.stream_errno != 0)\n\t\t_stream->istream.eof = TRUE;\n\n", "Selected Statement": "_stream->get_size = i_stream_default_get_size;", "Function Input": {}, "Variable Values Before Statement": {"i_stream_default_get_size": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "}\n\nvoid io_stream_init(struct iostream_private *stream)\n{\n\tif (stream->close == NULL)\n\t\tstream->close = io_stream_default_close;\n\tif (stream->destroy == NULL)\n\t\tstream->destroy = io_stream_default_destroy;\n\tstream->ioloop = current_ioloop;\n\n\tstream->refcount = 1;\n", "Selected Statement": "stream->destroy = io_stream_default_destroy;", "Function Input": {}, "Variable Values Before Statement": {"io_stream_default_destroy": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "json_istream_create(struct istream *input, enum json_istream_type type,\n\t\t    const struct json_limits *limits,\n\t\t    enum json_parser_flags parser_flags)\n{\n\tstruct json_istream *stream;\n\n\tstream = i_new(struct json_istream, 1);\n\tstream->refcount = 1;\n\tstream->type = type;\n\n\tstream->input = input; \n\tstream->parser = json_parser_init(input, limits, parser_flags,\n\t\t\t\t\t  &parser_callbacks, (void *)stream);\n\n", "Selected Statement": "stream->input = input; /* Parser holds reference */", "Function Input": {"stream": {"value": null}}, "Variable Values Before Statement": {"input": {"v_offset": "0", "stream_errno": "0", "mmaped": "false", "blocking": "false", "closed": "false", "readable_fd": "false", "seekable": "true", "eof": "false", "real_stream": null}}, "Value After Statement Execution": {"v_offset": "0", "stream_errno": "0", "mmaped": "false", "blocking": "false", "closed": "false", "readable_fd": "false", "seekable": "true", "eof": "false", "real_stream": null}, "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "json_parser_init(struct istream *input, const struct json_limits *limits,\n\t\t enum json_parser_flags flags,\n\t\t const struct json_parser_callbacks *callbacks, void *context)\n{\n\tstruct json_parser *parser;\n\n\tparser = i_new(struct json_parser, 1);\n\tparser->flags = flags;\n\n\ti_array_init(&parser->level_stack, 8);\n\n\tparser->input = input;\n\ti_stream_ref(input);\n\tparser->input_offset = input->v_offset;\n\n\tif (limits != NULL)\n\t\tparser->limits = *limits;\n\tif (parser->limits.max_string_size == 0)\n\t\tparser->limits.max_string_size = JSON_DEFAULT_MAX_STRING_SIZE;\n\tif (parser->limits.max_name_size == 0)\n\t\tparser->limits.max_name_size = JSON_DEFAULT_MAX_NAME_SIZE;\n\tif (parser->limits.max_nesting == 0)\n\t\tparser->limits.max_nesting = JSON_DEFAULT_MAX_NESTING;\n\tif (parser->limits.max_list_items == 0)\n\t\tparser->limits.max_list_items = JSON_DEFAULT_MAX_LIST_ITEMS;\n\n\tparser->callbacks = callbacks;\n\tparser->context = context;\n\n\tparser->loc.line_number = 1;\n\n", "Selected Statement": "parser->callbacks = callbacks;", "Function Input": {"parser": {"value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x88\n", "message": "Cannot access memory at address 0x88"}}}, "Variable Values Before Statement": {"callbacks": {"parse_list_open": "{void (void *, void *, const char *, _Bool, void **)} 0x4dc500 <json_istream_parse_list_open>", "parse_list_close": "{void (void *, void *, _Bool)} 0x4dcb00 <json_istream_parse_list_close>", "parse_object_member": "{void (void *, void *, const char *)} 0x4dd0b0 <json_istream_parse_object_member>", "parse_value": "{void (void *, void *, const char *, enum json_type, const struct json_value *)} 0x4dd420 <json_istream_parse_value>"}}, "Value After Statement Execution": {"parse_list_open": "{void (void *, void *, const char *, _Bool, void **)} 0x4dc500 <json_istream_parse_list_open>", "parse_list_close": "{void (void *, void *, _Bool)} 0x4dcb00 <json_istream_parse_list_close>", "parse_object_member": "{void (void *, void *, const char *)} 0x4dd0b0 <json_istream_parse_object_member>", "parse_value": "{void (void *, void *, const char *, enum json_type, const struct json_value *)} 0x4dd420 <json_istream_parse_value>"}, "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "#endif\n\npool_t pool_alloconly_create(const char *name ATTR_UNUSED, size_t size)\n{\n\tstruct alloconly_pool apool, *new_apool;\n\tsize_t min_alloc = SIZEOF_POOLBLOCK +\n\t\tMEM_ALIGN(sizeof(struct alloconly_pool) + SENTRY_COUNT);\n\n\t(void) COMPILE_ERROR_IF_TRUE(POOL_ALLOCONLY_MAX_EXTRA >\n\t\t\t\t     (SSIZE_T_MAX - POOL_MAX_ALLOC_SIZE));\n\n#ifdef DEBUG\n\tmin_alloc += MEM_ALIGN(strlen(name) + 1 + SENTRY_COUNT) +\n\t\tsizeof(size_t)*2;\n#endif\n\n\t\n\ti_zero(&apool);\n\tapool.pool = static_alloconly_pool;\n\tapool.refcount = 1;\n\n\tif (size < min_alloc)\n\t\tsize = nearest_power(size + min_alloc);\n\tblock_alloc(&apool, size);\n\n\t\n\tnew_apool = p_new(&apool.pool, struct alloconly_pool, 1);\n\t*new_apool = apool;\n#ifdef DEBUG\n\tif (str_begins(name, MEMPOOL_GROWING, &name) ||\n\t    getenv(\"DEBUG_SILENT\") != NULL)\n\t\tnew_apool->disable_warning = TRUE;\n\tnew_apool->name = p_strdup(&new_apool->pool, name);\n\n\t\n\tnew_apool->base_size = new_apool->block->size - new_apool->block->left;\n\tnew_apool->block->last_alloc_size = 0;\n#endif\n\t\n\ti_assert(new_apool->block->prev == NULL);\n\n", "Selected Statement": "apool.pool = static_alloconly_pool;", "Function Input": {}, "Variable Values Before Statement": {"static_alloconly_pool": {"v": null, "external_refs": null, "alloconly_pool": "true", "datastack_pool": "false"}}, "Value After Statement Execution": {"v": null, "external_refs": null, "alloconly_pool": "true", "datastack_pool": "false"}, "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "};\n\npool_t pool_datastack_create(void)\n{\n\tstruct datastack_pool *dpool;\n\n\tdpool = t_new(struct datastack_pool, 1);\n\tdpool->pool = static_data_stack_pool;\n\tdpool->refcount = 1;\n\tdpool->data_stack_frame = data_stack_frame_id;\n", "Selected Statement": "dpool->pool = static_data_stack_pool;", "Function Input": {}, "Variable Values Before Statement": {"static_data_stack_pool": {"v": null, "external_refs": null, "alloconly_pool": "true", "datastack_pool": "true"}}, "Value After Statement Execution": {"v": null, "external_refs": null, "alloconly_pool": "true", "datastack_pool": "true"}, "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "struct imap_parser *\nimap_parser_create(struct istream *input, struct ostream *output,\n\t\t   size_t max_line_size)\n{\n\tstruct imap_parser *parser;\n\n\tparser = i_new(struct imap_parser, 1);\n\tparser->refcount = 1;\n\tparser->pool = pool_alloconly_create(MEMPOOL_GROWING\"IMAP parser\",\n\t\t\t\t\t     1024);\n\tparser->input = input;\n\tparser->output = output;\n\tparser->max_line_size = max_line_size;\n\n\tp_array_init(&parser->root_list, parser->pool, LIST_INIT_COUNT);\n\tparser->cur_list = &parser->root_list;\n", "Selected Statement": "parser->input = input;", "Function Input": {}, "Variable Values Before Statement": {"input": {"v_offset": "0", "stream_errno": "0", "mmaped": "false", "blocking": "true", "closed": "false", "readable_fd": "false", "seekable": "true", "eof": "true", "real_stream": null}}, "Value After Statement Execution": {"v_offset": "0", "stream_errno": "0", "mmaped": "false", "blocking": "true", "closed": "false", "readable_fd": "false", "seekable": "true", "eof": "true", "real_stream": null}, "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "struct message_parser_ctx *\nmessage_parser_init(pool_t part_pool, struct istream *input,\n\t\t    const struct message_parser_settings *set)\n{\n\tstruct message_parser_ctx *ctx;\n\n\tctx = message_parser_init_int(input, set);\n\tctx->part_pool = part_pool;\n\tctx->parts = ctx->part = p_new(part_pool, struct message_part, 1);\n\tctx->next_part = &ctx->part->children;\n\tctx->parse_next_block = parse_next_header_init;\n\tctx->total_parts_count = 1;\n\ti_array_init(&ctx->next_part_stack, 4);\n", "Selected Statement": "ctx->part_pool = part_pool;", "Function Input": {}, "Variable Values Before Statement": {"part_pool": "pool_t"}, "Value After Statement Execution": "pool_t", "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "struct message_header_parser_ctx *\nmessage_parse_header_init(struct istream *input, struct message_size *hdr_size,\n\t\t\t  enum message_header_parser_flags flags)\n{\n\tstruct message_header_parser_ctx *ctx;\n\n\tctx = i_new(struct message_header_parser_ctx, 1);\n\tctx->input = input;\n\tctx->hdr_size = hdr_size;\n\tctx->name = str_new(default_pool, 128);\n\tctx->flags = flags;\n\tctx->value_buf = buffer_create_dynamic(default_pool, 4096);\n\ti_stream_ref(input);\n\n\tif (hdr_size != NULL)\n\t\ti_zero(hdr_size);\n", "Selected Statement": "ctx->hdr_size = hdr_size;", "Function Input": {}, "Variable Values Before Statement": {"hdr_size": {"physical_size": "0", "virtual_size": "0", "lines": "0"}}, "Value After Statement Execution": {"physical_size": "0", "virtual_size": "0", "lines": "0"}, "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Assignment", "Source Code": "        , size_t digest_size\n#endif\n        )\n{\n    hash_state *hs;\n    int i;\n#if DIGEST_SIZE == (512/8)\n    size_t variant;\n#endif\n\n    if (NULL == shaState) {\n        return ERR_NULL;\n    }\n\n    *shaState = hs = (hash_state*) calloc(1, sizeof(hash_state));\n    if (NULL == hs)\n        return ERR_MEMORY;\n\n    hs->curlen = 0;\n    hs->totbits[0] = hs->totbits[1] = 0;\n\n    \n#if DIGEST_SIZE == (512/8)\n    hs->digest_size = digest_size;\n\n    switch (digest_size) {\n        case 28: variant = 1;   \n                 break;\n        case 32: variant = 2;   \n                 break;\n        default: variant = 0;   \n    }\n    \n    for (i=0; i<8; i++) {\n        hs->h[i] = H_SHA_512[variant][i];\n    }\n#else\n    hs->digest_size = DIGEST_SIZE;\n    for (i=0; i<8; i++) {\n        hs->h[i] = H[i];\n    }\n#endif\n\n    return 0;\n", "Selected Statement": "hs->digest_size = DIGEST_SIZE;", "Function Input": {}, "Variable Values Before Statement": {"DIGEST_SIZE": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "pycryptodome"}
