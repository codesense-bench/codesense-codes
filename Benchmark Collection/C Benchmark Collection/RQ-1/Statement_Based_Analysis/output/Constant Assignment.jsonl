{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\nstatic inline size_t\nsmall_round(size_t size)\n{\n\tif (size < 2)\n\t\treturn size;\n\tassert(size <= SIZE_MAX / 2 + 1);\n\tassert(size - 1 <= ULONG_MAX);\n\tsize_t r = 1;\n\treturn r << (sizeof(unsigned long) * CHAR_BIT -\n\t\t     __builtin_clzl((unsigned long) (size - 1)));\n", "Selected Statement": "size_t r = 1;", "Function Input": {}, "Variable Values Before Statement": {"constant": "1"}, "Value After Statement Execution": "1", "Project Information": "tarantool"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\n\nconst char * decNumberFromString(decNumber *dn, const char chars[],\n                                 decContext *set) {\n  Int   exponent=0;                \n  uByte bits=0;                    \n  Unit  *res;                      \n  Unit  resbuff[SD2U(DECBUFFER+9)];\n                                   \n  Unit  *allocres=NULL;            \n  Int   d=0;                       \n  const char *dotchar=NULL;        \n  const char *cfirst=chars;        \n  const char *last=NULL;           \n  const char *end=chars;\n  const char *c;                   \n  Unit  *up;                       \n  #if DECDPUN>1\n  Int   cut, out;                  \n  #endif\n  Int   residue;                   \n  uInt  status=0;                  \n\n  #if DECCHECK\n  if (decCheckOperands(DECUNRESU, DECUNUSED, DECUNUSED, set))\n    return decNumberZero(dn);\n  #endif\n\n  do {                             \n    for (c=chars;; c++) {          \n      if (*c>='0' && *c<='9') {    \n        last=c;\n        d++;                       \n        continue;                  \n        }\n      if (*c=='.' && dotchar==NULL) { \n        dotchar=c;                 \n        if (c==cfirst) cfirst++;   \n        continue;}\n      if (c==chars) {              \n        if (*c=='-') {             \n          cfirst++;\n          bits=DECNEG;\n          continue;}\n        if (*c=='+') {             \n          cfirst++;\n          continue;}\n        }\n      \n      break;\n      } \n\n    if (last==NULL) {              \n      status=DEC_Conversion_syntax;\n      if (*c=='\\0') break;         \n      #if DECSUBSET\n      \n      if (!set->extended) break;   \n      #endif\n      \n      if (dotchar!=NULL) break;    \n      decNumberZero(dn);           \n      if (decBiStr(c, \"infinity\", \"INFINITY\")\n       || decBiStr(c, \"inf\", \"INF\")) {\n        dn->bits=bits | DECINF;\n        status=0;                  \n        break; \n        }\n      \n      \n      dn->bits=bits | DECNAN;      \n      if (*c=='s' || *c=='S') {    \n        c++;\n        dn->bits=bits | DECSNAN;\n        }\n      if (*c!='n' && *c!='N') break;    \n      c++;\n      if (*c!='a' && *c!='A') break;    \n      c++;\n      if (*c!='n' && *c!='N') break;    \n      c++;\n      \n      \n      for (cfirst=c; *cfirst=='0';) cfirst++;\n      if (*cfirst=='\\0') {         \n        status=0;                  \n        break;                     \n        }\n      \n      for (c=cfirst;; c++, d++) {\n        if (*c<'0' || *c>'9') break; \n        last=c;\n        }\n      if (*c!='\\0') break;         \n      if (d>set->digits-1) {\n        \n        \n        if (set->clamp) break;\n        if (d>set->digits) break;\n        } \n      \n      status=0;                    \n      bits=dn->bits;               \n      } \n\n     else if (*c!='\\0') {          \n      \n      status=0;                    \n      end=c;                       \n      Flag nege;                   \n      const char *firstexp;        \n      if (*c!='e' && *c!='E') goto finalize;\n      \n      \n      nege=0;\n      c++;                         \n      if (*c=='-') {nege=1; c++;}\n       else if (*c=='+') c++;\n      if (*c<'0' || *c>'9') goto finalize;\n\n      for (; *c=='0' && *(c+1)!='\\0';) c++;  \n      firstexp=c;                            \n      for (; ;c++) {\n        if (*c<'0' || *c>'9') break;         \n        exponent=X10(exponent)+(Int)*c-(Int)'0';\n        } \n\n      end=c;\n\n      \n      \n      \n      if (c>=firstexp+9+1) {\n        if (c>firstexp+9+1 || *firstexp>'1') exponent=DECNUMMAXE*2;\n        \n        }\n      if (nege) exponent=-exponent;     \n      } \n\n      else end=c;\nfinalize:\n    \n    \n\n    \n    if (*cfirst=='0') {                 \n      for (c=cfirst; c<last; c++, cfirst++) {\n        if (*c=='.') continue;          \n        if (*c!='0') break;             \n        d--;                            \n        } \n      #if DECSUBSET\n      \n      if (*cfirst=='0' && !set->extended) {\n        decNumberZero(dn);              \n        break;                          \n        }\n      #endif\n      } \n\n    \n    if (dotchar!=NULL && dotchar<last)  \n      exponent-=(last-dotchar);         \n    \n\n    \n    \n    if (d<=set->digits) res=dn->lsu;    \n     else {                             \n      Int needbytes=D2U(d)*sizeof(Unit);\n      res=resbuff;                      \n      if (needbytes>(Int)sizeof(resbuff)) { \n        allocres=(Unit *)malloc(needbytes);\n        if (allocres==NULL) {status|=DEC_Insufficient_storage; break;}\n        res=allocres;\n        }\n      }\n    \n\n    \n    \n    #if DECDPUN>1\n    out=0;                         \n    up=res+D2U(d)-1;               \n    cut=d-(up-res)*DECDPUN;        \n    for (c=cfirst;; c++) {         \n      if (*c=='.') continue;       \n      out=X10(out)+(Int)*c-(Int)'0';\n      if (c==last) break;          \n      cut--;\n      if (cut>0) continue;         \n      *up=(Unit)out;               \n      up--;                        \n      cut=DECDPUN;                 \n      out=0;                       \n      } \n    *up=(Unit)out;                 \n\n    #else\n    \n    up=res;                        \n    for (c=last; c>=cfirst; c--) { \n      if (*c=='.') continue;       \n      *up=(Unit)((Int)*c-(Int)'0');\n      up++;\n      } \n    #endif\n\n    dn->bits=bits;\n    dn->exponent=exponent;\n    dn->digits=d;\n\n    \n    if (d>set->digits) {\n      residue=0;\n      decSetCoeff(dn, set, res, d, &residue, &status);\n      \n      decFinalize(dn, set, &residue, &status);\n      }\n     else { \n      \n      if ((dn->exponent-1<set->emin-dn->digits)\n       || (dn->exponent-1>set->emax-set->digits)) {\n        residue=0;\n        decFinalize(dn, set, &residue, &status);\n        }\n      }\n    \n    } while(0);                         \n\n  if (allocres!=NULL) free(allocres);   \n  if (status!=0) decStatus(dn, status, set);\n", "Selected Statement": "status=0;                    // we have a number already", "Function Input": {"dn": {"value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x6d80\n", "message": "Cannot access memory at address 0x6d80"}}, "set": {"value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xb1f70292cecd0000\n", "message": "Cannot access memory at address 0xb1f70292cecd0000"}}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "tarantool"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\n\n\ndecContext *decContextZeroStatus(decContext *context) {\n  context->status=0;\n", "Selected Statement": "context->status=0;", "Function Input": {"context": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"digits": {"type_category": "unknown", "concrete_type": "int32_t", "value": "1"}, "emax": {"type_category": "unknown", "concrete_type": "int32_t", "value": "0"}, "emin": {"type_category": "unknown", "concrete_type": "int32_t", "value": "97536"}, "round": {"type_category": "unknown", "concrete_type": "rounding", "value": "DEC_ROUND_CEILING"}, "traps": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "14203712"}, "status": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, "clamp": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "0 '\\000'"}}}}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "tarantool"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": " */\n\nvoid http_parser_create(struct http_parser *parser)\n{\n parser->hdr_value_start = NULL;\n parser->hdr_value_end = NULL;\n parser->http_major = -1;\n parser->http_minor = -1;\n parser->hdr_name = NULL;\n parser->hdr_name_idx = 0;\n", "Selected Statement": "parser->http_minor = -1;", "Function Input": {"parser": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"hdr_value_start": {"type_category": "string", "concrete_type": "string", "value": "0x8c48348707e8b49 <error: Cannot access memory at address 0x8c48348707e8b49>"}, "hdr_value_end": {"type_category": "string", "concrete_type": "string", "value": "0x634c1e95e415b <error: Cannot access memory at address 0x634c1e95e415b>"}, "http_major": {"type_category": "int", "concrete_type": "int", "value": "1398161868"}, "http_minor": {"type_category": "int", "concrete_type": "int", "value": "-24557232"}, "hdr_name": {"type_category": "string", "concrete_type": "string", "value": "0x48000664c2058d48 <error: Cannot access memory at address 0x48000664c2058d48>"}, "hdr_name_idx": {"type_category": "int", "concrete_type": "int", "value": "-1958213751"}}}}}, "Variable Values Before Statement": {"constant": "-1"}, "Value After Statement Execution": "-1", "Project Information": "tarantool"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "ssize_t\ndatetime_parse_full(struct datetime *date, const char *str, size_t len,\n\t\t    const char *tzsuffix, int32_t offset)\n{\n\tsize_t n;\n\tdt_t dt;\n\tconst char *svp = str;\n\tchar c;\n\tint sec_of_day = 0, nanosecond = 0;\n\tint16_t tzindex = 0;\n\n\tn = dt_parse_iso_date(str, len, &dt);\n\tif (n == 0)\n\t\treturn 0;\n\n\tstr += n;\n\tlen -= n;\n\tif (len <= 0)\n\t\tgoto exit;\n\n\tc = *str++;\n\tif (c != 'T' && c != 't' && c != ' ')\n\t\treturn 0;\n\tlen--;\n\tif (len <= 0)\n\t\tgoto exit;\n\n\tn = dt_parse_iso_time(str, len, &sec_of_day, &nanosecond);\n\tif (n == 0)\n\t\treturn 0;\n\n\tstr += n;\n\tlen -= n;\n\tif (len <= 0)\n\t\tgoto exit;\n\n\t\n\ttime_t base = dt_epoch(dt) + sec_of_day - offset * 60;\n\tssize_t l;\n\tif (tzsuffix != NULL) {\n\t\tl = parse_tz_suffix(tzsuffix, strlen(tzsuffix), base,\n\t\t\t\t    &tzindex, &offset);\n\t\tif (l < 0)\n\t\t\treturn l;\n\t\tgoto exit;\n\t}\n\n\tif (*str == ' ') {\n\t\tstr++;\n\t\tlen--;\n\t}\n\tif (len <= 0)\n\t\tgoto exit;\n\n\tl = parse_tz_suffix(str, len, base, &tzindex, &offset);\n\tif (l < 0)\n\t\treturn l;\n\tstr += l;\n\nexit:\n\tdate->epoch = dt_epoch(dt) + sec_of_day - offset * 60;\n\tdate->nsec = nanosecond;\n\tdate->tzoffset = offset;\n\tdate->tzindex = tzindex;\n\n\treturn str - svp;\n", "Selected Statement": "int sec_of_day = 0, nanosecond = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "tarantool"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\nint\npg_vsnprintf(char *str, size_t count, const char *fmt, va_list args)\n{\n\tPrintfTarget target;\n\tchar\t\tonebyte[1];\n\n\t\n\tif (count == 0)\n\t{\n\t\tstr = onebyte;\n\t\tcount = 1;\n\t}\n\ttarget.bufstart = target.bufptr = str;\n\ttarget.bufend = str + count - 1;\n\ttarget.stream = NULL;\n\ttarget.nchars = 0;\n\ttarget.failed = false;\n\tdopr(&target, fmt, args);\n\t*(target.bufptr) = '\\0';\n", "Selected Statement": "target.nchars = 0;", "Function Input": {"count": {"value": "<optimized out>"}, "fmt": {"value": "<optimized out>"}, "str": {"value": "<optimized out>"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libpg_query"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\nstatic void process_wtmp_file(const struct last_control *ctl,\n\t\t\t      const char *filename)\n{\n\tFILE *fp;\t\t\n\n\tstruct utmpx ut;\t\n\tstruct utmplist *ulist = NULL;\t\n\tstruct utmplist *p;\t\n\tstruct utmplist *next;\t\n\n\ttime_t lastboot = 0;\t\n\ttime_t lastrch = 0;\t\n\ttime_t lastdown;\t\n\ttime_t begintime;\t\n\tint whydown = 0;\t\n\n\tint c, x;\t\t\n\tstruct stat st;\t\t\n\tint quit = 0;\t\t\n\tint down = 0;\t\t\n\n#ifndef FUZZ_TARGET\n\ttime(&lastdown);\n#else\n\tlastdown = 1596001948;\n#endif\n\t\n\tlastdate = currentdate = lastrch = lastdown;\n\n#ifndef FUZZ_TARGET\n\t\n\tsignal(SIGINT, int_handler);\n\tsignal(SIGQUIT, quit_handler);\n#endif\n\n\t\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), filename);\n\n\t\n\tsetvbuf(fp, NULL, _IOFBF, UCHUNKSIZE);\n\n\t\n\tif (uread(fp, &ut, NULL, filename) == 1)\n\t\tbegintime = ut.ut_tv.tv_sec;\n\telse {\n\t\tif (fstat(fileno(fp), &st) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"stat of %s failed\"), filename);\n\t\tbegintime = st.st_ctime;\n\t\tquit = 1;\n\t}\n\n\t\n\turead(fp, NULL, NULL, filename);\n\n\t\n\twhile (!quit) {\n\n\t\tif (uread(fp, &ut, &quit, filename) != 1)\n\t\t\tbreak;\n\n\t\tif (ctl->since && ut.ut_tv.tv_sec < ctl->since)\n\t\t\tcontinue;\n\n\t\tif (ctl->until && ctl->until < ut.ut_tv.tv_sec)\n\t\t\tcontinue;\n\n\t\tlastdate = ut.ut_tv.tv_sec;\n\n\t\tif (ctl->lastb) {\n\t\t\tquit = list(ctl, &ut, ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (strncmp(ut.ut_line, \"~\", 1) == 0) {\n\t\t\tif (strncmp(ut.ut_user, \"shutdown\", 8) == 0)\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"reboot\", 6) == 0)\n\t\t\t\tut.ut_type = BOOT_TIME;\n\t\t\telse if (strncmp(ut.ut_user, \"runlevel\", 8) == 0)\n\t\t\t\tut.ut_type = RUN_LVL;\n\t\t}\n#if 1 \n\t\t\n\t\telse {\n\t\t\tif (ut.ut_type != DEAD_PROCESS &&\n\t\t\t    ut.ut_user[0] && ut.ut_line[0] &&\n\t\t\t    strncmp(ut.ut_user, \"LOGIN\", 5) != 0)\n\t\t\t\tut.ut_type = USER_PROCESS;\n\t\t\t\n\t\t\tif (ut.ut_user[0] == 0)\n\t\t\t\tut.ut_type = DEAD_PROCESS;\n\n\t\t\t\n\t\t\tif (strncmp(ut.ut_user, \"date\", 4) == 0) {\n\t\t\t\tif (ut.ut_line[0] == '|')\n\t\t\t\t\tut.ut_type = OLD_TIME;\n\t\t\t\tif (ut.ut_line[0] == '{')\n\t\t\t\t\tut.ut_type = NEW_TIME;\n\t\t\t}\n\t\t}\n#endif\n\t\tswitch (ut.ut_type) {\n\t\tcase SHUTDOWN_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line, \"system down\");\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_NORMAL);\n\t\t\t}\n\t\t\tlastdown = lastrch = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase OLD_TIME:\n\t\tcase NEW_TIME:\n\t\t\tif (ctl->extended) {\n\t\t\t\tstrcpy(ut.ut_line,\n\t\t\t\tut.ut_type == NEW_TIME ? \"new time\" :\n\t\t\t\t\t\"old time\");\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_TIMECHANGE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BOOT_TIME:\n\t\t\tstrcpy(ut.ut_line, \"system boot\");\n\t\t\tif (lastdown > lastboot && lastdown != currentdate)\n\t\t\t\tquit = list(ctl, &ut, lastboot, R_REBOOT_CRASH);\n\t\t\telse\n\t\t\t\tquit = list(ctl, &ut, lastdown, R_REBOOT);\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\tdown = 1;\n\t\t\tbreak;\n\t\tcase RUN_LVL:\n\t\t\tx = ut.ut_pid & 255;\n\t\t\tif (ctl->extended) {\n\t\t\t\tsnprintf(ut.ut_line, sizeof(ut.ut_line), \"(to lvl %c)\", x);\n\t\t\t\tquit = list(ctl, &ut, lastrch, R_NORMAL);\n\t\t\t}\n\t\t\tif (x == '0' || x == '6') {\n\t\t\t\tlastdown = ut.ut_tv.tv_sec;\n\t\t\t\tdown = 1;\n\t\t\t\tut.ut_type = SHUTDOWN_TIME;\n\t\t\t}\n\t\t\tlastrch = ut.ut_tv.tv_sec;\n\t\t\tbreak;\n\n\t\tcase USER_PROCESS:\n\t\t\t\n\t\t\tc = 0;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tif (strncmp(p->ut.ut_line, ut.ut_line,\n\t\t\t\t    sizeof(ut.ut_line)) == 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tquit = list(ctl, &ut, p->ut.ut_tv.tv_sec, R_NORMAL);\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (p->next)\n\t\t\t\t\t\tp->next->prev = p->prev;\n\t\t\t\t\tif (p->prev)\n\t\t\t\t\t\tp->prev->next = p->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tulist = p->next;\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (c == 0) {\n\t\t\t\tif (!lastboot) {\n\t\t\t\t\tc = R_NOW;\n\t\t\t\t\t\n\t\t\t\t\tif (is_phantom(ctl, &ut))\n\t\t\t\t\t\tc = R_PHANTOM;\n\t\t\t\t} else\n\t\t\t\t\tc = whydown;\n\t\t\t\tquit = list(ctl, &ut, lastboot, c);\n\t\t\t}\n\t\t\t\n\n\t\tcase DEAD_PROCESS:\n\t\t\t\n\t\t\tif (ut.ut_line[0] == 0)\n\t\t\t\tbreak;\n\t\t\tp = xmalloc(sizeof(struct utmplist));\n\t\t\tmemcpy(&p->ut, &ut, sizeof(struct utmpx));\n\t\t\tp->next  = ulist;\n\t\t\tp->prev  = NULL;\n\t\t\tif (ulist)\n\t\t\t\tulist->prev = p;\n\t\t\tulist = p;\n\t\t\tbreak;\n\n\t\tcase EMPTY:\n\t\tcase INIT_PROCESS:\n\t\tcase LOGIN_PROCESS:\n#ifdef ACCOUNTING\n\t\tcase ACCOUNTING:\n#endif\n\t\t\t\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twarnx(\"unrecognized ut_type: %d\", ut.ut_type);\n\t\t}\n\n\t\t\n\t\tif (down) {\n\t\t\tlastboot = ut.ut_tv.tv_sec;\n\t\t\twhydown = (ut.ut_type == SHUTDOWN_TIME) ? R_DOWN : R_CRASH;\n\t\t\tfor (p = ulist; p; p = next) {\n\t\t\t\tnext = p->next;\n\t\t\t\tfree(p);\n\t\t\t}\n\t\t\tulist = NULL;\n\t\t\tdown = 0;\n\t\t}\n\t}\n\n\tif (ctl->time_fmt != LAST_TIMEFTM_NONE) {\n\t\tstruct last_timefmt *fmt;\n\t\tchar timestr[LAST_TIMESTAMP_LEN];\n\t\tchar *tmp = xstrdup(filename);\n\n\t\tfmt = &timefmts[ctl->time_fmt];\n\t\tif (time_formatter(fmt->in_fmt, timestr,\n\t\t\t\t   sizeof(timestr), &begintime) < 0)\n\t\t\terrx(EXIT_FAILURE, _(\"preallocation size exceeded\"));\n\t\tprintf(_(\"\\n%s begins %s\\n\"), basename(tmp), timestr);\n\t\tfree(tmp);\n\t}\n\n\tfclose(fp);\n\n\tfor (p = ulist; p; p = next) {\n\t\tnext = p->next;\n\t\tfree(p);\n\t}\n}\n\n#ifdef FUZZ_TARGET\n# include \"all-io.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\tstruct last_control ctl = {\n\t\t.showhost = TRUE,\n\t\t.name_len = LAST_LOGIN_LEN,\n\t\t.time_fmt = LAST_TIMEFTM_SHORT,\n\t\t.domain_len = LAST_DOMAIN_LEN,\n\t\t.boot_time = {\n\t\t\t.tv_sec = 1595978419,\n\t\t\t.tv_usec = 816074\n\t\t}\n\t};\n\tchar name[] = \"/tmp/test-last-fuzz.XXXXXX\";\n\tint fd;\n\n\tfd = mkstemp_cloexec(name);\n\tif (fd < 0)\n\t\terr(EXIT_FAILURE, \"mkstemp() failed\");\n\tif (write_all(fd, data, size) != 0)\n\t\terr(EXIT_FAILURE, \"write() failed\");\n\n\tprocess_wtmp_file(&ctl, name);\n\n", "Selected Statement": "time_t lastboot = 0;\t/* Last boottime */", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "util-linux"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "#include <unistd.h>\n\nstatic int process_file(const char *name)\n{\n    int rc = -1;\n    blkid_probe pr = blkid_new_probe_from_filename(name);\n    if (pr != NULL) {\n        blkid_probe_enable_partitions(pr, TRUE);\n        blkid_probe_set_partitions_flags(pr, FALSE);\n        blkid_probe_enable_superblocks(pr, TRUE);\n        blkid_probe_set_superblocks_flags(pr, BLKID_SUBLKS_DEFAULT | BLKID_SUBLKS_FSINFO | BLKID_SUBLKS_MAGIC | BLKID_SUBLKS_VERSION | BLKID_SUBLKS_BADCSUM);\n        rc = blkid_do_safeprobe(pr) == -1 ? -1 : 0;\n    }\n    blkid_free_probe(pr);\n    return rc;\n}\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n    int fd;\n    char name[] = \"/tmp/test-script-fuzz.XXXXXX\";\n\n    fd = mkostemp(name, O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC);\n    if (fd == -1)\n        err(EXIT_FAILURE, \"mkostemp() failed\");\n\n    if (write(fd, data, size) != (ssize_t)size)\n        goto out;\n\n    process_file(name);\nout:\n", "Selected Statement": "int rc = -1;", "Function Input": {"name": {"value": null}}, "Variable Values Before Statement": {"constant": "-1"}, "Value After Statement Execution": "-1", "Project Information": "util-linux"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": " * allocates BSD label driver\n */\nstruct fdisk_label *fdisk_new_bsd_label(struct fdisk_context *cxt __attribute__ ((__unused__)))\n{\n\tstruct fdisk_label *lb;\n\tstruct fdisk_bsd_label *bsd;\n\n\tbsd = calloc(1, sizeof(*bsd));\n\tif (!bsd)\n\t\treturn NULL;\n\n\t\n\tlb = (struct fdisk_label *) bsd;\n\tlb->name = \"bsd\";\n\tlb->id = FDISK_DISKLABEL_BSD;\n\tlb->op = &bsd_operations;\n\tlb->parttypes = bsd_fstypes;\n\tlb->nparttypes = ARRAY_SIZE(bsd_fstypes) - 1;\n\n\tlb->fields = bsd_fields;\n\tlb->nfields = ARRAY_SIZE(bsd_fields);\n\n\tlb->flags |= FDISK_LABEL_FL_INCHARS_PARTNO;\n\tlb->flags |= FDISK_LABEL_FL_REQUIRE_GEOMETRY;\n\n\t\n\treturn (struct fdisk_label *) bsd;\n", "Selected Statement": "lb->name = \"bsd\";", "Function Input": {}, "Variable Values Before Statement": {"constant": "\"bsd\""}, "Value After Statement Execution": "\"bsd\"", "Project Information": "util-linux"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": " * Returns: newly allocated tab struct.\n */\nstruct libmnt_table *mnt_new_table(void)\n{\n\tstruct libmnt_table *tb = NULL;\n\n\ttb = calloc(1, sizeof(*tb));\n\tif (!tb)\n\t\treturn NULL;\n\n\tDBG(TAB, ul_debugobj(tb, \"alloc\"));\n\ttb->refcount = 1;\n\tINIT_LIST_HEAD(&tb->ents);\n\treturn tb;\n", "Selected Statement": "tb->refcount = 1;", "Function Input": {"tb": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"fmt": {"type_category": "int", "concrete_type": "int", "value": "1220708680"}, "nents": {"type_category": "int", "concrete_type": "int", "value": "1668857989"}, "refcount": {"type_category": "int", "concrete_type": "int", "value": "139103049"}, "comms": {"type_category": "int", "concrete_type": "int", "value": "675515209"}, "comm_intro": {"type_category": "string", "concrete_type": "string", "value": "0x76ca394818728b41 <error: Cannot access memory at address 0x76ca394818728b41>"}, "comm_tail": {"type_category": "string", "concrete_type": "string", "value": "0xd6af0f48ca29480a <error: Cannot access memory at address 0xd6af0f48ca29480a>"}, "cache": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7ffff7fcd82a", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x491c4a8b41d00148\n", "message": "Cannot access memory at address 0x491c4a8b41d00148"}}, "errcb": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7ffff7fcd832", "value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3941128b4120738b\n", "message": "Cannot access memory at address 0x3941128b4120738b"}}, "fltrcb": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7ffff7fcd83a", "value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3d48e8d348b775d5\n", "message": "Cannot access memory at address 0x3d48e8d348b775d5"}}, "fltrcb_data": {"type_category": "pointer", "concrete_type": "VOID"}, "noautofs": {"type_category": "int", "concrete_type": "int", "value": "-905958072"}, "ents": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"next": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7ffff7fcd852", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x773b9ac9ff3d4801\n", "message": "Cannot access memory at address 0x773b9ac9ff3d4801"}}, "prev": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7ffff7fcd85a", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x24348949d60148ef\n", "message": "Cannot access memory at address 0x24348949d60148ef"}}}}, "userdata": {"type_category": "pointer", "concrete_type": "VOID"}}}}}, "Variable Values Before Statement": {"constant": "1"}, "Value After Statement Execution": "1", "Project Information": "util-linux"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": " * Returns: 0 on success, negative number in case of error.\n */\nint mnt_table_parse_stream(struct libmnt_table *tb, FILE *f, const char *filename)\n{\n\tint rc = -1;\n\tint flags = 0;\n\tpid_t tid = -1;\n\tstruct libmnt_parser pa = { .line = 0 };\n\n\tassert(tb);\n\tassert(f);\n\tassert(filename);\n\n\tDBG(TAB, ul_debugobj(tb, \"%s: start parsing [entries=%d, filter=%s]\",\n\t\t\t\tfilename, mnt_table_get_nents(tb),\n\t\t\t\ttb->fltrcb ? \"yes\" : \"not\"));\n\n\tpa.filename = filename;\n\tpa.f = f;\n\n\t\n\tif (tb->fmt == MNT_FMT_SWAPS)\n\t\tflags = MNT_FS_SWAP;\n\telse if (filename && strcmp(filename, _PATH_PROC_MOUNTS) == 0)\n\t\tflags = MNT_FS_KERNEL;\n\n\tdo {\n\t\tstruct libmnt_fs *fs;\n\n\t\tif (feof(f)) {\n\t\t\tDBG(TAB, ul_debugobj(tb, \"end-of-file\"));\n\t\t\tbreak;\n\t\t}\n\t\tfs = mnt_new_fs();\n\t\tif (!fs)\n\t\t\tgoto err;\n\n\t\t\n\t\trc = mnt_table_parse_next(&pa, tb, fs);\n\n\t\tif (rc == 0 && tb->fltrcb && tb->fltrcb(fs, tb->fltrcb_data))\n\t\t\trc = 1;\t\n\n\t\tif (rc == 0 && mnt_table_is_noautofs(tb)) {\n\t\t\tconst char *fstype = mnt_fs_get_fstype(fs);\n\n\t\t\tif (fstype && strcmp(fstype, \"autofs\") == 0 &&\n\t\t\t    mnt_fs_get_option(fs, \"ignore\", NULL, NULL) == 0)\n\t\t\t\trc = 1; \n\t\t}\n\n\t\t\n\t\tif (rc == 0) {\n\t\t\trc = mnt_table_add_fs(tb, fs);\n\t\t\tfs->flags |= flags;\n\n\t\t\tif (rc == 0 && tb->fmt == MNT_FMT_MOUNTINFO) {\n\t\t\t\trc = kernel_fs_postparse(&pa, tb, fs, &tid);\n\t\t\t\tif (rc)\n\t\t\t\t\tmnt_table_remove_fs(tb, fs);\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tmnt_unref_fs(fs);\n\n\t\t\n\t\tif (rc > 0) {\n\t\t\tDBG(TAB, ul_debugobj(tb, \"recoverable error (continue)\"));\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (rc < 0 && !feof(f)) {\n\t\t\tDBG(TAB, ul_debugobj(tb, \"fatal error\"));\n\t\t\tgoto err;\n\t\t}\n\t} while (1);\n\n\tDBG(TAB, ul_debugobj(tb, \"%s: stop parsing (%d entries)\",\n\t\t\t\tfilename, mnt_table_get_nents(tb)));\n\tparser_cleanup(&pa);\n\treturn 0;\nerr:\n\tDBG(TAB, ul_debugobj(tb, \"%s: parse error (rc=%d)\", filename, rc));\n\tparser_cleanup(&pa);\n\treturn rc;\n", "Selected Statement": "int rc = -1;", "Function Input": {}, "Variable Values Before Statement": {"constant": "-1"}, "Value After Statement Execution": "-1", "Project Information": "util-linux"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": " * Returns: newly allocated struct libmnt_fs.\n */\nstruct libmnt_fs *mnt_new_fs(void)\n{\n\tstruct libmnt_fs *fs = calloc(1, sizeof(*fs));\n\n\tif (!fs)\n\t\treturn NULL;\n\n\tfs->refcount = 1;\n\tINIT_LIST_HEAD(&fs->ents);\n\tDBG(FS, ul_debugobj(fs, \"alloc\"));\n\treturn fs;\n", "Selected Statement": "fs->refcount = 1;", "Function Input": {"fs": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"ents": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"next": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x1055460", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"next": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x1050a5e", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3339326363303330\n", "message": "Cannot access memory at address 0x3339326363303330"}}, "prev": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x1050a66", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3938383033306136\n", "message": "Cannot access memory at address 0x3938383033306136"}}}}}, "prev": {"type_category": "pointer", "concrete_type": "NULL"}}}, "tab": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x1055470", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x20\n", "message": "Cannot access memory at address 0x20"}}, "refcount": {"type_category": "int", "concrete_type": "int", "value": "401"}, "opts_age": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}, "optlist": {"type_category": "pointer", "concrete_type": "NULL"}, "id": {"type_category": "int", "concrete_type": "int", "value": "17088528"}, "parent": {"type_category": "int", "concrete_type": "int", "value": "0"}, "devno": {"type_category": "unknown", "concrete_type": "dev_t", "value": "0"}, "bindsrc": {"type_category": "string", "concrete_type": "NULL"}, "source": {"type_category": "string", "concrete_type": "NULL"}, "tagname": {"type_category": "string", "concrete_type": "NULL"}, "tagval": {"type_category": "string", "concrete_type": "NULL"}, "root": {"type_category": "string", "concrete_type": "NULL"}, "target": {"type_category": "string", "concrete_type": "NULL"}, "fstype": {"type_category": "string", "concrete_type": "NULL"}, "optstr": {"type_category": "string", "concrete_type": "NULL"}, "vfs_optstr": {"type_category": "string", "concrete_type": "NULL"}, "opt_fields": {"type_category": "string", "concrete_type": "NULL"}, "fs_optstr": {"type_category": "string", "concrete_type": "NULL"}, "user_optstr": {"type_category": "string", "concrete_type": "NULL"}, "attrs": {"type_category": "string", "concrete_type": "NULL"}, "freq": {"type_category": "int", "concrete_type": "int", "value": "0"}, "passno": {"type_category": "int", "concrete_type": "int", "value": "0"}, "swaptype": {"type_category": "string", "concrete_type": "NULL"}, "size": {"type_category": "unknown", "concrete_type": "off_t", "value": "0"}, "usedsize": {"type_category": "unknown", "concrete_type": "off_t", "value": "0"}, "priority": {"type_category": "int", "concrete_type": "int", "value": "0"}, "flags": {"type_category": "int", "concrete_type": "int", "value": "0"}, "tid": {"type_category": "unknown", "concrete_type": "pid_t", "value": "0"}, "comment": {"type_category": "string", "concrete_type": "NULL"}, "userdata": {"type_category": "pointer", "concrete_type": "NULL"}}}}}, "Variable Values Before Statement": {"constant": "1"}, "Value After Statement Execution": "1", "Project Information": "util-linux"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": " */\n\nAPR_DECLARE(apr_status_t) apr_pool_initialize(void)\n{\n    apr_status_t rv;\n#if (APR_POOL_DEBUG & APR_POOL_DEBUG_VERBOSE_ALL)\n    char *logpath;\n    apr_file_t *debug_log = NULL;\n#endif\n\n    if (apr_pools_initialized++)\n        return APR_SUCCESS;\n\n#if defined(_SC_PAGESIZE)\n    boundary_size = sysconf(_SC_PAGESIZE);\n#elif defined(WIN32)\n    {\n        SYSTEM_INFO si;\n        GetSystemInfo(&si);\n        boundary_size = si.dwPageSize;\n    }\n#endif\n    boundary_index = 12;\n    while ( (1 << boundary_index) < boundary_size)\n        boundary_index++;\n    boundary_size = (1 << boundary_index);\n\n    \n    if ((rv = apr_pool_create_ex(&global_pool, NULL, NULL,\n                                 NULL)) != APR_SUCCESS) {\n        return rv;\n    }\n\n    apr_pool_tag(global_pool, \"APR global pool\");\n\n    apr_pools_initialized = 1;\n\n    \n    if ((rv = apr_atomic_init(global_pool)) != APR_SUCCESS) {\n        return rv;\n    }\n\n#if (APR_POOL_DEBUG & APR_POOL_DEBUG_VERBOSE_ALL)\n    rv = apr_env_get(&logpath, \"APR_POOL_DEBUG_LOG\", global_pool);\n\n    \n    if (rv == APR_SUCCESS) {\n        apr_file_open(&debug_log, logpath,\n                      APR_FOPEN_APPEND|APR_FOPEN_WRITE|APR_FOPEN_CREATE,\n                      APR_FPROT_OS_DEFAULT, global_pool);\n    }\n    else {\n        apr_file_open_stderr(&debug_log, global_pool);\n    }\n\n    \n    file_stderr = debug_log;\n\n    if (file_stderr) {\n        apr_file_printf(file_stderr,\n            \"POOL DEBUG: [PID\"\n#if APR_HAS_THREADS\n            \"/TID\"\n#endif \n            \"] ACTION  (SIZE      /POOL SIZE /TOTAL SIZE) \"\n            \"POOL       \\\"TAG\\\" <__FILE__:__LINE__> PARENT     (ALLOCS/TOTAL ALLOCS/CLEARS)\\n\");\n\n        apr_pool_log_event(global_pool, \"GLOBAL\", __FILE__ \":apr_pool_initialize\", 0);\n\n        \n        apr_pool_cleanup_register(global_pool, NULL,\n                                  apr_pool_cleanup_file_stderr,\n                                  apr_pool_cleanup_null);\n    }\n#endif \n\n    return APR_SUCCESS;\n", "Selected Statement": "boundary_index = 12;", "Function Input": {}, "Variable Values Before Statement": {"constant": "12"}, "Value After Statement Execution": "12", "Project Information": "apache-httpd"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "void *pointer_arr[GB_SIZE];\nstatic int pointer_idx = 0;\n\n\n\nvoid af_gb_init() {\n  pointer_idx = 0;\n\n   for (int i = 0; i < GB_SIZE; i++) {\n", "Selected Statement": "pointer_idx = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "apache-httpd"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "APR_DECLARE(apr_status_t) apr_tokenize_to_argv(const char *arg_str,\n                                            char ***argv_out,\n                                            apr_pool_t *token_context)\n{\n    const char *cp;\n    const char *ct;\n    char *cleaned, *dirty;\n    int escaped;\n    int isquoted, numargs = 0, argnum;\n\n#define SKIP_WHITESPACE(cp) \\\n    for ( ; *cp == ' ' || *cp == '\\t'; ) { \\\n        cp++; \\\n    };\n\n#define CHECK_QUOTATION(cp,isquoted) \\\n    isquoted = 0; \\\n    if (*cp == '\"') { \\\n        isquoted = 1; \\\n        cp++; \\\n    } \\\n    else if (*cp == '\\'') { \\\n        isquoted = 2; \\\n        cp++; \\\n    }\n\n\n#define DETERMINE_NEXTSTRING(cp,isquoted) \\\n    for ( ; *cp != '\\0'; cp++) { \\\n        if (   (*cp == '\\\\' && (*(cp+1) == ' ' || *(cp+1) == '\\t' || \\\n                                *(cp+1) == '\"' || *(cp+1) == '\\''))) { \\\n            cp++; \\\n            continue; \\\n        } \\\n        if (   (!isquoted && (*cp == ' ' || *cp == '\\t')) \\\n            || (isquoted == 1 && *cp == '\"') \\\n            || (isquoted == 2 && *cp == '\\'')                 ) { \\\n            break; \\\n        } \\\n    }\n\n\n#define REMOVE_ESCAPE_CHARS(cleaned, dirty, escaped) \\\n    escaped = 0; \\\n    while(*dirty) { \\\n        if (!escaped && *dirty == '\\\\') { \\\n            escaped = 1; \\\n        } \\\n        else { \\\n            escaped = 0; \\\n            *cleaned++ = *dirty; \\\n        } \\\n        ++dirty; \\\n    } \\\n    *cleaned = 0;        \n\n    cp = arg_str;\n    SKIP_WHITESPACE(cp);\n    ct = cp;\n\n    \n    numargs = 1;\n    while (*ct != '\\0') {\n        CHECK_QUOTATION(ct, isquoted);\n        DETERMINE_NEXTSTRING(ct, isquoted);\n        if (*ct != '\\0') {\n            ct++;\n        }\n        numargs++;\n        SKIP_WHITESPACE(ct);\n    }\n    *argv_out = apr_palloc(token_context, numargs * sizeof(char*));\n\n    \n    for (argnum = 0; argnum < (numargs-1); argnum++) {\n        SKIP_WHITESPACE(cp);\n        CHECK_QUOTATION(cp, isquoted);\n        ct = cp;\n        DETERMINE_NEXTSTRING(cp, isquoted);\n        cp++;\n        (*argv_out)[argnum] = apr_palloc(token_context, cp - ct);\n        apr_cpystrn((*argv_out)[argnum], ct, cp - ct);\n        cleaned = dirty = (*argv_out)[argnum];\n        REMOVE_ESCAPE_CHARS(cleaned, dirty, escaped);\n    }\n    (*argv_out)[argnum] = NULL;\n\n", "Selected Statement": "numargs = 1;", "Function Input": {}, "Variable Values Before Statement": {"constant": "1"}, "Value After Statement Execution": "1", "Project Information": "apache-httpd"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "nxt_mp_t *\nnxt_mp_create(size_t cluster_size, size_t page_alignment, size_t page_size,\n    size_t min_chunk_size)\n{\n    nxt_mp_t     *mp;\n    uint32_t     pages, chunk_size_shift, page_size_shift;\n    nxt_queue_t  *chunk_pages;\n\n    chunk_size_shift = nxt_lg2(min_chunk_size);\n    page_size_shift = nxt_lg2(page_size);\n\n    pages = page_size_shift - chunk_size_shift;\n\n    mp = nxt_zalloc(sizeof(nxt_mp_t) + pages * sizeof(nxt_queue_t));\n\n    if (nxt_fast_path(mp != NULL)) {\n        mp->retain = 1;\n        mp->chunk_size_shift = chunk_size_shift;\n        mp->page_size_shift = page_size_shift;\n        mp->page_size = page_size;\n        mp->page_alignment = nxt_max(page_alignment, NXT_MAX_ALIGNMENT);\n        mp->cluster_size = cluster_size;\n\n        chunk_pages = mp->chunk_pages;\n\n        while (pages != 0) {\n            nxt_queue_init(chunk_pages);\n            chunk_pages++;\n            pages--;\n        }\n\n        nxt_queue_init(&mp->free_pages);\n        nxt_queue_init(&mp->nget_pages);\n        nxt_queue_init(&mp->get_pages);\n\n        nxt_rbtree_init(&mp->blocks, nxt_mp_rbtree_compare);\n    }\n\n    nxt_debug_alloc(\"mp %p create(%uz, %uz, %uz, %uz)\", mp, cluster_size,\n                    page_alignment, page_size, min_chunk_size);\n\n", "Selected Statement": "mp->retain = 1;", "Function Input": {}, "Variable Values Before Statement": {"constant": "1"}, "Value After Statement Execution": "1", "Project Information": "unit"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\nnxt_int_t\nnxt_lib_start(const char *app, char **argv, char ***envp)\n{\n    int           n;\n    nxt_int_t     flags;\n    nxt_bool_t    update;\n    nxt_thread_t  *thread;\n\n    flags = nxt_stderr_start();\n\n    nxt_log_start(app);\n\n    nxt_pid = getpid();\n    nxt_ppid = getppid();\n    nxt_euid = geteuid();\n    nxt_egid = getegid();\n\n#if (NXT_DEBUG)\n\n    nxt_main_log.level = NXT_LOG_DEBUG;\n\n#if (NXT_HAVE_MALLOPT)\n    \n    mallopt(M_PERTURB, 0x55);\n#endif\n\n#if (NXT_MACOSX)\n    \n    setenv(\"MallocScribble\", \"1\", 0);\n#endif\n\n#endif \n\n    \n\n    nxt_thread_init_data(nxt_thread_context);\n    thread = nxt_thread();\n    thread->log = &nxt_main_log;\n\n    thread->handle = nxt_thread_handle();\n    thread->time.signal = -1;\n    nxt_thread_time_update(thread);\n\n    nxt_main_task.thread = thread;\n    nxt_main_task.log = thread->log;\n    nxt_main_task.ident = nxt_task_next_ident();\n\n    if (nxt_strerror_start() != NXT_OK) {\n        return NXT_ERROR;\n    }\n\n    if (flags != -1) {\n        nxt_debug(&nxt_main_task, \"stderr flags: 0x%04Xd\", flags);\n    }\n\n#ifdef _SC_NPROCESSORS_ONLN\n    \n    n = sysconf(_SC_NPROCESSORS_ONLN);\n\n#elif (NXT_HPUX)\n    n = mpctl(MPC_GETNUMSPUS, NULL, NULL);\n\n#else\n    n = 0;\n\n#endif\n\n    nxt_debug(&nxt_main_task, \"ncpu: %d\", n);\n\n    if (n > 1) {\n        nxt_ncpu = n;\n    }\n\n    nxt_thread_spin_init(nxt_ncpu, 0);\n\n    nxt_random_init(&thread->random);\n\n    nxt_pagesize = getpagesize();\n\n    nxt_debug(&nxt_main_task, \"pagesize: %ui\", nxt_pagesize);\n\n    if (argv != NULL) {\n        update = (argv[0] == app);\n\n        nxt_process_arguments(&nxt_main_task, argv, envp);\n\n        if (update) {\n            nxt_log_start(nxt_process_argv[0]);\n        }\n    }\n\n    return NXT_OK;\n", "Selected Statement": "thread->time.signal = -1;", "Function Input": {"app": {"value": "0x622e00 <vtable for std::__Fuzzer::ios_base::failure+8> \"\\260.b\""}, "argv": {"value": {"type_category": "string", "concrete_type": "string", "value": "0x8c48348707e8b49 <error: Cannot access memory at address 0x8c48348707e8b49>"}}, "envp": {"value": null}}, "Variable Values Before Statement": {"constant": "-1"}, "Value After Statement Execution": "-1", "Project Information": "unit"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\nnxt_int_t\nnxt_strerror_start(void)\n{\n    char        *msg;\n    u_char      *p;\n    size_t      size, length, n;\n    nxt_uint_t  err, invalid;\n\n    \n    size = nxt_length(\"Unknown error\");\n\n    \n\n    for (invalid = 0; invalid < 100 && nxt_sys_nerr < 65536; nxt_sys_nerr++) {\n\n        nxt_set_errno(0);\n        msg = strerror((int) nxt_sys_nerr);\n\n        \n\n        if (msg == NULL) {\n            invalid++;\n            continue;\n        }\n\n        length = nxt_strlen(msg);\n        size += length;\n\n        if (length == 0  \n            || nxt_errno == NXT_EINVAL\n            || memcmp(msg, \"Unknown error\", 13) == 0)\n        {\n            invalid++;\n            continue;\n        }\n\n#if (NXT_AIX)\n\n        if (memcmp(msg, \"Error \", 6) == 0\n            && memcmp(msg + length - 10, \" occurred.\", 9) == 0)\n        {\n            invalid++;\n            continue;\n        }\n\n#endif\n    }\n\n    nxt_sys_nerr -= invalid;\n\n    nxt_main_log_debug(\"sys_nerr: %d\", nxt_sys_nerr);\n\n    n = (nxt_sys_nerr + 1) * sizeof(nxt_str_t);\n\n    nxt_sys_errlist = nxt_malloc(n + size);\n    if (nxt_sys_errlist == NULL) {\n        return NXT_ERROR;\n    }\n\n    p = nxt_pointer_to(nxt_sys_errlist, n);\n\n    for (err = 0; err < nxt_sys_nerr; err++) {\n        msg = strerror((int) err);\n        length = nxt_strlen(msg);\n\n        nxt_sys_errlist[err].length = length;\n        nxt_sys_errlist[err].start = p;\n\n        p = nxt_cpymem(p, msg, length);\n    }\n\n    nxt_sys_errlist[err].length = 13;\n    nxt_sys_errlist[err].start = p;\n    nxt_memcpy(p, \"Unknown error\", 13);\n\n    nxt_strerror = nxt_runtime_strerror;\n\n    return NXT_OK;\n", "Selected Statement": "nxt_sys_errlist[err].length = 13;", "Function Input": {}, "Variable Values Before Statement": {"constant": "13"}, "Value After Statement Execution": "13", "Project Information": "unit"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "    return result;\n}\n\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n    \n\n    uint32_t range_start = 0;\n    uint32_t range_end = 10'000'000;\n\n    \n\n    FuzzedDataProvider fdp(data, size);\n    \n    std::vector<uint32_t> bitmap_data_a = ConsumeVecInRange(fdp, 500, 0, 1000);\n", "Selected Statement": "uint32_t range_start = 0;", "Function Input": {"data": {"value": "0xff3ad0 \"\\300?\\377\""}, "size": {"value": "16732112"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "croaring"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\nstruct window *\nwindow_create(u_int sx, u_int sy, u_int xpixel, u_int ypixel)\n{\n\tstruct window\t*w;\n\n\tif (xpixel == 0)\n\t\txpixel = DEFAULT_XPIXEL;\n\tif (ypixel == 0)\n\t\typixel = DEFAULT_YPIXEL;\n\n\tw = xcalloc(1, sizeof *w);\n\tw->name = xstrdup(\"\");\n\tw->flags = 0;\n\n\tTAILQ_INIT(&w->panes);\n\tTAILQ_INIT(&w->last_panes);\n\tw->active = NULL;\n\n\tw->lastlayout = -1;\n\tw->layout_root = NULL;\n\n\tw->sx = sx;\n\tw->sy = sy;\n\tw->manual_sx = sx;\n\tw->manual_sy = sy;\n\tw->xpixel = xpixel;\n\tw->ypixel = ypixel;\n\n\tw->options = options_create(global_w_options);\n\n\tw->references = 0;\n\tTAILQ_INIT(&w->winlinks);\n\n\tw->id = next_window_id++;\n\tRB_INSERT(windows, &windows, w);\n\n\twindow_set_fill_character(w);\n", "Selected Statement": "w->lastlayout = -1;", "Function Input": {}, "Variable Values Before Statement": {"constant": "-1"}, "Value After Statement Execution": "-1", "Project Information": "tmux"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\nvoid\ncolour_palette_init(struct colour_palette *p)\n{\n\tp->fg = 8;\n\tp->bg = 8;\n\tp->palette = NULL;\n\tp->default_palette = NULL;\n", "Selected Statement": "p->bg = 8;", "Function Input": {}, "Variable Values Before Statement": {"constant": "8"}, "Value After Statement Execution": "8", "Project Information": "tmux"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\nvoid\nscreen_init(struct screen *s, u_int sx, u_int sy, u_int hlimit)\n{\n\ts->grid = grid_create(sx, sy, hlimit);\n\ts->saved_grid = NULL;\n\n\ts->title = xstrdup(\"\");\n\ts->titles = NULL;\n\ts->path = NULL;\n\n\ts->cstyle = SCREEN_CURSOR_DEFAULT;\n\ts->default_cstyle = SCREEN_CURSOR_DEFAULT;\n\ts->mode = MODE_CURSOR;\n\ts->default_mode = 0;\n\ts->ccolour = -1;\n\ts->default_ccolour = -1;\n\ts->tabs = NULL;\n\ts->sel = NULL;\n\n#ifdef ENABLE_SIXEL\n\tTAILQ_INIT(&s->images);\n#endif\n\n\ts->write_list = NULL;\n\ts->hyperlinks = NULL;\n\n\tscreen_reinit(s);\n", "Selected Statement": "s->default_ccolour = -1;", "Function Input": {"s": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"title": {"type_category": "string", "concrete_type": "string", "value": "0x800000008 <error: Cannot access memory at address 0x800000008>"}, "path": {"type_category": "string", "concrete_type": "NULL"}, "titles": {"type_category": "pointer", "concrete_type": "NULL"}, "grid": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x26ebb10", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xffffffff\n", "message": "Cannot access memory at address 0xffffffff"}}, "cx": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "cy": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "cstyle": {"type_category": "unknown", "concrete_type": "screen_cursor_style", "value": "SCREEN_CURSOR_DEFAULT"}, "default_cstyle": {"type_category": "unknown", "concrete_type": "screen_cursor_style", "value": "SCREEN_CURSOR_DEFAULT"}, "ccolour": {"type_category": "int", "concrete_type": "int", "value": "0"}, "default_ccolour": {"type_category": "int", "concrete_type": "int", "value": "0"}, "rupper": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "rlower": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "mode": {"type_category": "int", "concrete_type": "int", "value": "0"}, "default_mode": {"type_category": "int", "concrete_type": "int", "value": "0"}, "saved_cx": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "saved_cy": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "saved_grid": {"type_category": "pointer", "concrete_type": "NULL"}, "saved_cell": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"data": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"data": {"type_category": "string", "concrete_type": "string", "value": "\"\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\""}, "have": {"type_category": "unknown", "concrete_type": "u_char", "value": "0 '\\000'"}, "size": {"type_category": "unknown", "concrete_type": "u_char", "value": "0 '\\000'"}, "width": {"type_category": "unknown", "concrete_type": "u_char", "value": "0 '\\000'"}}}, "attr": {"type_category": "unknown", "concrete_type": "u_short", "value": "0"}, "flags": {"type_category": "unknown", "concrete_type": "u_char", "value": "0 '\\000'"}, "fg": {"type_category": "int", "concrete_type": "int", "value": "0"}, "bg": {"type_category": "int", "concrete_type": "int", "value": "0"}, "us": {"type_category": "int", "concrete_type": "int", "value": "0"}, "link": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}}}, "saved_flags": {"type_category": "int", "concrete_type": "int", "value": "0"}, "tabs": {"type_category": "string", "concrete_type": "NULL"}, "sel": {"type_category": "pointer", "concrete_type": "NULL"}, "write_list": {"type_category": "pointer", "concrete_type": "NULL"}, "hyperlinks": {"type_category": "pointer", "concrete_type": "NULL"}}}}}, "Variable Values Before Statement": {"constant": "-1"}, "Value After Statement Execution": "-1", "Project Information": "tmux"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\nstruct grid *\ngrid_create(u_int sx, u_int sy, u_int hlimit)\n{\n\tstruct grid\t*gd;\n\n\tgd = xmalloc(sizeof *gd);\n\tgd->sx = sx;\n\tgd->sy = sy;\n\n\tif (hlimit != 0)\n\t\tgd->flags = GRID_HISTORY;\n\telse\n\t\tgd->flags = 0;\n\n\tgd->hscrolled = 0;\n\tgd->hsize = 0;\n\tgd->hlimit = hlimit;\n\n\tif (gd->sy != 0)\n\t\tgd->linedata = xcalloc(gd->sy, sizeof *gd->linedata);\n\telse\n\t\tgd->linedata = NULL;\n\n", "Selected Statement": "gd->hsize = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "tmux"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\nstruct hyperlinks *\nhyperlinks_init(void)\n{\n\tstruct hyperlinks\t*hl;\n\n\thl = xcalloc(1, sizeof *hl);\n\thl->next_inner = 1;\n\tRB_INIT(&hl->by_uri);\n\tRB_INIT(&hl->by_inner);\n", "Selected Statement": "hl->next_inner = 1;", "Function Input": {}, "Variable Values Before Statement": {"constant": "1"}, "Value After Statement Execution": "1", "Project Information": "tmux"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "static int\nalloc_exec(OnigEncoding enc, OnigOptionType options, OnigSyntaxType* syntax,\n           int backward, int pattern_size, size_t rem_size, unsigned char *data)\n{\n  extern int onig_detect_can_be_slow_pattern(const UChar* pattern, const UChar* pattern_end, OnigOptionType option, OnigEncoding enc, OnigSyntaxType* syntax);\n\n  int r;\n  int sl;\n  int data_pattern_size;\n  unsigned char *pattern;\n  unsigned char *pattern_end;\n  unsigned char *data_pattern;\n  unsigned char *data_pattern_end;\n  unsigned char *str_null_end;\n\n#ifdef TEST_PATTERN\n  pattern = (unsigned char *)malloc(sizeof(TestPattern));\n  memcpy(pattern, TestPattern, sizeof(TestPattern));\n  pattern_end = pattern + sizeof(TestPattern);\n#else\n  pattern = (unsigned char *)malloc(pattern_size != 0 ? pattern_size : 1);\n  pattern_end = pattern + pattern_size;\n  memcpy(pattern, data, pattern_size);\n#endif\n\n  sl = onig_detect_can_be_slow_pattern(pattern, pattern_end, options, enc, syntax);\n#ifdef STANDALONE\n  fprintf(stdout, \"sl: %d\\n\", sl);\n#endif\n\n  data_pattern_size = fix_size(pattern_size, enc, sl, backward);\n\n  if (\n#ifdef TEST_PATTERN\n      1 ||\n#endif\n      data_pattern_size != pattern_size) {\n    data_pattern = (unsigned char *)malloc(data_pattern_size != 0\n                                           ? data_pattern_size : 1);\n    data_pattern_end = data_pattern + data_pattern_size;\n    memcpy(data_pattern, data, data_pattern_size);\n  }\n  else {\n    data_pattern     = pattern;\n    data_pattern_end = pattern_end;\n  }\n\n  data += pattern_size;\n  rem_size -= pattern_size;\n  rem_size = fix_size(rem_size, enc, sl, backward);\n#ifdef STANDALONE\n  fprintf(stdout, \"rem_size: %ld\\n\", rem_size);\n#endif\n\n  unsigned char *str = (unsigned char*)malloc(rem_size != 0 ? rem_size : 1);\n  memcpy(str, data, rem_size);\n  str_null_end = str + rem_size;\n\n  r = exec(enc, options, syntax,\n           (char* )pattern,      (char* )pattern_end,\n           (char* )data_pattern, (char* )data_pattern_end,\n           (char* )str, str_null_end, backward, sl);\n\n  if (data_pattern != pattern)\n    free(data_pattern);\n\n  free(pattern);\n  free(str);\n  return r;\n}\n\n#ifdef PREV_CONTROL\n#ifdef SYNTAX_TEST\n#define NUM_CONTROL_BYTES      7\n#else\n#define NUM_CONTROL_BYTES      6\n#endif\n#else\n#ifdef SYNTAX_TEST\n#define NUM_CONTROL_BYTES      8\n#else\n#define NUM_CONTROL_BYTES      7\n#endif\n#endif\n\nint LLVMFuzzerTestOneInput(const uint8_t * Data, size_t Size)\n{\n#if !defined(UTF16_BE) && !defined(UTF16_LE)\n  static OnigEncoding encodings[] = {\n    ONIG_ENCODING_UTF8,\n    ONIG_ENCODING_UTF8,\n    ONIG_ENCODING_UTF8,\n    ONIG_ENCODING_UTF8,\n    ONIG_ENCODING_UTF8,\n    ONIG_ENCODING_UTF8,\n    ONIG_ENCODING_UTF8,\n    ONIG_ENCODING_UTF8,\n    ONIG_ENCODING_ASCII,\n    ONIG_ENCODING_EUC_JP,\n    ONIG_ENCODING_EUC_TW,\n    ONIG_ENCODING_EUC_KR,\n    ONIG_ENCODING_EUC_CN,\n    ONIG_ENCODING_SJIS,\n    ONIG_ENCODING_KOI8_R,\n    ONIG_ENCODING_CP1251,\n    ONIG_ENCODING_BIG5,\n    ONIG_ENCODING_GB18030,\n    ONIG_ENCODING_UTF16_BE,\n    ONIG_ENCODING_UTF16_LE,\n    ONIG_ENCODING_UTF16_BE,\n    ONIG_ENCODING_UTF16_LE,\n    ONIG_ENCODING_UTF32_BE,\n    ONIG_ENCODING_UTF32_LE,\n    ONIG_ENCODING_UTF32_BE,\n    ONIG_ENCODING_UTF32_LE,\n    ONIG_ENCODING_ISO_8859_1,\n    ONIG_ENCODING_ISO_8859_2,\n    ONIG_ENCODING_ISO_8859_3,\n    ONIG_ENCODING_ISO_8859_4,\n    ONIG_ENCODING_ISO_8859_5,\n    ONIG_ENCODING_ISO_8859_6,\n    ONIG_ENCODING_ISO_8859_7,\n    ONIG_ENCODING_ISO_8859_8,\n    ONIG_ENCODING_ISO_8859_9,\n    ONIG_ENCODING_ISO_8859_10,\n    ONIG_ENCODING_ISO_8859_11,\n    ONIG_ENCODING_ISO_8859_13,\n    ONIG_ENCODING_ISO_8859_14,\n    ONIG_ENCODING_ISO_8859_15,\n    ONIG_ENCODING_ISO_8859_16\n  };\n  unsigned char encoding_choice;\n#endif\n\n#ifdef SYNTAX_TEST\n  static OnigSyntaxType* syntaxes[] = {\n    ONIG_SYNTAX_POSIX_EXTENDED,\n    ONIG_SYNTAX_EMACS,\n    ONIG_SYNTAX_GREP,\n    ONIG_SYNTAX_GNU_REGEX,\n    ONIG_SYNTAX_JAVA,\n    ONIG_SYNTAX_PERL_NG,\n    ONIG_SYNTAX_PYTHON,\n    ONIG_SYNTAX_ONIGURUMA\n  };\n\n#ifdef STANDALONE\n  static char* syntax_names[] = {\n    \"Posix Extended\",\n    \"Emacs\",\n    \"Grep\",\n    \"GNU Regex\",\n    \"Java\",\n    \"Perl+NG\",\n    \"Python\",\n    \"Oniguruma\"\n  };\n#endif\n\n  unsigned char syntax_choice;\n#endif\n\n  int r;\n  int backward;\n  int pattern_size;\n  size_t rem_size;\n  unsigned char *data;\n  unsigned char pattern_size_choice;\n  OnigOptionType  options;\n  OnigEncoding    enc;\n  OnigSyntaxType* syntax;\n\n#ifndef STANDALONE\n#ifdef EXEC_PRINT_INTERVAL\n  static FILE* STAT_FP;\n#endif\n#endif\n\n  INPUT_COUNT++;\n\n#ifdef DUMP_DATA_INTERVAL\n  if (INPUT_COUNT % DUMP_DATA_INTERVAL == 0) {\n    char path[20];\n    sprintf(path, \"dump-%ld\", INPUT_COUNT);\n    dump_file(path, (unsigned char* )Data, Size);\n  }\n#endif\n\n  if (Size < NUM_CONTROL_BYTES) return 0;\n\n  rem_size = Size;\n  data = (unsigned char* )(Data);\n\n#ifdef UTF16_BE\n  enc = ONIG_ENCODING_UTF16_BE;\n#else\n#ifdef UTF16_LE\n  enc = ONIG_ENCODING_UTF16_LE;\n#else\n  encoding_choice = data[0];\n  data++;\n  rem_size--;\n\n  int num_encodings = sizeof(encodings)/sizeof(encodings[0]);\n  enc = encodings[encoding_choice % num_encodings];\n#endif\n#endif\n\n#ifdef SYNTAX_TEST\n  syntax_choice = data[0];\n  data++;\n  rem_size--;\n\n  int num_syntaxes = sizeof(syntaxes)/sizeof(syntaxes[0]);\n  syntax = syntaxes[syntax_choice % num_syntaxes];\n#else\n  syntax = ONIG_SYNTAX_DEFAULT;\n#endif\n\n#ifdef PREV_CONTROL\n  if ((data[2] & 0xc0) == 0)\n    options = data[0] | (data[1] << 8) | (data[2] << 16);\n#else\n  if ((data[3] & 0xc0) == 0)\n    options = data[0] | (data[1] << 8) | (data[2] << 16) | (data[3] << 24);\n#endif\n  else\n    options = data[0] & ONIG_OPTION_IGNORECASE;\n\n  data++; rem_size--;\n  data++; rem_size--;\n  data++; rem_size--;\n#ifndef PREV_CONTROL\n  data++; rem_size--;\n#endif\n\n  pattern_size_choice = data[0];\n  data++; rem_size--;\n\n  backward = (data[0] == 0xbb);\n  data++; rem_size--;\n\n  if (backward != 0) {\n    options = options & ~ONIG_OPTION_FIND_LONGEST;\n  }\n\n  if (rem_size == 0)\n    pattern_size = 0;\n  else {\n    pattern_size = (int )pattern_size_choice % rem_size;\n    ADJUST_LEN(enc, pattern_size);\n  }\n\n#ifdef STANDALONE\n  {\n    char soptions[33];\n\n    dump_data(stdout, data, pattern_size);\n    to_binary(options, soptions);\n#ifdef SYNTAX_TEST\n    fprintf(stdout,\n            \"enc: %s, syntax: %s, pattern_size: %d, back:%d\\noptions: %s\\n\",\n            ONIGENC_NAME(enc),\n            syntax_names[syntax_choice % num_syntaxes],\n            pattern_size, backward, soptions);\n#else\n    fprintf(stdout, \"enc: %s, pattern_size: %d, back:%d\\noptions: %s\\n\",\n            ONIGENC_NAME(enc), pattern_size, backward, soptions);\n#endif\n\n    print_options(stdout, options);\n    fprintf(stdout, \"\\n\");\n  }\n#endif\n\n#ifdef DUMP_INPUT\n  dump_input((unsigned char* )Data, Size);\n#endif\n\n", "Selected Statement": "if (upper <= 10) upper = 10;", "Function Input": {}, "Variable Values Before Statement": {"constant": "10"}, "Value After Statement Execution": "10", "Project Information": "oniguruma"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "onig_detect_can_be_slow_pattern(const UChar* pattern,\n  const UChar* pattern_end, OnigOptionType option, OnigEncoding enc,\n  OnigSyntaxType* syntax)\n{\n  int r;\n  regex_t* reg;\n  Node* root;\n  ParseEnv scan_env;\n  SlowElementCount count;\n  int calls[MAX_CALLS_IN_DETECT];\n#ifdef USE_CALL\n  UnsetAddrList  uslist = {0};\n#endif\n\n  reg = (regex_t* )xmalloc(sizeof(regex_t));\n  if (IS_NULL(reg)) return ONIGERR_MEMORY;\n\n  r = onig_reg_init(reg, option, ONIGENC_CASE_FOLD_DEFAULT, enc, syntax);\n  if (r != 0) {\n    xfree(reg);\n    return r;\n  }\n\n  r = parse_and_tune(reg, pattern, pattern_end, &scan_env, &root, NULL\n#ifdef USE_CALL\n                     , &uslist\n#endif\n                    );\n  if (r != 0) goto err;\n\n#ifdef USE_CALL\n  if (scan_env.num_call > 0) {\n    unset_addr_list_end(&uslist);\n  }\n#endif\n\n  count.prec_read          = 0;\n  count.look_behind        = 0;\n  count.backref            = 0;\n  count.backref_with_level = 0;\n  count.call               = 0;\n  count.is_keep            = FALSE;\n  count.anychar_reluctant_many     = 0;\n  count.empty_check_nest_level     = 0;\n  count.max_empty_check_nest_level = 0;\n  count.heavy_element = 0;\n\n  r = detect_can_be_slow(root, &count, 0, calls);\n  if (r == 0) {\n    int n;\n\n    n = count.prec_read + count.look_behind\n      + count.backref + count.backref_with_level + count.call\n      + count.anychar_reluctant_many;\n\n    if (count.is_keep) count.max_empty_check_nest_level++;\n\n    if (count.max_empty_check_nest_level > 2)\n      n += count.max_empty_check_nest_level - 2;\n    if (count.heavy_element != 0) {\n      if (count.heavy_element < 0x10000)\n        n += count.heavy_element << 8;\n      else\n        n += count.heavy_element;\n    }\n\n    r = n;\n\n#ifdef ONIG_DEBUG_PARSE\n    fprintf(DBGFP, \"-- detect can be slow --\\n\");\n    fprintf(DBGFP, \"  prec_read:          %d\\n\", count.prec_read);\n    fprintf(DBGFP, \"  look_behind:        %d\\n\", count.look_behind);\n    fprintf(DBGFP, \"  backref:            %d\\n\", count.backref);\n    fprintf(DBGFP, \"  backref_with_level: %d\\n\", count.backref_with_level);\n    fprintf(DBGFP, \"  call:               %d\\n\", count.call);\n    fprintf(DBGFP, \"  is_keep:            %d\\n\", count.is_keep);\n    fprintf(DBGFP, \"  any_reluctant_many: %d\\n\", count.anychar_reluctant_many);\n    fprintf(DBGFP, \"  max_empty_check_nest_level: %d\\n\", count.max_empty_check_nest_level);\n    fprintf(DBGFP, \"  heavy_element:      %d\\n\", count.heavy_element);\n    fprintf(DBGFP, \"  r:                  %d\\n\", r);\n    fprintf(DBGFP, \"\\n\");\n#endif\n  }\n\n  if (IS_NOT_NULL(scan_env.mem_env_dynamic))\n    xfree(scan_env.mem_env_dynamic);\n\n err:\n  onig_node_free(root);\n  onig_free(reg);\n  return r;\n", "Selected Statement": "count.empty_check_nest_level     = 0;", "Function Input": {"reg": {"value": null}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "oniguruma"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\nextern int\nonigenc_init(void)\n{\n  if (OnigEncInited != 0) return 0;\n\n  OnigEncInited = 1;\n  return 0;\n", "Selected Statement": "OnigEncInited = 1;", "Function Input": {}, "Variable Values Before Statement": {"constant": "1"}, "Value After Statement Execution": "1", "Project Information": "oniguruma"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\nextern st_table*\nst_init_table_with_size(struct st_hash_type* type, int size)\n{\n  st_table *tbl;\n\n#ifdef HASH_LOG\n  if (init_st == 0) {\n    init_st = 1;\n    atexit(stat_col);\n  }\n#endif\n\n  size = new_size(size);\t\n  if (size <= 0) return 0;\n\n  tbl = alloc(st_table);\n  if (tbl == 0) return 0;\n\n  tbl->type = type;\n  tbl->num_entries = 0;\n  tbl->num_bins = size;\n  tbl->bins = (st_table_entry **)Calloc(size, sizeof(st_table_entry*));\n  if (tbl->bins == 0) {\n    free(tbl);\n    return 0;\n  }\n\n  return tbl;\n", "Selected Statement": "tbl->num_entries = 0;", "Function Input": {"size": {"value": "0"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "oniguruma"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "}\n\nvoid ddsi_iid_init (void)\n{\n  union { uint64_t u64; uint32_t u32[2]; } tmp;\n  ddsrt_prng_seed_t seed;\n  DDSRT_STATIC_ASSERT (sizeof (seed.key) >= sizeof (ddsi_iid.key));\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if (ddsrt_prng_makeseed (&seed))\n    memcpy (ddsi_iid.key, seed.key, sizeof (ddsi_iid.key));\n  else\n  {\n    for (size_t i = 0; i < sizeof (ddsi_iid.key) / sizeof (ddsi_iid.key[0]); i++)\n      ddsi_iid.key[i] = ddsrt_random ();\n  }\n  tmp.u64 = 0;\n  dds_tea_decrypt (tmp.u32, ddsi_iid.key);\n  ddsrt_atomic_st64 (&ddsi_iid.counter, tmp.u64);\n", "Selected Statement": "tmp.u64 = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "cyclonedds"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "CxPlatSystemLoad(\n    void\n    )\n{\n#if defined(CX_PLATFORM_DARWIN)\n    \n    \n    \n    \n    CxPlatProcessorCount = 1;\n#else\n    CxPlatProcessorCount = (uint32_t)sysconf(_SC_NPROCESSORS_ONLN);\n#endif\n\n#ifdef CXPLAT_NUMA_AWARE\n    if (numa_available() >= 0) {\n        CxPlatNumaNodeCount = (uint32_t)numa_num_configured_nodes();\n        CxPlatNumaNodeMasks =\n            CXPLAT_ALLOC_NONPAGED(sizeof(cpu_set_t) * CxPlatNumaNodeCount, QUIC_POOL_PLATFORM_PROC);\n        CXPLAT_FRE_ASSERT(CxPlatNumaNodeMasks);\n        for (uint32_t n = 0; n < CxPlatNumaNodeCount; ++n) {\n            CPU_ZERO(&CxPlatNumaNodeMasks[n]);\n            CXPLAT_FRE_ASSERT(numa_node_to_cpus_compat((int)n, CxPlatNumaNodeMasks[n].__bits, sizeof(cpu_set_t)) >= 0);\n        }\n    } else {\n        CxPlatNumaNodeCount = 0;\n    }\n#endif \n\n#ifdef DEBUG\n    CxPlatform.AllocFailDenominator = 0;\n    CxPlatform.AllocCounter = 0;\n#endif\n\n    \n    \n    \n    \n\n    \n    \n    \n    \n\n    long ShouldLoad = 1;\n\n    \n    \n    \n    char *DisableValue = getenv(\"QUIC_LTTng\");\n    if (DisableValue != NULL) {\n        ShouldLoad = strtol(DisableValue, NULL, 10);\n    }\n\n    if (!ShouldLoad) {\n        goto Exit;\n    }\n\n    \n    \n    \n    Dl_info Info;\n    int Succeeded = dladdr((void *)CxPlatSystemLoad, &Info);\n    if (!Succeeded) {\n        goto Exit;\n    }\n\n    size_t PathLen = strlen(Info.dli_fname);\n\n    \n    \n    \n    int LastTrailingSlashLen = -1;\n    for (int i = PathLen; i >= 0; i--) {\n        if (Info.dli_fname[i] == '/') {\n            LastTrailingSlashLen = i + 1;\n            break;\n        }\n    }\n\n    if (LastTrailingSlashLen == -1) {\n        goto Exit;\n    }\n\n    size_t TpLibNameLen = strlen(TpLibName);\n    size_t ProviderFullPathLength = TpLibNameLen + LastTrailingSlashLen + 1;\n\n    char* ProviderFullPath = CXPLAT_ALLOC_PAGED(ProviderFullPathLength, QUIC_POOL_PLATFORM_TMP_ALLOC);\n    if (ProviderFullPath == NULL) {\n        goto Exit;\n    }\n\n    CxPlatCopyMemory(ProviderFullPath, Info.dli_fname, LastTrailingSlashLen);\n    CxPlatCopyMemory(ProviderFullPath + LastTrailingSlashLen, TpLibName, TpLibNameLen);\n    ProviderFullPath[LastTrailingSlashLen + TpLibNameLen] = '\\0';\n\n    \n    \n    \n    \n    dlopen(ProviderFullPath, RTLD_NOW | RTLD_GLOBAL);\n\n    CXPLAT_FREE(ProviderFullPath, QUIC_POOL_PLATFORM_TMP_ALLOC);\n\nExit:\n\n    QuicTraceLogInfo(\n        PosixLoaded,\n        \"[ dso] Loaded\");\n", "Selected Statement": "CxPlatform.AllocFailDenominator = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "msquic"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\nuint64_t\nCGroupGetMemoryLimit()\n{\n    uint64_t PhysicalMemoryLimit = 0;\n    uint64_t RestrictedMemoryLimit = 0;\n\n    CGroupInitialize();\n\n    PhysicalMemoryLimit = GetPhysicalMemoryLimit();\n\n", "Selected Statement": "uint64_t PhysicalMemoryLimit = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "msquic"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "#include \"cmsys/FStream.hxx\"\n\ncmXMLParser::cmXMLParser()\n{\n  this->Parser = nullptr;\n  this->ParseError = 0;\n  this->ReportCallback = nullptr;\n  this->ReportCallbackData = nullptr;\n", "Selected Statement": "this->ParseError = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "cmake"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\n\ninline static char* eat_token_end(const char* p, const char* pend)\n{\n\tfor (;(p<pend)&&(*p!=' ')&&(*p!='\\t')&&(*p!='\\n')&&(*p!='\\r'); p++);\n", "Selected Statement": "if (_s->s[i] == '\\\"') quoted = 1;", "Function Input": {"p": {"value": "0x76d25d0 \"%%%%%%%%%%%%pBYE t\""}, "pend": {"value": "0x11076d25d0 <error: Cannot access memory at address 0x11076d25d0>"}}, "Variable Values Before Statement": {"constant": "1"}, "Value After Statement Execution": "1", "Project Information": "opensips"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\nMmsValue*\nMmsValue_createEmptyArray(int size)\n{\n    MmsValue* self = (MmsValue*) GLOBAL_CALLOC(1, sizeof(MmsValue));\n\n    if (self == NULL)\n        goto exit_function;\n\n    self->type = MMS_ARRAY;\n    self->value.structure.size = size;\n    self->value.structure.components = (MmsValue**) GLOBAL_CALLOC(size, sizeof(MmsValue*));\n\n    if (self->value.structure.components == NULL) {\n        GLOBAL_FREEMEM(self);\n        self = NULL;\n        goto exit_function;\n    }\n\n    int i;\n    for (i = 0; i < size; i++) {\n        self->value.structure.components[i] = NULL;\n    }\n\nexit_function:\n", "Selected Statement": "for (i = 0; i < size; i++) {", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libiec61850"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\nAsn1PrimitiveValue*\nAsn1PrimitiveValue_create(int size)\n{\n\tAsn1PrimitiveValue* self = (Asn1PrimitiveValue*) GLOBAL_MALLOC(sizeof(Asn1PrimitiveValue));\n\n\tif (self) {\n\t    self->size = 1;\n\t    self->maxSize = size;\n\n\t    self->octets = (uint8_t*) GLOBAL_CALLOC(1, size);\n\n\t    if (self->octets == NULL) {\n\t        GLOBAL_FREEMEM(self);\n\t        self = NULL;\n\t    }\n\t}\n\n", "Selected Statement": "self->size = 1;", "Function Input": {"self": {"value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x1\n", "message": "Cannot access memory at address 0x1"}}}, "Variable Values Before Statement": {"constant": "1"}, "Value After Statement Execution": "1", "Project Information": "libiec61850"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "int\nsonmp_decode(struct lldpd *cfg, char *frame, int s, struct lldpd_hardware *hardware,\n    struct lldpd_chassis **newchassis, struct lldpd_port **newport)\n{\n\tconst u_int8_t mcastaddr[] = SONMP_MULTICAST_ADDR;\n\tstruct lldpd_chassis *chassis;\n\tstruct lldpd_port *port;\n\tstruct lldpd_mgmt *mgmt;\n\tint length, i;\n\tu_int8_t *pos;\n\tu_int8_t seg[3], rchassis;\n\tstruct in_addr address;\n\n\tlog_debug(\"sonmp\", \"decode SONMP PDU from %s\", hardware->h_ifname);\n\n\tif ((chassis = calloc(1, sizeof(struct lldpd_chassis))) == NULL) {\n\t\tlog_warn(\"sonmp\", \"failed to allocate remote chassis\");\n\t\treturn -1;\n\t}\n\tTAILQ_INIT(&chassis->c_mgmt);\n\tif ((port = calloc(1, sizeof(struct lldpd_port))) == NULL) {\n\t\tlog_warn(\"sonmp\", \"failed to allocate remote port\");\n\t\tfree(chassis);\n\t\treturn -1;\n\t}\n#  ifdef ENABLE_DOT1\n\tTAILQ_INIT(&port->p_vlans);\n#  endif\n\n\tlength = s;\n\tpos = (u_int8_t *)frame;\n\tif (length < SONMP_SIZE + 2 * ETHER_ADDR_LEN + sizeof(u_int16_t)) {\n\t\tlog_warnx(\"sonmp\", \"too short SONMP frame received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tif (PEEK_CMP(mcastaddr, sizeof(mcastaddr)) != 0)\n\t\t\n\t\tgoto malformed;\n\t\n\tPEEK_DISCARD(ETHER_ADDR_LEN);\n\tPEEK_DISCARD_UINT16;\n\tPEEK_DISCARD(6);\n\tif (PEEK_UINT16 != LLC_PID_SONMP_HELLO) {\n\t\tlog_debug(\"sonmp\", \"incorrect LLC protocol ID received for SONMP on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\n\tchassis->c_id_subtype = LLDP_CHASSISID_SUBTYPE_ADDR;\n\tif ((chassis->c_id = calloc(1, sizeof(struct in_addr) + 1)) == NULL) {\n\t\tlog_warn(\"sonmp\", \"unable to allocate memory for chassis id on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tchassis->c_id_len = sizeof(struct in_addr) + 1;\n\tchassis->c_id[0] = 1;\n\tPEEK_BYTES(&address, sizeof(struct in_addr));\n\tmemcpy(chassis->c_id + 1, &address, sizeof(struct in_addr));\n\tif (asprintf(&chassis->c_name, \"%s\", inet_ntoa(address)) == -1) {\n\t\tlog_warnx(\"sonmp\", \"unable to write chassis name for %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tPEEK_BYTES(seg, sizeof(seg));\n\trchassis = PEEK_UINT8;\n\tfor (i = 0; sonmp_chassis_types[i].type != 0; i++) {\n\t\tif (sonmp_chassis_types[i].type == rchassis) break;\n\t}\n\tif (asprintf(&chassis->c_descr, \"%s\", sonmp_chassis_types[i].description) ==\n\t    -1) {\n\t\tlog_warnx(\"sonmp\", \"unable to write chassis description for %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tmgmt = lldpd_alloc_mgmt(LLDPD_AF_IPV4, &address, sizeof(struct in_addr), 0);\n\tif (mgmt == NULL) {\n\t\tif (errno == ENOMEM)\n\t\t\tlog_warn(\"sonmp\",\n\t\t\t    \"unable to allocate memory for management address\");\n\t\telse\n\t\t\tlog_warn(\"sonmp\", \"too large management address received on %s\",\n\t\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tTAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries);\n\tport->p_ttl =\n\t    cfg ? (cfg->g_config.c_tx_interval * cfg->g_config.c_tx_hold) : LLDPD_TTL;\n\tport->p_ttl = (port->p_ttl + 999) / 1000;\n\n\tport->p_id_subtype = LLDP_PORTID_SUBTYPE_LOCAL;\n\n\tport->p_id_len =\n\t    asprintf(&port->p_id, \"%02x-%02x-%02x\", seg[0], seg[1], seg[2]);\n\tif (port->p_id_len == -1) {\n\t\tlog_warn(\"sonmp\", \"unable to allocate memory for port id on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\n\t\n\tif ((seg[0] == 0) && (seg[1] == 0)) {\n\t\tif (asprintf(&port->p_descr, \"port %d\", seg[2]) == -1) {\n\t\t\tlog_warnx(\"sonmp\", \"unable to write port description for %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t} else if (seg[0] == 0) {\n\t\tif (asprintf(&port->p_descr, \"port %d/%d\", seg[1], seg[2]) == -1) {\n\t\t\tlog_warnx(\"sonmp\", \"unable to write port description for %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t} else {\n\t\tif (asprintf(&port->p_descr, \"port %x:%x:%x\", seg[0], seg[1], seg[2]) ==\n\t\t    -1) {\n\t\t\tlog_warnx(\"sonmp\", \"unable to write port description for %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t}\n\t*newchassis = chassis;\n\t*newport = port;\n\treturn 1;\n\nmalformed:\n\tlldpd_chassis_cleanup(chassis, 1);\n\tlldpd_port_cleanup(port, 1);\n\tfree(port);\n\treturn -1;\n", "Selected Statement": "chassis->c_id[0] = 1;", "Function Input": {"hardware": {"value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x18\n", "message": "Cannot access memory at address 0x18"}}}, "Variable Values Before Statement": {"constant": "1"}, "Value After Statement Execution": "1", "Project Information": "lldpd"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "   are not refreshed periodically. Port should be freed manually. */\nvoid\nlldpd_port_cleanup(struct lldpd_port *port, int all)\n{\n#ifdef ENABLE_LLDPMED\n\tint i;\n\tif (all)\n\t\tfor (i = 0; i < LLDP_MED_LOCFORMAT_LAST; i++)\n\t\t\tfree(port->p_med_location[i].data);\n#endif\n#ifdef ENABLE_DOT1\n\tlldpd_vlan_cleanup(port);\n\tlldpd_ppvid_cleanup(port);\n\tlldpd_pi_cleanup(port);\n#endif\n\t\n\n\tif (all) {\n\t\tfree(port->p_id);\n\t\tport->p_id = NULL;\n\t\tfree(port->p_descr);\n\t\tport->p_descr = NULL;\n\t\tfree(port->p_lastframe);\n\t\tif (port->p_chassis) { \n\t\t\tport->p_chassis->c_refcount--;\n\t\t\tport->p_chassis = NULL;\n\t\t}\n#ifdef ENABLE_CUSTOM\n\t\tlldpd_custom_list_cleanup(port);\n#endif\n\t}\n", "Selected Statement": "for (i = 0; i < LLDP_MED_LOCFORMAT_LAST; i++)", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "lldpd"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\t\t\t\t\tconst_hashtab_key_t key1,\n\t\t\t\t\tconst_hashtab_key_t key2),\n\t\t\t unsigned int size)\n{\n\n\thashtab_t p;\n\n\tp = (hashtab_t) malloc(sizeof(hashtab_val_t));\n\tif (p == NULL)\n\t\treturn p;\n\n\tmemset(p, 0, sizeof(hashtab_val_t));\n\tp->size = size;\n\tp->nel = 0;\n\tp->hash_value = hash_value;\n\tp->keycmp = keycmp;\n\tp->htable = (hashtab_ptr_t *) calloc(size, sizeof(hashtab_ptr_t));\n\tif (p->htable == NULL) {\n\t\tfree(p);\n\t\treturn NULL;\n\t}\n\n\treturn p;\n", "Selected Statement": "p->nel = 0;", "Function Input": {"size": {"value": "32767"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "selinux"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "}\n\nint symtab_init(symtab_t * s, unsigned int size)\n{\n\ts->table = hashtab_create(symhash, symcmp, size);\n\tif (!s->table)\n\t\treturn -1;\n\ts->nprim = 0;\n\treturn 0;\n", "Selected Statement": "s->nprim = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "selinux"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": " * Initialize a policy database structure.\n */\nint policydb_init(policydb_t * p)\n{\n\tint i, rc;\n\n\tmemset(p, 0, sizeof(policydb_t));\n\n\tfor (i = 0; i < SYM_NUM; i++) {\n\t\tp->sym_val_to_name[i] = NULL;\n\t\trc = symtab_init(&p->symtab[i], symtab_sizes[i]);\n\t\tif (rc)\n\t\t\tgoto err;\n\t}\n\n\t\n\tfor (i = 0; i < SYM_NUM; i++) {\n\t\tif (symtab_init(&p->scope[i], symtab_sizes[i])) {\n\t\t\tgoto err;\n\t\t}\n\t}\n\tif ((p->global = avrule_block_create()) == NULL ||\n\t    (p->global->branch_list = avrule_decl_create(1)) == NULL) {\n\t\tgoto err;\n\t}\n\tp->decl_val_to_struct = NULL;\n\n\trc = avtab_init(&p->te_avtab);\n\tif (rc)\n\t\tgoto err;\n\n\trc = roles_init(p);\n\tif (rc)\n\t\tgoto err;\n\n\trc = cond_policydb_init(p);\n\tif (rc)\n\t\tgoto err;\n\n\tp->filename_trans = hashtab_create(filenametr_hash, filenametr_cmp, (1 << 10));\n\tif (!p->filename_trans) {\n\t\trc = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tp->range_tr = hashtab_create(rangetr_hash, rangetr_cmp, 256);\n\tif (!p->range_tr) {\n\t\trc = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tebitmap_init(&p->policycaps);\n\tebitmap_init(&p->permissive_map);\n\n\treturn 0;\nerr:\n\thashtab_destroy(p->filename_trans);\n\thashtab_destroy(p->range_tr);\n\tfor (i = 0; i < SYM_NUM; i++) {\n\t\thashtab_destroy(p->symtab[i].table);\n\t\thashtab_destroy(p->scope[i].table);\n\t}\n\tavrule_block_list_destroy(p->global);\n\treturn rc;\n", "Selected Statement": "for (i = 0; i < SYM_NUM; i++) {", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "selinux"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "}\n\nint avtab_init(avtab_t * h)\n{\n\th->htable = NULL;\n\th->nel = 0;\n", "Selected Statement": "h->nel = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "selinux"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": " * NULL then this function will create a new array (*cnt is reset to\n * 0).  Return 0 on success, -1 on out of memory. */\nint add_i_to_a(uint32_t i, uint32_t * cnt, uint32_t ** a)\n{\n\tuint32_t *new;\n\n\tif (cnt == NULL || *cnt == UINT32_MAX || a == NULL)\n\t\treturn -1;\n\n\t\n\tif (*a != NULL)\n\t\tnew = (uint32_t *) reallocarray(*a, *cnt + 1, sizeof(uint32_t));\n\telse {\t\t\t\n\n\t\t*cnt = 0;\n\t\tnew = (uint32_t *) malloc(sizeof(uint32_t));\n\t}\n\tif (new == NULL) {\n\t\treturn -1;\n\t}\n\tnew[*cnt] = i;\n\t(*cnt)++;\n\t*a = new;\n\treturn 0;\n", "Selected Statement": "*cnt = 0;", "Function Input": {"a": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x10a7570", "value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x725f7463656a626f\n", "message": "Cannot access memory at address 0x725f7463656a626f"}}}, "cnt": {"value": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "17455024"}}, "i": {"value": "4294956832"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "selinux"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "}\n\nvoid set_source_file(const char *name)\n{\n\tsource_lineno = 1;\n\tstrncpy(source_file, name, sizeof(source_file)-1); \n\tsource_file[sizeof(source_file)-1] = '\\0';\n\tif (strlen(source_file) && source_file[strlen(source_file)-1] == '\"')\n\t\tsource_file[strlen(source_file)-1] = '\\0';\n", "Selected Statement": "source_lineno = 1;", "Function Input": {}, "Variable Values Before Statement": {"constant": "1"}, "Value After Statement Execution": "1", "Project Information": "selinux"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\n\nvoid init_parser(int pass_number)\n{\n\tpolicydb_lineno = 1;\n\tsource_lineno = 1;\n\tpolicydb_errors = 0;\n\tpass = pass_number;\n", "Selected Statement": "source_lineno = 1;", "Function Input": {"pass_number": {"value": "0"}}, "Variable Values Before Statement": {"constant": "1"}, "Value After Statement Execution": "1", "Project Information": "selinux"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "}\n\nvoid sepol_sidtab_destroy(sidtab_t * s)\n{\n\tint i;\n\tsidtab_ptr_t cur, temp;\n\n\tif (!s || !s->htable)\n\t\treturn;\n\n\tfor (i = 0; i < SIDTAB_SIZE; i++) {\n\t\tcur = s->htable[i];\n\t\twhile (cur != NULL) {\n\t\t\ttemp = cur;\n\t\t\tcur = cur->next;\n\t\t\tcontext_destroy(&temp->context);\n\t\t\tfree(temp);\n\t\t}\n\t\ts->htable[i] = NULL;\n\t}\n\tfree(s->htable);\n\ts->htable = NULL;\n\ts->nel = 0;\n\ts->next_sid = 1;\n", "Selected Statement": "s->next_sid = 1;", "Function Input": {"s": {"value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xffffffff00000000\n", "message": "Cannot access memory at address 0xffffffff00000000"}}}, "Variable Values Before Statement": {"constant": "1"}, "Value After Statement Execution": "1", "Project Information": "selinux"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "}\n\nvoid ebitmap_destroy(ebitmap_t * e)\n{\n\tebitmap_node_t *n, *temp;\n\n\tif (!e)\n\t\treturn;\n\n\tn = e->node;\n\twhile (n) {\n\t\ttemp = n;\n\t\tn = n->next;\n\t\tfree(temp);\n\t}\n\n\te->highbit = 0;\n\te->node = 0;\n\treturn;\n", "Selected Statement": "e->highbit = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "selinux"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\nvoid module_compiler_reset(void)\n{\n\twhile (stack_top)\n\t\tpop_stack();\n\n\tlast_block = NULL;\n\tnext_decl_id = 1;\n", "Selected Statement": "next_decl_id = 1;", "Function Input": {}, "Variable Values Before Statement": {"constant": "1"}, "Value After Statement Execution": "1", "Project Information": "selinux"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": " *\n */\nint shm_address_in(void *p)\n{\n\tint i;\n\n\tfor(i = 0; i < _shm_core_pools_num; i++) {\n\t\tif(_shm_core_pools_mem[i] == (void *)-1) {\n\t\t\tcontinue;\n\t\t}\n\t\tif(((char *)p >= (char *)_shm_core_pools_mem[i])\n\t\t\t\t&& ((char *)p\n\t\t\t\t\t\t< ((char *)_shm_core_pools_mem[i]) + shm_mem_size)) {\n\t\t\t\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t\n\treturn 0;\n", "Selected Statement": "for(i = 0; i < _shm_core_pools_num; i++) {", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "kamailio"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "      int error_code,\n      const char *,\n      format_string )\n{\n\tva_list argument_list;\n\n\tlibcerror_internal_error_t *internal_error = NULL;\n\tsystem_character_t *error_string           = NULL;\n\tsystem_character_t *system_format_string   = NULL;\n\tvoid *reallocation                         = NULL;\n\tsize_t error_string_size                   = 0;\n\tsize_t format_string_length                = 0;\n\tsize_t message_size                        = 0;\n\tsize_t next_message_size                   = LIBCERROR_MESSAGE_INCREMENT_SIZE;\n\tint message_index                          = 0;\n\tint print_count                            = 0;\n\n\tif( error == NULL )\n\t{\n\t\treturn;\n\t}\n\tif( format_string == NULL )\n\t{\n\t\treturn;\n\t}\n\tformat_string_length = narrow_string_length(\n\t                        format_string );\n\n#if defined( HAVE_WIDE_SYSTEM_CHARACTER )\n\tlibcerror_error_get_system_format_string(\n\t format_string,\n\t format_string_length,\n\t &system_format_string );\n\n\tif( system_format_string == NULL )\n\t{\n\t\treturn;\n\t}\n#else\n\tsystem_format_string = (system_character_t *) format_string;\n#endif\n\tif( *error == NULL )\n\t{\n\t\tif( libcerror_error_initialize(\n\t\t     error,\n\t\t     error_domain,\n\t\t     error_code ) != 1 )\n\t\t{\n\t\t\tgoto on_error;\n\t\t}\n\t}\n\tinternal_error = (libcerror_internal_error_t *) *error;\n\n\tif( libcerror_error_resize(\n\t     internal_error ) != 1 )\n\t{\n\t\tgoto on_error;\n\t}\n\tif( format_string_length > next_message_size )\n\t{\n\t\tnext_message_size = ( ( format_string_length / LIBCERROR_MESSAGE_INCREMENT_SIZE ) + 1 )\n\t\t                  * LIBCERROR_MESSAGE_INCREMENT_SIZE;\n\t}\n\tdo\n\t{\n\t\tif( next_message_size >= LIBCERROR_MESSAGE_MAXIMUM_SIZE )\n\t\t{\n\t\t\tnext_message_size = LIBCERROR_MESSAGE_MAXIMUM_SIZE;\n\t\t}\n\t\treallocation = memory_reallocate(\n\t\t                error_string,\n\t\t                sizeof( system_character_t ) * next_message_size );\n\n\t\tif( reallocation == NULL )\n\t\t{\n\t\t\tmemory_free(\n\t\t\t error_string );\n\n\t\t\tgoto on_error;\n\t\t}\n\t\terror_string = (system_character_t *) reallocation;\n\n\t\tmessage_size = next_message_size;\n\n\t\t\n\t\tVASTART(\n\t\t argument_list,\n\t\t const char *,\n\t\t format_string );\n\n\t\tprint_count = system_string_vsnprintf(\n\t\t               error_string,\n\t\t               message_size,\n\t\t               system_format_string,\n\t\t               argument_list );\n\n\t\tVAEND(\n\t\t argument_list );\n\n\t\tif( print_count <= -1 )\n\t\t{\n\t\t\tnext_message_size += LIBCERROR_MESSAGE_INCREMENT_SIZE;\n\t\t}\n\t\telse if( ( (size_t) print_count >= message_size )\n\t\t      || ( error_string[ print_count ] != (system_character_t) 0 ) )\n\t\t{\n\t\t\tnext_message_size = (size_t) ( print_count + 1 );\n\t\t\tprint_count       = -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\terror_string_size = (size_t) print_count + 1;\n\t\t}\n\t\tif( message_size >= LIBCERROR_MESSAGE_MAXIMUM_SIZE )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\twhile( print_count <= -1 );\n\n\tif( message_size >= LIBCERROR_MESSAGE_MAXIMUM_SIZE )\n\t{\n\t\terror_string[ LIBCERROR_MESSAGE_MAXIMUM_SIZE - 4 ] = (system_character_t) '.';\n\t\terror_string[ LIBCERROR_MESSAGE_MAXIMUM_SIZE - 3 ] = (system_character_t) '.';\n\t\terror_string[ LIBCERROR_MESSAGE_MAXIMUM_SIZE - 2 ] = (system_character_t) '.';\n\t\terror_string[ LIBCERROR_MESSAGE_MAXIMUM_SIZE - 1 ] = 0;\n\t\terror_string_size                                  = (size_t) LIBCERROR_MESSAGE_MAXIMUM_SIZE;\n\t}\n\tmessage_index = internal_error->number_of_messages - 1;\n\n\tinternal_error->messages[ message_index ] = error_string;\n\tinternal_error->sizes[ message_index ]    = error_string_size;\n\n#if defined( HAVE_WIDE_SYSTEM_CHARACTER )\n\tmemory_free(\n\t system_format_string );\n\n\tsystem_format_string = NULL;\n#endif\n\treturn;\n\non_error:\n#if defined( HAVE_WIDE_SYSTEM_CHARACTER )\n\tif( system_format_string != NULL )\n\t{\n\t\tmemory_free(\n\t\t system_format_string );\n\t}\n#endif\n\treturn;\n", "Selected Statement": "int message_index                          = 0;", "Function Input": {"error": {"value": null}, "error_code": {"value": "5"}, "error_domain": {"value": "97"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "int LLVMFuzzerTestOneInput(\n     const uint8_t *data,\n     size_t size )\n{\n\tuint8_t string_value[ 64 ];\n\n\tlibbfio_handle_t *file_io_handle       = NULL;\n\tlibfsapfs_container_t *container       = NULL;\n\tlibfsapfs_file_entry_t *root_directory = NULL;\n\tlibfsapfs_file_entry_t *sub_file_entry = NULL;\n\tlibfsapfs_volume_t *volume             = NULL;\n\tsize64_t file_size                     = 0;\n\tsize_t string_size                     = 0;\n\toff64_t file_offset                    = 0;\n\tuint64_t value_64bit                   = 0;\n\tint64_t posix_time                     = 0;\n\tuint32_t major_device_number           = 0;\n\tuint32_t minor_device_number           = 0;\n\tuint32_t value_32bit                   = 0;\n\tuint16_t value_16bit                   = 0;\n\tint number_of_extents                  = 0;\n\tint number_of_sub_file_entries         = 0;\n\tint number_of_volumes                  = 0;\n\tint result                             = 0;\n\n\tif( libbfio_memory_range_initialize(\n\t     &file_io_handle,\n\t     NULL ) != 1 )\n\t{\n\t\treturn( 0 );\n\t}\n\tif( libbfio_memory_range_set(\n\t     file_io_handle,\n\t     (uint8_t *) data,\n\t     size,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libbfio;\n\t}\n\tif( libfsapfs_container_initialize(\n\t     &container,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libbfio;\n\t}\n\tif( libfsapfs_container_open_file_io_handle(\n\t     container,\n\t     file_io_handle,\n\t     LIBFSAPFS_OPEN_READ,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libfsapfs_container;\n\t}\n\tif( libfsapfs_container_get_number_of_volumes(\n\t     container,\n\t     &number_of_volumes,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libfsapfs_container;\n\t}\n\tif( number_of_volumes > 0 )\n\t{\n\t\tif( libfsapfs_container_get_volume_by_index(\n\t\t     container,\n\t\t     0,\n\t\t     &volume,\n\t\t     NULL ) != 1 )\n\t\t{\n\t\t\tgoto on_error_libfsapfs_container;\n\t\t}\n\t\tif( libfsapfs_volume_get_root_directory(\n\t\t     volume,\n\t\t     &root_directory,\n\t\t     NULL ) == 1 )\n\t\t{\n\t\t\tif( libfsapfs_file_entry_get_number_of_sub_file_entries(\n\t\t\t     root_directory,\n\t\t\t     &number_of_sub_file_entries,\n\t\t\t     NULL ) != 1 )\n\t\t\t{\n\t\t\t\tgoto on_error_libfsapfs_root_directory;\n\t\t\t}\n\t\t\tif( number_of_sub_file_entries > 0 )\n\t\t\t{\n\t\t\t\tresult = libfsapfs_file_entry_get_sub_file_entry_by_index(\n\t\t\t\t          root_directory,\n\t\t\t\t          0,\n\t\t\t\t          &sub_file_entry,\n\t\t\t\t          NULL );\n\n\t\t\t\tif( result != -1 )\n\t\t\t\t{\n\t\t\t\t\tlibfsapfs_file_entry_get_identifier(\n\t\t\t\t\t sub_file_entry,\n\t\t\t\t\t &value_64bit,\n\t\t\t\t\t NULL );\n\n\t\t\t\t\tlibfsapfs_file_entry_get_parent_identifier(\n\t\t\t\t\t sub_file_entry,\n\t\t\t\t\t &value_64bit,\n\t\t\t\t\t NULL );\n\n\t\t\t\t\tlibfsapfs_file_entry_get_creation_time(\n\t\t\t\t\t sub_file_entry,\n\t\t\t\t\t &posix_time,\n\t\t\t\t\t NULL );\n\n\t\t\t\t\tlibfsapfs_file_entry_get_modification_time(\n\t\t\t\t\t sub_file_entry,\n\t\t\t\t\t &posix_time,\n\t\t\t\t\t NULL );\n\n\t\t\t\t\tlibfsapfs_file_entry_get_access_time(\n\t\t\t\t\t sub_file_entry,\n\t\t\t\t\t &posix_time,\n\t\t\t\t\t NULL );\n\n\t\t\t\t\tlibfsapfs_file_entry_get_inode_change_time(\n\t\t\t\t\t sub_file_entry,\n\t\t\t\t\t &posix_time,\n\t\t\t\t\t NULL );\n\n\t\t\t\t\tlibfsapfs_file_entry_get_added_time(\n\t\t\t\t\t sub_file_entry,\n\t\t\t\t\t &posix_time,\n\t\t\t\t\t NULL );\n\n\t\t\t\t\tlibfsapfs_file_entry_get_file_mode(\n\t\t\t\t\t sub_file_entry,\n\t\t\t\t\t &value_16bit,\n\t\t\t\t\t NULL );\n\n\t\t\t\t\tlibfsapfs_file_entry_get_number_of_links(\n\t\t\t\t\t sub_file_entry,\n\t\t\t\t\t &value_32bit,\n\t\t\t\t\t NULL );\n\n\t\t\t\t\tlibfsapfs_file_entry_get_owner_identifier(\n\t\t\t\t\t sub_file_entry,\n\t\t\t\t\t &value_32bit,\n\t\t\t\t\t NULL );\n\n\t\t\t\t\tlibfsapfs_file_entry_get_group_identifier(\n\t\t\t\t\t sub_file_entry,\n\t\t\t\t\t &value_32bit,\n\t\t\t\t\t NULL );\n\n\t\t\t\t\tlibfsapfs_file_entry_get_device_identifier(\n\t\t\t\t\t sub_file_entry,\n\t\t\t\t\t &value_32bit,\n\t\t\t\t\t NULL );\n\n\t\t\t\t\tlibfsapfs_file_entry_get_device_number(\n\t\t\t\t\t sub_file_entry,\n\t\t\t\t\t &major_device_number,\n\t\t\t\t\t &minor_device_number,\n\t\t\t\t\t NULL );\n\n\t\t\t\t\tlibfsapfs_file_entry_get_utf8_name_size(\n\t\t\t\t\t sub_file_entry,\n\t\t\t\t\t &string_size,\n\t\t\t\t\t NULL );\n\n\t\t\t\t\tlibfsapfs_file_entry_get_utf8_name(\n\t\t\t\t\t sub_file_entry,\n\t\t\t\t\t string_value,\n\t\t\t\t\t 64,\n\t\t\t\t\t NULL );\n\n\t\t\t\t\tlibfsapfs_file_entry_get_utf8_symbolic_link_target_size(\n\t\t\t\t\t sub_file_entry,\n\t\t\t\t\t &string_size,\n\t\t\t\t\t NULL );\n\n\t\t\t\t\tlibfsapfs_file_entry_get_utf8_symbolic_link_target(\n\t\t\t\t\t sub_file_entry,\n\t\t\t\t\t string_value,\n\t\t\t\t\t 64,\n\t\t\t\t\t NULL );\n\n\t\t\t\t\tlibfsapfs_file_entry_get_offset(\n\t\t\t\t\t sub_file_entry,\n\t\t\t\t\t &file_offset,\n\t\t\t\t\t NULL );\n\n\t\t\t\t\tlibfsapfs_file_entry_get_size(\n\t\t\t\t\t sub_file_entry,\n\t\t\t\t\t &file_size,\n\t\t\t\t\t NULL );\n\n\t\t\t\t\tlibfsapfs_file_entry_get_number_of_extents(\n\t\t\t\t\t sub_file_entry,\n\t\t\t\t\t &number_of_extents,\n\t\t\t\t\t NULL );\n\t\t\t\t}\n\t\t\t\tlibfsapfs_file_entry_free(\n\t\t\t\t &sub_file_entry,\n\t\t\t\t NULL );\n\t\t\t}\non_error_libfsapfs_root_directory:\n\t\t\tlibfsapfs_file_entry_free(\n\t\t\t &root_directory,\n\t\t\t NULL );\n\t\t}\n\t\tlibfsapfs_volume_free(\n\t\t &volume,\n\t\t NULL );\n\t}\non_error_libfsapfs_container:\n\tlibfsapfs_container_free(\n\t &container,\n\t NULL );\n\non_error_libbfio:\n\tlibbfio_handle_free(\n\t &file_io_handle,\n\t NULL );\n\n\treturn( 0 );\n", "Selected Statement": "uint32_t minor_device_number           = 0;", "Function Input": {"data": {"value": "0x1125a00 \"\\005\""}, "size": {"value": "7513600"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "int libfsapfs_io_handle_initialize(\n     libfsapfs_io_handle_t **io_handle,\n     libcerror_error_t **error )\n{\n\tstatic char *function = \"libfsapfs_io_handle_initialize\";\n\n\tif( io_handle == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid IO handle.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *io_handle != NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\n\t\t \"%s: invalid IO handle value already set.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\t*io_handle = memory_allocate_structure(\n\t              libfsapfs_io_handle_t );\n\n\tif( *io_handle == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create IO handle.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     *io_handle,\n\t     0,\n\t     sizeof( libfsapfs_io_handle_t ) ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear IO handle.\",\n\t\t function );\n\n\t\tmemory_free(\n\t\t *io_handle );\n\n\t\t*io_handle = NULL;\n\n\t\treturn( -1 );\n\t}\n#if defined( HAVE_PROFILER )\n\tif( libfsapfs_profiler_initialize(\n\t     &( ( *io_handle )->profiler ),\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to initialize profiler.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( libfsapfs_profiler_open(\n\t     ( *io_handle )->profiler,\n\t     \"profiler.csv\",\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_IO,\n\t\t LIBCERROR_IO_ERROR_OPEN_FAILED,\n\t\t \"%s: unable to open profiler.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n#endif \n\n\t( *io_handle )->bytes_per_sector = 512;\n\t( *io_handle )->block_size       = 4096;\n\n\treturn( 1 );\n\non_error:\n\tif( *io_handle != NULL )\n\t{\n#if defined( HAVE_PROFILER )\n\t\tif( ( *io_handle )->profiler != NULL )\n\t\t{\n\t\t\tlibfsapfs_profiler_free(\n\t\t\t &( ( *io_handle )->profiler ),\n\t\t\t NULL );\n\t\t}\n#endif\n\t\tmemory_free(\n\t\t *io_handle );\n\n\t\t*io_handle = NULL;\n\t}\n\treturn( -1 );\n", "Selected Statement": "( *io_handle )->bytes_per_sector = 512;", "Function Input": {"error": {"value": {"type_category": "pointer", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x1004c73e0\n", "message": "Cannot access memory at address 0x1004c73e0"}}, "io_handle": {"value": {"type_category": "pointer", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x11\n", "message": "Cannot access memory at address 0x11"}}}, "Variable Values Before Statement": {"constant": "512"}, "Value After Statement Execution": "512", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "int LLVMFuzzerTestOneInput(\n     const uint8_t *data,\n     size_t size )\n{\n\tuint8_t string_value[ 64 ];\n\n\tlibbfio_handle_t *file_io_handle = NULL;\n\tlibfshfs_volume_t *volume        = NULL;\n\tsize_t string_size               = 0;\n\tint result                       = 0;\n\n\tif( libbfio_memory_range_initialize(\n\t     &file_io_handle,\n\t     NULL ) != 1 )\n\t{\n\t\treturn( 0 );\n\t}\n\tif( libbfio_memory_range_set(\n\t     file_io_handle,\n\t     (uint8_t *) data,\n\t     size,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libbfio;\n\t}\n\tif( libfshfs_volume_initialize(\n\t     &volume,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libbfio;\n\t}\n\tresult = libfshfs_volume_open_file_io_handle(\n\t          volume,\n\t          file_io_handle,\n\t          LIBFSHFS_OPEN_READ,\n\t          NULL );\n\n\tif( result != -1 )\n\t{\n\t\tlibfshfs_volume_get_utf8_name_size(\n\t\t volume,\n\t\t &string_size,\n\t\t NULL );\n\n\t\tlibfshfs_volume_get_utf8_name(\n\t\t volume,\n\t\t string_value,\n\t\t 64,\n\t\t NULL );\n\n\t\tlibfshfs_volume_close(\n\t\t volume,\n\t\t NULL );\n\t}\n\tlibfshfs_volume_free(\n\t &volume,\n\t NULL );\n\non_error_libbfio:\n\tlibbfio_handle_free(\n\t &file_io_handle,\n\t NULL );\n\n\treturn( 0 );\n", "Selected Statement": "size_t string_size               = 0;", "Function Input": {"data": {"value": "0x10f0980 \"\""}, "size": {"value": "7241216"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "     const uint8_t *data,\n     size_t data_size,\n     libcerror_error_t **error )\n{\n\tstatic char *function                 = \"libfshfs_extents_record_read_data\";\n\tsize_t data_offset                    = 0;\n\tuint32_t physical_extent_block_number = 0;\n\tuint16_t extent_block_number          = 0;\n\tuint16_t extent_number_of_blocks      = 0;\n\tint extent_index                      = 0;\n\n\tif( fork_descriptor == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid fork descriptor.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( data == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_MISSING,\n\t\t \"%s: invalid data.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( data_size > (size_t) SSIZE_MAX )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: invalid data size value out of bounds.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n#if defined( HAVE_DEBUG_OUTPUT )\n\tif( libcnotify_verbose != 0 )\n\t{\n\t\tlibcnotify_printf(\n\t\t \"%s: extents records data:\\n\",\n\t\t function );\n\t\tlibcnotify_print_data(\n\t\t data,\n\t\t data_size,\n\t\t LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA );\n\t}\n#endif\n\tif( data_size != 12 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_UNSUPPORTED_VALUE,\n\t\t \"%s: unsupported extents record data size: %\" PRIzd \"\\n\",\n\t\t function,\n\t\t data_size );\n\n\t\treturn( -1 );\n\t}\n\twhile( data_offset < 12 )\n\t{\n\t\tbyte_stream_copy_to_uint16_big_endian(\n\t\t &( data[ data_offset ] ),\n\t\t extent_block_number );\n\n\t\tdata_offset += 2;\n\n\t\tbyte_stream_copy_to_uint16_big_endian(\n\t\t &( data[ data_offset ] ),\n\t\t extent_number_of_blocks );\n\n\t\tdata_offset += 2;\n\n\t\tphysical_extent_block_number = extent_block_number;\n\n\t\tif( extent_number_of_blocks > 0 )\n\t\t{\n\t\t\tphysical_extent_block_number += extents_start_block_number;\n\t\t}\n#if defined( HAVE_DEBUG_OUTPUT )\n\t\tif( libcnotify_verbose != 0 )\n\t\t{\n\t\t\tlibcnotify_printf(\n\t\t\t \"%s: extent: %d block number\\t\\t: %\" PRIu32 \" (%\" PRIu16 \")\\n\",\n\t\t\t function,\n\t\t\t extent_index,\n\t\t\t physical_extent_block_number,\n\t\t\t extent_block_number );\n\n\t\t\tlibcnotify_printf(\n\t\t\t \"%s: extent: %d number of blocks\\t\\t: %\" PRIu16 \"\\n\",\n\t\t\t function,\n\t\t\t extent_index,\n\t\t\t extent_number_of_blocks );\n\t\t}\n#endif \n\n\t\tfork_descriptor->extents[ extent_index ][ 0 ] = physical_extent_block_number;\n\t\tfork_descriptor->extents[ extent_index ][ 1 ] = extent_number_of_blocks;\n\n\t\tfork_descriptor->number_of_blocks_in_extents += extent_number_of_blocks;\n\n\t\textent_index++;\n\t}\n#if defined( HAVE_DEBUG_OUTPUT )\n\tif( libcnotify_verbose != 0 )\n\t{\n\t\tlibcnotify_printf(\n\t\t \"\\n\" );\n\t}\n#endif\n\treturn( 1 );\n", "Selected Statement": "static char *function                 = \"libfshfs_extents_record_read_data\";", "Function Input": {"data": {"value": "0x600 <error: Cannot access memory at address 0x600>"}, "data_size": {"value": "4809124"}, "error": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd8e0", "value": {"type_category": "unknown", "concrete_type": "libcerror_error_t", "value": "140737488346128"}}}, "extents_start_block_number": {"value": "0"}, "fork_descriptor": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"size": {"type_category": "unknown", "concrete_type": "uint64_t", "value": "0"}, "number_of_blocks": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, "extents": {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}]}, "number_of_blocks_in_extents": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}}}, "Variable Values Before Statement": {"constant": "\"libfshfs_extents_record_read_data\""}, "Value After Statement Execution": "\"libfshfs_extents_record_read_data\"", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "int LLVMFuzzerTestOneInput(\n     const uint8_t *data,\n     size_t size )\n{\n\tlibbfio_handle_t *file_io_handle                  = NULL;\n\tlibfsxfs_extended_attribute_t *extended_attribute = NULL;\n\tlibfsxfs_file_entry_t *file_entry                 = NULL;\n\tlibfsxfs_volume_t *volume                         = NULL;\n\tint number_of_extended_attributes                 = 0;\n\tint result                                        = 0;\n\n\tif( libbfio_memory_range_initialize(\n\t     &file_io_handle,\n\t     NULL ) != 1 )\n\t{\n\t\treturn( 0 );\n\t}\n\tif( libbfio_memory_range_set(\n\t     file_io_handle,\n\t     (uint8_t *) data,\n\t     size,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libbfio;\n\t}\n\tif( libfsxfs_volume_initialize(\n\t     &volume,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libbfio;\n\t}\n\tif( libfsxfs_volume_open_file_io_handle(\n\t     volume,\n\t     file_io_handle,\n\t     LIBFSXFS_OPEN_READ,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libfsxfs_volume;\n\t}\n\tresult = libfsxfs_volume_get_file_entry_by_utf8_path(\n\t          volume,\n\t          (uint8_t *) \"/a_directory/a_file\",\n\t          19,\n\t          &file_entry,\n\t          NULL );\n\n\tif( result == 1 )\n\t{\n\t\tif( libfsxfs_file_entry_get_number_of_extended_attributes(\n\t\t     file_entry,\n\t\t     &number_of_extended_attributes,\n\t\t     NULL ) != 1 )\n\t\t{\n\t\t\tgoto on_error_libfsxfs_file_entry;\n\t\t}\n\t\tif( number_of_extended_attributes > 0 )\n\t\t{\n\t\t\tif( libfsxfs_file_entry_get_extended_attribute_by_index(\n\t\t\t     file_entry,\n\t\t\t     0,\n\t\t\t     &extended_attribute,\n\t\t\t     NULL ) != 1 )\n\t\t\t{\n\t\t\t\tgoto on_error_libfsxfs_file_entry;\n\t\t\t}\n\t\t\tlibfsxfs_extended_attribute_free(\n\t\t\t &extended_attribute,\n\t\t\t NULL );\n\t\t}\non_error_libfsxfs_file_entry:\n\t\tlibfsxfs_file_entry_free(\n\t\t &file_entry,\n\t\t NULL );\n\t}\n\tlibfsxfs_volume_close(\n\t volume,\n\t NULL );\n\non_error_libfsxfs_volume:\n\tlibfsxfs_volume_free(\n\t &volume,\n\t NULL );\n\non_error_libbfio:\n\tlibbfio_handle_free(\n\t &file_io_handle,\n\t NULL );\n\n\treturn( 0 );\n", "Selected Statement": "int number_of_extended_attributes                 = 0;", "Function Input": {"data": {"value": "0x108c440 \"XFSB\""}, "size": {"value": "6899712"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "     libcdata_array_t **array,\n     int number_of_entries,\n     libcerror_error_t **error )\n{\n\tlibcdata_internal_array_t *internal_array = NULL;\n\tstatic char *function                     = \"libcdata_array_initialize\";\n\tsize_t entries_size                       = 0;\n\tint number_of_allocated_entries           = 0;\n\n\tif( array == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid array.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *array != NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\n\t\t \"%s: invalid array value already set.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( number_of_entries < 0 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_LESS_THAN_ZERO,\n\t\t \"%s: invalid number of entries value less than zero.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tinternal_array = memory_allocate_structure(\n\t                  libcdata_internal_array_t );\n\n\tif( internal_array == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create array.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     internal_array,\n\t     0,\n\t     sizeof( libcdata_internal_array_t ) ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear array.\",\n\t\t function );\n\n\t\tmemory_free(\n\t\t internal_array );\n\n\t\treturn( -1 );\n\t}\n\t\n\tif( number_of_entries >= (int) ( INT_MAX - 16 ) )\n\t{\n\t\tnumber_of_allocated_entries = INT_MAX;\n\t}\n\telse\n\t{\n\t\tnumber_of_allocated_entries = ( number_of_entries & ~( 15 ) ) + 16;\n\t}\n#if SIZEOF_INT <= SIZEOF_SIZE_T\n\tif( (size_t) number_of_allocated_entries > (size_t) ( SSIZE_MAX / sizeof( intptr_t * ) ) )\n#else\n\tif( number_of_allocated_entries > (int) ( SSIZE_MAX / sizeof( intptr_t * ) ) )\n#endif\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_EXCEEDS_MAXIMUM,\n\t\t \"%s: invalid number of allocated entries value exceeds maximum.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tentries_size = sizeof( intptr_t * ) * number_of_allocated_entries;\n\n\tif( entries_size > (size_t) LIBCDATA_ARRAY_ENTRIES_MEMORY_LIMIT )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_EXCEEDS_MAXIMUM,\n\t\t \"%s: invalid entries size value exceeds maximum.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tinternal_array->entries = (intptr_t **) memory_allocate(\n\t                                         entries_size );\n\n\tif( internal_array->entries == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create array entries.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     internal_array->entries,\n\t     0,\n\t     entries_size ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear array entries.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tinternal_array->number_of_allocated_entries = number_of_allocated_entries;\n\tinternal_array->number_of_entries           = number_of_entries;\n\n#if defined( HAVE_MULTI_THREAD_SUPPORT ) && !defined( HAVE_LOCAL_LIBCDATA )\n\tif( libcthreads_read_write_lock_initialize(\n\t     &( internal_array->read_write_lock ),\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to initialize read/write lock.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n#endif\n\t*array = (libcdata_array_t *) internal_array;\n\n\treturn( 1 );\n\non_error:\n\tif( internal_array != NULL )\n\t{\n\t\tif( internal_array->entries != NULL )\n\t\t{\n\t\t\tmemory_free(\n\t\t\t internal_array->entries );\n\t\t}\n\t\tmemory_free(\n\t\t internal_array );\n\t}\n\treturn( -1 );\n", "Selected Statement": "size_t entries_size                       = 0;", "Function Input": {"array": {"value": {"type_category": "pointer", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x200\n", "message": "Cannot access memory at address 0x200"}}, "error": {"value": {"type_category": "pointer", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x7366780800000200\n", "message": "Cannot access memory at address 0x7366780800000200"}}, "number_of_entries": {"value": "116"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "     int number_of_symbols,\n     uint8_t maximum_code_size,\n     libcerror_error_t **error )\n{\n\tstatic char *function = \"libfwnt_huffman_tree_initialize\";\n\tsize_t array_size     = 0;\n\n\tif( huffman_tree == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid Huffman tree.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *huffman_tree != NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\n\t\t \"%s: invalid Huffman tree value already set.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( ( number_of_symbols < 0 )\n\t || ( number_of_symbols > 1024 ) )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: invalid number of symbols value out of bounds.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( maximum_code_size > 32 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: invalid maximum code size value out of bounds.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\t*huffman_tree = memory_allocate_structure(\n\t                 libfwnt_huffman_tree_t );\n\n\tif( *huffman_tree == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create Huffman tree.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     *huffman_tree,\n\t     0,\n\t     sizeof( libfwnt_huffman_tree_t ) ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear Huffman tree.\",\n\t\t function );\n\n\t\tmemory_free(\n\t\t *huffman_tree );\n\n\t\t*huffman_tree = NULL;\n\n\t\treturn( -1 );\n\t}\n\tarray_size = sizeof( int ) * number_of_symbols;\n\n\t( *huffman_tree )->symbols = (int *) memory_allocate(\n\t                                      array_size );\n\n\tif( ( *huffman_tree )->symbols == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create symbols.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     ( *huffman_tree )->symbols,\n\t     0,\n\t     array_size ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear symbols.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tarray_size = sizeof( int ) * ( maximum_code_size + 1 );\n\n\t( *huffman_tree )->code_size_counts = (int *) memory_allocate(\n\t                                               array_size );\n\n\tif( ( *huffman_tree )->code_size_counts == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create code size counts.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     ( *huffman_tree )->code_size_counts,\n\t     0,\n\t     array_size ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear code size counts.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\t( *huffman_tree )->maximum_code_size = maximum_code_size;\n\n\treturn( 1 );\n\non_error:\n\tif( *huffman_tree != NULL )\n\t{\n\t\tif( ( *huffman_tree )->code_size_counts != NULL )\n\t\t{\n\t\t\tmemory_free(\n\t\t\t ( *huffman_tree )->code_size_counts );\n\t\t}\n\t\tif( ( *huffman_tree )->symbols != NULL )\n\t\t{\n\t\t\tmemory_free(\n\t\t\t ( *huffman_tree )->symbols );\n\t\t}\n\t\tmemory_free(\n\t\t *huffman_tree );\n\n\t\t*huffman_tree = NULL;\n\t}\n\treturn( -1 );\n", "Selected Statement": "static char *function = \"libfwnt_huffman_tree_initialize\";", "Function Input": {"error": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7ffffffedaac", "value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x8000\n", "message": "Cannot access memory at address 0x8000"}}}, "huffman_tree": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a860", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"maximum_code_size": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "96 '`'"}, "symbols": {"type_category": "pointer", "concrete_type": "NULL"}, "code_size_counts": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x10bed10", "value": {"type_category": "int", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x20\n", "message": "Cannot access memory at address 0x20"}}}}}}, "maximum_code_size": {"value": "1 '\\001'"}, "number_of_symbols": {"value": "16777216"}}, "Variable Values Before Statement": {"constant": "\"libfwnt_huffman_tree_initialize\""}, "Value After Statement Execution": "\"libfwnt_huffman_tree_initialize\"", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "int LLVMFuzzerTestOneInput(\n     const uint8_t *data,\n     size_t size )\n{\n\tlibbfio_handle_t *file_io_handle                  = NULL;\n\tlibfshfs_extended_attribute_t *extended_attribute = NULL;\n\tlibfshfs_file_entry_t *file_entry                 = NULL;\n\tlibfshfs_volume_t *volume                         = NULL;\n\tint number_of_extended_attributes                 = 0;\n\tint result                                        = 0;\n\n\tif( libbfio_memory_range_initialize(\n\t     &file_io_handle,\n\t     NULL ) != 1 )\n\t{\n\t\treturn( 0 );\n\t}\n\tif( libbfio_memory_range_set(\n\t     file_io_handle,\n\t     (uint8_t *) data,\n\t     size,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libbfio;\n\t}\n\tif( libfshfs_volume_initialize(\n\t     &volume,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libbfio;\n\t}\n\tif( libfshfs_volume_open_file_io_handle(\n\t     volume,\n\t     file_io_handle,\n\t     LIBFSHFS_OPEN_READ,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libfshfs_volume;\n\t}\n\tresult = libfshfs_volume_get_file_entry_by_utf8_path(\n\t          volume,\n\t          (uint8_t *) \"/a_directory/a_file\",\n\t          19,\n\t          &file_entry,\n\t          NULL );\n\n\tif( result == 1 )\n\t{\n\t\tif( libfshfs_file_entry_get_number_of_extended_attributes(\n\t\t     file_entry,\n\t\t     &number_of_extended_attributes,\n\t\t     NULL ) != 1 )\n\t\t{\n\t\t\tgoto on_error_libfshfs_file_entry;\n\t\t}\n\t\tif( number_of_extended_attributes > 0 )\n\t\t{\n\t\t\tif( libfshfs_file_entry_get_extended_attribute_by_index(\n\t\t\t     file_entry,\n\t\t\t     0,\n\t\t\t     &extended_attribute,\n\t\t\t     NULL ) != 1 )\n\t\t\t{\n\t\t\t\tgoto on_error_libfshfs_file_entry;\n\t\t\t}\n\t\t\tlibfshfs_extended_attribute_free(\n\t\t\t &extended_attribute,\n\t\t\t NULL );\n\t\t}\non_error_libfshfs_file_entry:\n\t\tlibfshfs_file_entry_free(\n\t\t &file_entry,\n\t\t NULL );\n\t}\n\tlibfshfs_volume_close(\n\t volume,\n\t NULL );\n\non_error_libfshfs_volume:\n\tlibfshfs_volume_free(\n\t &volume,\n\t NULL );\n\non_error_libbfio:\n\tlibbfio_handle_free(\n\t &file_io_handle,\n\t NULL );\n\n\treturn( 0 );\n", "Selected Statement": "int number_of_extended_attributes                 = 0;", "Function Input": {"data": {"value": "0x10ed4c0 \"\""}, "size": {"value": "7241216"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "int LLVMFuzzerTestOneInput(\n     const uint8_t *data,\n     size_t size )\n{\n\tlibbfio_handle_t *file_io_handle = NULL;\n\tlibesedb_column_t *column        = NULL;\n\tlibesedb_file_t *file            = NULL;\n\tlibesedb_table_t *table          = NULL;\n\tint number_of_columns            = 0;\n\tint number_of_tables             = 0;\n\n\tif( libbfio_memory_range_initialize(\n\t     &file_io_handle,\n\t     NULL ) != 1 )\n\t{\n\t\treturn( 0 );\n\t}\n\tif( libbfio_memory_range_set(\n\t     file_io_handle,\n\t     (uint8_t *) data,\n\t     size,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libbfio;\n\t}\n\tif( libesedb_file_initialize(\n\t     &file,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libbfio;\n\t}\n\tif( libesedb_file_open_file_io_handle(\n\t     file,\n\t     file_io_handle,\n\t     LIBESEDB_OPEN_READ,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libesedb_file;\n\t}\n\tif( libesedb_file_get_number_of_tables(\n\t     file,\n\t     &number_of_tables,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libesedb_file;\n\t}\n\tif( number_of_tables > 0 )\n\t{\n\t\tif( libesedb_file_get_table(\n\t\t     file,\n\t\t     0,\n\t\t     &table,\n\t\t     NULL ) == 1 )\n\t\t{\n\t\t\tif( libesedb_table_get_number_of_columns(\n\t\t\t     table,\n\t\t\t     &number_of_columns,\n\t\t\t     0,\n\t\t\t     NULL ) != 1 )\n\t\t\t{\n\t\t\t\tgoto on_error_libesedb_table;\n\t\t\t}\n\t\t\tif( number_of_columns > 0 )\n\t\t\t{\n\t\t\t\tif( libesedb_table_get_column(\n\t\t\t\t     table,\n\t\t\t\t     0,\n\t\t\t\t     &column,\n\t\t\t\t     0,\n\t\t\t\t     NULL ) == 1 )\n\t\t\t\t{\n\t\t\t\t\tlibesedb_column_free(\n\t\t\t\t\t &column,\n\t\t\t\t\t NULL );\n\t\t\t\t}\n\t\t\t}\non_error_libesedb_table:\n\t\t\tlibesedb_table_free(\n\t\t\t &table,\n\t\t\t NULL );\n\t\t}\n\t}\n\tlibesedb_file_close(\n\t file,\n\t NULL );\n\non_error_libesedb_file:\n\tlibesedb_file_free(\n\t &file,\n\t NULL );\n\non_error_libbfio:\n\tlibbfio_handle_free(\n\t &file_io_handle,\n\t NULL );\n\n\treturn( 0 );\n", "Selected Statement": "int number_of_columns            = 0;", "Function Input": {"data": {"value": "0x117aa30 \"\""}, "size": {"value": "7827968"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "     size_t size,\n     uint32_t initial_value,\n     libcerror_error_t **error )\n{\n\tlibesedb_aligned_t *aligned_buffer_iterator = NULL;\n\tuint8_t *buffer_iterator                    = NULL;\n\tstatic char *function                       = \"libesedb_checksum_calculate_little_endian_xor32\";\n\tlibesedb_aligned_t value_aligned            = 0;\n\tuint32_t big_endian_value_32bit             = 0;\n\tuint32_t safe_checksum_value                = 0;\n\tuint32_t value_32bit                        = 0;\n\tuint8_t alignment_count                     = 0;\n\tuint8_t alignment_size                      = 0;\n\tuint8_t byte_count                          = 0;\n\tuint8_t byte_order                          = 0;\n\tuint8_t byte_size                           = 0;\n\n\tif( checksum_value == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid checksum value.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( buffer == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid buffer.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( size > (size_t) SSIZE_MAX )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM,\n\t\t \"%s: invalid size value exceeds maximum.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tsafe_checksum_value = initial_value;\n\n\tbuffer_iterator = (uint8_t *) buffer;\n\n\t\n\tif( ( ( sizeof( libesedb_aligned_t ) % 4 ) == 0 )\n\t && ( size > ( 2 * sizeof( libesedb_aligned_t ) ) ) )\n\t{\n\t\t\n\t\talignment_size = (uint8_t) ( (intptr_t) buffer_iterator % sizeof( libesedb_aligned_t ) );\n\n\t\tif( alignment_size > 0 )\n\t\t{\n\t\t\tbyte_size = sizeof( libesedb_aligned_t ) - alignment_size;\n\n\t\t\t\n\t\t\twhile( byte_size != 0 )\n\t\t\t{\n\t\t\t\tvalue_32bit = 0;\n\t\t\t\tbyte_count  = 1;\n\n\t\t\t\tif( byte_size >= 4 )\n\t\t\t\t{\n\t\t\t\t\tvalue_32bit |= buffer_iterator[ 3 ];\n\t\t\t\t\tvalue_32bit <<= 8;\n\n\t\t\t\t\tbyte_count++;\n\t\t\t\t}\n\t\t\t\tif( byte_size >= 3 )\n\t\t\t\t{\n\t\t\t\t\tvalue_32bit |= buffer_iterator[ 2 ];\n\t\t\t\t\tvalue_32bit <<= 8;\n\n\t\t\t\t\tbyte_count++;\n\t\t\t\t}\n\t\t\t\tif( byte_size >= 2 )\n\t\t\t\t{\n\t\t\t\t\tvalue_32bit |= buffer_iterator[ 1 ];\n\t\t\t\t\tvalue_32bit <<= 8;\n\n\t\t\t\t\tbyte_count++;\n\t\t\t\t}\n\t\t\t\tvalue_32bit |= buffer_iterator[ 0 ];\n\n\t\t\t\tbuffer_iterator += byte_count;\n\t\t\t\tbyte_size       -= byte_count;\n\n\t\t\t\tsafe_checksum_value ^= value_32bit;\n\t\t\t}\n\t\t\tsize -= byte_count;\n\t\t}\n\t\taligned_buffer_iterator = (libesedb_aligned_t *) buffer_iterator;\n\n\t\tif( *buffer_iterator != (uint8_t) ( *aligned_buffer_iterator & 0xff ) )\n\t\t{\n\t\t\tbyte_order = _BYTE_STREAM_ENDIAN_BIG;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbyte_order = _BYTE_STREAM_ENDIAN_LITTLE;\n\t\t}\n\t\t\n\t\twhile( size > sizeof( libesedb_aligned_t ) )\n\t\t{\n\t\t\tvalue_aligned ^= *aligned_buffer_iterator;\n\n\t\t\taligned_buffer_iterator++;\n\n\t\t\tsize -= sizeof( libesedb_aligned_t );\n\t\t}\n\t\t\n\t\tif( alignment_size > 0 )\n\t\t{\n\t\t\tbyte_count      = ( alignment_size % 4 ) * 8;\n\t\t\talignment_count = ( sizeof( libesedb_aligned_t ) - alignment_size ) * 8;\n\n\t\t\tif( byte_order == _BYTE_STREAM_ENDIAN_BIG )\n\t\t\t{\n\t\t\t\t\n\t\t\t\tbig_endian_value_32bit = (uint32_t) ( ( value_aligned >> alignment_count ) << byte_count );\n\n\t\t\t\t\n\t\t\t\tvalue_32bit = ( ( big_endian_value_32bit & 0x000000ffUL ) << 24 )\n\t\t\t\t            | ( ( big_endian_value_32bit & 0x0000ff00UL ) << 8 )\n\t\t\t\t            | ( ( big_endian_value_32bit >> 8 ) & 0x0000ff00UL )\n\t\t\t\t            | ( ( big_endian_value_32bit >> 24 ) & 0x000000ffUL );\n\n\t\t\t\t\n\t\t\t\tvalue_aligned <<= alignment_count;\n\t\t\t}\n\t\t\telse if( byte_order == _BYTE_STREAM_ENDIAN_LITTLE )\n\t\t\t{\n\t\t\t\tvalue_32bit = (uint32_t) ( value_aligned << byte_count );\n\n\t\t\t\t\n\t\t\t\tvalue_aligned >>= alignment_count;\n\t\t\t}\n\t\t\tsafe_checksum_value ^= value_32bit;\n\t\t}\n\t\t\n\t\tbyte_size = (uint8_t) sizeof( libesedb_aligned_t );\n\n\t\twhile( byte_size != 0 )\n\t\t{\n\t\t\tbyte_count = ( ( byte_size / 4 ) - 1 ) * 32;\n\n\t\t\tif( byte_order == _BYTE_STREAM_ENDIAN_BIG )\n\t\t\t{\n\t\t\t\tbig_endian_value_32bit = (uint32_t) ( ( value_aligned >> byte_count ) & 0xffffffffUL );\n\n\t\t\t\t\n\t\t\t\tvalue_32bit = ( ( big_endian_value_32bit & 0x000000ffUL ) << 24 )\n\t\t\t\t            | ( ( big_endian_value_32bit & 0x0000ff00UL ) << 8 )\n\t\t\t\t            | ( ( big_endian_value_32bit >> 8 ) & 0x0000ff00UL )\n\t\t\t\t            | ( ( big_endian_value_32bit >> 24 ) & 0x000000ffUL );\n\t\t\t}\n\t\t\telse if( byte_order == _BYTE_STREAM_ENDIAN_LITTLE )\n\t\t\t{\n\t\t\t\tvalue_32bit = (uint32_t) value_aligned;\n\n\t\t\t\tvalue_aligned >>= byte_count;\n\t\t\t}\n\t\t\tbyte_size -= 4;\n\n\t\t\tsafe_checksum_value ^= value_32bit;\n\t\t}\n\t\t\n\t\tbuffer_iterator = (uint8_t *) aligned_buffer_iterator;\n\n\t\tbyte_size = 4 - ( alignment_size % 4 );\n\n\t\tif( byte_size != 4 )\n\t\t{\n\t\t\tvalue_32bit   = buffer_iterator[ 0 ];\n\t\t\tvalue_32bit <<= 8;\n\n\t\t\tif( byte_size >= 2 )\n\t\t\t{\n\t\t\t\tvalue_32bit |= buffer_iterator[ 1 ];\n\t\t\t}\n\t\t\tvalue_32bit <<= 8;\n\n\t\t\tif( byte_size >= 3 )\n\t\t\t{\n\t\t\t\tvalue_32bit |= buffer_iterator[ 2 ];\n\t\t\t}\n\t\t\tvalue_32bit <<= 8;\n\n\t\t\tbuffer_iterator += byte_size;\n\t\t\tsize            -= byte_size;\n\n\t\t\tsafe_checksum_value ^= value_32bit;\n\t\t}\n\t}\n\twhile( size > 0 )\n\t{\n\t\tvalue_32bit = 0;\n\t\tbyte_count  = 1;\n\n\t\tif( size >= 4 )\n\t\t{\n\t\t\tvalue_32bit |= buffer_iterator[ 3 ];\n\t\t\tvalue_32bit <<= 8;\n\n\t\t\tbyte_count++;\n\t\t}\n\t\tif( size >= 3 )\n\t\t{\n\t\t\tvalue_32bit |= buffer_iterator[ 2 ];\n\t\t\tvalue_32bit <<= 8;\n\n\t\t\tbyte_count++;\n\t\t}\n\t\tif( size >= 2 )\n\t\t{\n\t\t\tvalue_32bit |= buffer_iterator[ 1 ];\n\t\t\tvalue_32bit <<= 8;\n\n\t\t\tbyte_count++;\n\t\t}\n\t\tvalue_32bit |= buffer_iterator[ 0 ];\n\n\t\tbuffer_iterator += byte_count;\n\t\tsize            -= byte_count;\n\n\t\tsafe_checksum_value ^= value_32bit;\n\t}\n\t*checksum_value = safe_checksum_value;\n\n\treturn( 1 );\n", "Selected Statement": "value_32bit = 0;", "Function Input": {"buffer": {"value": "0x117ca50 \"\""}, "error": {"value": {"type_category": "pointer", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x29c\n", "message": "Cannot access memory at address 0x29c"}}, "initial_value": {"value": "0"}, "size": {"value": "672"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "int LLVMFuzzerTestOneInput(\n     const uint8_t *data,\n     size_t size )\n{\n\tuint8_t volume_identifier[ 16 ];\n\tuint8_t string_value[ 64 ];\n\n\tlibbfio_handle_t *file_io_handle             = NULL;\n\tlibfsapfs_container_t *container             = NULL;\n\tlibfsapfs_volume_t *volume                   = NULL;\n\tsize64_t volume_size                         = 0;\n\tsize_t string_size                           = 0;\n\tuint64_t compatible_features_flags           = 0;\n\tuint64_t incompatible_features_flags         = 0;\n\tuint64_t read_only_compatible_features_flags = 0;\n\tint number_of_volumes                        = 0;\n\tint result                                   = 0;\n\n\tif( libbfio_memory_range_initialize(\n\t     &file_io_handle,\n\t     NULL ) != 1 )\n\t{\n\t\treturn( 0 );\n\t}\n\tif( libbfio_memory_range_set(\n\t     file_io_handle,\n\t     (uint8_t *) data,\n\t     size,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libbfio;\n\t}\n\tif( libfsapfs_container_initialize(\n\t     &container,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libbfio;\n\t}\n\tif( libfsapfs_container_open_file_io_handle(\n\t     container,\n\t     file_io_handle,\n\t     LIBFSAPFS_OPEN_READ,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libfsapfs_container;\n\t}\n\tif( libfsapfs_container_get_number_of_volumes(\n\t     container,\n\t     &number_of_volumes,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libfsapfs_container;\n\t}\n\tif( number_of_volumes > 0 )\n\t{\n\t\tresult = libfsapfs_container_get_volume_by_index(\n\t\t          container,\n\t\t          0,\n\t\t          &volume,\n\t\t          NULL );\n\n\t\tif( result != -1 )\n\t\t{\n\t\t\tlibfsapfs_volume_get_features_flags(\n\t\t\t volume,\n\t\t\t &compatible_features_flags,\n\t\t\t &incompatible_features_flags,\n\t\t\t &read_only_compatible_features_flags,\n\t\t\t NULL );\n\n\t\t\tlibfsapfs_volume_get_size(\n\t\t\t volume,\n\t\t\t &volume_size,\n\t\t\t NULL );\n\n\t\t\tlibfsapfs_volume_get_identifier(\n\t\t\t volume,\n\t\t\t volume_identifier,\n\t\t\t 16,\n\t\t\t NULL );\n\n\t\t\tlibfsapfs_volume_get_utf8_name_size(\n\t\t\t volume,\n\t\t\t &string_size,\n\t\t\t NULL );\n\n\t\t\tlibfsapfs_volume_get_utf8_name(\n\t\t\t volume,\n\t\t\t string_value,\n\t\t\t 64,\n\t\t\t NULL );\n\n\t\t\tlibfsapfs_volume_is_locked(\n\t\t\t volume,\n\t\t\t NULL );\n\n\t\t\tlibfsapfs_volume_free(\n\t\t\t &volume,\n\t\t\t NULL );\n\t\t}\n\t}\non_error_libfsapfs_container:\n\tlibfsapfs_container_free(\n\t &container,\n\t NULL );\n\non_error_libbfio:\n\tlibbfio_handle_free(\n\t &file_io_handle,\n\t NULL );\n\n\treturn( 0 );\n", "Selected Statement": "int number_of_volumes                        = 0;", "Function Input": {"data": {"value": "0x11528d0 \"\\005z\\f]U)&\\254\\001\""}, "size": {"value": "7513600"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "     size_t size,\n     uint32_t initial_value,\n     libcerror_error_t **error )\n{\n\tstatic char *function = \"libfvde_checkcum_calculate_weak_crc32\";\n\tsize_t buffer_offset  = 0;\n\tuint32_t table_index  = 0;\n\n\tif( checksum == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid checksum.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( buffer == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid buffer.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( size > (size_t) SSIZE_MAX )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM,\n\t\t \"%s: invalid size value exceeds maximum.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n        if( libfvde_checksum_crc32_table_computed == 0 )\n\t{\n\t\tlibfvde_checksum_initialize_crc32_table(\n\t\t 0x82f63b78UL );\n\t}\n\t*checksum = initial_value;\n\n        for( buffer_offset = 0;\n\t     buffer_offset < size;\n\t     buffer_offset++ )\n\t{\n\t\ttable_index = ( *checksum ^ buffer[ buffer_offset ] ) & 0x000000ffUL;\n\n\t\t*checksum = libfvde_checksum_crc32_table[ table_index ] ^ ( *checksum >> 8 );\n        }\n\treturn( 1 );\n", "Selected Statement": "size_t buffer_offset  = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "int libfplist_xml_tag_free(\n     libfplist_xml_tag_t **tag,\n     libcerror_error_t **error )\n{\n\tstatic char *function = \"libfplist_xml_tag_free\";\n\tint result            = 1;\n\n\tif( tag == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid XML plist tag.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *tag != NULL )\n\t{\n\t\t\n\n\t\tif( libcdata_array_free(\n\t\t     &( ( *tag )->elements_array ),\n\t\t     (int (*)(intptr_t **, libcerror_error_t **)) &libfplist_xml_tag_free,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_FINALIZE_FAILED,\n\t\t\t \"%s: unable to free elements array.\",\n\t\t\t function );\n\n\t\t\tresult = -1;\n\t\t}\n\t\tif( libcdata_array_free(\n\t\t     &( ( *tag )->attributes_array ),\n\t\t     (int (*)(intptr_t **, libcerror_error_t **)) &libfplist_xml_attribute_free,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_FINALIZE_FAILED,\n\t\t\t \"%s: unable to free attributes array.\",\n\t\t\t function );\n\n\t\t\tresult = -1;\n\t\t}\n\t\tif( ( *tag )->value != NULL )\n\t\t{\n\t\t\tmemory_free(\n\t\t\t ( *tag )->value );\n\t\t}\n\t\tif( ( *tag )->name != NULL )\n\t\t{\n\t\t\tmemory_free(\n\t\t\t ( *tag )->name );\n\t\t}\n\t\tmemory_free(\n\t\t *tag );\n\n\t\t*tag = NULL;\n\t}\n\treturn( result );\n", "Selected Statement": "static char *function = \"libfplist_xml_tag_free\";", "Function Input": {"error": {"value": {"type_category": "pointer", "concrete_type": "NULL"}}, "tag": {"value": null}}, "Variable Values Before Statement": {"constant": "\"libfplist_xml_tag_free\""}, "Value After Statement Execution": "\"libfplist_xml_tag_free\"", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "     uint8_t *buffer,\n     size_t buffer_size,\n     libcerror_error_t **error )\n{\n\tlibfplist_xml_parser_state_t parser_state;\n\t\n\tYY_BUFFER_STATE buffer_state = NULL;\n\tstatic char *function        = \"libfplist_xml_parser_parse_buffer\";\n\tint result                   = -1;\n\n\tif( buffer == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid buffer.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tbuffer_state = libfplist_xml_scanner__scan_buffer(\n\t                (char *) buffer,\n\t                buffer_size );\n\n\tlibfplist_xml_scanner_buffer_offset = 0;\n\n\tif( buffer_state != NULL )\n\t{\n\t\tparser_state.property_list = property_list;\n\t\tparser_state.error         = error;\n\t\tparser_state.root_tag      = NULL;\n\t\tparser_state.current_tag   = NULL;\n\t\tparser_state.parent_tag    = NULL;\n\n\t\tif( libfplist_xml_scanner_parse(\n\t\t     &parser_state ) == 0 )\n\t\t{\n\t\t\tif( libfplist_property_list_set_root_tag(\n\t\t\t     property_list,\n\t\t\t     parser_state.root_tag,\n\t\t\t     error ) != 1 )\n\t\t\t{\n\t\t\t\tlibcerror_error_set(\n\t\t\t\t error,\n\t\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t\t LIBCERROR_RUNTIME_ERROR_GET_FAILED,\n\t\t\t\t \"%s: unable to set root tag.\",\n\t\t\t\t function );\n\n\t\t\t\tresult = -1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tparser_state.root_tag = NULL;\n\n\t\t\t\tresult = 1;\n\t\t\t}\n\t\t}\n\t\tlibfplist_xml_scanner__delete_buffer(\n\t\t buffer_state );\n\t}\n\tlibfplist_xml_scanner_lex_destroy();\n\n\tif( parser_state.root_tag != NULL )\n\t{\n\t\tlibfplist_xml_tag_free(\n\t\t &( parser_state.root_tag ),\n\t\t NULL );\n\t}\n\treturn( result );\n", "Selected Statement": "static char *function        = \"libfplist_xml_parser_parse_buffer\";", "Function Input": {"buffer": {"value": "0x11f6eb0 \"\\340\\v\\342\\367\\377\\177\""}, "buffer_size": {"value": "4096"}, "error": {"value": {"type_category": "pointer", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x1000\n", "message": "Cannot access memory at address 0x1000"}}, "property_list": {"value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x2\n", "message": "Cannot access memory at address 0x2"}}}, "Variable Values Before Statement": {"constant": "\"libfplist_xml_parser_parse_buffer\""}, "Value After Statement Execution": "\"libfplist_xml_parser_parse_buffer\"", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": " * @return the newly allocated buffer state object.\n */\nYY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )\n{\n\tYY_BUFFER_STATE b;\n    \n\tif ( size < 2 ||\n\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n\t\t\n\t\treturn NULL;\n\n\tb = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_scan_buffer()\" );\n\n\tb->yy_buf_size = (int) (size - 2);\t\n\tb->yy_buf_pos = b->yy_ch_buf = base;\n\tb->yy_is_our_buffer = 0;\n\tb->yy_input_file = NULL;\n\tb->yy_n_chars = b->yy_buf_size;\n\tb->yy_is_interactive = 0;\n\tb->yy_at_bol = 1;\n\tb->yy_fill_buffer = 0;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tyy_switch_to_buffer( b  );\n\n\treturn b;\n", "Selected Statement": "b->yy_is_our_buffer = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "int libewf_io_handle_initialize(\n     libewf_io_handle_t **io_handle,\n     libcerror_error_t **error )\n{\n\tstatic char *function = \"libewf_io_handle_initialize\";\n\n\tif( io_handle == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid IO handle.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *io_handle != NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\n\t\t \"%s: invalid IO handle value already set.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\t*io_handle = memory_allocate_structure(\n\t              libewf_io_handle_t );\n\n\tif( *io_handle == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create IO handle.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     *io_handle,\n\t     0,\n\t     sizeof( libewf_io_handle_t ) ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear IO handle.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\t( *io_handle )->segment_file_type  = LIBEWF_SEGMENT_FILE_TYPE_UNDEFINED;\n\t( *io_handle )->format             = LIBEWF_FORMAT_ENCASE6;\n\t( *io_handle )->major_version      = 1;\n\t( *io_handle )->minor_version      = 0;\n\t( *io_handle )->compression_method = LIBEWF_COMPRESSION_METHOD_DEFLATE;\n\t( *io_handle )->compression_level  = LIBEWF_COMPRESSION_LEVEL_NONE;\n\t( *io_handle )->zero_on_error      = 1;\n\t( *io_handle )->header_codepage    = LIBEWF_CODEPAGE_ASCII;\n\n\treturn( 1 );\n\non_error:\n\tif( *io_handle != NULL )\n\t{\n\t\tmemory_free(\n\t\t *io_handle );\n\n\t\t*io_handle = NULL;\n\t}\n\treturn( -1 );\n", "Selected Statement": "( *io_handle )->minor_version      = 0;", "Function Input": {"error": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7ffff7cce299 <malloc+441>", "value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x840fc08548c08949\n", "message": "Cannot access memory at address 0x840fc08548c08949"}}}, "io_handle": {"value": null}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "int libewf_media_values_initialize(\n     libewf_media_values_t **media_values,\n     libcerror_error_t **error )\n{\n\tstatic char *function = \"libewf_media_values_initialize\";\n\n\tif( media_values == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid media values.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *media_values != NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\n\t\t \"%s: invalid media values value already set.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\t*media_values = memory_allocate_structure(\n\t                 libewf_media_values_t );\n\n\tif( *media_values == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create media values.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     *media_values,\n\t     0,\n\t     sizeof( libewf_media_values_t ) ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear media values.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\t( *media_values )->chunk_size        = LIBEWF_MINIMUM_CHUNK_SIZE;\n\t( *media_values )->sectors_per_chunk = 64;\n\t( *media_values )->bytes_per_sector  = 512;\n\t( *media_values )->media_flags       = 0x01;\n\n\treturn( 1 );\n\non_error:\n\tif( *media_values != NULL )\n\t{\n\t\tmemory_free(\n\t\t *media_values );\n\n\t\t*media_values = NULL;\n\t}\n\treturn( -1 );\n", "Selected Statement": "( *media_values )->sectors_per_chunk = 64;", "Function Input": {"error": {"value": null}, "media_values": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x124a380", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"media_size": {"type_category": "unknown", "concrete_type": "size64_t", "value": "288072046477312"}, "chunk_size": {"type_category": "unknown", "concrete_type": "size32_t", "value": "1"}, "sectors_per_chunk": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, "bytes_per_sector": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, "number_of_chunks": {"type_category": "unknown", "concrete_type": "uint64_t", "value": "20127"}, "number_of_sectors": {"type_category": "unknown", "concrete_type": "uint64_t", "value": "48"}, "error_granularity": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "81"}, "media_type": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "0 '\\000'"}, "media_flags": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "0 '\\000'"}, "set_identifier": {"type_category": "string", "concrete_type": "string", "value": "\"\\000\\000/testcase/8800\""}}}}}}, "Variable Values Before Statement": {"constant": "64"}, "Value After Statement Execution": "64", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "     libewf_segment_file_t **segment_file,\n     libewf_io_handle_t *io_handle,\n     libcerror_error_t **error )\n{\n\tstatic char *function = \"libewf_segment_file_initialize\";\n\n\tif( segment_file == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid segment file.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *segment_file != NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\n\t\t \"%s: invalid segment file value already set.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( io_handle == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid IO handle.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\t*segment_file = memory_allocate_structure(\n\t                 libewf_segment_file_t );\n\n\tif( *segment_file == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create segment file.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     *segment_file,\n\t     0,\n\t     sizeof( libewf_segment_file_t ) ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear segment file.\",\n\t\t function );\n\n\t\tmemory_free(\n\t\t *segment_file );\n\n\t\t*segment_file = NULL;\n\n\t\treturn( -1 );\n\t}\n\tif( libfdata_list_initialize(\n\t     &( ( *segment_file )->sections_list ),\n\t     (intptr_t *) *segment_file,\n\t     NULL,\n\t     NULL,\n\t     (int (*)(intptr_t *, intptr_t *, libfdata_list_element_t *, libfdata_cache_t *, int, off64_t, size64_t, uint32_t, uint8_t, libcerror_error_t **)) &libewf_segment_file_read_section_element_data,\n\t     NULL,\n\t     LIBFDATA_DATA_HANDLE_FLAG_NON_MANAGED,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create sections list.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( libfdata_list_initialize(\n\t     &( ( *segment_file )->chunk_groups_list ),\n\t     (intptr_t *) *segment_file,\n\t     NULL,\n\t     NULL,\n\t     (int (*)(intptr_t *, intptr_t *, libfdata_list_element_t *, libfdata_cache_t *, int, off64_t, size64_t, uint32_t, uint8_t, libcerror_error_t **)) &libewf_segment_file_read_chunk_group_element_data,\n\t     NULL,\n\t     LIBFDATA_DATA_HANDLE_FLAG_NON_MANAGED,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create chunk groups list.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( libfcache_cache_initialize(\n\t     &( ( *segment_file )->chunk_groups_cache ),\n\t     LIBEWF_MAXIMUM_CACHE_ENTRIES_CHUNK_GROUPS,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create chunk groups cache.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\t( *segment_file )->io_handle                        = io_handle;\n\t( *segment_file )->device_information_section_index = -1;\n\t( *segment_file )->previous_last_chunk_filled       = -1;\n\t( *segment_file )->last_chunk_filled                = -1;\n\t( *segment_file )->last_chunk_compared              = -1;\n\n\treturn( 1 );\n\non_error:\n\tif( *segment_file != NULL )\n\t{\n\t\tif( ( *segment_file )->chunk_groups_list != NULL )\n\t\t{\n\t\t\tlibfdata_list_free(\n\t\t\t &( ( *segment_file )->chunk_groups_list ),\n\t\t\t NULL );\n\t\t}\n\t\tif( ( *segment_file )->sections_list != NULL )\n\t\t{\n\t\t\tlibfdata_list_free(\n\t\t\t &( ( *segment_file )->sections_list ),\n\t\t\t NULL );\n\t\t}\n\t\tmemory_free(\n\t\t *segment_file );\n\n\t\t*segment_file = NULL;\n\t}\n\treturn( -1 );\n", "Selected Statement": "( *segment_file )->device_information_section_index = -1;", "Function Input": {"error": {"value": null}, "io_handle": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"access_flags": {"type_category": "int", "concrete_type": "int", "value": "1"}, "segment_file_type": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "0 '\\000'"}, "format": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "0 '\\000'"}, "major_version": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "0 '\\000'"}, "minor_version": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "0 '\\000'"}, "compression_method": {"type_category": "unknown", "concrete_type": "uint16_t", "value": "0"}, "compression_level": {"type_category": "unknown", "concrete_type": "int8_t", "value": "0 '\\000'"}, "compression_flags": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "0 '\\000'"}, "is_encrypted": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "0 '\\000'"}, "chunk_size": {"type_category": "unknown", "concrete_type": "size32_t", "value": "0"}, "zero_on_error": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "0 '\\000'"}, "header_codepage": {"type_category": "int", "concrete_type": "int", "value": "0"}, "abort": {"type_category": "int", "concrete_type": "int", "value": "0"}}}}, "segment_file": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x124a0b0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x1\n", "message": "Cannot access memory at address 0x1"}}}}, "Variable Values Before Statement": {"constant": "-1"}, "Value After Statement Execution": "-1", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "     size_t size,\n     uint32_t initial_value,\n     libcerror_error_t **error )\n{\n\tstatic char *function  = \"libfmapi_checksum_calculate_weak_crc32\";\n\tsize_t buffer_offset   = 0;\n\tuint32_t safe_checksum = 0;\n\tuint32_t table_index   = 0;\n\n\tif( checksum == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid checksum.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( buffer == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid buffer.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( size > (size_t) SSIZE_MAX )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM,\n\t\t \"%s: invalid size value exceeds maximum.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n        if( libfmapi_checksum_crc32_table_computed == 0 )\n\t{\n\t\tlibfmapi_checksum_initialize_crc32_table(\n\t\t 0xedb88320UL );\n\t}\n\tsafe_checksum = initial_value;\n\n        for( buffer_offset = 0;\n\t     buffer_offset < size;\n\t     buffer_offset++ )\n\t{\n\t\ttable_index = ( safe_checksum ^ buffer[ buffer_offset ] ) & 0x000000ffUL;\n\n\t\tsafe_checksum = libfmapi_checksum_crc32_table[ table_index ] ^ ( safe_checksum >> 8 );\n        }\n\t*checksum = safe_checksum;\n\n        return( 1 );\n", "Selected Statement": "static char *function  = \"libfmapi_checksum_calculate_weak_crc32\";", "Function Input": {}, "Variable Values Before Statement": {"constant": "\"libfmapi_checksum_calculate_weak_crc32\""}, "Value After Statement Execution": "\"libfmapi_checksum_calculate_weak_crc32\"", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "int LLVMFuzzerTestOneInput(\n     const uint8_t *data,\n     size_t size )\n{\n\tuint8_t string_value[ 64 ];\n\n\tlibbfio_handle_t *file_io_handle      = NULL;\n\tlibfsxfs_file_entry_t *root_directory = NULL;\n\tlibfsxfs_file_entry_t *sub_file_entry = NULL;\n\tlibfsxfs_volume_t *volume             = NULL;\n\tsize64_t file_size                    = 0;\n\tsize_t string_size                    = 0;\n\toff64_t file_offset                   = 0;\n\tuint64_t value_64bit                  = 0;\n\tint64_t posix_time                    = 0;\n\tuint32_t major_device_number          = 0;\n\tuint32_t minor_device_number          = 0;\n\tuint32_t value_32bit                  = 0;\n\tuint16_t value_16bit                  = 0;\n\tint number_of_extents                 = 0;\n\tint number_of_sub_file_entries        = 0;\n\tint result                            = 0;\n\n\tif( libbfio_memory_range_initialize(\n\t     &file_io_handle,\n\t     NULL ) != 1 )\n\t{\n\t\treturn( 0 );\n\t}\n\tif( libbfio_memory_range_set(\n\t     file_io_handle,\n\t     (uint8_t *) data,\n\t     size,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libbfio;\n\t}\n\tif( libfsxfs_volume_initialize(\n\t     &volume,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libbfio;\n\t}\n\tif( libfsxfs_volume_open_file_io_handle(\n\t     volume,\n\t     file_io_handle,\n\t     LIBFSXFS_OPEN_READ,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libfsxfs_volume;\n\t}\n\tif( libfsxfs_volume_get_root_directory(\n\t     volume,\n\t     &root_directory,\n\t     NULL ) == 1 )\n\t{\n\t\tif( libfsxfs_file_entry_get_number_of_sub_file_entries(\n\t\t     root_directory,\n\t\t     &number_of_sub_file_entries,\n\t\t     NULL ) != 1 )\n\t\t{\n\t\t\tgoto on_error_libfsxfs_root_directory;\n\t\t}\n\t\tif( number_of_sub_file_entries > 0 )\n\t\t{\n\t\t\tresult = libfsxfs_file_entry_get_sub_file_entry_by_index(\n\t\t\t          root_directory,\n\t\t\t          0,\n\t\t\t          &sub_file_entry,\n\t\t\t          NULL );\n\n\t\t\tif( result != -1 )\n\t\t\t{\n\t\t\t\tlibfsxfs_file_entry_get_inode_number(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &value_64bit,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfsxfs_file_entry_get_creation_time(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &posix_time,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfsxfs_file_entry_get_modification_time(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &posix_time,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfsxfs_file_entry_get_access_time(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &posix_time,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfsxfs_file_entry_get_inode_change_time(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &posix_time,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfsxfs_file_entry_get_file_mode(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &value_16bit,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfsxfs_file_entry_get_number_of_links(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &value_32bit,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfsxfs_file_entry_get_owner_identifier(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &value_32bit,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfsxfs_file_entry_get_group_identifier(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &value_32bit,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfsxfs_file_entry_get_device_identifier(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &value_32bit,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfsxfs_file_entry_get_device_number(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &major_device_number,\n\t\t\t\t &minor_device_number,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfsxfs_file_entry_get_utf8_name_size(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &string_size,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfsxfs_file_entry_get_utf8_name(\n\t\t\t\t sub_file_entry,\n\t\t\t\t string_value,\n\t\t\t\t 64,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfsxfs_file_entry_get_utf8_symbolic_link_target_size(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &string_size,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfsxfs_file_entry_get_utf8_symbolic_link_target(\n\t\t\t\t sub_file_entry,\n\t\t\t\t string_value,\n\t\t\t\t 64,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfsxfs_file_entry_get_offset(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &file_offset,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfsxfs_file_entry_get_size(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &file_size,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfsxfs_file_entry_get_number_of_extents(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &number_of_extents,\n\t\t\t\t NULL );\n\t\t\t}\n\t\t\tlibfsxfs_file_entry_free(\n\t\t\t &sub_file_entry,\n\t\t\t NULL );\n\t\t}\non_error_libfsxfs_root_directory:\n\t\tlibfsxfs_file_entry_free(\n\t\t &root_directory,\n\t\t NULL );\n\t}\n\tlibfsxfs_volume_close(\n\t volume,\n\t NULL );\n\non_error_libfsxfs_volume:\n\tlibfsxfs_volume_free(\n\t &volume,\n\t NULL );\n\non_error_libbfio:\n\tlibbfio_handle_free(\n\t &file_io_handle,\n\t NULL );\n\n\treturn( 0 );\n", "Selected Statement": "uint32_t minor_device_number          = 0;", "Function Input": {"data": {"value": "0x10db170 \"XFSB\""}, "size": {"value": "6899712"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "     libfsfat_allocation_table_t **allocation_table,\n     uint32_t total_number_of_clusters,\n     libcerror_error_t **error )\n{\n\tstatic char *function            = \"libfsfat_allocation_table_initialize\";\n\tsize_t cluster_numbers_data_size = 0;\n\n\tif( allocation_table == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid allocation table.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *allocation_table != NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\n\t\t \"%s: invalid allocation table value already set.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( ( total_number_of_clusters == 0 )\n\t || ( total_number_of_clusters > (uint32_t) LIBFSFAT_MAXIMUM_NUMBER_OF_CLUSTERS_IN_FAT ) )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: invalid total number of clusters value out of bounds.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\t*allocation_table = memory_allocate_structure(\n\t                     libfsfat_allocation_table_t );\n\n\tif( *allocation_table == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create allocation table.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     *allocation_table,\n\t     0,\n\t     sizeof( libfsfat_allocation_table_t ) ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear allocation table.\",\n\t\t function );\n\n\t\tmemory_free(\n\t\t *allocation_table );\n\n\t\t*allocation_table = NULL;\n\n\t\treturn( -1 );\n\t}\n\tcluster_numbers_data_size = sizeof( uint32_t ) * total_number_of_clusters;\n\n\t( *allocation_table )->cluster_numbers = (uint32_t *) memory_allocate(\n\t                                                       cluster_numbers_data_size );\n\n\tif( ( *allocation_table )->cluster_numbers == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create cluster numbers.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\t( *allocation_table )->number_of_cluster_numbers = total_number_of_clusters;\n\n\tif( memory_set(\n\t     ( *allocation_table )->cluster_numbers,\n\t     0,\n\t     cluster_numbers_data_size ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear cluster numbers.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\treturn( 1 );\n\non_error:\n\tif( *allocation_table != NULL )\n\t{\n\t\tif( ( *allocation_table )->cluster_numbers != NULL )\n\t\t{\n\t\t\tmemory_free(\n\t\t\t ( *allocation_table )->cluster_numbers );\n\t\t}\n\t\tmemory_free(\n\t\t *allocation_table );\n\n\t\t*allocation_table = NULL;\n\t}\n\treturn( -1 );\n", "Selected Statement": "static char *function            = \"libfsfat_allocation_table_initialize\";", "Function Input": {"allocation_table": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdc10", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"number_of_cluster_numbers": {"type_category": "int", "concrete_type": "int", "value": "-8960"}, "cluster_numbers": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffdc88", "value": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "1971963529"}}}}}}, "error": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x10960a0", "value": {"type_category": "unknown", "concrete_type": "libcerror_error_t", "value": "0"}}}, "total_number_of_clusters": {"value": "0"}}, "Variable Values Before Statement": {"constant": "\"libfsfat_allocation_table_initialize\""}, "Value After Statement Execution": "\"libfsfat_allocation_table_initialize\"", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "     size64_t size,\n     size64_t leaf_value_size,\n     libcerror_error_t **error )\n{\n\tstatic char *function  = \"libfsfat_block_tree_node_initialize\";\n\tsize64_t sub_node_size = 0;\n\n\tif( block_tree_node == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid block tree node.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *block_tree_node != NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\n\t\t \"%s: invalid block tree node value already set.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( offset < 0 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: invalid offset value out of bounds.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( ( size == 0 )\n\t || ( size > (size64_t) ( INT64_MAX - offset ) ) )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: invalid size value out of bounds.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( leaf_value_size == 0 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: invalid leaf value size value out of bounds.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\t*block_tree_node = memory_allocate_structure(\n\t                    libfsfat_block_tree_node_t );\n\n\tif( *block_tree_node == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create block tree node.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     *block_tree_node,\n\t     0,\n\t     sizeof( libfsfat_block_tree_node_t ) ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear block tree node.\",\n\t\t function );\n\n\t\tmemory_free(\n\t\t *block_tree_node );\n\n\t\t*block_tree_node = NULL;\n\n\t\treturn( -1 );\n\t}\n\tif( libcdata_array_initialize(\n\t     &( ( *block_tree_node )->sub_nodes_array ),\n\t     LIBFSFAT_BLOCK_TREE_NUMBER_OF_SUB_NODES,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create sub nodes array.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tsub_node_size = leaf_value_size;\n\n\twhile( ( size / sub_node_size ) > LIBFSFAT_BLOCK_TREE_NUMBER_OF_SUB_NODES )\n\t{\n\t\tsub_node_size *= LIBFSFAT_BLOCK_TREE_NUMBER_OF_SUB_NODES;\n\t}\n\t( *block_tree_node )->start_offset  = offset;\n\t( *block_tree_node )->end_offset    = offset + size;\n\t( *block_tree_node )->size          = size;\n\t( *block_tree_node )->sub_node_size = sub_node_size;\n\n\tif( sub_node_size == leaf_value_size )\n\t{\n\t\t( *block_tree_node )->is_leaf_node = 1;\n\t}\n\treturn( 1 );\n\non_error:\n\tif( *block_tree_node != NULL )\n\t{\n\t\tmemory_free(\n\t\t *block_tree_node );\n\n\t\t*block_tree_node = NULL;\n\t}\n\treturn( -1 );\n", "Selected Statement": "static char *function  = \"libfsfat_block_tree_node_initialize\";", "Function Input": {"block_tree_node": {"value": {"type_category": "pointer", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x204\n", "message": "Cannot access memory at address 0x204"}}, "error": {"value": null}, "leaf_value_size": {"value": "140737488345584"}, "offset": {"value": "2199023255553"}, "size": {"value": "262144"}}, "Variable Values Before Statement": {"constant": "\"libfsfat_block_tree_node_initialize\""}, "Value After Statement Execution": "\"libfsfat_block_tree_node_initialize\"", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "int LLVMFuzzerTestOneInput(\n     const uint8_t *data,\n     size_t size )\n{\n\tuint8_t volume_identifier[ 16 ];\n\tuint8_t string_value[ 64 ];\n\n\tlibbfio_handle_t *file_io_handle             = NULL;\n\tlibfsext_volume_t *volume                    = NULL;\n\tsize_t string_size                           = 0;\n\tuint32_t compatible_features_flags           = 0;\n\tuint32_t incompatible_features_flags         = 0;\n\tuint32_t number_of_file_entries              = 0;\n\tuint32_t read_only_compatible_features_flags = 0;\n\tint32_t posix_time                           = 0;\n\tuint8_t format_version                       = 0;\n\tint result                                   = 0;\n\n\tif( libbfio_memory_range_initialize(\n\t     &file_io_handle,\n\t     NULL ) != 1 )\n\t{\n\t\treturn( 0 );\n\t}\n\tif( libbfio_memory_range_set(\n\t     file_io_handle,\n\t     (uint8_t *) data,\n\t     size,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libbfio;\n\t}\n\tif( libfsext_volume_initialize(\n\t     &volume,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libbfio;\n\t}\n\tresult = libfsext_volume_open_file_io_handle(\n\t          volume,\n\t          file_io_handle,\n\t          LIBFSEXT_OPEN_READ,\n\t          NULL );\n\n\tif( result != -1 )\n\t{\n\t\tlibfsext_volume_get_format_version(\n\t\t volume,\n\t\t &format_version,\n\t\t NULL );\n\n\t\tlibfsext_volume_get_features_flags(\n\t\t volume,\n\t\t &compatible_features_flags,\n\t\t &incompatible_features_flags,\n\t\t &read_only_compatible_features_flags,\n\t\t NULL );\n\n\t\tlibfsext_volume_get_identifier(\n\t\t volume,\n\t\t volume_identifier,\n\t\t 16,\n\t\t NULL );\n\n\t\tlibfsext_volume_get_utf8_label_size(\n\t\t volume,\n\t\t &string_size,\n\t\t NULL );\n\n\t\tlibfsext_volume_get_utf8_label(\n\t\t volume,\n\t\t string_value,\n\t\t 64,\n\t\t NULL );\n\n\t\tlibfsext_volume_get_utf8_last_mount_path_size(\n\t\t volume,\n\t\t &string_size,\n\t\t NULL );\n\n\t\tlibfsext_volume_get_utf8_last_mount_path(\n\t\t volume,\n\t\t string_value,\n\t\t 64,\n\t\t NULL );\n\n\t\tlibfsext_volume_get_last_mount_time(\n\t\t volume,\n\t\t &posix_time,\n\t\t NULL );\n\n\t\tlibfsext_volume_get_last_written_time(\n\t\t volume,\n\t\t &posix_time,\n\t\t NULL );\n\n\t\tlibfsext_volume_get_number_of_file_entries(\n\t\t volume,\n\t\t &number_of_file_entries,\n\t\t NULL );\n\n\t\tlibfsext_volume_close(\n\t\t volume,\n\t\t NULL );\n\t}\n\tlibfsext_volume_free(\n\t &volume,\n\t NULL );\n\non_error_libbfio:\n\tlibbfio_handle_free(\n\t &file_io_handle,\n\t NULL );\n\n\treturn( 0 );\n", "Selected Statement": "int32_t posix_time                           = 0;", "Function Input": {"data": {"value": "0x10a6040 \"\""}, "size": {"value": "6970368"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "     size_t size,\n     uint32_t initial_value,\n     libcerror_error_t **error )\n{\n\tstatic char *function  = \"libfsext_checksum_calculate_crc32\";\n\tsize_t buffer_offset   = 0;\n\tuint32_t safe_checksum = 0;\n\tuint32_t table_index   = 0;\n\n\tif( checksum == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid checksum.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( buffer == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid buffer.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( size > (size_t) SSIZE_MAX )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM,\n\t\t \"%s: invalid size value exceeds maximum.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n        if( libfsext_checksum_crc32_table_computed == 0 )\n\t{\n\t\tlibfsext_checksum_initialize_crc32_table(\n\t\t 0x82f63b78UL );\n\t}\n\tsafe_checksum = initial_value ^ (uint32_t) 0xffffffffUL;\n\n        for( buffer_offset = 0;\n\t     buffer_offset < size;\n\t     buffer_offset++ )\n\t{\n\t\ttable_index = ( safe_checksum ^ buffer[ buffer_offset ] ) & 0x000000ffUL;\n\n\t\tsafe_checksum = libfsext_checksum_crc32_table[ table_index ] ^ ( safe_checksum >> 8 );\n        }\n        *checksum = safe_checksum ^ 0xffffffffUL;\n\n\treturn( 1 );\n", "Selected Statement": "size_t buffer_offset   = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "int LLVMFuzzerTestOneInput(\n     const uint8_t *data,\n     size_t size )\n{\n\tuint8_t string_value[ 64 ];\n\n\tlibbfio_handle_t *file_io_handle      = NULL;\n\tlibfsext_file_entry_t *root_directory = NULL;\n\tlibfsext_file_entry_t *sub_file_entry = NULL;\n\tlibfsext_volume_t *volume             = NULL;\n\tsize64_t file_size                    = 0;\n\tsize_t string_size                    = 0;\n\toff64_t file_offset                   = 0;\n\tint64_t posix_time_64bit              = 0;\n\tuint32_t value_32bit                  = 0;\n\tint32_t posix_time_32bit              = 0;\n\tuint16_t value_16bit                  = 0;\n\tuint8_t major_device_number           = 0;\n\tuint8_t minor_device_number           = 0;\n\tint number_of_extents                 = 0;\n\tint number_of_sub_file_entries        = 0;\n\tint result                            = 0;\n\n\tif( libbfio_memory_range_initialize(\n\t     &file_io_handle,\n\t     NULL ) != 1 )\n\t{\n\t\treturn( 0 );\n\t}\n\tif( libbfio_memory_range_set(\n\t     file_io_handle,\n\t     (uint8_t *) data,\n\t     size,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libbfio;\n\t}\n\tif( libfsext_volume_initialize(\n\t     &volume,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libbfio;\n\t}\n\tif( libfsext_volume_open_file_io_handle(\n\t     volume,\n\t     file_io_handle,\n\t     LIBFSEXT_OPEN_READ,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libfsext_volume;\n\t}\n\tif( libfsext_volume_get_root_directory(\n\t     volume,\n\t     &root_directory,\n\t     NULL ) == 1 )\n\t{\n\t\tif( libfsext_file_entry_get_number_of_sub_file_entries(\n\t\t     root_directory,\n\t\t     &number_of_sub_file_entries,\n\t\t     NULL ) != 1 )\n\t\t{\n\t\t\tgoto on_error_libfsext_root_directory;\n\t\t}\n\t\tif( number_of_sub_file_entries > 0 )\n\t\t{\n\t\t\tresult = libfsext_file_entry_get_sub_file_entry_by_index(\n\t\t\t          root_directory,\n\t\t\t          0,\n\t\t\t          &sub_file_entry,\n\t\t\t          NULL );\n\n\t\t\tif( result != -1 )\n\t\t\t{\n\t\t\t\tlibfsext_file_entry_get_inode_number(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &value_32bit,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfsext_file_entry_get_creation_time(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &posix_time_64bit,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfsext_file_entry_get_modification_time(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &posix_time_64bit,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfsext_file_entry_get_access_time(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &posix_time_64bit,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfsext_file_entry_get_inode_change_time(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &posix_time_64bit,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfsext_file_entry_get_deletion_time(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &posix_time_32bit,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfsext_file_entry_get_file_mode(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &value_16bit,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfsext_file_entry_get_number_of_links(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &value_16bit,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfsext_file_entry_get_owner_identifier(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &value_32bit,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfsext_file_entry_get_group_identifier(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &value_32bit,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfsext_file_entry_get_device_identifier(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &value_32bit,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfsext_file_entry_get_device_number(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &major_device_number,\n\t\t\t\t &minor_device_number,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfsext_file_entry_get_utf8_name_size(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &string_size,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfsext_file_entry_get_utf8_name(\n\t\t\t\t sub_file_entry,\n\t\t\t\t string_value,\n\t\t\t\t 64,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfsext_file_entry_get_utf8_symbolic_link_target_size(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &string_size,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfsext_file_entry_get_utf8_symbolic_link_target(\n\t\t\t\t sub_file_entry,\n\t\t\t\t string_value,\n\t\t\t\t 64,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfsext_file_entry_get_offset(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &file_offset,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfsext_file_entry_get_size(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &file_size,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfsext_file_entry_get_number_of_extents(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &number_of_extents,\n\t\t\t\t NULL );\n\t\t\t}\n\t\t\tlibfsext_file_entry_free(\n\t\t\t &sub_file_entry,\n\t\t\t NULL );\n\t\t}\non_error_libfsext_root_directory:\n\t\tlibfsext_file_entry_free(\n\t\t &root_directory,\n\t\t NULL );\n\t}\n\tlibfsext_volume_close(\n\t volume,\n\t NULL );\n\non_error_libfsext_volume:\n\tlibfsext_volume_free(\n\t &volume,\n\t NULL );\n\non_error_libbfio:\n\tlibbfio_handle_free(\n\t &file_io_handle,\n\t NULL );\n\n\treturn( 0 );\n", "Selected Statement": "int number_of_sub_file_entries        = 0;", "Function Input": {"data": {"value": "0x10a7070 \"\""}, "size": {"value": "6974464"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "int LLVMFuzzerTestOneInput(\n     const uint8_t *data,\n     size_t size )\n{\n\tuint8_t string_value[ 64 ];\n\n\tlibbfio_handle_t *file_io_handle = NULL;\n\tlibfsxfs_volume_t *volume        = NULL;\n\tsize_t string_size               = 0;\n\tuint8_t format_version           = 0;\n\tint result                       = 0;\n\n\tif( libbfio_memory_range_initialize(\n\t     &file_io_handle,\n\t     NULL ) != 1 )\n\t{\n\t\treturn( 0 );\n\t}\n\tif( libbfio_memory_range_set(\n\t     file_io_handle,\n\t     (uint8_t *) data,\n\t     size,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libbfio;\n\t}\n\tif( libfsxfs_volume_initialize(\n\t     &volume,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libbfio;\n\t}\n\tresult = libfsxfs_volume_open_file_io_handle(\n\t          volume,\n\t          file_io_handle,\n\t          LIBFSXFS_OPEN_READ,\n\t          NULL );\n\n\tif( result != -1 )\n\t{\n\t\tlibfsxfs_volume_get_format_version(\n\t\t volume,\n\t\t &format_version,\n\t\t NULL );\n\n\t\tlibfsxfs_volume_get_utf8_label_size(\n\t\t volume,\n\t\t &string_size,\n\t\t NULL );\n\n\t\tlibfsxfs_volume_get_utf8_label(\n\t\t volume,\n\t\t string_value,\n\t\t 64,\n\t\t NULL );\n\n\t\tlibfsxfs_volume_close(\n\t\t volume,\n\t\t NULL );\n\t}\n\tlibfsxfs_volume_free(\n\t &volume,\n\t NULL );\n\non_error_libbfio:\n\tlibbfio_handle_free(\n\t &file_io_handle,\n\t NULL );\n\n\treturn( 0 );\n", "Selected Statement": "uint8_t format_version           = 0;", "Function Input": {"data": {"value": "0x108c450 \"XFSB\""}, "size": {"value": "6899712"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "     size_t utf8_stream_size,\n     size_t *utf8_string_size,\n     libcerror_error_t **error )\n{\n\tstatic char *function                        = \"libuna_utf8_string_size_from_utf8_stream\";\n\tsize_t utf8_stream_index                     = 0;\n\tlibuna_unicode_character_t unicode_character = 0;\n\n\tif( utf8_stream == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid UTF-8 stream.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( utf8_stream_size > (size_t) SSIZE_MAX )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM,\n\t\t \"%s: invalid UTF-8 stream size value exceeds maximum.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( utf8_string_size == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid UTF-8 string size.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\t*utf8_string_size = 0;\n\n\tif( utf8_stream_size == 0 )\n\t{\n\t\treturn( 1 );\n\t}\n\t\n\tif( utf8_stream_size >= 3 )\n\t{\n\t\tif( ( utf8_stream[ 0 ] == 0x0ef )\n\t\t && ( utf8_stream[ 1 ] == 0x0bb )\n\t\t && ( utf8_stream[ 2 ] == 0x0bf ) )\n\t\t{\n\t\t\tutf8_stream_index += 3;\n\t\t}\n\t}\n\twhile( utf8_stream_index < utf8_stream_size )\n\t{\n\t\t\n\t\tif( libuna_unicode_character_copy_from_utf8(\n\t\t     &unicode_character,\n\t\t     utf8_stream,\n\t\t     utf8_stream_size,\n\t\t     &utf8_stream_index,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_CONVERSION,\n\t\t\t LIBCERROR_CONVERSION_ERROR_INPUT_FAILED,\n\t\t\t \"%s: unable to copy Unicode character from UTF-8 stream.\",\n\t\t\t function );\n\n\t\t\treturn( -1 );\n\t\t}\n\t\t\n\t\tif( libuna_unicode_character_size_to_utf8(\n\t\t     unicode_character,\n\t\t     utf8_string_size,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_CONVERSION,\n\t\t\t LIBCERROR_CONVERSION_ERROR_INPUT_FAILED,\n\t\t\t \"%s: unable to unable to determine size of Unicode character in UTF-8.\",\n\t\t\t function );\n\n\t\t\treturn( -1 );\n\t\t}\n\t\tif( unicode_character == 0 )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif( unicode_character != 0 )\n\t{\n\t\t*utf8_string_size += 1;\n\t}\n\treturn( 1 );\n", "Selected Statement": "size_t utf8_stream_index                     = 0;", "Function Input": {"error": {"value": null}, "utf8_string_size": {"value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x200\n", "message": "Cannot access memory at address 0x200"}}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "int LLVMFuzzerTestOneInput(\n     const uint8_t *data,\n     size_t size )\n{\n\tlibbfio_handle_t *file_io_handle = NULL;\n\tlibcreg_file_t *file             = NULL;\n\tlibcreg_key_t *root_key          = NULL;\n\tlibcreg_key_t *sub_key           = NULL;\n\tlibcreg_value_t *value           = NULL;\n\tuint32_t value_type              = 0;\n\tint number_of_sub_keys           = 0;\n\tint number_of_values             = 0;\n\n\tif( libbfio_memory_range_initialize(\n\t     &file_io_handle,\n\t     NULL ) != 1 )\n\t{\n\t\treturn( 0 );\n\t}\n\tif( libbfio_memory_range_set(\n\t     file_io_handle,\n\t     (uint8_t *) data,\n\t     size,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libbfio;\n\t}\n\tif( libcreg_file_initialize(\n\t     &file,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libbfio;\n\t}\n\tif( libcreg_file_open_file_io_handle(\n\t     file,\n\t     file_io_handle,\n\t     LIBCREG_OPEN_READ,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libcreg_file;\n\t}\n\tif( libcreg_file_get_root_key(\n\t     file,\n\t     &root_key,\n\t     NULL ) == 1 )\n\t{\n\t\tif( libcreg_key_get_number_of_sub_keys(\n\t\t     root_key,\n\t\t     &number_of_sub_keys,\n\t\t     NULL ) != 1 )\n\t\t{\n\t\t\tgoto on_error_libcreg_root_key;\n\t\t}\n\t\tif( number_of_sub_keys > 0 )\n\t\t{\n\t\t\tif( libcreg_key_get_sub_key_by_index(\n\t\t\t     root_key,\n\t\t\t     0,\n\t\t\t     &sub_key,\n\t\t\t     NULL ) != 1 )\n\t\t\t{\n\t\t\t\tgoto on_error_libcreg_root_key;\n\t\t\t}\n\t\t\tif( libcreg_key_get_number_of_values(\n\t\t\t     sub_key,\n\t\t\t     &number_of_values,\n\t\t\t     NULL ) != 1 )\n\t\t\t{\n\t\t\t\tgoto on_error_libcreg_sub_key;\n\t\t\t}\n\t\t\tif( number_of_sub_keys > 0 )\n\t\t\t{\n\t\t\t\tif( libcreg_key_get_value_by_index(\n\t\t\t\t     root_key,\n\t\t\t\t     0,\n\t\t\t\t     &value,\n\t\t\t\t     NULL ) != 1 )\n\t\t\t\t{\n\t\t\t\t\tgoto on_error_libcreg_sub_key;\n\t\t\t\t}\n\t\t\t\tlibcreg_value_get_value_type(\n\t\t\t\t value,\n\t\t\t\t &value_type,\n\t\t\t\t NULL );\n\n\t\t\t\tlibcreg_value_free(\n\t\t\t\t &value,\n\t\t\t\t NULL );\n\t\t\t}\non_error_libcreg_sub_key:\n\t\t\tlibcreg_key_free(\n\t\t\t &sub_key,\n\t\t\t NULL );\n\t\t}\non_error_libcreg_root_key:\n\t\tlibcreg_key_free(\n\t\t &root_key,\n\t\t NULL );\n\t}\n\tlibcreg_file_close(\n\t file,\n\t NULL );\n\non_error_libcreg_file:\n\tlibcreg_file_free(\n\t &file,\n\t NULL );\n\non_error_libbfio:\n\tlibbfio_handle_free(\n\t &file_io_handle,\n\t NULL );\n\n\treturn( 0 );\n", "Selected Statement": "int number_of_sub_keys           = 0;", "Function Input": {"data": {"value": "0x116cea0 \"CRE\\002\""}, "size": {"value": "6879232"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "int libfsntfs_mft_entry_initialize(\n     libfsntfs_mft_entry_t **mft_entry,\n     libcerror_error_t **error )\n{\n\tstatic char *function = \"libfsntfs_mft_entry_initialize\";\n\n\tif( mft_entry == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid MFT entry.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *mft_entry != NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\n\t\t \"%s: invalid MFT entry value already set.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\t*mft_entry = memory_allocate_structure(\n\t              libfsntfs_mft_entry_t );\n\n\tif( *mft_entry == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create MFT entry.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     *mft_entry,\n\t     0,\n\t     sizeof( libfsntfs_mft_entry_t ) ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear MFT entry.\",\n\t\t function );\n\n\t\tmemory_free(\n\t\t *mft_entry );\n\n\t\t*mft_entry = NULL;\n\n\t\treturn( -1 );\n\t}\n\tif( libcdata_array_initialize(\n\t     &( ( *mft_entry )->attributes_array ),\n\t     0,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create attributes array.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( libcdata_array_initialize(\n\t     &( ( *mft_entry )->alternate_data_attributes_array ),\n\t     0,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create alternate data attributes array.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\t( *mft_entry )->file_name_attribute_index            = -1;\n\t( *mft_entry )->reparse_point_attribute_index        = -1;\n\t( *mft_entry )->security_descriptor_attribute_index  = -1;\n\t( *mft_entry )->standard_information_attribute_index = -1;\n\t( *mft_entry )->volume_information_attribute_index   = -1;\n\t( *mft_entry )->volume_name_attribute_index          = -1;\n\n\treturn( 1 );\n\non_error:\n\tif( *mft_entry != NULL )\n\t{\n\t\tif( ( *mft_entry )->alternate_data_attributes_array != NULL )\n\t\t{\n\t\t\tlibcdata_array_free(\n\t\t\t &( ( *mft_entry )->alternate_data_attributes_array ),\n\t\t\t NULL,\n\t\t\t NULL );\n\t\t}\n\t\tif( ( *mft_entry )->attributes_array != NULL )\n\t\t{\n\t\t\tlibcdata_array_free(\n\t\t\t &( ( *mft_entry )->attributes_array ),\n\t\t\t NULL,\n\t\t\t NULL );\n\t\t}\n\t\tmemory_free(\n\t\t *mft_entry );\n\n\t\t*mft_entry = NULL;\n\t}\n\treturn( -1 );\n", "Selected Statement": "( *mft_entry )->reparse_point_attribute_index        = -1;", "Function Input": {"error": {"value": {"type_category": "pointer", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xffffffffffffffff\n", "message": "Cannot access memory at address 0xffffffffffffffff"}}}, "Variable Values Before Statement": {"constant": "-1"}, "Value After Statement Execution": "-1", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "int LLVMFuzzerTestOneInput(\n     const uint8_t *data,\n     size_t size )\n{\n\tlibbfio_handle_t *file_io_handle                  = NULL;\n\tlibfsext_extended_attribute_t *extended_attribute = NULL;\n\tlibfsext_file_entry_t *file_entry                 = NULL;\n\tlibfsext_volume_t *volume                         = NULL;\n\tint number_of_extended_attributes                 = 0;\n\tint result                                        = 0;\n\n\tif( libbfio_memory_range_initialize(\n\t     &file_io_handle,\n\t     NULL ) != 1 )\n\t{\n\t\treturn( 0 );\n\t}\n\tif( libbfio_memory_range_set(\n\t     file_io_handle,\n\t     (uint8_t *) data,\n\t     size,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libbfio;\n\t}\n\tif( libfsext_volume_initialize(\n\t     &volume,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libbfio;\n\t}\n\tif( libfsext_volume_open_file_io_handle(\n\t     volume,\n\t     file_io_handle,\n\t     LIBFSEXT_OPEN_READ,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libfsext_volume;\n\t}\n\tresult = libfsext_volume_get_file_entry_by_utf8_path(\n\t          volume,\n\t          (uint8_t *) \"/a_directory/a_file\",\n\t          19,\n\t          &file_entry,\n\t          NULL );\n\n\tif( result == 1 )\n\t{\n\t\tif( libfsext_file_entry_get_number_of_extended_attributes(\n\t\t     file_entry,\n\t\t     &number_of_extended_attributes,\n\t\t     NULL ) != 1 )\n\t\t{\n\t\t\tgoto on_error_libfsext_file_entry;\n\t\t}\n\t\tif( number_of_extended_attributes > 0 )\n\t\t{\n\t\t\tif( libfsext_file_entry_get_extended_attribute_by_index(\n\t\t\t     file_entry,\n\t\t\t     0,\n\t\t\t     &extended_attribute,\n\t\t\t     NULL ) != 1 )\n\t\t\t{\n\t\t\t\tgoto on_error_libfsext_file_entry;\n\t\t\t}\n\t\t\tlibfsext_extended_attribute_free(\n\t\t\t &extended_attribute,\n\t\t\t NULL );\n\t\t}\non_error_libfsext_file_entry:\n\t\tlibfsext_file_entry_free(\n\t\t &file_entry,\n\t\t NULL );\n\t}\n\tlibfsext_volume_close(\n\t volume,\n\t NULL );\n\non_error_libfsext_volume:\n\tlibfsext_volume_free(\n\t &volume,\n\t NULL );\n\non_error_libbfio:\n\tlibbfio_handle_free(\n\t &file_io_handle,\n\t NULL );\n\n\treturn( 0 );\n", "Selected Statement": "int number_of_extended_attributes                 = 0;", "Function Input": {"data": {"value": "0x10a6140 \"\""}, "size": {"value": "6970368"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "int LLVMFuzzerTestOneInput(\n     const uint8_t *data,\n     size_t size )\n{\n\tuint8_t string_value[ 64 ];\n\n\tlibbfio_handle_t *file_io_handle      = NULL;\n\tlibfshfs_file_entry_t *root_directory = NULL;\n\tlibfshfs_file_entry_t *sub_file_entry = NULL;\n\tlibfshfs_volume_t *volume             = NULL;\n\tsize64_t file_size                    = 0;\n\tsize_t string_size                    = 0;\n\toff64_t file_offset                   = 0;\n\tuint32_t hfs_time                     = 0;\n\tuint32_t major_device_number          = 0;\n\tuint32_t minor_device_number          = 0;\n\tuint32_t value_32bit                  = 0;\n\tint32_t posix_time                    = 0;\n\tuint16_t value_16bit                  = 0;\n\tint number_of_extents                 = 0;\n\tint number_of_sub_file_entries        = 0;\n\tint result                            = 0;\n\n\tif( libbfio_memory_range_initialize(\n\t     &file_io_handle,\n\t     NULL ) != 1 )\n\t{\n\t\treturn( 0 );\n\t}\n\tif( libbfio_memory_range_set(\n\t     file_io_handle,\n\t     (uint8_t *) data,\n\t     size,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libbfio;\n\t}\n\tif( libfshfs_volume_initialize(\n\t     &volume,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libbfio;\n\t}\n\tif( libfshfs_volume_open_file_io_handle(\n\t     volume,\n\t     file_io_handle,\n\t     LIBFSHFS_OPEN_READ,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libfshfs_volume;\n\t}\n\tif( libfshfs_volume_get_root_directory(\n\t     volume,\n\t     &root_directory,\n\t     NULL ) == 1 )\n\t{\n\t\tif( libfshfs_file_entry_get_number_of_sub_file_entries(\n\t\t     root_directory,\n\t\t     &number_of_sub_file_entries,\n\t\t     NULL ) != 1 )\n\t\t{\n\t\t\tgoto on_error_libfshfs_root_directory;\n\t\t}\n\t\tif( number_of_sub_file_entries > 0 )\n\t\t{\n\t\t\tresult = libfshfs_file_entry_get_sub_file_entry_by_index(\n\t\t\t          root_directory,\n\t\t\t          0,\n\t\t\t          &sub_file_entry,\n\t\t\t          NULL );\n\n\t\t\tif( result != -1 )\n\t\t\t{\n\t\t\t\tlibfshfs_file_entry_get_identifier(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &value_32bit,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfshfs_file_entry_get_parent_identifier(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &value_32bit,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfshfs_file_entry_get_link_identifier(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &value_32bit,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfshfs_file_entry_get_creation_time(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &hfs_time,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfshfs_file_entry_get_access_time(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &hfs_time,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfshfs_file_entry_get_backup_time(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &hfs_time,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfshfs_file_entry_get_added_time(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &posix_time,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfshfs_file_entry_get_file_mode(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &value_16bit,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfshfs_file_entry_get_number_of_links(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &value_32bit,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfshfs_file_entry_get_owner_identifier(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &value_32bit,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfshfs_file_entry_get_group_identifier(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &value_32bit,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfshfs_file_entry_get_device_identifier(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &value_32bit,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfshfs_file_entry_get_device_number(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &major_device_number,\n\t\t\t\t &minor_device_number,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfshfs_file_entry_get_utf8_name_size(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &string_size,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfshfs_file_entry_get_utf8_name(\n\t\t\t\t sub_file_entry,\n\t\t\t\t string_value,\n\t\t\t\t 64,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfshfs_file_entry_get_utf8_symbolic_link_target_size(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &string_size,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfshfs_file_entry_get_utf8_symbolic_link_target(\n\t\t\t\t sub_file_entry,\n\t\t\t\t string_value,\n\t\t\t\t 64,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfshfs_file_entry_has_resource_fork(\n\t\t\t\t sub_file_entry,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfshfs_file_entry_get_offset(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &file_offset,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfshfs_file_entry_get_size(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &file_size,\n\t\t\t\t NULL );\n\n\t\t\t\tlibfshfs_file_entry_get_number_of_extents(\n\t\t\t\t sub_file_entry,\n\t\t\t\t &number_of_extents,\n\t\t\t\t NULL );\n\t\t\t}\n\t\t\tlibfshfs_file_entry_free(\n\t\t\t &sub_file_entry,\n\t\t\t NULL );\n\t\t}\non_error_libfshfs_root_directory:\n\t\tlibfshfs_file_entry_free(\n\t\t &root_directory,\n\t\t NULL );\n\t}\n\tlibfshfs_volume_close(\n\t volume,\n\t NULL );\n\non_error_libfshfs_volume:\n\tlibfshfs_volume_free(\n\t &volume,\n\t NULL );\n\non_error_libbfio:\n\tlibbfio_handle_free(\n\t &file_io_handle,\n\t NULL );\n\n\treturn( 0 );\n", "Selected Statement": "int32_t posix_time                    = 0;", "Function Input": {"data": {"value": "0x10ec8c0 \"\""}, "size": {"value": "7245312"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "int libevtx_io_handle_initialize(\n     libevtx_io_handle_t **io_handle,\n     libcerror_error_t **error )\n{\n\tstatic char *function = \"libevtx_io_handle_initialize\";\n\n\tif( io_handle == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid IO handle.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *io_handle != NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\n\t\t \"%s: invalid IO handle value already set.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\t*io_handle = memory_allocate_structure(\n\t              libevtx_io_handle_t );\n\n\tif( *io_handle == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create IO handle.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     *io_handle,\n\t     0,\n\t     sizeof( libevtx_io_handle_t ) ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear IO handle.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\t( *io_handle )->chunk_size     = 0x00010000UL;\n\t( *io_handle )->ascii_codepage = LIBEVTX_CODEPAGE_WINDOWS_1252;\n\n\treturn( 1 );\n\non_error:\n\tif( *io_handle != NULL )\n\t{\n\t\tmemory_free(\n\t\t *io_handle );\n\n\t\t*io_handle = NULL;\n\t}\n\treturn( -1 );\n", "Selected Statement": "( *io_handle )->chunk_size     = 0x00010000UL;", "Function Input": {"error": {"value": {"type_category": "pointer", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x1004c6f20\n", "message": "Cannot access memory at address 0x1004c6f20"}}, "io_handle": {"value": {"type_category": "pointer", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x18\n", "message": "Cannot access memory at address 0x18"}}}, "Variable Values Before Statement": {"constant": "0x00010000UL"}, "Value After Statement Execution": "0x00010000UL", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "                libcerror_error_t **error ),\n     uint8_t flags,\n     libcerror_error_t **error )\n{\n\tlibfdata_internal_stream_t *internal_stream = NULL;\n\tstatic char *function                       = \"libfdata_stream_initialize\";\n\n\tif( stream == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid stream.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *stream != NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\n\t\t \"%s: invalid stream value already set.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( ( flags & 0xfe ) != 0 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_UNSUPPORTED_VALUE,\n\t\t \"%s: unsupported flags: 0x%02\" PRIx8 \".\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tinternal_stream = memory_allocate_structure(\n\t                   libfdata_internal_stream_t );\n\n\tif( internal_stream == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create stream.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     internal_stream,\n\t     0,\n\t     sizeof( libfdata_internal_stream_t ) ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear stream.\",\n\t\t function );\n\n\t\tmemory_free(\n\t\t internal_stream );\n\n\t\treturn( -1 );\n\t}\n\tif( libcdata_array_initialize(\n\t     &( internal_stream->segments_array ),\n\t     0,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create segments array.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( libcdata_array_initialize(\n\t     &( internal_stream->mapped_ranges_array ),\n\t     0,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create mapped ranges array.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tinternal_stream->segment_offset      = -1;\n\tinternal_stream->flags              |= flags;\n\tinternal_stream->data_handle         = data_handle;\n\tinternal_stream->free_data_handle    = free_data_handle;\n\tinternal_stream->clone_data_handle   = clone_data_handle;\n\tinternal_stream->create_segment      = create_segment;\n\tinternal_stream->read_segment_data   = read_segment_data;\n\tinternal_stream->write_segment_data  = write_segment_data;\n\tinternal_stream->seek_segment_offset = seek_segment_offset;\n\n\t*stream = (libfdata_stream_t *) internal_stream;\n\n\treturn( 1 );\n\non_error:\n\tif( internal_stream != NULL )\n\t{\n\t\tif( internal_stream->segments_array != NULL )\n\t\t{\n\t\t\tlibcdata_array_free(\n\t\t\t &( internal_stream->segments_array ),\n\t\t\t NULL,\n\t\t\t NULL );\n\t\t}\n\t\tmemory_free(\n\t\t internal_stream );\n\t}\n\treturn( -1 );\n", "Selected Statement": "internal_stream->segment_offset      = -1;", "Function Input": {"data_handle": {"value": {"type_category": "unknown", "concrete_type": "intptr_t", "value": "17218720"}}, "error": {"value": {"type_category": "pointer", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x5b0000006e\n", "message": "Cannot access memory at address 0x5b0000006e"}}, "flags": {"value": "0 '\\000'"}, "stream": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7ffff7cce299 <malloc+441>", "value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x840fc08548c08949\n", "message": "Cannot access memory at address 0x840fc08548c08949"}}}}, "Variable Values Before Statement": {"constant": "-1"}, "Value After Statement Execution": "-1", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "     size64_t segment_size,\n     uint32_t segment_flags,\n     libcerror_error_t **error )\n{\n\tlibfdata_mapped_range_t *mapped_range = NULL;\n\tlibfdata_range_t *segment_data_range  = NULL;\n\tstatic char *function                 = \"libfdata_segments_array_set_segment_by_index\";\n\toff64_t previous_segment_offset       = 0;\n\tsize64_t previous_segment_size        = 0;\n\tuint32_t previous_segment_flags       = 0;\n\tint previous_segment_file_index       = 0;\n\n\tif( data_size == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid data size.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( segment_file_index < 0 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: invalid segment file index value out of bounds.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( segment_offset < 0 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: invalid segment offset value out of bounds.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( libcdata_array_get_entry_by_index(\n\t     segments_array,\n\t     segment_index,\n\t     (intptr_t **) &segment_data_range,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_GET_FAILED,\n\t\t \"%s: unable to retrieve entry: %d from segments array.\",\n\t\t function,\n\t\t segment_index );\n\n\t\treturn( -1 );\n\t}\n\tif( segment_data_range == NULL )\n\t{\n\t\tif( libfdata_range_initialize(\n\t\t     &segment_data_range,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t\t \"%s: unable to create segment data range.\",\n\t\t\t function );\n\n\t\t\treturn( -1 );\n\t\t}\n\t\tif( libcdata_array_set_entry_by_index(\n\t\t     segments_array,\n\t\t     segment_index,\n\t\t     (intptr_t *) segment_data_range,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_SET_FAILED,\n\t\t\t \"%s: unable to set entry: %d to segments array.\",\n\t\t\t function,\n\t\t\t segment_index );\n\n\t\t\tlibfdata_range_free(\n\t\t\t &segment_data_range,\n\t\t\t NULL );\n\n\t\t\treturn( -1 );\n\t\t}\n\t}\n\telse\n\t{\n\t\tif( libfdata_range_get(\n\t\t     segment_data_range,\n\t\t     &previous_segment_file_index,\n\t\t     &previous_segment_offset,\n\t\t     &previous_segment_size,\n\t\t     &previous_segment_flags,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_GET_FAILED,\n\t\t\t \"%s: unable to retrieve segment: %d data range values.\",\n\t\t\t function,\n\t\t\t segment_index );\n\n\t\t\treturn( -1 );\n\t\t}\n\t\t*data_size -= previous_segment_size;\n\t}\n\tif( libfdata_range_set(\n\t     segment_data_range,\n\t     segment_file_index,\n\t     segment_offset,\n\t     segment_size,\n\t     segment_flags,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_SET_FAILED,\n\t\t \"%s: unable to set segment data range values.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\t\n\tif( libcdata_array_get_entry_by_index(\n\t     mapped_ranges_array,\n\t     segment_index,\n\t     (intptr_t **) &mapped_range,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_GET_FAILED,\n\t\t \"%s: unable to retrieve entry: %d from mapped ranges array.\",\n\t\t function,\n\t\t segment_index );\n\n\t\treturn( -1 );\n\t}\n\tif( mapped_range == NULL )\n\t{\n\t\tif( libfdata_mapped_range_initialize(\n\t\t     &mapped_range,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t\t \"%s: unable to create mapped range.\",\n\t\t\t function );\n\n\t\t\treturn( -1 );\n\t\t}\n\t\tif( libcdata_array_set_entry_by_index(\n\t\t     mapped_ranges_array,\n\t\t     segment_index,\n\t\t     (intptr_t *) mapped_range,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_SET_FAILED,\n\t\t\t \"%s: unable to set entry: %d in mapped ranges array.\",\n\t\t\t function,\n\t\t\t segment_index );\n\n\t\t\tlibfdata_mapped_range_free(\n\t\t\t &mapped_range,\n\t\t\t NULL );\n\n\t\t\treturn( -1 );\n\t\t}\n\t}\n\t*data_size += segment_size;\n\n\treturn( 1 );\n", "Selected Statement": "static char *function                 = \"libfdata_segments_array_set_segment_by_index\";", "Function Input": {"error": {"value": {"type_category": "pointer", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x1004fb7c6\n", "message": "Cannot access memory at address 0x1004fb7c6"}}, "segment_file_index": {"value": "48"}, "segment_flags": {"value": "32767"}, "segment_index": {"value": "1"}, "segment_offset": {"value": "17174704"}, "segment_size": {"value": "5113557"}, "segments_array": {"value": {"type_category": "unknown", "concrete_type": "libcdata_array_t", "value": "3525336957436119125"}}}, "Variable Values Before Statement": {"constant": "\"libfdata_segments_array_set_segment_by_index\""}, "Value After Statement Execution": "\"libfdata_segments_array_set_segment_by_index\"", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "int libfdata_range_initialize(\n     libfdata_range_t **range,\n     libcerror_error_t **error )\n{\n\tstatic char *function = \"libfdata_range_initialize\";\n\n\tif( range == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid range.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *range != NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\n\t\t \"%s: invalid range value already set.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\t*range = memory_allocate_structure(\n\t          libfdata_range_t );\n\n\tif( *range == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create range.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     *range,\n\t     0,\n\t     sizeof( libfdata_range_t ) ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear range.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\t( *range )->file_index = -1;\n\t( *range )->offset     = (off64_t) -1;\n\n\treturn( 1 );\n\non_error:\n\tif( *range != NULL )\n\t{\n\t\tmemory_free(\n\t\t *range );\n\n\t\t*range = NULL;\n\t}\n\treturn( -1 );\n", "Selected Statement": "( *range )->file_index = -1;", "Function Input": {"error": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x4e039f <libcdata_internal_array_resize+1039>", "value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x858bffffff608d8b\n", "message": "Cannot access memory at address 0x858bffffff608d8b"}}}, "range": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x1073810", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x100000010\n", "message": "Cannot access memory at address 0x100000010"}}}}, "Variable Values Before Statement": {"constant": "-1"}, "Value After Statement Execution": "-1", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "     libfdata_list_t *compressed_blocks_list,\n     libfcache_cache_t *compressed_blocks_cache,\n     libcerror_error_t **error )\n{\n\tlibagdb_compressed_blocks_stream_data_handle_t *data_handle = NULL;\n\tstatic char *function                                       = \"libagdb_compressed_blocks_stream_initialize\";\n\toff64_t segment_offset                                      = 0;\n\tsize64_t segment_size                                       = 0;\n\tint element_index                                           = 0;\n\tint number_of_elements                                      = 0;\n\tint segment_index                                           = 0;\n\n\tif( compressed_blocks_stream == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid compressed block stream.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( compressed_blocks_list == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid compressed blocks list.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( libagdb_compressed_blocks_stream_data_handle_initialize(\n\t     &data_handle,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create data handle.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( data_handle == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_MISSING,\n\t\t \"%s: missing data handle.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tdata_handle->compressed_blocks_list  = compressed_blocks_list;\n\tdata_handle->compressed_blocks_cache = compressed_blocks_cache;\n\n\tif( libfdata_stream_initialize(\n\t     compressed_blocks_stream,\n\t     (intptr_t *) data_handle,\n\t     (int (*)(intptr_t **, libcerror_error_t **)) &libagdb_compressed_blocks_stream_data_handle_free,\n\t     NULL,\n\t     NULL,\n\t     (ssize_t (*)(intptr_t *, intptr_t *, int, int, uint8_t *, size_t, uint32_t, uint8_t, libcerror_error_t **)) &libagdb_compressed_blocks_stream_data_handle_read_segment_data,\n\t     NULL,\n\t     (off64_t (*)(intptr_t *, intptr_t *, int, int, off64_t, libcerror_error_t **)) &libagdb_compressed_blocks_stream_data_handle_seek_segment_offset,\n\t     LIBFDATA_DATA_HANDLE_FLAG_MANAGED,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create stream.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( libfdata_list_get_number_of_elements(\n\t     compressed_blocks_list,\n\t     &number_of_elements,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_GET_FAILED,\n\t\t \"%s: unable to retrieve number of compressed blocks list elements.\",\n\t\t function );\n\n\t\tdata_handle = NULL;\n\n\t\tgoto on_error;\n\t}\n\tfor( element_index = 0;\n\t     element_index < number_of_elements;\n\t     element_index++ )\n\t{\n\t\tif( libfdata_list_get_mapped_size_by_index(\n\t\t     compressed_blocks_list,\n\t\t     element_index,\n\t\t     &segment_size,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_GET_FAILED,\n\t\t\t \"%s: unable to retrieve compressed blocks list element: %d mapped size.\",\n\t\t\t function,\n\t\t\t element_index );\n\n\t\t\tdata_handle = NULL;\n\n\t\t\tgoto on_error;\n\t\t}\n\t\tif( libfdata_stream_append_segment(\n\t\t     *compressed_blocks_stream,\n\t\t     &segment_index,\n\t\t     0,\n\t\t     segment_offset,\n\t\t     segment_size,\n\t\t     0,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_APPEND_FAILED,\n\t\t\t \"%s: unable to append compressed blocks stream segment: %d.\",\n\t\t\t function,\n\t\t\t element_index );\n\n\t\t\tdata_handle = NULL;\n\n\t\t\tgoto on_error;\n\t\t}\n\t\tsegment_offset += segment_size;\n\t}\n\treturn( 1 );\n\non_error:\n\tif( *compressed_blocks_stream != NULL )\n\t{\n\t\tlibfdata_stream_free(\n\t\t compressed_blocks_stream,\n\t\t NULL );\n\t}\n\tif( data_handle != NULL )\n\t{\n\t\tlibagdb_compressed_blocks_stream_data_handle_free(\n\t\t &data_handle,\n\t\t NULL );\n\t}\n\treturn( -1 );\n", "Selected Statement": "off64_t segment_offset                                      = 0;", "Function Input": {"compressed_blocks_cache": {"value": null}, "compressed_blocks_list": {"value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x801087060\n", "message": "Cannot access memory at address 0x801087060"}}, "compressed_blocks_stream": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x11e6400", "value": {"type_category": "unknown", "concrete_type": "libfdata_stream_t", "value": "17303920"}}}, "error": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x108a300", "value": {"type_category": "unknown", "concrete_type": "libcerror_error_t", "value": "34359738384"}}}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "int LLVMFuzzerTestOneInput(\n     const uint8_t *data,\n     size_t size )\n{\n\tlibbfio_handle_t *file_io_handle                   = NULL;\n\tlibfsapfs_container_t *container                   = NULL;\n\tlibfsapfs_extended_attribute_t *extended_attribute = NULL;\n\tlibfsapfs_file_entry_t *file_entry                 = NULL;\n\tlibfsapfs_volume_t *volume                         = NULL;\n\tint number_of_extended_attributes                  = 0;\n\tint number_of_volumes                              = 0;\n\tint result                                         = 0;\n\n\tif( libbfio_memory_range_initialize(\n\t     &file_io_handle,\n\t     NULL ) != 1 )\n\t{\n\t\treturn( 0 );\n\t}\n\tif( libbfio_memory_range_set(\n\t     file_io_handle,\n\t     (uint8_t *) data,\n\t     size,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libbfio;\n\t}\n\tif( libfsapfs_container_initialize(\n\t     &container,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libbfio;\n\t}\n\tif( libfsapfs_container_open_file_io_handle(\n\t     container,\n\t     file_io_handle,\n\t     LIBFSAPFS_OPEN_READ,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libfsapfs_container;\n\t}\n\tif( libfsapfs_container_get_number_of_volumes(\n\t     container,\n\t     &number_of_volumes,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libfsapfs_container;\n\t}\n\tif( number_of_volumes > 0 )\n\t{\n\t\tif( libfsapfs_container_get_volume_by_index(\n\t\t     container,\n\t\t     0,\n\t\t     &volume,\n\t\t     NULL ) != 1 )\n\t\t{\n\t\t\tgoto on_error_libfsapfs_container;\n\t\t}\n\t\tresult = libfsapfs_volume_get_file_entry_by_utf8_path(\n\t\t          volume,\n\t\t          (uint8_t *) \"/a_directory/a_file\",\n\t\t          19,\n\t\t          &file_entry,\n\t\t          NULL );\n\n\t\tif( result == 1 )\n\t\t{\n\t\t\tif( libfsapfs_file_entry_get_number_of_extended_attributes(\n\t\t\t     file_entry,\n\t\t\t     &number_of_extended_attributes,\n\t\t\t     NULL ) != 1 )\n\t\t\t{\n\t\t\t\tgoto on_error_libfsapfs_file_entry;\n\t\t\t}\n\t\t\tif( number_of_extended_attributes > 0 )\n\t\t\t{\n\t\t\t\tif( libfsapfs_file_entry_get_extended_attribute_by_index(\n\t\t\t\t     file_entry,\n\t\t\t\t     0,\n\t\t\t\t     &extended_attribute,\n\t\t\t\t     NULL ) != 1 )\n\t\t\t\t{\n\t\t\t\t\tgoto on_error_libfsapfs_file_entry;\n\t\t\t\t}\n\t\t\t\tlibfsapfs_extended_attribute_free(\n\t\t\t\t &extended_attribute,\n\t\t\t\t NULL );\n\t\t\t}\non_error_libfsapfs_file_entry:\n\t\t\tlibfsapfs_file_entry_free(\n\t\t\t &file_entry,\n\t\t\t NULL );\n\t\t}\n\t\tlibfsapfs_volume_free(\n\t\t &volume,\n\t\t NULL );\n\t}\non_error_libfsapfs_container:\n\tlibfsapfs_container_free(\n\t &container,\n\t NULL );\n\non_error_libbfio:\n\tlibbfio_handle_free(\n\t &file_io_handle,\n\t NULL );\n\n\treturn( 0 );\n", "Selected Statement": "int number_of_extended_attributes                  = 0;", "Function Input": {"data": {"value": "0x112efb0 \"\\005z\\f]U)&\\254\\001\""}, "size": {"value": "7513600"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "int LLVMFuzzerTestOneInput(\n     const uint8_t *data,\n     size_t size )\n{\n\tlibbfio_handle_t *file_io_handle = NULL;\n\tlibesedb_file_t *file            = NULL;\n\tlibesedb_record_t *record        = NULL;\n\tlibesedb_table_t *table          = NULL;\n\tint number_of_records            = 0;\n\tint number_of_tables             = 0;\n\n\tif( libbfio_memory_range_initialize(\n\t     &file_io_handle,\n\t     NULL ) != 1 )\n\t{\n\t\treturn( 0 );\n\t}\n\tif( libbfio_memory_range_set(\n\t     file_io_handle,\n\t     (uint8_t *) data,\n\t     size,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libbfio;\n\t}\n\tif( libesedb_file_initialize(\n\t     &file,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libbfio;\n\t}\n\tif( libesedb_file_open_file_io_handle(\n\t     file,\n\t     file_io_handle,\n\t     LIBESEDB_OPEN_READ,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libesedb_file;\n\t}\n\tif( libesedb_file_get_number_of_tables(\n\t     file,\n\t     &number_of_tables,\n\t     NULL ) != 1 )\n\t{\n\t\tgoto on_error_libesedb_file;\n\t}\n\tif( number_of_tables > 0 )\n\t{\n\t\tif( libesedb_file_get_table(\n\t\t     file,\n\t\t     0,\n\t\t     &table,\n\t\t     NULL ) == 1 )\n\t\t{\n\t\t\tif( libesedb_table_get_number_of_records(\n\t\t\t     table,\n\t\t\t     &number_of_records,\n\t\t\t     NULL ) != 1 )\n\t\t\t{\n\t\t\t\tgoto on_error_libesedb_table;\n\t\t\t}\n\t\t\tif( number_of_records > 0 )\n\t\t\t{\n\t\t\t\tif( libesedb_table_get_record(\n\t\t\t\t     table,\n\t\t\t\t     0,\n\t\t\t\t     &record,\n\t\t\t\t     NULL ) == 1 )\n\t\t\t\t{\n\t\t\t\t\tlibesedb_record_free(\n\t\t\t\t\t &record,\n\t\t\t\t\t NULL );\n\t\t\t\t}\n\t\t\t}\non_error_libesedb_table:\n\t\t\tlibesedb_table_free(\n\t\t\t &table,\n\t\t\t NULL );\n\t\t}\n\t}\n\tlibesedb_file_close(\n\t file,\n\t NULL );\n\non_error_libesedb_file:\n\tlibesedb_file_free(\n\t &file,\n\t NULL );\n\non_error_libbfio:\n\tlibbfio_handle_free(\n\t &file_io_handle,\n\t NULL );\n\n\treturn( 0 );\n", "Selected Statement": "int number_of_records            = 0;", "Function Input": {"data": {"value": "0x117af00 \"\\a|\\026\\a\\357\\315\\253\\211 \\006\""}, "size": {"value": "7827968"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "void\ndns_message_create(isc_mem_t *mctx, isc_mempool_t *namepool,\n\t\t   isc_mempool_t *rdspool, dns_message_intent_t intent,\n\t\t   dns_message_t **msgp) {\n\tREQUIRE(mctx != NULL);\n\tREQUIRE(msgp != NULL);\n\tREQUIRE(*msgp == NULL);\n\tREQUIRE(intent == DNS_MESSAGE_INTENTPARSE ||\n\t\tintent == DNS_MESSAGE_INTENTRENDER);\n\tREQUIRE((namepool != NULL && rdspool != NULL) ||\n\t\t(namepool == NULL && rdspool == NULL));\n\n\tdns_message_t *msg = isc_mem_get(mctx, sizeof(dns_message_t));\n\t*msg = (dns_message_t){\n\t\t.from_to_wire = intent,\n\t\t.references = ISC_REFCOUNT_INITIALIZER(1),\n\t\t.scratchpad = ISC_LIST_INITIALIZER,\n\t\t.cleanup = ISC_LIST_INITIALIZER,\n\t\t.rdatas = ISC_LIST_INITIALIZER,\n\t\t.rdatalists = ISC_LIST_INITIALIZER,\n\t\t.offsets = ISC_LIST_INITIALIZER,\n\t\t.freerdata = ISC_LIST_INITIALIZER,\n\t\t.freerdatalist = ISC_LIST_INITIALIZER,\n\t\t.magic = DNS_MESSAGE_MAGIC,\n\t\t.namepool = namepool,\n\t\t.rdspool = rdspool,\n\t\t.free_pools = (namepool == NULL && rdspool == NULL),\n\t};\n\n\tisc_mem_attach(mctx, &msg->mctx);\n\n\tif (msg->free_pools) {\n\t\tdns_message_createpools(mctx, &msg->namepool, &msg->rdspool);\n\t}\n\n\tmsginit(msg);\n\n\tfor (size_t i = 0; i < DNS_SECTION_MAX; i++) {\n\t\tISC_LIST_INIT(msg->sections[i]);\n\t}\n\n\tisc_buffer_t *dynbuf = NULL;\n\tisc_buffer_allocate(mctx, &dynbuf, SCRATCHPAD_SIZE);\n\tISC_LIST_APPEND(msg->scratchpad, dynbuf, link);\n\n\t*msgp = msg;\n", "Selected Statement": "for (size_t i = 0; i < DNS_SECTION_MAX; i++) {", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "bind9"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "#include <isc/result.h>\n\nisc_result_t\nisc_parse_uint32(uint32_t *uip, const char *string, int base) {\n\tunsigned long n;\n\tuint32_t r;\n\tchar *e;\n\tif (!isalnum((unsigned char)(string[0]))) {\n\t\treturn (ISC_R_BADNUMBER);\n\t}\n\terrno = 0;\n\tn = strtoul(string, &e, base);\n\tif (*e != '\\0') {\n\t\treturn (ISC_R_BADNUMBER);\n\t}\n\t\n\tr = (uint32_t)n;\n\tif ((n == ULONG_MAX && errno == ERANGE) || (n != (unsigned long)r)) {\n\t\treturn (ISC_R_RANGE);\n\t}\n\t*uip = r;\n\treturn (ISC_R_SUCCESS);\n", "Selected Statement": "errno = 0;", "Function Input": {"base": {"value": "-1"}, "string": {"value": "0x7ffffffed9b0 \"\\260\\334\\376\\377\\377\\177\""}, "uip": {"value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xffffffff00000000\n", "message": "Cannot access memory at address 0xffffffff00000000"}}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "bind9"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "    Dwarf_Ptr       errarg,\n    Dwarf_Debug *   ret_dbg,\n    Dwarf_Error *   error)\n{\n    unsigned ftype = 0;\n    unsigned endian = 0;\n    unsigned offsetsize = 0;\n    unsigned universalnumber = 0;\n    Dwarf_Unsigned   filesize = 0;\n    int res = 0;\n    int errcode = 0;\n\n    if (!ret_dbg) {\n        DWARF_DBG_ERROR(NULL,DW_DLE_DWARF_INIT_DBG_NULL,DW_DLV_ERROR);\n    }\n    \n    *ret_dbg = 0;\n    res = dwarf_object_detector_fd(fd, &ftype,\n        &endian,&offsetsize,&filesize,&errcode);\n    if (res == DW_DLV_NO_ENTRY) {\n        return res;\n    }\n    if (res == DW_DLV_ERROR) {\n        \n        DWARF_DBG_ERROR(NULL, DW_DLE_FILE_WRONG_TYPE, DW_DLV_ERROR);\n    }\n    switch(ftype) {\n    case DW_FTYPE_ELF: {\n        int res2 = 0;\n\n        res2 = _dwarf_elf_nlsetup(fd,\"\",\n            ftype,endian,offsetsize,filesize,\n            group_number,errhand,errarg,ret_dbg,error);\n        if (res2 != DW_DLV_OK) {\n            return res2;\n        }\n        set_global_paths_init(*ret_dbg,error);\n        return res2;\n        }\n    case DW_FTYPE_APPLEUNIVERSAL:\n    case DW_FTYPE_MACH_O: {\n        int resm = 0;\n\n        resm = _dwarf_macho_setup(fd,\"\",\n            universalnumber,\n            ftype,endian,offsetsize,filesize,\n            group_number,errhand,errarg,ret_dbg,error);\n        if (resm != DW_DLV_OK) {\n            return resm;\n        }\n        set_global_paths_init(*ret_dbg,error);\n        return resm;\n        }\n\n    case DW_FTYPE_PE: {\n        int resp = 0;\n\n        resp = _dwarf_pe_setup(fd,\n            \"\",\n            ftype,endian,offsetsize,filesize,\n            group_number,errhand,errarg,ret_dbg,error);\n        if (resp != DW_DLV_OK) {\n            return resp;\n        }\n        set_global_paths_init(*ret_dbg,error);\n        return resp;\n        }\n    default: break;\n    }\n    DWARF_DBG_ERROR(NULL, DW_DLE_FILE_WRONG_TYPE, DW_DLV_ERROR);\n    \n", "Selected Statement": "int res = 0;", "Function Input": {"error": {"value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xfe02dd63e9f26600\n", "message": "Cannot access memory at address 0xfe02dd63e9f26600"}}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libdwarf"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "    unsigned *offsetsize,\n    Dwarf_Unsigned  *filesize,\n    int *errcode)\n{\n    Dwarf_Unsigned fileoffsetbase = 0;\n    int res = 0;\n\n    res = _dwarf_object_detector_fd_a(fd,\n        ftype,endian,offsetsize,\n        fileoffsetbase,filesize,\n        errcode);\n", "Selected Statement": "Dwarf_Unsigned fileoffsetbase = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libdwarf"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "    Dwarf_Unsigned loc,\n    int seektype,\n    Dwarf_Unsigned *out_loc)\n{\n    Dwarf_Signed fsize = 0;\n    Dwarf_Signed sloc = 0;\n\n    sloc = (Dwarf_Signed)loc;\n    if (sloc < 0) {\n        return DW_DLV_ERROR;\n    }\n#ifdef _WIN64\n    fsize = (Dwarf_Signed)lseek(fd,(__int64)loc,seektype);\n#elif defined(_WIN32)\n    fsize = (Dwarf_Signed)lseek(fd,(off_t)loc,seektype);\n#else \n    fsize = (Dwarf_Signed)lseek(fd,(off_t)loc,seektype);\n#endif\n    if (fsize < 0) {\n        return DW_DLV_ERROR;\n    }\n    if (out_loc) {\n        *out_loc = (Dwarf_Unsigned)fsize;\n    }\n    return DW_DLV_OK;\n", "Selected Statement": "Dwarf_Signed fsize = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libdwarf"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "    Dwarf_Handler errhand,\n    Dwarf_Ptr errarg,\n    Dwarf_Debug *dbg,Dwarf_Error *error)\n{\n    Dwarf_Obj_Access_Interface_a *binary_interface = 0;\n    dwarf_macho_object_access_internals_t *intfc = 0;\n    int res = DW_DLV_OK;\n    int localerrnum = 0;\n    unsigned universalbinary_count = 0;\n\n    res = _dwarf_macho_object_access_init(\n        fd,\n        universalnumber,\n        ftype,endian,offsetsize,\n        &universalbinary_count,\n        filesize,\n        &binary_interface,\n        &localerrnum);\n    if (res != DW_DLV_OK) {\n        if (res == DW_DLV_NO_ENTRY) {\n            return res;\n        }\n        _dwarf_error(NULL, error, localerrnum);\n        return DW_DLV_ERROR;\n    }\n    \n    res = dwarf_object_init_b(binary_interface, errhand, errarg,\n        groupnumber, dbg, error);\n    if (res != DW_DLV_OK){\n        _dwarf_destruct_macho_access(binary_interface);\n        return res;\n    }\n    intfc = binary_interface->ai_object;\n    intfc->mo_path = strdup(true_path);\n    (*dbg)->de_obj_flags = intfc->mo_flags;\n    (*dbg)->de_obj_machine = intfc->mo_machine;\n    (*dbg)->de_universalbinary_index = universalnumber;\n    (*dbg)->de_universalbinary_count = universalbinary_count;\n    return res;\n", "Selected Statement": "int localerrnum = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libdwarf"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "int\n_dwarf_object_read_random(int fd, char *buf, Dwarf_Unsigned loc,\n    Dwarf_Unsigned size, Dwarf_Unsigned filesize, int *errc)\n{\n    Dwarf_Unsigned endpoint = 0;\n    int res = 0;\n\n    if (loc >= filesize) {\n        \n        *errc = DW_DLE_SEEK_OFF_END;\n        return DW_DLV_ERROR;\n    }\n    endpoint = loc+size;\n    if (endpoint < loc) {\n        \n        *errc = DW_DLE_READ_OFF_END;\n        return DW_DLV_ERROR;\n    }\n    if (endpoint > filesize) {\n        \n        *errc = DW_DLE_READ_OFF_END;\n        return DW_DLV_ERROR;\n    }\n    res = _dwarf_seekr(fd,loc,SEEK_SET,0);\n    if (res != DW_DLV_OK) {\n        *errc = DW_DLE_SEEK_ERROR;\n        return DW_DLV_ERROR;\n    }\n    res = _dwarf_readr(fd,buf,size,0);\n    if (res != DW_DLV_OK) {\n        *errc = DW_DLE_READ_ERROR;\n        return DW_DLV_ERROR;\n    }\n    return DW_DLV_OK;\n", "Selected Statement": "Dwarf_Unsigned endpoint = 0;", "Function Input": {"buf": {"value": "0x3 <error: Cannot access memory at address 0x3>"}, "errc": {"value": null}, "fd": {"value": "-10544"}, "filesize": {"value": "6002422"}, "loc": {"value": "140737348690585"}, "size": {"value": "3"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libdwarf"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "    Dwarf_Handler errhand,\n    Dwarf_Ptr errarg,\n    Dwarf_Debug *dbg,Dwarf_Error *error)\n{\n    Dwarf_Obj_Access_Interface_a *binary_interface = 0;\n    dwarf_elf_object_access_internals_t *intfc = 0;\n    int res = DW_DLV_OK;\n    int localerrnum = 0;\n\n    res = _dwarf_elf_object_access_init(\n        fd,\n        ftype,endian,offsetsize,filesize,\n        &binary_interface,\n        &localerrnum);\n    if (res != DW_DLV_OK) {\n        if (res == DW_DLV_NO_ENTRY) {\n            return res;\n        }\n        _dwarf_error(NULL, error, localerrnum);\n        return DW_DLV_ERROR;\n    }\n    \n    res = dwarf_object_init_b(binary_interface, errhand, errarg,\n        groupnumber, dbg, error);\n    if (res != DW_DLV_OK){\n        _dwarf_destruct_elf_nlaccess(binary_interface);\n        return res;\n    }\n    intfc = binary_interface->ai_object;\n    intfc->f_path = strdup(true_path);\n    (*dbg)->de_obj_machine = intfc->f_machine;\n    (*dbg)->de_obj_flags = intfc->f_flags;\n    return res;\n", "Selected Statement": "dwarf_elf_object_access_internals_t *intfc = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libdwarf"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "int\ndwarf_crc32 (Dwarf_Debug dbg,unsigned char *crcbuf,\n    Dwarf_Error *error)\n{\n    \n    \n\n    \n    Dwarf_Unsigned   fsize = 0;\n    \n    Dwarf_Unsigned  readlenu = 10000;\n    Dwarf_Unsigned  size_left = 0;\n    const unsigned char *readbuf = 0;\n    unsigned int   tcrc = 0;\n    unsigned int   init = 0;\n    int            fd = -1;\n    Dwarf_Unsigned   sz = 0;\n    int            res = 0;\n\n    CHECK_DBG(dbg,error,\"dwarf_crc32()\");\n    if (!crcbuf) {\n        return DW_DLV_NO_ENTRY;\n    }\n    if (!dbg->de_owns_fd) {\n        return DW_DLV_NO_ENTRY;\n    }\n    fd = dbg->de_fd;\n    if (fd < 0) {\n        return DW_DLV_NO_ENTRY;\n    }\n    fd = dbg->de_fd;\n    if (dbg->de_filesize) {\n        fsize = (size_t)dbg->de_filesize;\n    } else {\n        res = _dwarf_seekr(fd,0,SEEK_END,&sz);\n        if (res != DW_DLV_OK) {\n            _dwarf_error_string(dbg,error,DW_DLE_SEEK_ERROR,\n                \"DW_DLE_SEEK_ERROR: dwarf_crc32 seek \"\n                \"to end fails\");\n            return DW_DLV_ERROR;\n        }\n        fsize = sz;\n    }\n    if (fsize <= (Dwarf_Unsigned)500) {\n        \n        return DW_DLV_NO_ENTRY;\n    }\n    size_left = fsize;\n    res = _dwarf_seekr(fd,0,SEEK_SET,0);\n    if (res != DW_DLV_OK) {\n        _dwarf_error_string(dbg,error,DW_DLE_SEEK_ERROR,\n            \"DW_DLE_SEEK_ERROR: dwarf_crc32 seek \"\n            \"to start fails\");\n        return DW_DLV_ERROR;\n    }\n    readbuf = (unsigned char *)malloc(readlenu);\n    if (!readbuf) {\n        _dwarf_error_string(dbg,error,DW_DLE_ALLOC_FAIL,\n            \"DW_DLE_ALLOC_FAIL: dwarf_crc32 read buffer\"\n            \" alloc fails\");\n        return DW_DLV_ERROR;\n    }\n    while (size_left > 0) {\n        if (size_left < readlenu) {\n            readlenu = size_left;\n        }\n        res = _dwarf_readr(fd,(char *)readbuf,readlenu,0);\n        if (res != DW_DLV_OK) {\n            _dwarf_error_string(dbg,error,DW_DLE_READ_ERROR,\n                \"DW_DLE_READ_ERROR: dwarf_crc32 read fails \");\n            free((unsigned char*)readbuf);\n            return DW_DLV_ERROR;\n        }\n        \n        tcrc = (unsigned int)dwarf_basic_crc32(readbuf,\n            (unsigned long)readlenu,\n            (unsigned long)init);\n        init = tcrc;\n        size_left -= readlenu;\n    }\n    \n    free((unsigned char*)readbuf);\n    memcpy(crcbuf,(void *)&tcrc,4);\n    return DW_DLV_OK;\n", "Selected Statement": "unsigned int   init = 0;", "Function Input": {"crcbuf": {"value": null}, "dbg": {"value": "0xfd1bf0"}, "error": {"value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x100000003\n", "message": "Cannot access memory at address 0x100000003"}}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libdwarf"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "    the s_size and s_avail are set to zero. */\nint\ndwarfstring_constructor(struct dwarfstring_s *g)\n{\n    g->s_data = \"\";\n    g->s_size = 0;\n    g->s_avail = 0;\n    g->s_malloc = FALSE;\n", "Selected Statement": "g->s_size = 0;", "Function Input": {"g": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"s_data": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffe51000 <error: Cannot access memory at address 0x7fffffffe51000>"}, "s_size": {"type_category": "unknown", "concrete_type": "size_t", "value": "36028797016885248"}, "s_avail": {"type_category": "unknown", "concrete_type": "size_t", "value": "4237742080"}, "s_malloc": {"type_category": "int", "concrete_type": "unsigned char", "value": "0 '\\000'"}}}}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libdwarf"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "    const char  *key_type  ,\n    Dwarf_Debug_Fission_Per_CU *  percu_out,\n    Dwarf_Error *error)\n{\n    int sres = 0;\n    Dwarf_Unsigned percu_index = 0;\n    Dwarf_Xu_Index_Header xuhdr = 0;\n\n    CHECK_DBG(dbg,error,\"dwarf_get_debugfission_for_key()\");\n    if (!key || !key_type || !percu_out) {\n        _dwarf_error_string(0,error,DW_DLE_XU_TYPE_ARG_ERROR,\n            \"DW_DLE_XU_TYPE_ARG_ERROR: dw_key, dw_keytype, or \"\n            \"Dwarf_Debug_Fission_Per_CU pointer* to return \"\n            \"is not valid\");\n        return DW_DLV_ERROR;\n    }\n\n    sres = _dwarf_load_debug_info(dbg,error);\n    if (sres == DW_DLV_ERROR) {\n        return sres;\n    }\n    sres = _dwarf_load_debug_types(dbg,error);\n    if (sres == DW_DLV_ERROR) {\n        return sres;\n    }\n    \n    sres = _dwarf_get_xuhdr(dbg,key_type, &xuhdr,error);\n    if (sres != DW_DLV_OK) {\n        return sres;\n    }\n    \n    sres = _dwarf_search_fission_for_key(dbg,\n        xuhdr,key,&percu_index,error);\n    if (sres != DW_DLV_OK) {\n        return sres;\n    }\n    sres = transform_xu_to_dfp(xuhdr,percu_index,key,\n        key_type,percu_out,error);\n    return sres;\n", "Selected Statement": "int sres = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libdwarf"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "int\ndwarf_formaddr(Dwarf_Attribute attr,\n    Dwarf_Addr * return_addr, Dwarf_Error * error)\n{\n    Dwarf_Debug dbg = 0;\n    Dwarf_Addr ret_addr = 0;\n    Dwarf_CU_Context cu_context = 0;\n    Dwarf_Half attrform = 0;\n    int res = 0;\n\n    res  = get_attr_dbg(&dbg,&cu_context,attr,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    attrform = attr->ar_attribute_form;\n    if (dwarf_addr_form_is_indexed(attrform)) {\n        res = _dwarf_look_in_local_and_tied(\n            attrform,\n            cu_context,\n            attr->ar_debug_ptr,\n            return_addr,\n            error);\n        return res;\n    }\n    if (attrform == DW_FORM_addr ||\n        (cu_context->cc_producer == CC_PROD_METROWERKS &&\n        attrform == DW_FORM_ref_addr)\n            \n        ) {\n        Dwarf_Small *section_end =\n            _dwarf_calculate_info_section_end_ptr(cu_context);\n\n        READ_UNALIGNED_CK(dbg, ret_addr, Dwarf_Addr,\n            attr->ar_debug_ptr,\n            cu_context->cc_address_size,\n            error,section_end);\n        *return_addr = ret_addr;\n        return DW_DLV_OK;\n    }\n    generate_form_error(dbg,error,attrform,\n        DW_DLE_ATTR_FORM_BAD,\n        \"DW_DLE_ATTR_FORM_BAD\",\n        \"dwarf_formaddr\");\n    return DW_DLV_ERROR;\n", "Selected Statement": "Dwarf_Addr ret_addr = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libdwarf"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "    Dwarf_Debug dbg,\n    Dwarf_Unsigned *rnglists_count,\n    Dwarf_Error *error)\n{\n    int res = DW_DLV_ERROR;\n    Dwarf_Rnglists_Context *cxt = 0;\n    Dwarf_Unsigned count = 0;\n\n    CHECK_DBG(dbg,error,\"dwarf_load_rnglists\");\n    if (dbg->de_rnglists_context) {\n        if (rnglists_count) {\n            *rnglists_count = dbg->de_rnglists_context_count;\n        }\n        return DW_DLV_OK;\n    }\n    if (!dbg->de_debug_rnglists.dss_size) {\n        \n        return DW_DLV_NO_ENTRY;\n    }\n    if (!dbg->de_debug_rnglists.dss_data) {\n        res = _dwarf_load_section(dbg, &dbg->de_debug_rnglists,\n            error);\n        if (res != DW_DLV_OK) {\n            return res;\n        }\n    }\n    res = internal_load_rnglists_contexts(dbg,&cxt,&count,error);\n    if (res == DW_DLV_ERROR) {\n        return res;\n    }\n    dbg->de_rnglists_context = cxt;\n    dbg->de_rnglists_context_count = count;\n    if (rnglists_count) {\n        *rnglists_count = count;\n    }\n    return DW_DLV_OK;\n", "Selected Statement": "Dwarf_Rnglists_Context *cxt = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libdwarf"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "*/\n\n\nTable *luaH_new (lua_State *L) {\n  GCObject *o = luaC_newobj(L, LUA_VTABLE, sizeof(Table));\n  Table *t = gco2t(o);\n  t->metatable = NULL;\n  t->flags = cast_byte(maskflags);  \n  t->array = NULL;\n  t->alimit = 0;\n  setnodevector(L, t, 0);\n", "Selected Statement": "t->alimit = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "lua"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\nvoid luaS_init (lua_State *L) {\n  global_State *g = G(L);\n  int i, j;\n  stringtable *tb = &G(L)->strt;\n  tb->hash = luaM_newvector(L, MINSTRTABSIZE, TString*);\n  tablerehash(tb->hash, 0, MINSTRTABSIZE);  \n  tb->size = MINSTRTABSIZE;\n  \n  g->memerrmsg = luaS_newliteral(L, MEMERRMSG);\n  luaC_fix(L, obj2gco(g->memerrmsg));  \n  for (i = 0; i < STRCACHE_N; i++)  \n    for (j = 0; j < STRCACHE_M; j++)\n      g->strcache[i][j] = g->memerrmsg;\n", "Selected Statement": "for (i = 0; i < STRCACHE_N; i++)  /* fill cache with valid strings */", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "lua"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "};\n\n\nvoid luaT_init (lua_State *L) {\n  static const char *const luaT_eventname[] = {  \n    \"__index\", \"__newindex\",\n    \"__gc\", \"__mode\", \"__len\", \"__eq\",\n    \"__add\", \"__sub\", \"__mul\", \"__mod\", \"__pow\",\n    \"__div\", \"__idiv\",\n    \"__band\", \"__bor\", \"__bxor\", \"__shl\", \"__shr\",\n    \"__unm\", \"__bnot\", \"__lt\", \"__le\",\n    \"__concat\", \"__call\", \"__close\"\n  };\n  int i;\n  for (i=0; i<TM_N; i++) {\n    G(L)->tmname[i] = luaS_new(L, luaT_eventname[i]);\n    luaC_fix(L, obj2gco(G(L)->tmname[i]));  \n  }\n", "Selected Statement": "for (i=0; i<TM_N; i++) {", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "lua"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "}\n\n\nvoid luaX_init (lua_State *L) {\n  int i;\n  TString *e = luaS_newliteral(L, LUA_ENV);  \n  luaC_fix(L, obj2gco(e));  \n  for (i=0; i<NUM_RESERVED; i++) {\n    TString *ts = luaS_new(L, luaX_tokens[i]);\n    luaC_fix(L, obj2gco(ts));  \n    ts->extra = cast_byte(i+1);  \n  }\n", "Selected Statement": "for (i=0; i<NUM_RESERVED; i++) {", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "lua"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\nextern \"C\" int\nLLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n\tchar new_file[256];\n\tsprintf(new_file, \"/tmp/libfuzzer.uti\");\n\n\tFILE *fp = fopen(new_file, \"wb\");\n\tif (!fp)\n\t\treturn 0;\n\tfwrite(data, size, 1, fp);\n\tfclose(fp);\n\n\tchar *table = \"empty.ctb\";\n\tlou_compileString(table, \"include /tmp/libfuzzer.uti\");\n\n\tlou_free();\n\tstd::__fs::filesystem::remove_all(\"/tmp/libfuzzer.uti\");\n\n\treturn 0;\n", "Selected Statement": "char *table = \"empty.ctb\";", "Function Input": {"data": {"value": "0xfc2f80 \"\""}, "size": {"value": "6017536"}}, "Variable Values Before Statement": {"constant": "\"empty.ctb\""}, "Value After Statement Execution": "\"empty.ctb\"", "Project Information": "liblouis"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\n\n__attribute_noinline__\nbuffer* buffer_init(void) {\n  #if 0 \n\treturn ck_calloc(1, sizeof(buffer));\n  #else\n\tbuffer * const b = calloc(1, sizeof(*b));\n\tforce_assert(b);\n", "Selected Statement": "if (light_islower(s[i])) s[i] &= 0xdf;", "Function Input": {"b": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"ptr": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdec0 \"\\260\\337\\377\\377\\377\\177\""}, "used": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "4350436"}, "size": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}}}, "Variable Values Before Statement": {"constant": "0xdf"}, "Value After Statement Execution": "0xdf", "Project Information": "lighttpd"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\nvoid\nsldns_buffer_init_frm_data(sldns_buffer *buffer, void *data, size_t size)\n{\n\tmemset(buffer, 0, sizeof(*buffer));\n\tbuffer->_data = data;\n\tbuffer->_capacity = buffer->_limit = size;\n\tbuffer->_fixed = 1;\n", "Selected Statement": "buffer->_fixed = 1;", "Function Input": {"buffer": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"_position": {"type_category": "unknown", "concrete_type": "size_t", "value": "0"}, "_limit": {"type_category": "unknown", "concrete_type": "size_t", "value": "18767888"}, "_capacity": {"type_category": "unknown", "concrete_type": "size_t", "value": "0"}, "_data": {"type_category": "string", "concrete_type": "NULL"}, "_fixed": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}, "_status_err": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}}}}, "data": {"value": null}, "size": {"value": "105810743"}}, "Variable Values Before Statement": {"constant": "1"}, "Value After Statement Execution": "1", "Project Information": "unbound"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\nvoid\nlog_init(const char* filename, int use_syslog, const char* chrootdir)\n{\n\tFILE *f;\n\tif(!key_created) {\n\t\tkey_created = 1;\n\t\tub_thread_key_create(&logkey, NULL);\n\t\tlock_basic_init(&log_lock);\n\t}\n\tlock_basic_lock(&log_lock);\n\tif(logfile \n#if defined(HAVE_SYSLOG_H) || defined(UB_ON_WINDOWS)\n\t|| logging_to_syslog\n#endif\n\t) {\n\t\tlock_basic_unlock(&log_lock); \n\t\tverbose(VERB_QUERY, \"switching log to %s\", \n\t\t\tuse_syslog?\"syslog\":(filename&&filename[0]?filename:\"stderr\"));\n\t\tlock_basic_lock(&log_lock);\n\t}\n\tif(logfile && logfile != stderr) {\n\t\tFILE* cl = logfile;\n\t\tlogfile = NULL; \n\t\tfclose(cl);\n\t}\n#ifdef HAVE_SYSLOG_H\n\tif(logging_to_syslog) {\n\t\tcloselog();\n\t\tlogging_to_syslog = 0;\n\t}\n\tif(use_syslog) {\n\t\t\n\t\t\n\t\topenlog(ident, LOG_NDELAY, UB_SYSLOG_FACILITY);\n\t\tlogging_to_syslog = 1;\n\t\tlock_basic_unlock(&log_lock);\n\t\treturn;\n\t}\n#elif defined(UB_ON_WINDOWS)\n\tif(logging_to_syslog) {\n\t\tlogging_to_syslog = 0;\n\t}\n\tif(use_syslog) {\n\t\tlogging_to_syslog = 1;\n\t\tlock_basic_unlock(&log_lock);\n\t\treturn;\n\t}\n#endif \n\tif(!filename || !filename[0]) {\n\t\tlogfile = stderr;\n\t\tlock_basic_unlock(&log_lock);\n\t\treturn;\n\t}\n\t\n\tif(chrootdir && chrootdir[0] && strncmp(filename, chrootdir,\n\t\tstrlen(chrootdir)) == 0) \n\t\tfilename += strlen(chrootdir);\n\tf = fopen(filename, \"a\");\n\tif(!f) {\n\t\tlock_basic_unlock(&log_lock);\n\t\tlog_err(\"Could not open logfile %s: %s\", filename, \n\t\t\tstrerror(errno));\n\t\treturn;\n\t}\n#ifndef UB_ON_WINDOWS\n\t\n\tsetvbuf(f, NULL, (int)_IOLBF, 0);\n#endif\n\tlogfile = f;\n\tlock_basic_unlock(&log_lock);\n", "Selected Statement": "key_created = 1;", "Function Input": {"chrootdir": {"value": "0x1ee000 <error: Cannot access memory at address 0x1ee000>"}, "filename": {"value": "0x1f1660 <error: Cannot access memory at address 0x1f1660>"}, "use_syslog": {"value": "0"}}, "Variable Values Before Statement": {"constant": "1"}, "Value After Statement Execution": "1", "Project Information": "unbound"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "              p11_dict_equals equal_func,\n              p11_destroyer key_destroy_func,\n              p11_destroyer value_destroy_func)\n{\n\tp11_dict *dict;\n\n\tassert (hash_func);\n\tassert (equal_func);\n\n\tdict = malloc (sizeof (p11_dict));\n\tif (dict) {\n\t\tdict->hash_func = hash_func;\n\t\tdict->equal_func = equal_func;\n\t\tdict->key_destroy_func = key_destroy_func;\n\t\tdict->value_destroy_func = value_destroy_func;\n\n\t\tdict->num_buckets = 9;\n\t\tdict->buckets = (dictbucket **)calloc (dict->num_buckets, sizeof (dictbucket *));\n\t\tif (!dict->buckets) {\n\t\t\tfree (dict);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tdict->num_items = 0;\n\t}\n\n\treturn dict;\n", "Selected Statement": "dict->num_buckets = 9;", "Function Input": {}, "Variable Values Before Statement": {"constant": "9"}, "Value After Statement Execution": "9", "Project Information": "p11-kit"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\nvoid\np11_message_clear (void)\n{\n\tchar *buffer;\n\tbuffer = p11_message_storage ();\n\tif (buffer != NULL)\n\t\tbuffer[0] = 0;\n", "Selected Statement": "buffer[0] = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "p11-kit"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\n\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n  tjhandle handle = NULL;\n  unsigned short *srcBuf = NULL;\n  unsigned char *dstBuf = NULL;\n  int width = 0, height = 0, fd = -1, i, ti;\n  char filename[FILENAME_MAX] = { 0 };\n  struct test tests[NUMTESTS] = {\n    { TJPF_RGB, 1, 0 },\n    { TJPF_BGR, 2, 2 },\n    { TJPF_RGBX, 3, 4 },\n    { TJPF_BGRA, 4, 7 },\n    { TJPF_XRGB, 5, 5 },\n    { TJPF_GRAY, 6, 3 },\n    { TJPF_CMYK, 7, 0 }\n  };\n#if defined(__has_feature) && __has_feature(memory_sanitizer)\n  char env[18] = \"JSIMD_FORCENONE=1\";\n\n  \n  putenv(env);\n#endif\n\n  snprintf(filename, FILENAME_MAX, \"/tmp/libjpeg-turbo_compress_fuzz.XXXXXX\");\n  if ((fd = mkstemp(filename)) < 0 || write(fd, data, size) < 0)\n    goto bailout;\n\n  if ((handle = tj3Init(TJINIT_COMPRESS)) == NULL)\n    goto bailout;\n\n  for (ti = 0; ti < NUMTESTS; ti++) {\n    int sum = 0, pf = tests[ti].pf;\n    size_t dstSize = 0, maxBufSize;\n\n    \n    tj3Set(handle, TJPARAM_BOTTOMUP, ti == 0);\n    tj3Set(handle, TJPARAM_NOREALLOC, ti != 2);\n    tj3Set(handle, TJPARAM_RESTARTROWS, ti == 0 || ti == 6 ? 1 : 0);\n\n    tj3Set(handle, TJPARAM_MAXPIXELS, 1048576);\n    \n    if ((srcBuf = tj3LoadImage16(handle, filename, &width, 1, &height,\n                                 &pf)) == NULL)\n      continue;\n\n    maxBufSize = tj3JPEGBufSize(width, height, TJSAMP_444);\n    if (tj3Get(handle, TJPARAM_NOREALLOC)) {\n      if ((dstBuf = (unsigned char *)malloc(maxBufSize)) == NULL)\n        goto bailout;\n    } else\n      dstBuf = NULL;\n\n    tj3Set(handle, TJPARAM_LOSSLESS, 1);\n    tj3Set(handle, TJPARAM_LOSSLESSPSV, tests[ti].psv);\n    tj3Set(handle, TJPARAM_LOSSLESSPT, tests[ti].pt);\n    if (tj3Compress16(handle, srcBuf, width, 0, height, pf, &dstBuf,\n                      &dstSize) == 0) {\n      \n      for (i = 0; i < dstSize; i++)\n        sum += dstBuf[i];\n    }\n\n    free(dstBuf);\n    dstBuf = NULL;\n    tj3Free(srcBuf);\n    srcBuf = NULL;\n\n    \n    if (sum > 255 * maxBufSize)\n      goto bailout;\n  }\n\nbailout:\n  free(dstBuf);\n  tj3Free(srcBuf);\n  if (fd >= 0) {\n    close(fd);\n    if (strlen(filename) > 0) unlink(filename);\n  }\n  tj3Destroy(handle);\n", "Selected Statement": "int width = 0, height = 0, fd = -1, i, ti;", "Function Input": {"data": {"value": "0x1108b30 \" \\220\\020\\001\""}, "size": {"value": "17866800"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\n\nDLLEXPORT tjhandle tj3Init(int initType)\n{\n  static const char FUNCTION_NAME[] = \"tj3Init\";\n  tjinstance *this = NULL;\n  tjhandle retval = NULL;\n\n  if (initType < 0 || initType >= TJ_NUMINIT)\n    THROWG(\"Invalid argument\", NULL);\n\n  if ((this = (tjinstance *)malloc(sizeof(tjinstance))) == NULL)\n    THROWG(\"Memory allocation failure\", NULL);\n  memset(this, 0, sizeof(tjinstance));\n  SNPRINTF(this->errStr, JMSG_LENGTH_MAX, \"No error\");\n\n  this->quality = -1;\n  this->subsamp = TJSAMP_UNKNOWN;\n  this->jpegWidth = -1;\n  this->jpegHeight = -1;\n  this->precision = 8;\n  this->colorspace = -1;\n  this->losslessPSV = 1;\n  this->xDensity = 1;\n  this->yDensity = 1;\n  this->scalingFactor = TJUNSCALED;\n\n  switch (initType) {\n  case TJINIT_COMPRESS:  return _tjInitCompress(this);\n  case TJINIT_DECOMPRESS:  return _tjInitDecompress(this);\n  case TJINIT_TRANSFORM:\n    retval = _tjInitCompress(this);\n    if (!retval) return NULL;\n    retval = _tjInitDecompress(this);\n    return retval;\n  }\n\nbailout:\n  return retval;\n", "Selected Statement": "this->jpegWidth = -1;", "Function Input": {}, "Variable Values Before Statement": {"constant": "-1"}, "Value After Statement Execution": "-1", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\nGLOBAL(struct jpeg_error_mgr *)\njpeg_std_error(struct jpeg_error_mgr *err)\n{\n  err->error_exit = error_exit;\n  err->emit_message = emit_message;\n  err->output_message = output_message;\n  err->format_message = format_message;\n  err->reset_error_mgr = reset_error_mgr;\n\n  err->trace_level = 0;         \n  err->num_warnings = 0;        \n  err->msg_code = 0;            \n\n  \n  err->jpeg_message_table = jpeg_std_message_table;\n  err->last_jpeg_message = (int)JMSG_LASTMSGCODE - 1;\n\n  err->addon_message_table = NULL;\n  err->first_addon_message = 0; \n  err->last_addon_message = 0;\n\n", "Selected Statement": "err->trace_level = 0;         /* default = no tracing */", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\nGLOBAL(void)\njpeg_CreateCompress(j_compress_ptr cinfo, int version, size_t structsize)\n{\n  int i;\n\n  \n  cinfo->mem = NULL;            \n  if (version != JPEG_LIB_VERSION)\n    ERREXIT2(cinfo, JERR_BAD_LIB_VERSION, JPEG_LIB_VERSION, version);\n  if (structsize != sizeof(struct jpeg_compress_struct))\n    ERREXIT2(cinfo, JERR_BAD_STRUCT_SIZE,\n             (int)sizeof(struct jpeg_compress_struct), (int)structsize);\n\n  \n  {\n    struct jpeg_error_mgr *err = cinfo->err;\n    void *client_data = cinfo->client_data; \n    memset(cinfo, 0, sizeof(struct jpeg_compress_struct));\n    cinfo->err = err;\n    cinfo->client_data = client_data;\n  }\n  cinfo->is_decompressor = FALSE;\n\n  \n  jinit_memory_mgr((j_common_ptr)cinfo);\n\n  \n  cinfo->progress = NULL;\n  cinfo->dest = NULL;\n\n  cinfo->comp_info = NULL;\n\n  for (i = 0; i < NUM_QUANT_TBLS; i++) {\n    cinfo->quant_tbl_ptrs[i] = NULL;\n#if JPEG_LIB_VERSION >= 70\n    cinfo->q_scale_factor[i] = 100;\n#endif\n  }\n\n  for (i = 0; i < NUM_HUFF_TBLS; i++) {\n    cinfo->dc_huff_tbl_ptrs[i] = NULL;\n    cinfo->ac_huff_tbl_ptrs[i] = NULL;\n  }\n\n#if JPEG_LIB_VERSION >= 80\n  \n  cinfo->block_size = DCTSIZE;\n  cinfo->natural_order = jpeg_natural_order;\n  cinfo->lim_Se = DCTSIZE2 - 1;\n#endif\n\n  cinfo->script_space = NULL;\n\n  cinfo->input_gamma = 1.0;     \n\n  cinfo->data_precision = BITS_IN_JSAMPLE;\n\n  \n  cinfo->global_state = CSTATE_START;\n\n  \n  cinfo->master = (struct jpeg_comp_master *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,\n                                  sizeof(my_comp_master));\n  memset(cinfo->master, 0, sizeof(my_comp_master));\n", "Selected Statement": "for (i = 0; i < NUM_HUFF_TBLS; i++) {", "Function Input": {"cinfo": {"value": "0x7ffff7ffe190"}, "structsize": {"value": "511101108348"}, "version": {"value": "0"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\nGLOBAL(void)\njpeg_destroy(j_common_ptr cinfo)\n{\n  \n  \n  if (cinfo->mem != NULL)\n    (*cinfo->mem->self_destruct) (cinfo);\n  cinfo->mem = NULL;            \n  cinfo->global_state = 0;      \n", "Selected Statement": "cinfo->global_state = 0;      /* mark it destroyed */", "Function Input": {"cinfo": {"value": "0x7ffff7de8807"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\n\nDLLEXPORT tjhandle tjInitCompress(void)\n{\n  tjinstance *this = NULL;\n\n  if ((this = (tjinstance *)malloc(sizeof(tjinstance))) == NULL) {\n    SNPRINTF(errStr, JMSG_LENGTH_MAX,\n             \"tjInitCompress(): Memory allocation failure\");\n    return NULL;\n  }\n  memset(this, 0, sizeof(tjinstance));\n  SNPRINTF(this->errStr, JMSG_LENGTH_MAX, \"No error\");\n  return _tjInitCompress(this);\n", "Selected Statement": "if (this->jerr.warning) retval = -1;", "Function Input": {}, "Variable Values Before Statement": {"constant": "-1"}, "Value After Statement Execution": "-1", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\nGLOBAL(void)\njpeg_CreateCompress(j_compress_ptr cinfo, int version, size_t structsize)\n{\n  int i;\n\n  \n  cinfo->mem = NULL;            \n  if (version != JPEG_LIB_VERSION)\n    ERREXIT2(cinfo, JERR_BAD_LIB_VERSION, JPEG_LIB_VERSION, version);\n  if (structsize != sizeof(struct jpeg_compress_struct))\n    ERREXIT2(cinfo, JERR_BAD_STRUCT_SIZE,\n             (int)sizeof(struct jpeg_compress_struct), (int)structsize);\n\n  \n  {\n    struct jpeg_error_mgr *err = cinfo->err;\n    void *client_data = cinfo->client_data; \n    memset(cinfo, 0, sizeof(struct jpeg_compress_struct));\n    cinfo->err = err;\n    cinfo->client_data = client_data;\n  }\n  cinfo->is_decompressor = FALSE;\n\n  \n  jinit_memory_mgr((j_common_ptr)cinfo);\n\n  \n  cinfo->progress = NULL;\n  cinfo->dest = NULL;\n\n  cinfo->comp_info = NULL;\n\n  for (i = 0; i < NUM_QUANT_TBLS; i++) {\n    cinfo->quant_tbl_ptrs[i] = NULL;\n#if JPEG_LIB_VERSION >= 70\n    cinfo->q_scale_factor[i] = 100;\n#endif\n  }\n\n  for (i = 0; i < NUM_HUFF_TBLS; i++) {\n    cinfo->dc_huff_tbl_ptrs[i] = NULL;\n    cinfo->ac_huff_tbl_ptrs[i] = NULL;\n  }\n\n#if JPEG_LIB_VERSION >= 80\n  \n  cinfo->block_size = DCTSIZE;\n  cinfo->natural_order = jpeg_natural_order;\n  cinfo->lim_Se = DCTSIZE2 - 1;\n#endif\n\n  cinfo->script_space = NULL;\n\n  cinfo->input_gamma = 1.0;     \n\n  \n  cinfo->global_state = CSTATE_START;\n", "Selected Statement": "for (i = 0; i < NUM_HUFF_TBLS; i++) {", "Function Input": {"cinfo": {"value": "0x7ffff7ffe190"}, "structsize": {"value": "511101108348"}, "version": {"value": "0"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\n\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n  tjhandle handle = NULL;\n  short *srcBuf = NULL;\n  unsigned char *dstBuf = NULL;\n  int width = 0, height = 0, fd = -1, i, ti;\n  char filename[FILENAME_MAX] = { 0 };\n  struct test tests[NUMTESTS] = {\n    { TJPF_RGB, TJSAMP_444, 100 },\n    { TJPF_BGR, TJSAMP_422, 90 },\n    { TJPF_RGBX, TJSAMP_420, 80 },\n    { TJPF_BGRA, TJSAMP_411, 70 },\n    { TJPF_XRGB, TJSAMP_GRAY, 60 },\n    { TJPF_GRAY, TJSAMP_GRAY, 50 },\n    { TJPF_CMYK, TJSAMP_440, 40 }\n  };\n#if defined(__has_feature) && __has_feature(memory_sanitizer)\n  char env[18] = \"JSIMD_FORCENONE=1\";\n\n  \n  putenv(env);\n#endif\n\n  snprintf(filename, FILENAME_MAX, \"/tmp/libjpeg-turbo_compress12_fuzz.XXXXXX\");\n  if ((fd = mkstemp(filename)) < 0 || write(fd, data, size) < 0)\n    goto bailout;\n\n  if ((handle = tj3Init(TJINIT_COMPRESS)) == NULL)\n    goto bailout;\n\n  for (ti = 0; ti < NUMTESTS; ti++) {\n    int sum = 0, pf = tests[ti].pf;\n    size_t dstSize = 0, maxBufSize;\n\n    \n    tj3Set(handle, TJPARAM_BOTTOMUP, ti == 0);\n    tj3Set(handle, TJPARAM_FASTDCT, ti == 0);\n    tj3Set(handle, TJPARAM_PROGRESSIVE, ti == 1 || ti == 3);\n    tj3Set(handle, TJPARAM_ARITHMETIC, ti == 2 || ti == 3);\n    tj3Set(handle, TJPARAM_NOREALLOC, ti != 2);\n    tj3Set(handle, TJPARAM_RESTARTROWS, ti == 1 || ti == 2 ? 2 : 0);\n\n    tj3Set(handle, TJPARAM_MAXPIXELS, 1048576);\n    \n    if ((srcBuf = tj3LoadImage12(handle, filename, &width, 1, &height,\n                                 &pf)) == NULL)\n      continue;\n\n    maxBufSize = tj3JPEGBufSize(width, height, tests[ti].subsamp);\n    if (tj3Get(handle, TJPARAM_NOREALLOC)) {\n      if ((dstBuf = (unsigned char *)malloc(maxBufSize)) == NULL)\n        goto bailout;\n    } else\n      dstBuf = NULL;\n\n    tj3Set(handle, TJPARAM_SUBSAMP, tests[ti].subsamp);\n    tj3Set(handle, TJPARAM_QUALITY, tests[ti].quality);\n    if (tj3Compress12(handle, srcBuf, width, 0, height, pf, &dstBuf,\n                      &dstSize) == 0) {\n      \n      for (i = 0; i < dstSize; i++)\n        sum += dstBuf[i];\n    }\n\n    free(dstBuf);\n    dstBuf = NULL;\n    tj3Free(srcBuf);\n    srcBuf = NULL;\n\n    \n    if (sum > 255 * maxBufSize)\n      goto bailout;\n  }\n\nbailout:\n  free(dstBuf);\n  tj3Free(srcBuf);\n  if (fd >= 0) {\n    close(fd);\n    if (strlen(filename) > 0) unlink(filename);\n  }\n  tj3Destroy(handle);\n", "Selected Statement": "for (ti = 0; ti < NUMTESTS; ti++) {", "Function Input": {"data": {"value": "0x1108b30 \" \\220\\020\\001\""}, "size": {"value": "17866800"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\nGLOBAL(void)\njpeg_set_defaults(j_compress_ptr cinfo)\n{\n  int i;\n\n  \n  if (cinfo->global_state != CSTATE_START)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n\n  \n  if (cinfo->comp_info == NULL)\n    cinfo->comp_info = (jpeg_component_info *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,\n                                  MAX_COMPONENTS * sizeof(jpeg_component_info));\n\n  \n\n#if JPEG_LIB_VERSION >= 70\n  cinfo->scale_num = 1;         \n  cinfo->scale_denom = 1;\n#endif\n  \n  jpeg_set_quality(cinfo, 75, TRUE);\n  \n  std_huff_tables((j_common_ptr)cinfo);\n\n  \n  for (i = 0; i < NUM_ARITH_TBLS; i++) {\n    cinfo->arith_dc_L[i] = 0;\n    cinfo->arith_dc_U[i] = 1;\n    cinfo->arith_ac_K[i] = 5;\n  }\n\n  \n  cinfo->scan_info = NULL;\n  cinfo->num_scans = 0;\n\n  \n  cinfo->raw_data_in = FALSE;\n\n  \n  cinfo->arith_code = FALSE;\n\n  \n  cinfo->optimize_coding = FALSE;\n  \n  if (cinfo->data_precision == 12 && !cinfo->arith_code)\n    cinfo->optimize_coding = TRUE;\n\n  \n  cinfo->CCIR601_sampling = FALSE;\n\n#if JPEG_LIB_VERSION >= 70\n  \n  cinfo->do_fancy_downsampling = TRUE;\n#endif\n\n  \n  cinfo->smoothing_factor = 0;\n\n  \n  cinfo->dct_method = JDCT_DEFAULT;\n\n  \n  cinfo->restart_interval = 0;\n  cinfo->restart_in_rows = 0;\n\n  \n  cinfo->JFIF_major_version = 1; \n  cinfo->JFIF_minor_version = 1;\n  cinfo->density_unit = 0;      \n  cinfo->X_density = 1;         \n  cinfo->Y_density = 1;\n\n  \n\n  jpeg_default_colorspace(cinfo);\n", "Selected Statement": "cinfo->arith_dc_L[i] = 0;", "Function Input": {"cinfo": {"value": "0x7fffffffcc08"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\nGLOBAL(void)\njpeg_CreateDecompress(j_decompress_ptr cinfo, int version, size_t structsize)\n{\n  int i;\n\n  \n  cinfo->mem = NULL;            \n  if (version != JPEG_LIB_VERSION)\n    ERREXIT2(cinfo, JERR_BAD_LIB_VERSION, JPEG_LIB_VERSION, version);\n  if (structsize != sizeof(struct jpeg_decompress_struct))\n    ERREXIT2(cinfo, JERR_BAD_STRUCT_SIZE,\n             (int)sizeof(struct jpeg_decompress_struct), (int)structsize);\n\n  \n  {\n    struct jpeg_error_mgr *err = cinfo->err;\n    void *client_data = cinfo->client_data; \n    memset(cinfo, 0, sizeof(struct jpeg_decompress_struct));\n    cinfo->err = err;\n    cinfo->client_data = client_data;\n  }\n  cinfo->is_decompressor = TRUE;\n\n  \n  jinit_memory_mgr((j_common_ptr)cinfo);\n\n  \n  cinfo->progress = NULL;\n  cinfo->src = NULL;\n\n  for (i = 0; i < NUM_QUANT_TBLS; i++)\n    cinfo->quant_tbl_ptrs[i] = NULL;\n\n  for (i = 0; i < NUM_HUFF_TBLS; i++) {\n    cinfo->dc_huff_tbl_ptrs[i] = NULL;\n    cinfo->ac_huff_tbl_ptrs[i] = NULL;\n  }\n\n  \n  cinfo->marker_list = NULL;\n  jinit_marker_reader(cinfo);\n\n  \n  jinit_input_controller(cinfo);\n\n  \n  cinfo->global_state = DSTATE_START;\n\n  \n  cinfo->master = (struct jpeg_decomp_master *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,\n                                sizeof(my_decomp_master));\n  memset(cinfo->master, 0, sizeof(my_decomp_master));\n", "Selected Statement": "for (i = 0; i < NUM_HUFF_TBLS; i++) {", "Function Input": {"cinfo": {"value": "0x7ffff7ffe190"}, "structsize": {"value": "3"}, "version": {"value": "0"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\nGLOBAL(void)\njinit_marker_reader(j_decompress_ptr cinfo)\n{\n  my_marker_ptr marker;\n  int i;\n\n  \n  marker = (my_marker_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,\n                                sizeof(my_marker_reader));\n  cinfo->marker = (struct jpeg_marker_reader *)marker;\n  \n  marker->pub.reset_marker_reader = reset_marker_reader;\n  marker->pub.read_markers = read_markers;\n  marker->pub.read_restart_marker = read_restart_marker;\n  \n  marker->process_COM = skip_variable;\n  marker->length_limit_COM = 0;\n  for (i = 0; i < 16; i++) {\n    marker->process_APPn[i] = skip_variable;\n    marker->length_limit_APPn[i] = 0;\n  }\n  marker->process_APPn[0] = get_interesting_appn;\n  marker->process_APPn[14] = get_interesting_appn;\n  \n  reset_marker_reader(cinfo);\n", "Selected Statement": "marker->length_limit_COM = 0;", "Function Input": {"cinfo": {"value": "0xffffdfd7"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\n\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n  tjhandle handle = NULL;\n  unsigned char *srcBuf = NULL, *dstBuf = NULL;\n  int width = 0, height = 0, fd = -1, i, ti;\n  char filename[FILENAME_MAX] = { 0 };\n  struct test tests[NUMTESTS] = {\n    { TJPF_RGB, 1, 0 },\n    { TJPF_BGR, 2, 2 },\n    { TJPF_RGBX, 3, 4 },\n    { TJPF_BGRA, 4, 7 },\n    { TJPF_XRGB, 5, 5 },\n    { TJPF_GRAY, 6, 3 },\n    { TJPF_CMYK, 7, 0 }\n  };\n#if defined(__has_feature) && __has_feature(memory_sanitizer)\n  char env[18] = \"JSIMD_FORCENONE=1\";\n\n  \n  putenv(env);\n#endif\n\n  snprintf(filename, FILENAME_MAX, \"/tmp/libjpeg-turbo_compress_fuzz.XXXXXX\");\n  if ((fd = mkstemp(filename)) < 0 || write(fd, data, size) < 0)\n    goto bailout;\n\n  if ((handle = tj3Init(TJINIT_COMPRESS)) == NULL)\n    goto bailout;\n\n  for (ti = 0; ti < NUMTESTS; ti++) {\n    int sum = 0, pf = tests[ti].pf;\n    size_t dstSize = 0, maxBufSize;\n\n    \n    tj3Set(handle, TJPARAM_BOTTOMUP, ti == 0);\n    tj3Set(handle, TJPARAM_NOREALLOC, ti != 2);\n    tj3Set(handle, TJPARAM_RESTARTROWS, ti == 0 || ti == 6 ? 1 : 0);\n\n    tj3Set(handle, TJPARAM_MAXPIXELS, 1048576);\n    \n    if ((srcBuf = tj3LoadImage8(handle, filename, &width, 1, &height,\n                                &pf)) == NULL)\n      continue;\n\n    maxBufSize = tj3JPEGBufSize(width, height, TJSAMP_444);\n    if (tj3Get(handle, TJPARAM_NOREALLOC)) {\n      if ((dstBuf = (unsigned char *)malloc(maxBufSize)) == NULL)\n        goto bailout;\n    } else\n      dstBuf = NULL;\n\n    tj3Set(handle, TJPARAM_LOSSLESS, 1);\n    tj3Set(handle, TJPARAM_LOSSLESSPSV, tests[ti].psv);\n    tj3Set(handle, TJPARAM_LOSSLESSPT, tests[ti].pt);\n    if (tj3Compress8(handle, srcBuf, width, 0, height, pf, &dstBuf,\n                     &dstSize) == 0) {\n      \n      for (i = 0; i < dstSize; i++)\n        sum += dstBuf[i];\n    }\n\n    free(dstBuf);\n    dstBuf = NULL;\n    tj3Free(srcBuf);\n    srcBuf = NULL;\n\n    \n    if (sum > 255 * maxBufSize)\n      goto bailout;\n  }\n\nbailout:\n  free(dstBuf);\n  tj3Free(srcBuf);\n  if (fd >= 0) {\n    close(fd);\n    if (strlen(filename) > 0) unlink(filename);\n  }\n  tj3Destroy(handle);\n", "Selected Statement": "int sum = 0, pf = tests[ti].pf;", "Function Input": {"data": {"value": "0x1108b70 \"`\\220\\020\\001\""}, "size": {"value": "17866864"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\nGLOBAL(void)\njpeg_CreateDecompress(j_decompress_ptr cinfo, int version, size_t structsize)\n{\n  int i;\n\n  \n  cinfo->mem = NULL;            \n  if (version != JPEG_LIB_VERSION)\n    ERREXIT2(cinfo, JERR_BAD_LIB_VERSION, JPEG_LIB_VERSION, version);\n  if (structsize != sizeof(struct jpeg_decompress_struct))\n    ERREXIT2(cinfo, JERR_BAD_STRUCT_SIZE,\n             (int)sizeof(struct jpeg_decompress_struct), (int)structsize);\n\n  \n  {\n    struct jpeg_error_mgr *err = cinfo->err;\n    void *client_data = cinfo->client_data; \n    memset(cinfo, 0, sizeof(struct jpeg_decompress_struct));\n    cinfo->err = err;\n    cinfo->client_data = client_data;\n  }\n  cinfo->is_decompressor = TRUE;\n\n  \n  jinit_memory_mgr((j_common_ptr)cinfo);\n\n  \n  cinfo->progress = NULL;\n  cinfo->src = NULL;\n\n  for (i = 0; i < NUM_QUANT_TBLS; i++)\n    cinfo->quant_tbl_ptrs[i] = NULL;\n\n  for (i = 0; i < NUM_HUFF_TBLS; i++) {\n    cinfo->dc_huff_tbl_ptrs[i] = NULL;\n    cinfo->ac_huff_tbl_ptrs[i] = NULL;\n  }\n\n  \n  cinfo->marker_list = NULL;\n  jinit_marker_reader(cinfo);\n\n  \n  jinit_input_controller(cinfo);\n\n  cinfo->data_precision = BITS_IN_JSAMPLE;\n\n  \n  cinfo->global_state = DSTATE_START;\n\n  \n  cinfo->master = (struct jpeg_decomp_master *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,\n                                sizeof(my_decomp_master));\n  memset(cinfo->master, 0, sizeof(my_decomp_master));\n", "Selected Statement": "for (i = 0; i < NUM_HUFF_TBLS; i++) {", "Function Input": {"cinfo": {"value": "0x7ffff7ffe190"}, "structsize": {"value": "0"}, "version": {"value": "0"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\nGLOBAL(void)\njinit_marker_reader(j_decompress_ptr cinfo)\n{\n  my_marker_ptr marker;\n  int i;\n\n  \n  marker = (my_marker_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,\n                                sizeof(my_marker_reader));\n  cinfo->marker = (struct jpeg_marker_reader *)marker;\n  \n  marker->pub.reset_marker_reader = reset_marker_reader;\n  marker->pub.read_markers = read_markers;\n  marker->pub.read_restart_marker = read_restart_marker;\n  \n  marker->process_COM = skip_variable;\n  marker->length_limit_COM = 0;\n  for (i = 0; i < 16; i++) {\n    marker->process_APPn[i] = skip_variable;\n    marker->length_limit_APPn[i] = 0;\n  }\n  marker->process_APPn[0] = get_interesting_appn;\n  marker->process_APPn[14] = get_interesting_appn;\n  \n  reset_marker_reader(cinfo);\n", "Selected Statement": "for (i = 0; i < 16; i++) {", "Function Input": {"cinfo": {"value": "0xffffdfe7"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\nGLOBAL(void)\njpeg_set_defaults(j_compress_ptr cinfo)\n{\n  int i;\n\n  \n  if (cinfo->global_state != CSTATE_START)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n\n  \n  if (cinfo->comp_info == NULL)\n    cinfo->comp_info = (jpeg_component_info *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,\n                                  MAX_COMPONENTS * sizeof(jpeg_component_info));\n\n  \n\n#if JPEG_LIB_VERSION >= 70\n  cinfo->scale_num = 1;         \n  cinfo->scale_denom = 1;\n#endif\n  cinfo->data_precision = BITS_IN_JSAMPLE;\n  \n  jpeg_set_quality(cinfo, 75, TRUE);\n  \n  std_huff_tables((j_common_ptr)cinfo);\n\n  \n  for (i = 0; i < NUM_ARITH_TBLS; i++) {\n    cinfo->arith_dc_L[i] = 0;\n    cinfo->arith_dc_U[i] = 1;\n    cinfo->arith_ac_K[i] = 5;\n  }\n\n  \n  cinfo->scan_info = NULL;\n  cinfo->num_scans = 0;\n\n  \n  cinfo->raw_data_in = FALSE;\n\n  \n  cinfo->arith_code = FALSE;\n\n  \n  cinfo->optimize_coding = FALSE;\n  \n  if (cinfo->data_precision > 8)\n    cinfo->optimize_coding = TRUE;\n\n  \n  cinfo->CCIR601_sampling = FALSE;\n\n#if JPEG_LIB_VERSION >= 70\n  \n  cinfo->do_fancy_downsampling = TRUE;\n#endif\n\n  \n  cinfo->smoothing_factor = 0;\n\n  \n  cinfo->dct_method = JDCT_DEFAULT;\n\n  \n  cinfo->restart_interval = 0;\n  cinfo->restart_in_rows = 0;\n\n  \n  cinfo->JFIF_major_version = 1; \n  cinfo->JFIF_minor_version = 1;\n  cinfo->density_unit = 0;      \n  cinfo->X_density = 1;         \n  cinfo->Y_density = 1;\n\n  \n\n  jpeg_default_colorspace(cinfo);\n", "Selected Statement": "for (i = 0; i < NUM_ARITH_TBLS; i++) {", "Function Input": {"cinfo": {"value": "0x7fffffffcbf8"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\n\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n  tjhandle handle = NULL;\n  unsigned char *srcBuf = NULL, *dstBuf = NULL, *yuvBuf = NULL;\n  int width = 0, height = 0, fd = -1, i, ti;\n  char filename[FILENAME_MAX] = { 0 };\n  struct test tests[NUMTESTS] = {\n    { TJPF_XBGR, TJSAMP_444, 100 },\n    { TJPF_XRGB, TJSAMP_422, 90 },\n    { TJPF_BGR, TJSAMP_420, 80 },\n    { TJPF_RGB, TJSAMP_411, 70 },\n    { TJPF_BGR, TJSAMP_GRAY, 60 },\n    { TJPF_GRAY, TJSAMP_GRAY, 50 }\n  };\n#if defined(__has_feature) && __has_feature(memory_sanitizer)\n  char env[18] = \"JSIMD_FORCENONE=1\";\n\n  \n  putenv(env);\n#endif\n\n  snprintf(filename, FILENAME_MAX, \"/tmp/libjpeg-turbo_compress_yuv_fuzz.XXXXXX\");\n  if ((fd = mkstemp(filename)) < 0 || write(fd, data, size) < 0)\n    goto bailout;\n\n  if ((handle = tj3Init(TJINIT_COMPRESS)) == NULL)\n    goto bailout;\n\n  for (ti = 0; ti < NUMTESTS; ti++) {\n    int sum = 0, pf = tests[ti].pf;\n    size_t dstSize = 0, maxBufSize;\n\n    \n    tj3Set(handle, TJPARAM_BOTTOMUP, ti == 0);\n    tj3Set(handle, TJPARAM_FASTDCT, ti == 1);\n    tj3Set(handle, TJPARAM_OPTIMIZE, ti == 4);\n    tj3Set(handle, TJPARAM_PROGRESSIVE, ti == 1 || ti == 3);\n    tj3Set(handle, TJPARAM_ARITHMETIC, ti == 2 || ti == 3);\n    tj3Set(handle, TJPARAM_NOREALLOC, 1);\n    tj3Set(handle, TJPARAM_RESTARTBLOCKS, ti == 3 || ti == 4 ? 4 : 0);\n\n    tj3Set(handle, TJPARAM_MAXPIXELS, 1048576);\n    \n    if ((srcBuf = tj3LoadImage8(handle, filename, &width, 1, &height,\n                                &pf)) == NULL)\n      continue;\n\n    maxBufSize = tj3JPEGBufSize(width, height, tests[ti].subsamp);\n    if ((dstBuf = (unsigned char *)malloc(maxBufSize)) == NULL)\n      goto bailout;\n    if ((yuvBuf =\n         (unsigned char *)malloc(tj3YUVBufSize(width, 1, height,\n                                               tests[ti].subsamp))) == NULL)\n      goto bailout;\n\n    tj3Set(handle, TJPARAM_SUBSAMP, tests[ti].subsamp);\n    tj3Set(handle, TJPARAM_QUALITY, tests[ti].quality);\n    if (tj3EncodeYUV8(handle, srcBuf, width, 0, height, pf, yuvBuf, 1) == 0 &&\n        tj3CompressFromYUV8(handle, yuvBuf, width, 1, height, &dstBuf,\n                            &dstSize) == 0) {\n      \n      for (i = 0; i < dstSize; i++)\n        sum += dstBuf[i];\n    }\n\n    free(dstBuf);\n    dstBuf = NULL;\n    free(yuvBuf);\n    yuvBuf = NULL;\n    tj3Free(srcBuf);\n    srcBuf = NULL;\n\n    \n    if (sum > 255 * maxBufSize)\n      goto bailout;\n  }\n\nbailout:\n  free(dstBuf);\n  free(yuvBuf);\n  tj3Free(srcBuf);\n  if (fd >= 0) {\n    close(fd);\n    if (strlen(filename) > 0) unlink(filename);\n  }\n  tj3Destroy(handle);\n", "Selected Statement": "int width = 0, height = 0, fd = -1, i, ti;", "Function Input": {"data": {"value": "0x1108b70 \"`\\220\\020\\001\""}, "size": {"value": "17866864"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\n\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n  tjhandle handle = NULL;\n  unsigned char *srcBuf = NULL, *dstBuf = NULL;\n  int width = 0, height = 0, fd = -1, i, ti;\n  char filename[FILENAME_MAX] = { 0 };\n  struct test tests[NUMTESTS] = {\n    { TJPF_RGB, TJSAMP_444, 100 },\n    { TJPF_BGR, TJSAMP_422, 90 },\n    { TJPF_RGBX, TJSAMP_420, 80 },\n    { TJPF_BGRA, TJSAMP_411, 70 },\n    { TJPF_XRGB, TJSAMP_GRAY, 60 },\n    { TJPF_GRAY, TJSAMP_GRAY, 50 },\n    { TJPF_CMYK, TJSAMP_440, 40 }\n  };\n#if defined(__has_feature) && __has_feature(memory_sanitizer)\n  char env[18] = \"JSIMD_FORCENONE=1\";\n\n  \n  putenv(env);\n#endif\n\n  snprintf(filename, FILENAME_MAX, \"/tmp/libjpeg-turbo_compress_fuzz.XXXXXX\");\n  if ((fd = mkstemp(filename)) < 0 || write(fd, data, size) < 0)\n    goto bailout;\n\n  if ((handle = tj3Init(TJINIT_COMPRESS)) == NULL)\n    goto bailout;\n\n  for (ti = 0; ti < NUMTESTS; ti++) {\n    int sum = 0, pf = tests[ti].pf;\n    size_t dstSize = 0, maxBufSize;\n\n    \n    tj3Set(handle, TJPARAM_BOTTOMUP, ti == 0);\n    tj3Set(handle, TJPARAM_FASTDCT, ti == 1);\n    tj3Set(handle, TJPARAM_OPTIMIZE, ti == 6);\n    tj3Set(handle, TJPARAM_PROGRESSIVE, ti == 1 || ti == 3);\n    tj3Set(handle, TJPARAM_ARITHMETIC, ti == 2 || ti == 3);\n    tj3Set(handle, TJPARAM_NOREALLOC, ti != 2);\n    tj3Set(handle, TJPARAM_RESTARTROWS, ti == 1 || ti == 2 ? 2 : 0);\n\n    tj3Set(handle, TJPARAM_MAXPIXELS, 1048576);\n    \n    if ((srcBuf = tj3LoadImage8(handle, filename, &width, 1, &height,\n                                &pf)) == NULL)\n      continue;\n\n    maxBufSize = tj3JPEGBufSize(width, height, tests[ti].subsamp);\n    if (tj3Get(handle, TJPARAM_NOREALLOC)) {\n      if ((dstBuf = (unsigned char *)malloc(maxBufSize)) == NULL)\n        goto bailout;\n    } else\n      dstBuf = NULL;\n\n    tj3Set(handle, TJPARAM_SUBSAMP, tests[ti].subsamp);\n    tj3Set(handle, TJPARAM_QUALITY, tests[ti].quality);\n    if (tj3Compress8(handle, srcBuf, width, 0, height, pf, &dstBuf,\n                     &dstSize) == 0) {\n      \n      for (i = 0; i < dstSize; i++)\n        sum += dstBuf[i];\n    }\n\n    free(dstBuf);\n    dstBuf = NULL;\n    tj3Free(srcBuf);\n    srcBuf = NULL;\n\n    \n    if (sum > 255 * maxBufSize)\n      goto bailout;\n  }\n\nbailout:\n  free(dstBuf);\n  tj3Free(srcBuf);\n  if (fd >= 0) {\n    close(fd);\n    if (strlen(filename) > 0) unlink(filename);\n  }\n  tj3Destroy(handle);\n", "Selected Statement": "int width = 0, height = 0, fd = -1, i, ti;", "Function Input": {"data": {"value": "0x1108b40 \"0\\220\\020\\001\""}, "size": {"value": "17866816"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\t\t\t             MIME_STATE_ANY_END body_end,\n\t\t\t             MIME_STATE_ERR_PRINT err_print,\n\t\t\t             void *context)\n{\n    MIME_STATE *state;\n\n    state = (MIME_STATE *) mymalloc(sizeof(*state));\n\n    \n    state->err_flags = 0;\n    state->body_offset = 0;\t\t\t\n    SET_MIME_STATE(state, MIME_STATE_PRIMARY,\n\t\t   MIME_CTYPE_TEXT, MIME_STYPE_PLAIN,\n\t\t   MIME_ENC_7BIT, MIME_ENC_7BIT);\n    state->output_buffer = vstring_alloc(100);\n    state->prev_rec_type = 0;\n    state->stack = 0;\n    state->token_buffer = vstring_alloc(1);\n    state->nesting_level = -1;\t\t\t\n\n    \n    state->static_flags = flags;\n    state->head_out = head_out;\n    state->head_end = head_end;\n    state->body_out = body_out;\n    state->body_end = body_end;\n    state->err_print = err_print;\n    state->app_context = context;\n", "Selected Statement": "state->body_offset = 0;\t\t\t/* XXX */", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "postfix"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\n\nVSTRING *vstring_alloc(ssize_t len)\n{\n    VSTRING *vp;\n\n    \n    if (len < 1 || len > SSIZE_T_MAX - 1)\n\tmsg_panic(\"vstring_alloc: bad length %ld\", (long) len);\n    vp = (VSTRING *) mymalloc(sizeof(*vp));\n    vp->vbuf.flags = 0;\n    vp->vbuf.len = 0;\n    vp->vbuf.data = (unsigned char *) mymalloc(len + 1);\n    vp->vbuf.data[len] = 0;\n    vp->vbuf.len = len;\n    VSTRING_RESET(vp);\n    vp->vbuf.data[0] = 0;\n    vp->vbuf.get_ready = vstring_buf_get_ready;\n    vp->vbuf.put_ready = vstring_buf_put_ready;\n    vp->vbuf.space = vstring_buf_space;\n", "Selected Statement": "vp->vbuf.data[len] = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "postfix"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\n\nssize_t is_header_buf(const char *str, ssize_t str_len)\n{\n    const unsigned char *cp;\n    int     state;\n    int     c;\n    ssize_t len;\n\n#define INIT\t\t0\n#define IN_CHAR\t\t1\n#define IN_CHAR_SPACE\t2\n#define CU_CHAR_PTR(x)\t((const unsigned char *) (x))\n\n    \n    for (len = 0, state = INIT, cp = CU_CHAR_PTR(str); ; cp++) {\n\tif (str_len != IS_HEADER_NULL_TERMINATED && str_len-- <= 0)\n\t    return (0);\n\tswitch (c = *cp) {\n\tdefault:\n\t    if (c == 0 || !ISASCII(c) || ISCNTRL(c))\n\t\treturn (0);\n\t    if (state == INIT)\n\t\tstate = IN_CHAR;\n\t    if (state == IN_CHAR) {\n\t\tlen++;\n\t\tcontinue;\n\t    }\n\t    return (0);\n\tcase ' ':\n\tcase '\\t':\n\t    if (state == IN_CHAR)\n\t\tstate = IN_CHAR_SPACE;\n\t    if (state == IN_CHAR_SPACE)\n\t\tcontinue;\n\t    return (0);\n\tcase ':':\n\t    return ((state == IN_CHAR || state == IN_CHAR_SPACE) ? len : 0);\n\t}\n    }\n    \n    return (0);\n", "Selected Statement": "for (len = 0, state = INIT, cp = CU_CHAR_PTR(str); /* see below */; cp++) {", "Function Input": {"str": {"value": "<optimized out>"}, "str_len": {"value": "<optimized out>"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "postfix"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\n\nvoid    msg_output(MSG_OUTPUT_FN output_fn)\n{\n    int     i;\n\n    \n    if (msg_buffers[MSG_OUT_NESTING_LIMIT - 1] == 0) {\n\tfor (i = 0; i < MSG_OUT_NESTING_LIMIT; i++)\n\t    msg_buffers[i] = vstring_alloc(100);\n    }\n\n    \n    if (msg_output_fn_count == 0)\n\tmsg_output_fn = (MSG_OUTPUT_FN *) mymalloc(sizeof(*msg_output_fn));\n    else\n\tmsg_output_fn = (MSG_OUTPUT_FN *) myrealloc((void *) msg_output_fn,\n\t\t\t(msg_output_fn_count + 1) * sizeof(*msg_output_fn));\n    msg_output_fn[msg_output_fn_count++] = output_fn;\n", "Selected Statement": "for (i = 0; i < MSG_OUT_NESTING_LIMIT; i++)", "Function Input": {"output_fn": {"value": "<optimized out>"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "postfix"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\n\nTOK822 *tok822_alloc(int type, const char *strval)\n{\n    TOK822 *tp;\n\n#define CONTAINER_TOKEN(x) \\\n\t((x) == TOK822_ADDR || (x) == TOK822_STARTGRP)\n\n    tp = (TOK822 *) mymalloc(sizeof(*tp));\n    tp->type = type;\n    tp->next = tp->prev = tp->head = tp->tail = tp->owner = 0;\n    tp->vstr = (type < TOK822_MINTOK || CONTAINER_TOKEN(type) ? 0 :\n\t\tstrval == 0 ? vstring_alloc(10) :\n\t\tvstring_strcpy(vstring_alloc(strlen(strval) + 1), strval));\n", "Selected Statement": "tp->next = tp->prev = tp->head = tp->tail = tp->owner = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "postfix"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\n\nTOK822 *tok822_cut_before(TOK822 *tp)\n{\n    TOK822 *prev = tp->prev;\n\n    if (prev) {\n\tprev->next = 0;\n\ttp->prev = 0;\n    }\n", "Selected Statement": "prev->next = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "postfix"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "static int ssh_known_hosts_read_entries(const char *match,\n                                        const char *filename,\n                                        struct ssh_list **entries)\n{\n    char line[MAX_LINE_SIZE];\n    size_t lineno = 0;\n    size_t len = 0;\n    FILE *fp;\n    int rc;\n\n    fp = fopen(filename, \"r\");\n    if (fp == NULL) {\n        char err_msg[SSH_ERRNO_MSG_MAX] = {0};\n        SSH_LOG(SSH_LOG_TRACE, \"Failed to open the known_hosts file '%s': %s\",\n                filename, ssh_strerror(errno, err_msg, SSH_ERRNO_MSG_MAX));\n        \n        return SSH_OK;\n    }\n\n    if (*entries == NULL) {\n        *entries = ssh_list_new();\n        if (*entries == NULL) {\n            fclose(fp);\n            return SSH_ERROR;\n        }\n    }\n\n    for (rc = known_hosts_read_line(fp, line, sizeof(line), &len, &lineno);\n         rc == 0;\n         rc = known_hosts_read_line(fp, line, sizeof(line), &len, &lineno)) {\n        struct ssh_knownhosts_entry *entry = NULL;\n        struct ssh_iterator *it = NULL;\n        char *p = NULL;\n\n        if (line[len] != '\\n') {\n            len = strcspn(line, \"\\n\");\n        }\n        line[len] = '\\0';\n\n        \n        for (p = line; isspace((int)p[0]); p++);\n\n        \n        if (p[0] == '\\0' || p[0] == '#') {\n            continue;\n        }\n\n        \n        if (p[0] == '@') {\n            continue;\n        }\n\n        rc = ssh_known_hosts_parse_line(match,\n                                        line,\n                                        &entry);\n        if (rc == SSH_AGAIN) {\n            continue;\n        } else if (rc != SSH_OK) {\n            goto error;\n        }\n\n        \n        for (it = ssh_list_get_iterator(*entries);\n             it != NULL;\n             it = it->next) {\n            struct ssh_knownhosts_entry *entry2;\n            int cmp;\n            entry2 = ssh_iterator_value(struct ssh_knownhosts_entry *, it);\n            cmp = ssh_known_hosts_entries_compare(entry, entry2);\n            if (cmp == 0) {\n                ssh_knownhosts_entry_free(entry);\n                entry = NULL;\n                break;\n            }\n        }\n        if (entry != NULL) {\n            ssh_list_append(*entries, entry);\n        }\n    }\n\n    fclose(fp);\n    return SSH_OK;\nerror:\n    fclose(fp);\n    return SSH_ERROR;\n", "Selected Statement": "size_t lineno = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libssh"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "    return s;\n}\n\nssh_bind ssh_bind_new(void) {\n    ssh_bind ptr;\n\n    ptr = calloc(1, sizeof(struct ssh_bind_struct));\n    if (ptr == NULL) {\n        return NULL;\n    }\n    ptr->bindfd = SSH_INVALID_SOCKET;\n    ptr->bindport = 22;\n    ptr->common.log_verbosity = 0;\n\n    return ptr;\n", "Selected Statement": "ptr->bindport = 22;", "Function Input": {}, "Variable Values Before Statement": {"constant": "22"}, "Value After Statement Execution": "22", "Project Information": "libssh"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": " * @returns             A new ssh_session pointer, NULL on error.\n */\nssh_session ssh_new(void)\n{\n    ssh_session session;\n    char *id = NULL;\n    int rc;\n\n    session = calloc(1, sizeof (struct ssh_session_struct));\n    if (session == NULL) {\n        return NULL;\n    }\n\n    session->next_crypto = crypto_new();\n    if (session->next_crypto == NULL) {\n        goto err;\n    }\n\n    session->socket = ssh_socket_new(session);\n    if (session->socket == NULL) {\n        goto err;\n    }\n\n    session->out_buffer = ssh_buffer_new();\n    if (session->out_buffer == NULL) {\n        goto err;\n    }\n\n    session->in_buffer = ssh_buffer_new();\n    if (session->in_buffer == NULL) {\n        goto err;\n    }\n\n    session->out_queue = ssh_list_new();\n    if (session->out_queue == NULL) {\n        goto err;\n    }\n\n    session->alive = 0;\n    session->auth.supported_methods = 0;\n    ssh_set_blocking(session, 1);\n    session->maxchannel = FIRST_CHANNEL;\n\n    session->agent = ssh_agent_new(session);\n    if (session->agent == NULL) {\n        goto err;\n    }\n\n    \n    session->opts.StrictHostKeyChecking = 1;\n    session->opts.port = 22;\n    session->opts.fd = -1;\n    session->opts.compressionlevel = 7;\n    session->opts.nodelay = 0;\n    session->opts.identities_only = false;\n    session->opts.control_master = SSH_CONTROL_MASTER_NO;\n\n    session->opts.flags = SSH_OPT_FLAG_PASSWORD_AUTH |\n                          SSH_OPT_FLAG_PUBKEY_AUTH |\n                          SSH_OPT_FLAG_KBDINT_AUTH |\n                          SSH_OPT_FLAG_GSSAPI_AUTH;\n\n    session->opts.exp_flags = 0;\n\n    session->opts.identity = ssh_list_new();\n    if (session->opts.identity == NULL) {\n        goto err;\n    }\n    session->opts.identity_non_exp = ssh_list_new();\n    if (session->opts.identity_non_exp == NULL) {\n        goto err;\n    }\n\n    session->opts.certificate = ssh_list_new();\n    if (session->opts.certificate == NULL) {\n        goto err;\n    }\n    session->opts.certificate_non_exp = ssh_list_new();\n    if (session->opts.certificate_non_exp == NULL) {\n        goto err;\n    }\n    \n\n    id = strdup(\"%d/id_ed25519\");\n    if (id == NULL) {\n        goto err;\n    }\n\n    rc = ssh_list_append(session->opts.identity_non_exp, id);\n    if (rc == SSH_ERROR) {\n        goto err;\n    }\n\n#ifdef HAVE_ECC\n    id = strdup(\"%d/id_ecdsa\");\n    if (id == NULL) {\n        goto err;\n    }\n    rc = ssh_list_append(session->opts.identity_non_exp, id);\n    if (rc == SSH_ERROR) {\n        goto err;\n    }\n#endif\n\n    id = strdup(\"%d/id_rsa\");\n    if (id == NULL) {\n        goto err;\n    }\n    rc = ssh_list_append(session->opts.identity_non_exp, id);\n    if (rc == SSH_ERROR) {\n        goto err;\n    }\n\n    \n    session->session_state = SSH_SESSION_STATE_NONE;\n    session->pending_call_state = SSH_PENDING_CALL_NONE;\n    session->packet_state = PACKET_STATE_INIT;\n    session->dh_handshake_state = DH_STATE_INIT;\n    session->global_req_state = SSH_CHANNEL_REQ_STATE_NONE;\n\n    session->auth.state = SSH_AUTH_STATE_NONE;\n    session->auth.service_state = SSH_AUTH_SERVICE_NONE;\n\n    return session;\n\nerr:\n    free(id);\n    ssh_free(session);\n    return NULL;\n", "Selected Statement": "session->opts.nodelay = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libssh"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": " * \\brief creates a new Socket object\n */\nssh_socket ssh_socket_new(ssh_session session)\n{\n    ssh_socket s;\n\n    s = calloc(1, sizeof(struct ssh_socket_struct));\n    if (s == NULL) {\n        ssh_set_error_oom(session);\n        return NULL;\n    }\n    s->fd = SSH_INVALID_SOCKET;\n    s->last_errno = -1;\n    s->fd_is_socket = 1;\n    s->session = session;\n    s->in_buffer = ssh_buffer_new();\n    if (s->in_buffer == NULL) {\n        ssh_set_error_oom(session);\n        SAFE_FREE(s);\n        return NULL;\n    }\n    s->out_buffer=ssh_buffer_new();\n    if (s->out_buffer == NULL) {\n        ssh_set_error_oom(session);\n        SSH_BUFFER_FREE(s->in_buffer);\n        SAFE_FREE(s);\n        return NULL;\n    }\n    s->read_wontblock = 0;\n    s->write_wontblock = 0;\n    s->data_except = 0;\n    s->poll_handle = NULL;\n    s->state=SSH_SOCKET_NONE;\n    return s;\n", "Selected Statement": "s->data_except = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libssh"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "    }\n}\n\nssh_agent ssh_agent_new(struct ssh_session_struct *session) {\n  ssh_agent agent = NULL;\n\n  agent = malloc(sizeof(struct ssh_agent_struct));\n  if (agent == NULL) {\n    return NULL;\n  }\n  ZERO_STRUCTP(agent);\n\n  agent->count = 0;\n  agent->sock = ssh_socket_new(session);\n  if (agent->sock == NULL) {\n    SAFE_FREE(agent);\n    return NULL;\n  }\n  agent->channel = NULL;\n  return agent;\n", "Selected Statement": "agent->count = 0;", "Function Input": {"agent": {"value": "0x510b29 <ssh_set_blocking+105>"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libssh"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": " */\nchar *ssh_find_all_matching(const char *available_list,\n                            const char *preferred_list)\n{\n    struct ssh_tokens_st *a_tok = NULL, *p_tok = NULL;\n    int i, j;\n    char *ret = NULL;\n    size_t max, len, pos = 0;\n    int match;\n\n    if ((available_list == NULL) || (preferred_list == NULL)) {\n        return NULL;\n    }\n\n    max = MAX(strlen(available_list), strlen(preferred_list));\n\n    ret = calloc(1, max + 1);\n    if (ret == NULL) {\n        return NULL;\n    }\n\n    a_tok = ssh_tokenize(available_list, ',');\n    if (a_tok == NULL) {\n        SAFE_FREE(ret);\n        goto out;\n    }\n\n    p_tok = ssh_tokenize(preferred_list, ',');\n    if (p_tok == NULL) {\n        SAFE_FREE(ret);\n        goto out;\n    }\n\n    for (i = 0; p_tok->tokens[i] ; i++) {\n        for (j = 0; a_tok->tokens[j]; j++) {\n            match = !strcmp(a_tok->tokens[j], p_tok->tokens[i]);\n            if (match) {\n                if (pos != 0) {\n                    ret[pos] = ',';\n                    pos++;\n                }\n\n                len = strlen(a_tok->tokens[j]);\n                memcpy(&ret[pos], a_tok->tokens[j], len);\n                pos += len;\n                ret[pos] = '\\0';\n            }\n        }\n    }\n\n    if (ret[0] == '\\0') {\n        SAFE_FREE(ret);\n    }\n\nout:\n    ssh_tokens_free(a_tok);\n    ssh_tokens_free(p_tok);\n    return ret;\n", "Selected Statement": "for (i = 0; p_tok->tokens[i] ; i++) {", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "libssh"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\nvoid\nk5_buf_init_dynamic(struct k5buf *buf)\n{\n    buf->buftype = K5BUF_DYNAMIC;\n    buf->space = 128;\n    buf->data = malloc(buf->space);\n    if (buf->data == NULL) {\n        set_error(buf);\n        return;\n    }\n    buf->len = 0;\n", "Selected Statement": "buf->space = 128;", "Function Input": {"buf": {"value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x65cc6ead\n", "message": "Cannot access memory at address 0x65cc6ead"}}}, "Variable Values Before Statement": {"constant": "128"}, "Value After Statement Execution": "128", "Project Information": "krb5"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "\n\nsize_t krb5int_ucs4_to_utf8(krb5_ucs4 c, char *buf)\n{\n    size_t len = 0;\n    unsigned char *p = (unsigned char *) buf;\n\n    \n    if (c > 0x10ffff)\n        return 0;\n\n    \n    if (buf == NULL) {\n        if (c < 0x80) return 1;\n        else if (c < 0x800) return 2;\n        else if (c < 0x10000) return 3;\n        else return 4;\n    }\n\n    if (c < 0x80) {\n        p[len++] = c;\n    } else if (c < 0x800) {\n        p[len++] = 0xc0 | ( c >> 6 );\n        p[len++] = 0x80 | ( c & 0x3f );\n    } else if (c < 0x10000) {\n        p[len++] = 0xe0 | ( c >> 12 );\n        p[len++] = 0x80 | ( (c >> 6) & 0x3f );\n        p[len++] = 0x80 | ( c & 0x3f );\n    } else  {\n        p[len++] = 0xf0 | ( c >> 18 );\n        p[len++] = 0x80 | ( (c >> 12) & 0x3f );\n        p[len++] = 0x80 | ( (c >> 6) & 0x3f );\n        p[len++] = 0x80 | ( c & 0x3f );\n    }\n\n    return len;\n", "Selected Statement": "size_t len = 0;", "Function Input": {"p": {"value": "0x73004c1cdf <error: Cannot access memory at address 0x73004c1cdf>"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "krb5"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "#include <unistd.h>\n\nvoid fuzzer_init(struct fuzzer_context *fuzz_ctx)\n{\n\ti_zero(fuzz_ctx);\n\tif (!lib_is_initialized()) {\n\t\tlib_init();\n\t\tlib_signals_init();\n\t\tlib_signals_ignore(SIGPIPE, TRUE);\n\t}\n\tfuzz_ctx->fd = -1;\n", "Selected Statement": "fuzz_ctx->fd = -1;", "Function Input": {"fuzz_ctx": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"fd": {"type_category": "int", "concrete_type": "int", "value": "-2051002043"}, "fd_pump": {"type_category": "int", "concrete_type": "int", "value": "-1794162240"}, "pump": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7ffff7cb63ce <fflush+142>", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x800003f7d8f741c0\n", "message": "Cannot access memory at address 0x800003f7d8f741c0"}}, "ioloop": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7ffff7cb63d6 <fflush+150>", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x88bb8b4829750000\n", "message": "Cannot access memory at address 0x88bb8b4829750000"}}}}}}, "Variable Values Before Statement": {"constant": "-1"}, "Value After Statement Execution": "-1", "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "}\n\nvoid var_expand_extensions_init(void)\n{\n\ti_array_init(&var_expand_extensions, 32);\n\n\t\n\tfor(const struct hash_method **meth = hash_methods;\n\t    *meth != NULL;\n\t    meth++) {\n\t\tstruct var_expand_extension_func_table *func =\n\t\t\tarray_append_space(&var_expand_extensions);\n\t\tfunc->key = (*meth)->name;\n\t\tfunc->func = var_expand_hash;\n\t}\n\n\t\n\tstruct var_expand_extension_func_table *func =\n\t\tarray_append_space(&var_expand_extensions);\n\tfunc->key = \"pkcs5\";\n\tfunc->func = var_expand_hash;\n\n\t\n\tfunc = array_append_space(&var_expand_extensions);\n\tfunc->key = \"if\";\n\tfunc->func = var_expand_if;\n\n\t\n\tfunc = array_append_space(&var_expand_extensions);\n\tfunc->key = \"system\";\n\tfunc->func = var_expand_system;\n\n\t\n\tfunc = array_append_space(&var_expand_extensions);\n\tfunc->key = \"process\";\n\tfunc->func = var_expand_process;\n", "Selected Statement": "func->key = \"pkcs5\";", "Function Input": {}, "Variable Values Before Statement": {"constant": "\"pkcs5\""}, "Value After Statement Execution": "\"pkcs5\"", "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "}\n\nvoid lib_signals_init(void)\n{\n\tint i;\n\n\tsignals_initialized = TRUE;\n\tio_loop_add_switch_callback(lib_signals_ioloop_switched);\n\tio_loop_add_destroy_callback(lib_signals_ioloop_destroyed);\n\n\t\n\tfor (i = 0; i < MAX_SIGNAL_VALUE; i++) {\n\t\tif (signal_handlers[i] != NULL)\n\t\t\tlib_signals_set(i, signal_handlers[i]->flags);\n\t}\n", "Selected Statement": "for (i = 0; i < MAX_SIGNAL_VALUE; i++) {", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "struct istream *\ni_stream_create(struct istream_private *_stream, struct istream *parent, int fd,\n\t\tenum istream_create_flag flags)\n{\n\tbool noop_snapshot = (flags & ISTREAM_CREATE_FLAG_NOOP_SNAPSHOT) != 0;\n\n\t_stream->fd = fd;\n\tif (parent != NULL)\n\t\ti_stream_init_parent(_stream, parent);\n\telse if (_stream->memarea == NULL && !noop_snapshot) {\n\t\t\n\t\t_stream->memarea = memarea_init_empty();\n\t}\n\t_stream->istream.real_stream = _stream;\n\n\tif (_stream->iostream.close == NULL)\n\t\t_stream->iostream.close = i_stream_default_close;\n\tif (_stream->iostream.destroy == NULL)\n\t\t_stream->iostream.destroy = i_stream_default_destroy;\n\tif (_stream->seek == NULL) {\n\t\t_stream->seek = _stream->istream.seekable ?\n\t\t\ti_stream_default_seek_seekable :\n\t\t\ti_stream_default_seek_nonseekable;\n\t}\n\tif (_stream->stat == NULL)\n\t\t_stream->stat = i_stream_default_stat;\n\tif (_stream->get_size == NULL)\n\t\t_stream->get_size = i_stream_default_get_size;\n\tif (_stream->snapshot == NULL) {\n\t\t_stream->snapshot = noop_snapshot ?\n\t\t\ti_stream_noop_snapshot :\n\t\t\ti_stream_default_snapshot;\n\t}\n\tif (_stream->iostream.set_max_buffer_size == NULL) {\n\t\t_stream->iostream.set_max_buffer_size =\n\t\t\ti_stream_default_set_max_buffer_size;\n\t}\n\tif (_stream->init_buffer_size == 0)\n\t\t_stream->init_buffer_size = I_STREAM_MIN_SIZE;\n\n\ti_zero(&_stream->statbuf);\n\t_stream->statbuf.st_size = -1;\n\t_stream->statbuf.st_atime =\n\t\t_stream->statbuf.st_mtime =\n\t\t_stream->statbuf.st_ctime = ioloop_time;\n\t_stream->cached_stream_size = UOFF_T_MAX;\n\n\tio_stream_init(&_stream->iostream);\n\n\tif (_stream->istream.stream_errno != 0)\n\t\t_stream->istream.eof = TRUE;\n\n", "Selected Statement": "_stream->statbuf.st_size = -1;", "Function Input": {}, "Variable Values Before Statement": {"constant": "-1"}, "Value After Statement Execution": "-1", "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "}\n\nvoid io_stream_init(struct iostream_private *stream)\n{\n\tif (stream->close == NULL)\n\t\tstream->close = io_stream_default_close;\n\tif (stream->destroy == NULL)\n\t\tstream->destroy = io_stream_default_destroy;\n\tstream->ioloop = current_ioloop;\n\n\tstream->refcount = 1;\n", "Selected Statement": "stream->refcount = 1;", "Function Input": {}, "Variable Values Before Statement": {"constant": "1"}, "Value After Statement Execution": "1", "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "json_istream_create(struct istream *input, enum json_istream_type type,\n\t\t    const struct json_limits *limits,\n\t\t    enum json_parser_flags parser_flags)\n{\n\tstruct json_istream *stream;\n\n\tstream = i_new(struct json_istream, 1);\n\tstream->refcount = 1;\n\tstream->type = type;\n\n\tstream->input = input; \n\tstream->parser = json_parser_init(input, limits, parser_flags,\n\t\t\t\t\t  &parser_callbacks, (void *)stream);\n\n", "Selected Statement": "stream->refcount = 1;", "Function Input": {"stream": {"value": null}}, "Variable Values Before Statement": {"constant": "1"}, "Value After Statement Execution": "1", "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "};\n\npool_t pool_datastack_create(void)\n{\n\tstruct datastack_pool *dpool;\n\n\tdpool = t_new(struct datastack_pool, 1);\n\tdpool->pool = static_data_stack_pool;\n\tdpool->refcount = 1;\n\tdpool->data_stack_frame = data_stack_frame_id;\n", "Selected Statement": "dpool->refcount = 1;", "Function Input": {}, "Variable Values Before Statement": {"constant": "1"}, "Value After Statement Execution": "1", "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "int imap_bodystructure_parse_full(const char *bodystructure,\n\tpool_t pool, struct message_part **parts,\n\tconst char **error_r)\n{\n\tstruct istream *input;\n\tstruct imap_parser *parser;\n\tconst struct imap_arg *args;\n\tint ret;\n\n\ti_assert(*parts == NULL || (*parts)->next == NULL);\n\n\tinput = i_stream_create_from_data(bodystructure, strlen(bodystructure));\n\t(void)i_stream_read(input);\n\n\tparser = imap_parser_create(input, NULL, SIZE_MAX);\n\tret = imap_parser_finish_line(parser, 0,\n\t\t\t\t      IMAP_PARSE_FLAG_LITERAL_TYPE, &args);\n\tif (ret < 0) {\n\t\t*error_r = t_strdup_printf(\"IMAP parser failed: %s\",\n\t\t\t\t\t   imap_parser_get_error(parser, NULL));\n\t} else if (ret == 0) {\n\t\t*error_r = \"Empty bodystructure\";\n\t\tret = -1;\n\t} else {\n\t\tT_BEGIN {\n\t\t\tret = imap_bodystructure_parse_args\n\t\t\t\t(args, pool, parts, error_r);\n\t\t} T_END_PASS_STR_IF(ret < 0, error_r);\n\t}\n\n\tif (ret < 0) {\n\t\t\n\t\timap_bodystructure_reset_data(*parts);\n\t}\n\n\timap_parser_unref(&parser);\n\ti_stream_destroy(&input);\n", "Selected Statement": "*error_r = \"Empty bodystructure\";", "Function Input": {}, "Variable Values Before Statement": {"constant": "\"Empty bodystructure\""}, "Value After Statement Execution": "\"Empty bodystructure\"", "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "struct imap_parser *\nimap_parser_create(struct istream *input, struct ostream *output,\n\t\t   size_t max_line_size)\n{\n\tstruct imap_parser *parser;\n\n\tparser = i_new(struct imap_parser, 1);\n\tparser->refcount = 1;\n\tparser->pool = pool_alloconly_create(MEMPOOL_GROWING\"IMAP parser\",\n\t\t\t\t\t     1024);\n\tparser->input = input;\n\tparser->output = output;\n\tparser->max_line_size = max_line_size;\n\n\tp_array_init(&parser->root_list, parser->pool, LIST_INIT_COUNT);\n\tparser->cur_list = &parser->root_list;\n", "Selected Statement": "parser->refcount = 1;", "Function Input": {}, "Variable Values Before Statement": {"constant": "1"}, "Value After Statement Execution": "1", "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "struct message_parser_ctx *\nmessage_parser_init(pool_t part_pool, struct istream *input,\n\t\t    const struct message_parser_settings *set)\n{\n\tstruct message_parser_ctx *ctx;\n\n\tctx = message_parser_init_int(input, set);\n\tctx->part_pool = part_pool;\n\tctx->parts = ctx->part = p_new(part_pool, struct message_part, 1);\n\tctx->next_part = &ctx->part->children;\n\tctx->parse_next_block = parse_next_header_init;\n\tctx->total_parts_count = 1;\n\ti_array_init(&ctx->next_part_stack, 4);\n", "Selected Statement": "ctx->total_parts_count = 1;", "Function Input": {}, "Variable Values Before Statement": {"constant": "1"}, "Value After Statement Execution": "1", "Project Information": "dovecot"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "        , size_t digest_size\n#endif\n        )\n{\n    hash_state *hs;\n    int i;\n#if DIGEST_SIZE == (512/8)\n    size_t variant;\n#endif\n\n    if (NULL == shaState) {\n        return ERR_NULL;\n    }\n\n    *shaState = hs = (hash_state*) calloc(1, sizeof(hash_state));\n    if (NULL == hs)\n        return ERR_MEMORY;\n\n    hs->curlen = 0;\n    hs->totbits[0] = hs->totbits[1] = 0;\n\n    \n#if DIGEST_SIZE == (512/8)\n    hs->digest_size = digest_size;\n\n    switch (digest_size) {\n        case 28: variant = 1;   \n                 break;\n        case 32: variant = 2;   \n                 break;\n        default: variant = 0;   \n    }\n    \n    for (i=0; i<8; i++) {\n        hs->h[i] = H_SHA_512[variant][i];\n    }\n#else\n    hs->digest_size = DIGEST_SIZE;\n    for (i=0; i<8; i++) {\n        hs->h[i] = H[i];\n    }\n#endif\n\n    return 0;\n", "Selected Statement": "for (i=0; i<8; i++) {", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "pycryptodome"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "}\n\nEXPORT_SYM int MD5_init(hash_state **mdState)\n{\n    hash_state *hs;\n\n    if (NULL == mdState) {\n        return ERR_NULL;\n    }\n\n    *mdState = hs = (hash_state*) calloc(1, sizeof(hash_state));\n    if (NULL == hs)\n        return ERR_MEMORY;\n\n    hs->curlen = 0;\n    hs->totbits = 0;\n\n    \n    hs->h[0] = 0x67452301;\n    hs->h[1] = 0xefcdab89;\n    hs->h[2] = 0x98badcfe;\n    hs->h[3] = 0x10325476;\n\n    return 0;\n", "Selected Statement": "hs->h[2] = 0x98badcfe;", "Function Input": {"hs": {"value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x48\n", "message": "Cannot access memory at address 0x48"}}}, "Variable Values Before Statement": {"constant": "0x98badcfe"}, "Value After Statement Execution": "0x98badcfe", "Project Information": "pycryptodome"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "#define ROL(x, n) (((x) << n) | ((x) >> (32-n) ))\n\nEXPORT_SYM int md4_init (hash_state **md4State)\n{\n    hash_state *hs;\n    \n    if (NULL == md4State) {\n        return ERR_NULL;\n    }\n\n    *md4State = hs = (hash_state*) calloc(1, sizeof(hash_state));\n    if (NULL == hs)\n        return ERR_MEMORY;\n \n    hs->A=0x67452301;\n    hs->B=0xefcdab89;\n    hs->C=0x98badcfe;\n    hs->D=0x10325476;\n\n    return 0;\n", "Selected Statement": "hs->B=0xefcdab89;", "Function Input": {"md4State": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf583b0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x2ff3d\n", "message": "Cannot access memory at address 0x2ff3d"}}}}, "Variable Values Before Statement": {"constant": "0xefcdab89"}, "Value After Statement Execution": "0xefcdab89", "Project Information": "pycryptodome"}
{"Programming Language": "C", "Statement Type": "Constant Assignment", "Source Code": "size_t krb5int_ucs4_to_utf8(krb5_ucs4 c, char *buf)\n{\n    size_t len = 0;\n    unsigned char *p = (unsigned char *) buf;\n\n    \n    if (c > 0x10ffff)\n        return 0;\n\n    \n    if (buf == NULL) {\n        if (c < 0x80) return 1;\n        else if (c < 0x800) return 2;\n        else if (c < 0x10000) return 3;\n        else return 4;\n    }\n\n    if (c < 0x80) {\n        p[len++] = c;\n    } else if (c < 0x800) {\n        p[len++] = 0xc0 | ( c >> 6 );\n        p[len++] = 0x80 | ( c & 0x3f );\n    } else if (c < 0x10000) {\n        p[len++] = 0xe0 | ( c >> 12 );\n        p[len++] = 0x80 | ( (c >> 6) & 0x3f );\n        p[len++] = 0x80 | ( c & 0x3f );\n    } else  {\n        p[len++] = 0xf0 | ( c >> 18 );\n        p[len++] = 0x80 | ( (c >> 12) & 0x3f );\n        p[len++] = 0x80 | ( (c >> 6) & 0x3f );\n        p[len++] = 0x80 | ( c & 0x3f );\n    }\n\n    return len;\n}", "Selected Statement": "size_t len = 0;", "Function Input": {"p": {"value": "0x6c004c1cdf <error: Cannot access memory at address 0x6c004c1cdf>"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Project Information": "krb5"}
