{"Programming Language": "C", "Statement Type": "Arithmetic Assignment", "Source Code": "static inline void\nquota_init(struct quota *quota, size_t total)\n{\n\tuint64_t new_total = (total + (QUOTA_UNIT_SIZE - 1)) /\n\t\t\t\tQUOTA_UNIT_SIZE;\n\tquota->value = new_total << 32;\n}", "Selected Statement": "quota->value = new_total << 32;", "Function Input": {"quota": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"value": {"type_category": "unknown", "concrete_type": "uint64_t", "value": "10740875931435413829"}}}}, "total": {"value": "140737348572320"}}, "Variable Values Before Statement": {"new_total": "4294967295"}, "Value After Statement Execution": "NULL", "Project Information": "tarantool"}
{"Programming Language": "C", "Statement Type": "Arithmetic Assignment", "Source Code": "void\nmempool_create_with_order(struct mempool *pool, struct slab_cache *cache,\n\t\t\t  uint32_t objsize, uint8_t order)\n{\n\tassert(order <= cache->order_max);\n\tpool->cache = cache;\n\tslab_list_create(&pool->slabs);\n\tmslab_tree_new(&pool->hot_slabs);\n\tpool->first_hot_slab = NULL;\n\trlist_create(&pool->cold_slabs);\n\tpool->spare = NULL;\n\tpool->objsize = objsize;\n\tpool->slab_order = order;\n\t\n\tuint32_t slab_size = slab_order_size(pool->cache, pool->slab_order);\n\t\n\tpool->objcount = (slab_size - mslab_sizeof()) / objsize;\n\tassert(pool->objcount);\n\tpool->offset = slab_size - pool->objcount * pool->objsize;\n\tpool->slab_ptr_mask = ~(slab_order_size(cache, order) - 1);\n\tpool->small_mempool = NULL;\n}", "Selected Statement": "pool->offset = slab_size - pool->objcount * pool->objsize;", "Function Input": {}, "Variable Values Before Statement": {"slab_size": "65536", "pool": {"cache": null, "slabs": null, "hot_slabs": null, "first_hot_slab": null, "cold_slabs": null, "spare": null, "objsize": "440", "slab_order": "4 '\\004'", "objcount": "148", "offset": "416", "slab_ptr_mask": "0", "small_mempool": null}}, "Value After Statement Execution": "416", "Project Information": "tarantool"}
{"Programming Language": "C", "Statement Type": "Arithmetic Assignment", "Source Code": "MemoryContext\nAllocSetContextCreateInternal(MemoryContext parent,\n\t\t\t\t\t\t\t  const char *name,\n\t\t\t\t\t\t\t  Size minContextSize,\n\t\t\t\t\t\t\t  Size initBlockSize,\n\t\t\t\t\t\t\t  Size maxBlockSize)\n{\n\tint\t\t\tfreeListIndex;\n\tSize\t\tfirstBlockSize;\n\tAllocSet\tset;\n\tAllocBlock\tblock;\n\n\t\n\tStaticAssertDecl(ALLOC_CHUNKHDRSZ == MAXALIGN(ALLOC_CHUNKHDRSZ),\n\t\t\t\t\t \"sizeof(MemoryChunk) is not maxaligned\");\n\t\n\tStaticAssertDecl(sizeof(AllocFreeListLink) <= (1 << ALLOC_MINBITS),\n\t\t\t\t\t \"sizeof(AllocFreeListLink) larger than minimum allocation size\");\n\n\t\n\tAssert(initBlockSize == MAXALIGN(initBlockSize) &&\n\t\t   initBlockSize >= 1024);\n\tAssert(maxBlockSize == MAXALIGN(maxBlockSize) &&\n\t\t   maxBlockSize >= initBlockSize &&\n\t\t   AllocHugeSizeIsValid(maxBlockSize)); \n\tAssert(minContextSize == 0 ||\n\t\t   (minContextSize == MAXALIGN(minContextSize) &&\n\t\t\tminContextSize >= 1024 &&\n\t\t\tminContextSize <= maxBlockSize));\n\tAssert(maxBlockSize <= MEMORYCHUNK_MAX_BLOCKOFFSET);\n\n\t\n\tif (minContextSize == ALLOCSET_DEFAULT_MINSIZE &&\n\t\tinitBlockSize == ALLOCSET_DEFAULT_INITSIZE)\n\t\tfreeListIndex = 0;\n\telse if (minContextSize == ALLOCSET_SMALL_MINSIZE &&\n\t\t\t initBlockSize == ALLOCSET_SMALL_INITSIZE)\n\t\tfreeListIndex = 1;\n\telse\n\t\tfreeListIndex = -1;\n\n\t\n\tif (freeListIndex >= 0)\n\t{\n\t\tAllocSetFreeList *freelist = &context_freelists[freeListIndex];\n\n\t\tif (freelist->first_free != NULL)\n\t\t{\n\t\t\t\n\t\t\tset = freelist->first_free;\n\t\t\tfreelist->first_free = (AllocSet) set->header.nextchild;\n\t\t\tfreelist->num_free--;\n\n\t\t\t\n\t\t\tset->maxBlockSize = maxBlockSize;\n\n\t\t\t\n\t\t\tMemoryContextCreate((MemoryContext) set,\n\t\t\t\t\t\t\t\tT_AllocSetContext,\n\t\t\t\t\t\t\t\tMCTX_ASET_ID,\n\t\t\t\t\t\t\t\tparent,\n\t\t\t\t\t\t\t\tname);\n\n\t\t\t((MemoryContext) set)->mem_allocated =\n\t\t\t\tset->keeper->endptr - ((char *) set);\n\n\t\t\treturn (MemoryContext) set;\n\t\t}\n\t}\n\n\t\n\tfirstBlockSize = MAXALIGN(sizeof(AllocSetContext)) +\n\t\tALLOC_BLOCKHDRSZ + ALLOC_CHUNKHDRSZ;\n\tif (minContextSize != 0)\n\t\tfirstBlockSize = Max(firstBlockSize, minContextSize);\n\telse\n\t\tfirstBlockSize = Max(firstBlockSize, initBlockSize);\n\n\t\n\tset = (AllocSet) malloc(firstBlockSize);\n\tif (set == NULL)\n\t{\n\t\tif (TopMemoryContext)\n\t\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed while creating memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   name)));\n\t}\n\n\t\n\n\t\n\tblock = (AllocBlock) (((char *) set) + MAXALIGN(sizeof(AllocSetContext)));\n\tblock->aset = set;\n\tblock->freeptr = ((char *) block) + ALLOC_BLOCKHDRSZ;\n\tblock->endptr = ((char *) set) + firstBlockSize;\n\tblock->prev = NULL;\n\tblock->next = NULL;\n\n\t\n\tVALGRIND_MAKE_MEM_NOACCESS(block->freeptr, block->endptr - block->freeptr);\n\n\t\n\tset->blocks = block;\n\t\n\tset->keeper = block;\n\n\t\n\tMemSetAligned(set->freelist, 0, sizeof(set->freelist));\n\n\tset->initBlockSize = initBlockSize;\n\tset->maxBlockSize = maxBlockSize;\n\tset->nextBlockSize = initBlockSize;\n\tset->freeListIndex = freeListIndex;\n\n\t\n\tStaticAssertStmt(ALLOC_CHUNK_LIMIT == ALLOCSET_SEPARATE_THRESHOLD,\n\t\t\t\t\t \"ALLOC_CHUNK_LIMIT != ALLOCSET_SEPARATE_THRESHOLD\");\n\n\t\n\tset->allocChunkLimit = ALLOC_CHUNK_LIMIT;\n\twhile ((Size) (set->allocChunkLimit + ALLOC_CHUNKHDRSZ) >\n\t\t   (Size) ((maxBlockSize - ALLOC_BLOCKHDRSZ) / ALLOC_CHUNK_FRACTION))\n\t\tset->allocChunkLimit >>= 1;\n\n\t\n\tMemoryContextCreate((MemoryContext) set,\n\t\t\t\t\t\tT_AllocSetContext,\n\t\t\t\t\t\tMCTX_ASET_ID,\n\t\t\t\t\t\tparent,\n\t\t\t\t\t\tname);\n\n\t((MemoryContext) set)->mem_allocated = firstBlockSize;\n\n\treturn (MemoryContext) set;\n}", "Selected Statement": "block->freeptr = ((char *) block) + ALLOC_BLOCKHDRSZ;", "Function Input": {}, "Variable Values Before Statement": {"block": "AllocBlock", "ALLOC_BLOCKHDRSZ": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "libpg_query"}
{"Programming Language": "C", "Statement Type": "Arithmetic Assignment", "Source Code": "int\npg_vsnprintf(char *str, size_t count, const char *fmt, va_list args)\n{\n\tPrintfTarget target;\n\tchar\t\tonebyte[1];\n\n\t\n\tif (count == 0)\n\t{\n\t\tstr = onebyte;\n\t\tcount = 1;\n\t}\n\ttarget.bufstart = target.bufptr = str;\n\ttarget.bufend = str + count - 1;\n\ttarget.stream = NULL;\n\ttarget.nchars = 0;\n\ttarget.failed = false;\n\tdopr(&target, fmt, args);\n\t*(target.bufptr) = '\\0';\n\treturn target.failed ? -1 : (target.bufptr - target.bufstart\n\t\t\t\t\t\t\t\t + target.nchars);\n}", "Selected Statement": "target.bufend = str + count - 1;", "Function Input": {"count": {"value": "<optimized out>"}, "fmt": {"value": "<optimized out>"}, "str": {"value": "<optimized out>"}}, "Variable Values Before Statement": {"str": "0x11ad798 \"\"", "count": "1024"}, "Value After Statement Execution": "0x11adb97 \"\"", "Project Information": "libpg_query"}
{"Programming Language": "C", "Statement Type": "Arithmetic Assignment", "Source Code": "APR_DECLARE(apr_status_t) apr_parse_addr_port(char **addr,\n                                              char **scope_id,\n                                              apr_port_t *port,\n                                              const char *str,\n                                              apr_pool_t *p)\n{\n    const char *ch, *lastchar;\n    int big_port;\n    apr_size_t addrlen;\n\n    *addr = NULL;         \n    *scope_id = NULL;     \n    *port = 0;            \n\n    \n    ch = lastchar = str + strlen(str) - 1;\n    while (ch >= str && apr_isdigit(*ch)) {\n        --ch;\n    }\n\n    if (ch < str) {       \n        big_port = atoi(str);\n        if (big_port < 1 || big_port > 65535) {\n            return APR_EINVAL;\n        }\n        *port = big_port;\n        return APR_SUCCESS;\n    }\n\n    if (*ch == ':' && ch < lastchar) { \n        if (ch == str) {               \n            return APR_EINVAL;\n        }\n        big_port = atoi(ch + 1);\n        if (big_port < 1 || big_port > 65535) {\n            return APR_EINVAL;\n        }\n        *port = big_port;\n        lastchar = ch - 1;\n    }\n\n    \n    addrlen = lastchar - str + 1;\n\n\n#if APR_HAVE_IPV6\n    if (*str == '[') {\n        const char *end_bracket = memchr(str, ']', addrlen);\n        struct in6_addr ipaddr;\n        const char *scope_delim;\n\n        if (!end_bracket || end_bracket != lastchar) {\n            *port = 0;\n            return APR_EINVAL;\n        }\n\n        \n        scope_delim = memchr(str, '%', addrlen);\n        if (scope_delim) {\n            if (scope_delim == end_bracket - 1) { \n                *port = 0;\n                return APR_EINVAL;\n            }\n            addrlen = scope_delim - str - 1;\n            *scope_id = apr_pstrmemdup(p, scope_delim + 1, end_bracket - scope_delim - 1);\n        }\n        else {\n            addrlen = addrlen - 2; \n        }\n\n        *addr = apr_pstrmemdup(p, str + 1, addrlen);\n        if (apr_inet_pton(AF_INET6, *addr, &ipaddr) != 1) {\n            *addr = NULL;\n            *scope_id = NULL;\n            *port = 0;\n            return APR_EINVAL;\n        }\n    }\n    else\n#endif\n    {\n        \n        *addr = apr_pstrmemdup(p, str, addrlen);\n    }\n    return APR_SUCCESS;\n}", "Selected Statement": "ch = lastchar = str + strlen(str) - 1;", "Function Input": {}, "Variable Values Before Statement": {"str": "0x11a16a0 \"\"", "strlen": "NULL"}, "Value After Statement Execution": "0x11a169f \"\"", "Project Information": "apache-httpd"}
{"Programming Language": "C", "Statement Type": "Arithmetic Assignment", "Source Code": "void\nnxt_monotonic_time(nxt_monotonic_time_t *now)\n{\n    nxt_nsec_t      current;\n    nxt_nsec_int_t  delta;\n    struct timeval  tv;\n\n    (void) gettimeofday(&tv, NULL);\n\n    now->realtime.sec = (nxt_time_t) tv.tv_sec;\n    now->realtime.nsec = tv.tv_usec * 1000;\n\n    \n\n    current = (nxt_nsec_t) tv.tv_sec * 1000000000 + tv.tv_usec * 1000;\n    delta = current - now->previous;\n    now->previous = current;\n\n    if (delta > 0) {\n        now->monotonic += delta;\n\n    } else {\n        \n        now->monotonic++;\n    }\n\n    \n    now->update = now->monotonic + 1;\n}", "Selected Statement": "now->monotonic = (nxt_nsec_t) ts.tv_sec * 1000000000 + ts.tv_nsec;", "Function Input": {"now": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"realtime": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"sec": {"type_category": "unknown", "concrete_type": "nxt_time_t", "value": "17259380"}, "nsec": {"type_category": "unknown", "concrete_type": "nxt_uint_t", "value": "0"}}}, "monotonic": {"type_category": "unknown", "concrete_type": "nxt_nsec_t", "value": "0"}, "update": {"type_category": "unknown", "concrete_type": "nxt_nsec_t", "value": "33"}}}}}, "Variable Values Before Statement": {"ts": {"tv_sec": "36258", "tv_nsec": "128765920"}}, "Value After Statement Execution": "NULL", "Project Information": "unit"}
{"Programming Language": "C", "Statement Type": "Arithmetic Assignment", "Source Code": "int\nutf8_isvalid(const char *s)\n{\n\tstruct utf8_data ud;\n\tconst char\t*end;\n\tenum utf8_state\t more;\n\n\tend = s + strlen(s);\n\twhile (s < end) {\n\t\tif ((more = utf8_open(&ud, *s)) == UTF8_MORE) {\n\t\t\twhile (++s < end && more == UTF8_MORE)\n\t\t\t\tmore = utf8_append(&ud, *s);\n\t\t\tif (more == UTF8_DONE)\n\t\t\t\tcontinue;\n\t\t\treturn (0);\n\t\t}\n\t\tif (*s < 0x20 || *s > 0x7e)\n\t\t\treturn (0);\n\t\ts++;\n\t}\n\treturn (1);\n}", "Selected Statement": "end = s + strlen(s);", "Function Input": {}, "Variable Values Before Statement": {"s": "0x7fffffffdddc \"\"", "strlen": "NULL"}, "Value After Statement Execution": "0x7fffffffdddc \"\"", "Project Information": "tmux"}
{"Programming Language": "C", "Statement Type": "Arithmetic Assignment", "Source Code": "extern int\nonig_detect_can_be_slow_pattern(const UChar* pattern,\n  const UChar* pattern_end, OnigOptionType option, OnigEncoding enc,\n  OnigSyntaxType* syntax)\n{\n  int r;\n  regex_t* reg;\n  Node* root;\n  ParseEnv scan_env;\n  SlowElementCount count;\n  int calls[MAX_CALLS_IN_DETECT];\n#ifdef USE_CALL\n  UnsetAddrList  uslist = {0};\n#endif\n\n  reg = (regex_t* )xmalloc(sizeof(regex_t));\n  if (IS_NULL(reg)) return ONIGERR_MEMORY;\n\n  r = onig_reg_init(reg, option, ONIGENC_CASE_FOLD_DEFAULT, enc, syntax);\n  if (r != 0) {\n    xfree(reg);\n    return r;\n  }\n\n  r = parse_and_tune(reg, pattern, pattern_end, &scan_env, &root, NULL\n#ifdef USE_CALL\n                     , &uslist\n#endif\n                    );\n  if (r != 0) goto err;\n\n#ifdef USE_CALL\n  if (scan_env.num_call > 0) {\n    unset_addr_list_end(&uslist);\n  }\n#endif\n\n  count.prec_read          = 0;\n  count.look_behind        = 0;\n  count.backref            = 0;\n  count.backref_with_level = 0;\n  count.call               = 0;\n  count.is_keep            = FALSE;\n  count.anychar_reluctant_many     = 0;\n  count.empty_check_nest_level     = 0;\n  count.max_empty_check_nest_level = 0;\n  count.heavy_element = 0;\n\n  r = detect_can_be_slow(root, &count, 0, calls);\n  if (r == 0) {\n    int n;\n\n    n = count.prec_read + count.look_behind\n      + count.backref + count.backref_with_level + count.call\n      + count.anychar_reluctant_many;\n\n    if (count.is_keep) count.max_empty_check_nest_level++;\n\n    if (count.max_empty_check_nest_level > 2)\n      n += count.max_empty_check_nest_level - 2;\n    if (count.heavy_element != 0) {\n      if (count.heavy_element < 0x10000)\n        n += count.heavy_element << 8;\n      else\n        n += count.heavy_element;\n    }\n\n    r = n;\n\n#ifdef ONIG_DEBUG_PARSE\n    fprintf(DBGFP, \"-- detect can be slow --\\n\");\n    fprintf(DBGFP, \"  prec_read:          %d\\n\", count.prec_read);\n    fprintf(DBGFP, \"  look_behind:        %d\\n\", count.look_behind);\n    fprintf(DBGFP, \"  backref:            %d\\n\", count.backref);\n    fprintf(DBGFP, \"  backref_with_level: %d\\n\", count.backref_with_level);\n    fprintf(DBGFP, \"  call:               %d\\n\", count.call);\n    fprintf(DBGFP, \"  is_keep:            %d\\n\", count.is_keep);\n    fprintf(DBGFP, \"  any_reluctant_many: %d\\n\", count.anychar_reluctant_many);\n    fprintf(DBGFP, \"  max_empty_check_nest_level: %d\\n\", count.max_empty_check_nest_level);\n    fprintf(DBGFP, \"  heavy_element:      %d\\n\", count.heavy_element);\n    fprintf(DBGFP, \"  r:                  %d\\n\", r);\n    fprintf(DBGFP, \"\\n\");\n#endif\n  }\n\n  if (IS_NOT_NULL(scan_env.mem_env_dynamic))\n    xfree(scan_env.mem_env_dynamic);\n\n err:\n  onig_node_free(root);\n  onig_free(reg);\n  return r;\n}", "Selected Statement": "n = count.prec_read + count.look_behind", "Function Input": {"reg": {"value": null}}, "Variable Values Before Statement": {"count": {"prec_read": "0", "look_behind": "0", "backref": "0", "backref_with_level": "0", "call": "0", "is_keep": "0", "anychar_reluctant_many": "0", "empty_check_nest_level": "0", "max_empty_check_nest_level": "0", "heavy_element": "0"}}, "Value After Statement Execution": "int", "Project Information": "oniguruma"}
{"Programming Language": "C", "Statement Type": "Arithmetic Assignment", "Source Code": "static int\ninit(void)\n{\n#ifdef USE_CALLOUT\n\n    int id;\n    OnigEncoding enc;\n    char* name;\n    unsigned int args[4];\n    OnigValue    opts[4];\n\n    enc = ONIG_ENCODING_ASCII;\n\n    name = \"FAIL\";        BC0_P(name, fail);\n    name = \"MISMATCH\";    BC0_P(name, mismatch);\n\n    name = \"MAX\";\n    args[0] = ONIG_TYPE_TAG | ONIG_TYPE_LONG;\n    args[1] = ONIG_TYPE_CHAR;\n    opts[0].c = 'X';\n    BC_B_O(name, max, 2, args, 1, opts);\n\n    name = \"ERROR\";\n    args[0] = ONIG_TYPE_LONG; opts[0].l = ONIG_ABORT;\n    BC_P_O(name, error, 1, args, 1, opts);\n\n    name = \"COUNT\";\n    args[0] = ONIG_TYPE_CHAR; opts[0].c = '>';\n    BC_B_O(name, count, 1, args, 1, opts);\n\n    name = \"TOTAL_COUNT\";\n    args[0] = ONIG_TYPE_CHAR; opts[0].c = '>';\n    BC_B_O(name, total_count, 1, args, 1, opts);\n\n    name = \"CMP\";\n    args[0] = ONIG_TYPE_TAG | ONIG_TYPE_LONG;\n    args[1] = ONIG_TYPE_STRING;\n    args[2] = ONIG_TYPE_TAG | ONIG_TYPE_LONG;\n    BC_P(name, cmp, 3, args);\n\n#endif \n\n  return ONIG_NORMAL;\n}", "Selected Statement": "args[0] = ONIG_TYPE_TAG | ONIG_TYPE_LONG;", "Function Input": {}, "Variable Values Before Statement": {"ONIG_TYPE_TAG": "NULL", "ONIG_TYPE_LONG": "NULL"}, "Value After Statement Execution": "NULL", "Project Information": "oniguruma"}
{"Programming Language": "C", "Statement Type": "Arithmetic Assignment", "Source Code": "extern int\nonig_set_callout_of_name(OnigEncoding enc, OnigCalloutType callout_type,\n                         UChar* name, UChar* name_end, int in,\n                         OnigCalloutFunc start_func,\n                         OnigCalloutFunc end_func,\n                         int arg_num, unsigned int arg_types[],\n                         int opt_arg_num, OnigValue opt_defaults[])\n{\n  int r;\n  int i;\n  int j;\n  int id;\n  int is_not_single;\n  CalloutNameEntry* e;\n  CalloutNameListEntry* fe;\n\n  if (callout_type != ONIG_CALLOUT_TYPE_SINGLE)\n    return ONIGERR_INVALID_ARGUMENT;\n\n  if (arg_num < 0 || arg_num > ONIG_CALLOUT_MAX_ARGS_NUM)\n    return ONIGERR_INVALID_CALLOUT_ARG;\n\n  if (opt_arg_num < 0 || opt_arg_num > arg_num)\n    return ONIGERR_INVALID_CALLOUT_ARG;\n\n  if (start_func == 0 && end_func == 0)\n    return ONIGERR_INVALID_CALLOUT_ARG;\n\n  if ((in & ONIG_CALLOUT_IN_PROGRESS) == 0 && (in & ONIG_CALLOUT_IN_RETRACTION) == 0)\n    return ONIGERR_INVALID_CALLOUT_ARG;\n\n  for (i = 0; i < arg_num; i++) {\n    unsigned int t = arg_types[i];\n    if (t == ONIG_TYPE_VOID)\n      return ONIGERR_INVALID_CALLOUT_ARG;\n    else {\n      if (i >= arg_num - opt_arg_num) {\n        if (t != ONIG_TYPE_LONG && t != ONIG_TYPE_CHAR && t != ONIG_TYPE_STRING &&\n            t != ONIG_TYPE_TAG)\n          return ONIGERR_INVALID_CALLOUT_ARG;\n      }\n      else {\n        if (t != ONIG_TYPE_LONG) {\n          t = t & ~ONIG_TYPE_LONG;\n          if (t != ONIG_TYPE_CHAR && t != ONIG_TYPE_STRING && t != ONIG_TYPE_TAG)\n            return ONIGERR_INVALID_CALLOUT_ARG;\n        }\n      }\n    }\n  }\n\n  if (! is_allowed_callout_name(enc, name, name_end)) {\n    return ONIGERR_INVALID_CALLOUT_NAME;\n  }\n\n  is_not_single = (callout_type != ONIG_CALLOUT_TYPE_SINGLE);\n  id = callout_name_entry(&e, enc, is_not_single, name, name_end);\n  if (id < 0) return id;\n\n  r = ONIG_NORMAL;\n  if (IS_NULL(GlobalCalloutNameList)) {\n    r = make_callout_func_list(&GlobalCalloutNameList, 10);\n    if (r != ONIG_NORMAL) return r;\n  }\n\n  while (id >= GlobalCalloutNameList->n) {\n    int rid;\n    r = callout_func_list_add(GlobalCalloutNameList, &rid);\n    if (r != ONIG_NORMAL) return r;\n  }\n\n  fe = GlobalCalloutNameList->v + id;\n  fe->type         = callout_type;\n  fe->in           = in;\n  fe->start_func   = start_func;\n  fe->end_func     = end_func;\n  fe->arg_num      = arg_num;\n  fe->opt_arg_num  = opt_arg_num;\n  fe->name         = e->name;\n\n  for (i = 0; i < arg_num; i++) {\n    fe->arg_types[i] = arg_types[i];\n  }\n  for (i = arg_num - opt_arg_num, j = 0; i < arg_num; i++, j++) {\n    if (IS_NULL(opt_defaults)) return ONIGERR_INVALID_ARGUMENT;\n    if (fe->arg_types[i] == ONIG_TYPE_STRING) {\n      OnigValue* val;\n      UChar* ds;\n\n      val = opt_defaults + j;\n      ds = onigenc_strdup(enc, val->s.start, val->s.end);\n      CHECK_NULL_RETURN_MEMERR(ds);\n\n      fe->opt_defaults[i].s.start = ds;\n      fe->opt_defaults[i].s.end   = ds + (val->s.end - val->s.start);\n    }\n    else {\n      fe->opt_defaults[i] = opt_defaults[j];\n    }\n  }\n\n  r = id;\n  return r;\n}", "Selected Statement": "fe = GlobalCalloutNameList->v + id;", "Function Input": {}, "Variable Values Before Statement": {"GlobalCalloutNameList": {"n": "2", "alloc": "10", "v": null}, "id": "int"}, "Value After Statement Execution": {"type": "ONIG_CALLOUT_TYPE_SINGLE", "in": "0", "start_func": null, "end_func": null, "arg_num": "0", "opt_arg_num": "0", "arg_types": [{"type_category": "int", "concrete_type": "unsigned int", "value": "0"}, {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}, {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}, {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}], "opt_defaults": [{"type_category": "struct", "concrete_type": "STRUCT", "value": {"l": {"type_category": "int", "concrete_type": "long", "value": "0"}, "c": {"type_category": "unknown", "concrete_type": "OnigCodePoint", "value": "0"}, "s": {"type_category": "struct", "concrete_type": "RECURSIVE", "value": "{start = 0x0, end = 0x0}"}, "p": {"type_category": "pointer", "concrete_type": "NULL"}, "tag": {"type_category": "int", "concrete_type": "int", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"l": {"type_category": "int", "concrete_type": "long", "value": "0"}, "c": {"type_category": "unknown", "concrete_type": "OnigCodePoint", "value": "0"}, "s": {"type_category": "struct", "concrete_type": "RECURSIVE", "value": "{start = 0x0, end = 0x0}"}, "p": {"type_category": "pointer", "concrete_type": "NULL"}, "tag": {"type_category": "int", "concrete_type": "int", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"l": {"type_category": "int", "concrete_type": "long", "value": "0"}, "c": {"type_category": "unknown", "concrete_type": "OnigCodePoint", "value": "0"}, "s": {"type_category": "struct", "concrete_type": "RECURSIVE", "value": "{start = 0x0, end = 0x0}"}, "p": {"type_category": "pointer", "concrete_type": "NULL"}, "tag": {"type_category": "int", "concrete_type": "int", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"l": {"type_category": "int", "concrete_type": "long", "value": "0"}, "c": {"type_category": "unknown", "concrete_type": "OnigCodePoint", "value": "0"}, "s": {"type_category": "struct", "concrete_type": "RECURSIVE", "value": "{start = 0x0, end = 0x0}"}, "p": {"type_category": "pointer", "concrete_type": "NULL"}, "tag": {"type_category": "int", "concrete_type": "int", "value": "0"}}}], "name": null}, "Project Information": "oniguruma"}
{"Programming Language": "C", "Statement Type": "Arithmetic Assignment", "Source Code": "int parse_msg(\n\t\tchar *const buf, const unsigned int len, struct sip_msg *const msg)\n{\n\n\tchar *tmp;\n\tchar *rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor(tmp = buf; (tmp - buf < len)\n\t\t\t\t   && (*tmp == '\\n' || *tmp == '\\r' || *tmp == '\\0'\n\t\t\t\t\t\t   || *tmp == '\\t' || *tmp == ' ');\n\t\t\ttmp++)\n\t\t;\n\toffset = tmp - buf;\n\tfl = &(msg->first_line);\n\trest = parse_first_line(tmp, len - offset, fl);\n\toffset += rest - tmp;\n\ttmp = rest;\n\tswitch(fl->type) {\n\t\tcase SIP_INVALID:\n\t\t\tDBG(\"invalid message\\n\");\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tDBG(\"SIP Request:\\n\");\n\t\t\tDBG(\" method:  <%.*s>\\n\", fl->u.request.method.len,\n\t\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tDBG(\" uri:     <%.*s>\\n\", fl->u.request.uri.len,\n\t\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tDBG(\" version: <%.*s>\\n\", fl->u.request.version.len,\n\t\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags = HDR_VIA_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tDBG(\"SIP Reply  (status):\\n\");\n\t\t\tDBG(\" version: <%.*s>\\n\", fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tDBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tDBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\t\n\t\t\t\n\t\t\tflags = HDR_VIA_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDBG(\"unknown type %d\\n\", fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed = tmp;\n\t\n\tif(parse_headers(msg, flags, 0) == -1)\n\t\tgoto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif(msg->via1) {\n\t\tDBG(\"first via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\", msg->via1->name.len,\n\t\t\t\tZSW(msg->via1->name.s), msg->via1->version.len,\n\t\t\t\tZSW(msg->via1->version.s), msg->via1->transport.len,\n\t\t\t\tZSW(msg->via1->transport.s), msg->via1->host.len,\n\t\t\t\tZSW(msg->via1->host.s), msg->via1->port_str.len,\n\t\t\t\tZSW(msg->via1->port_str.s), msg->via1->port);\n\t\tif(msg->via1->params.s)\n\t\t\tDBG(\";<%.*s>\", msg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif(msg->via1->comment.s)\n\t\t\tDBG(\" <%.*s>\", msg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tDBG(\"\\n\");\n\t}\n\tif(msg->via2) {\n\t\tDBG(\"second via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\", msg->via2->name.len,\n\t\t\t\tZSW(msg->via2->name.s), msg->via2->version.len,\n\t\t\t\tZSW(msg->via2->version.s), msg->via2->transport.len,\n\t\t\t\tZSW(msg->via2->transport.s), msg->via2->host.len,\n\t\t\t\tZSW(msg->via2->host.s), msg->via2->port_str.len,\n\t\t\t\tZSW(msg->via2->port_str.s), msg->via2->port);\n\t\tif(msg->via2->params.s)\n\t\t\tDBG(\";<%.*s>\", msg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif(msg->via2->comment.s)\n\t\t\tDBG(\" <%.*s>\", msg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tDBG(\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tDBG(\"exiting parse_msg\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLOG(cfg_get(core, core_cfg, sip_parser_log),\n\t\t\t\"ERROR: parse_msg: message=<%.*s>\\n\", (int)msg->len,\n\t\t\tZSW(ksr_buf_oneline(msg->buf, (int)msg->len)));\n\treturn -1;\n}", "Selected Statement": "offset += rest - tmp;", "Function Input": {"flags": {"value": "140737322669824"}, "msg": {"value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xffff00001f80\n", "message": "Cannot access memory at address 0xffff00001f80"}}}, "Variable Values Before Statement": {"rest": "0x1b7b2f0 \"\"", "tmp": "0x1b7b2f0 \"\""}, "Value After Statement Execution": "int", "Project Information": "kamailio"}
{"Programming Language": "C", "Statement Type": "Arithmetic Assignment", "Source Code": "int libesedb_checksum_calculate_little_endian_xor32(\n     uint32_t *checksum_value,\n     const uint8_t *buffer,\n     size_t size,\n     uint32_t initial_value,\n     libcerror_error_t **error )\n{\n\tlibesedb_aligned_t *aligned_buffer_iterator = NULL;\n\tuint8_t *buffer_iterator                    = NULL;\n\tstatic char *function                       = \"libesedb_checksum_calculate_little_endian_xor32\";\n\tlibesedb_aligned_t value_aligned            = 0;\n\tuint32_t big_endian_value_32bit             = 0;\n\tuint32_t safe_checksum_value                = 0;\n\tuint32_t value_32bit                        = 0;\n\tuint8_t alignment_count                     = 0;\n\tuint8_t alignment_size                      = 0;\n\tuint8_t byte_count                          = 0;\n\tuint8_t byte_order                          = 0;\n\tuint8_t byte_size                           = 0;\n\n\tif( checksum_value == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid checksum value.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( buffer == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid buffer.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( size > (size_t) SSIZE_MAX )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM,\n\t\t \"%s: invalid size value exceeds maximum.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tsafe_checksum_value = initial_value;\n\n\tbuffer_iterator = (uint8_t *) buffer;\n\n\t\n\tif( ( ( sizeof( libesedb_aligned_t ) % 4 ) == 0 )\n\t && ( size > ( 2 * sizeof( libesedb_aligned_t ) ) ) )\n\t{\n\t\t\n\t\talignment_size = (uint8_t) ( (intptr_t) buffer_iterator % sizeof( libesedb_aligned_t ) );\n\n\t\tif( alignment_size > 0 )\n\t\t{\n\t\t\tbyte_size = sizeof( libesedb_aligned_t ) - alignment_size;\n\n\t\t\t\n\t\t\twhile( byte_size != 0 )\n\t\t\t{\n\t\t\t\tvalue_32bit = 0;\n\t\t\t\tbyte_count  = 1;\n\n\t\t\t\tif( byte_size >= 4 )\n\t\t\t\t{\n\t\t\t\t\tvalue_32bit |= buffer_iterator[ 3 ];\n\t\t\t\t\tvalue_32bit <<= 8;\n\n\t\t\t\t\tbyte_count++;\n\t\t\t\t}\n\t\t\t\tif( byte_size >= 3 )\n\t\t\t\t{\n\t\t\t\t\tvalue_32bit |= buffer_iterator[ 2 ];\n\t\t\t\t\tvalue_32bit <<= 8;\n\n\t\t\t\t\tbyte_count++;\n\t\t\t\t}\n\t\t\t\tif( byte_size >= 2 )\n\t\t\t\t{\n\t\t\t\t\tvalue_32bit |= buffer_iterator[ 1 ];\n\t\t\t\t\tvalue_32bit <<= 8;\n\n\t\t\t\t\tbyte_count++;\n\t\t\t\t}\n\t\t\t\tvalue_32bit |= buffer_iterator[ 0 ];\n\n\t\t\t\tbuffer_iterator += byte_count;\n\t\t\t\tbyte_size       -= byte_count;\n\n\t\t\t\tsafe_checksum_value ^= value_32bit;\n\t\t\t}\n\t\t\tsize -= byte_count;\n\t\t}\n\t\taligned_buffer_iterator = (libesedb_aligned_t *) buffer_iterator;\n\n\t\tif( *buffer_iterator != (uint8_t) ( *aligned_buffer_iterator & 0xff ) )\n\t\t{\n\t\t\tbyte_order = _BYTE_STREAM_ENDIAN_BIG;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbyte_order = _BYTE_STREAM_ENDIAN_LITTLE;\n\t\t}\n\t\t\n\t\twhile( size > sizeof( libesedb_aligned_t ) )\n\t\t{\n\t\t\tvalue_aligned ^= *aligned_buffer_iterator;\n\n\t\t\taligned_buffer_iterator++;\n\n\t\t\tsize -= sizeof( libesedb_aligned_t );\n\t\t}\n\t\t\n\t\tif( alignment_size > 0 )\n\t\t{\n\t\t\tbyte_count      = ( alignment_size % 4 ) * 8;\n\t\t\talignment_count = ( sizeof( libesedb_aligned_t ) - alignment_size ) * 8;\n\n\t\t\tif( byte_order == _BYTE_STREAM_ENDIAN_BIG )\n\t\t\t{\n\t\t\t\t\n\t\t\t\tbig_endian_value_32bit = (uint32_t) ( ( value_aligned >> alignment_count ) << byte_count );\n\n\t\t\t\t\n\t\t\t\tvalue_32bit = ( ( big_endian_value_32bit & 0x000000ffUL ) << 24 )\n\t\t\t\t            | ( ( big_endian_value_32bit & 0x0000ff00UL ) << 8 )\n\t\t\t\t            | ( ( big_endian_value_32bit >> 8 ) & 0x0000ff00UL )\n\t\t\t\t            | ( ( big_endian_value_32bit >> 24 ) & 0x000000ffUL );\n\n\t\t\t\t\n\t\t\t\tvalue_aligned <<= alignment_count;\n\t\t\t}\n\t\t\telse if( byte_order == _BYTE_STREAM_ENDIAN_LITTLE )\n\t\t\t{\n\t\t\t\tvalue_32bit = (uint32_t) ( value_aligned << byte_count );\n\n\t\t\t\t\n\t\t\t\tvalue_aligned >>= alignment_count;\n\t\t\t}\n\t\t\tsafe_checksum_value ^= value_32bit;\n\t\t}\n\t\t\n\t\tbyte_size = (uint8_t) sizeof( libesedb_aligned_t );\n\n\t\twhile( byte_size != 0 )\n\t\t{\n\t\t\tbyte_count = ( ( byte_size / 4 ) - 1 ) * 32;\n\n\t\t\tif( byte_order == _BYTE_STREAM_ENDIAN_BIG )\n\t\t\t{\n\t\t\t\tbig_endian_value_32bit = (uint32_t) ( ( value_aligned >> byte_count ) & 0xffffffffUL );\n\n\t\t\t\t\n\t\t\t\tvalue_32bit = ( ( big_endian_value_32bit & 0x000000ffUL ) << 24 )\n\t\t\t\t            | ( ( big_endian_value_32bit & 0x0000ff00UL ) << 8 )\n\t\t\t\t            | ( ( big_endian_value_32bit >> 8 ) & 0x0000ff00UL )\n\t\t\t\t            | ( ( big_endian_value_32bit >> 24 ) & 0x000000ffUL );\n\t\t\t}\n\t\t\telse if( byte_order == _BYTE_STREAM_ENDIAN_LITTLE )\n\t\t\t{\n\t\t\t\tvalue_32bit = (uint32_t) value_aligned;\n\n\t\t\t\tvalue_aligned >>= byte_count;\n\t\t\t}\n\t\t\tbyte_size -= 4;\n\n\t\t\tsafe_checksum_value ^= value_32bit;\n\t\t}\n\t\t\n\t\tbuffer_iterator = (uint8_t *) aligned_buffer_iterator;\n\n\t\tbyte_size = 4 - ( alignment_size % 4 );\n\n\t\tif( byte_size != 4 )\n\t\t{\n\t\t\tvalue_32bit   = buffer_iterator[ 0 ];\n\t\t\tvalue_32bit <<= 8;\n\n\t\t\tif( byte_size >= 2 )\n\t\t\t{\n\t\t\t\tvalue_32bit |= buffer_iterator[ 1 ];\n\t\t\t}\n\t\t\tvalue_32bit <<= 8;\n\n\t\t\tif( byte_size >= 3 )\n\t\t\t{\n\t\t\t\tvalue_32bit |= buffer_iterator[ 2 ];\n\t\t\t}\n\t\t\tvalue_32bit <<= 8;\n\n\t\t\tbuffer_iterator += byte_size;\n\t\t\tsize            -= byte_size;\n\n\t\t\tsafe_checksum_value ^= value_32bit;\n\t\t}\n\t}\n\twhile( size > 0 )\n\t{\n\t\tvalue_32bit = 0;\n\t\tbyte_count  = 1;\n\n\t\tif( size >= 4 )\n\t\t{\n\t\t\tvalue_32bit |= buffer_iterator[ 3 ];\n\t\t\tvalue_32bit <<= 8;\n\n\t\t\tbyte_count++;\n\t\t}\n\t\tif( size >= 3 )\n\t\t{\n\t\t\tvalue_32bit |= buffer_iterator[ 2 ];\n\t\t\tvalue_32bit <<= 8;\n\n\t\t\tbyte_count++;\n\t\t}\n\t\tif( size >= 2 )\n\t\t{\n\t\t\tvalue_32bit |= buffer_iterator[ 1 ];\n\t\t\tvalue_32bit <<= 8;\n\n\t\t\tbyte_count++;\n\t\t}\n\t\tvalue_32bit |= buffer_iterator[ 0 ];\n\n\t\tbuffer_iterator += byte_count;\n\t\tsize            -= byte_count;\n\n\t\tsafe_checksum_value ^= value_32bit;\n\t}\n\t*checksum_value = safe_checksum_value;\n\n\treturn( 1 );\n}", "Selected Statement": "byte_count      = ( alignment_size % 4 ) * 8;", "Function Input": {"buffer": {"value": "0x117ca50 \"\""}, "error": {"value": {"type_category": "pointer", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x29c\n", "message": "Cannot access memory at address 0x29c"}}, "initial_value": {"value": "0"}, "size": {"value": "672"}}, "Variable Values Before Statement": {"alignment_size": "4 '\\004'"}, "Value After Statement Execution": "0 '\\000'", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Arithmetic Assignment", "Source Code": "int libfsfat_block_tree_node_initialize(\n     libfsfat_block_tree_node_t **block_tree_node,\n     off64_t offset,\n     size64_t size,\n     size64_t leaf_value_size,\n     libcerror_error_t **error )\n{\n\tstatic char *function  = \"libfsfat_block_tree_node_initialize\";\n\tsize64_t sub_node_size = 0;\n\n\tif( block_tree_node == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid block tree node.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *block_tree_node != NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\n\t\t \"%s: invalid block tree node value already set.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( offset < 0 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: invalid offset value out of bounds.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( ( size == 0 )\n\t || ( size > (size64_t) ( INT64_MAX - offset ) ) )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: invalid size value out of bounds.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( leaf_value_size == 0 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: invalid leaf value size value out of bounds.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\t*block_tree_node = memory_allocate_structure(\n\t                    libfsfat_block_tree_node_t );\n\n\tif( *block_tree_node == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create block tree node.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     *block_tree_node,\n\t     0,\n\t     sizeof( libfsfat_block_tree_node_t ) ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear block tree node.\",\n\t\t function );\n\n\t\tmemory_free(\n\t\t *block_tree_node );\n\n\t\t*block_tree_node = NULL;\n\n\t\treturn( -1 );\n\t}\n\tif( libcdata_array_initialize(\n\t     &( ( *block_tree_node )->sub_nodes_array ),\n\t     LIBFSFAT_BLOCK_TREE_NUMBER_OF_SUB_NODES,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create sub nodes array.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tsub_node_size = leaf_value_size;\n\n\twhile( ( size / sub_node_size ) > LIBFSFAT_BLOCK_TREE_NUMBER_OF_SUB_NODES )\n\t{\n\t\tsub_node_size *= LIBFSFAT_BLOCK_TREE_NUMBER_OF_SUB_NODES;\n\t}\n\t( *block_tree_node )->start_offset  = offset;\n\t( *block_tree_node )->end_offset    = offset + size;\n\t( *block_tree_node )->size          = size;\n\t( *block_tree_node )->sub_node_size = sub_node_size;\n\n\tif( sub_node_size == leaf_value_size )\n\t{\n\t\t( *block_tree_node )->is_leaf_node = 1;\n\t}\n\treturn( 1 );\n\non_error:\n\tif( *block_tree_node != NULL )\n\t{\n\t\tmemory_free(\n\t\t *block_tree_node );\n\n\t\t*block_tree_node = NULL;\n\t}\n\treturn( -1 );\n}", "Selected Statement": "( *block_tree_node )->end_offset    = offset + size;", "Function Input": {"block_tree_node": {"value": {"type_category": "pointer", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x204\n", "message": "Cannot access memory at address 0x204"}}, "error": {"value": null}, "leaf_value_size": {"value": "140737488345584"}, "offset": {"value": "2199023255553"}, "size": {"value": "262144"}}, "Variable Values Before Statement": {"offset": "off64_t", "size": "size64_t"}, "Value After Statement Execution": "NULL", "Project Information": "libyal"}
{"Programming Language": "C", "Statement Type": "Arithmetic Assignment", "Source Code": "size_t\ndns_qpkey_fromname(dns_qpkey_t key, const dns_name_t *name) {\n\tsize_t len, label;\n\tdns_fixedname_t fixed;\n\n\tREQUIRE(ISC_MAGIC_VALID(name, DNS_NAME_MAGIC));\n\n\tif (name->labels == 0) {\n\t\tkey[0] = SHIFT_NOBYTE;\n\t\treturn (0);\n\t}\n\n\tif (name->offsets == NULL) {\n\t\tdns_name_t *clone = dns_fixedname_initname(&fixed);\n\t\tdns_name_clone(name, clone);\n\t\tname = clone;\n\t}\n\n\tlen = 0;\n\tlabel = name->labels;\n\twhile (label-- > 0) {\n\t\tconst uint8_t *ldata = name->ndata + name->offsets[label];\n\t\tsize_t label_len = *ldata++;\n\t\twhile (label_len-- > 0) {\n\t\t\tuint16_t bits = dns_qp_bits_for_byte[*ldata++];\n\t\t\tkey[len++] = bits & 0xFF;\t\n\t\t\tif ((bits >> 8) != 0) {\t\t\n\t\t\t\tkey[len++] = bits >> 8; \n\t\t\t}\n\t\t}\n\t\t\n\t\tkey[len++] = SHIFT_NOBYTE;\n\t}\n\t\n\tkey[len] = SHIFT_NOBYTE;\n\tENSURE(len < sizeof(dns_qpkey_t));\n\treturn (len);\n}", "Selected Statement": "const uint8_t *ldata = name->ndata + name->offsets[label];", "Function Input": {}, "Variable Values Before Statement": {"name": {"magic": "1145983854", "ndata": "0x7fffffffdd38 \"\\001D\"", "length": "3", "labels": "2", "attributes": null, "offsets": "0x7fffffffdc78 \"\"", "buffer": null, "link": null, "list": null, "hashmap": null}, "label": "0"}, "Value After Statement Execution": "NULL", "Project Information": "bind9"}
{"Programming Language": "C", "Statement Type": "Arithmetic Assignment", "Source Code": "int\n_dwarf_object_read_random(int fd, char *buf, Dwarf_Unsigned loc,\n    Dwarf_Unsigned size, Dwarf_Unsigned filesize, int *errc)\n{\n    Dwarf_Unsigned endpoint = 0;\n    int res = 0;\n\n    if (loc >= filesize) {\n        \n        *errc = DW_DLE_SEEK_OFF_END;\n        return DW_DLV_ERROR;\n    }\n    endpoint = loc+size;\n    if (endpoint < loc) {\n        \n        *errc = DW_DLE_READ_OFF_END;\n        return DW_DLV_ERROR;\n    }\n    if (endpoint > filesize) {\n        \n        *errc = DW_DLE_READ_OFF_END;\n        return DW_DLV_ERROR;\n    }\n    res = _dwarf_seekr(fd,loc,SEEK_SET,0);\n    if (res != DW_DLV_OK) {\n        *errc = DW_DLE_SEEK_ERROR;\n        return DW_DLV_ERROR;\n    }\n    res = _dwarf_readr(fd,buf,size,0);\n    if (res != DW_DLV_OK) {\n        *errc = DW_DLE_READ_ERROR;\n        return DW_DLV_ERROR;\n    }\n    return DW_DLV_OK;\n}", "Selected Statement": "endpoint = loc+size;", "Function Input": {"buf": {"value": "0x3 <error: Cannot access memory at address 0x3>"}, "errc": {"value": null}, "fd": {"value": "-10544"}, "filesize": {"value": "6002422"}, "loc": {"value": "140737348690585"}, "size": {"value": "3"}}, "Variable Values Before Statement": {"loc": "Dwarf_Unsigned", "size": "Dwarf_Unsigned"}, "Value After Statement Execution": "Dwarf_Unsigned", "Project Information": "libdwarf"}
{"Programming Language": "C", "Statement Type": "Arithmetic Assignment", "Source Code": "unsigned int luaO_codeparam (unsigned int p) {\n  if (p >= (cast(lu_mem, 0x1F) << (0xF - 7 - 1)) * 100u)  \n    return 0xFF;  \n  else {\n    p = (cast(l_uint32, p) * 128 + 99) / 100;  \n    if (p < 0x10)  \n      return p;  \n    else {\n      int log = luaO_ceillog2(p + 1) - 5;  \n      return ((p >> log) - 0x10) | ((log + 1) << 4);\n    }\n  }\n}", "Selected Statement": "int log = luaO_ceillog2(p + 1) - 5;  /* preserve 5 bits */", "Function Input": {}, "Variable Values Before Statement": {"luaO_ceillog2": "NULL", "p": "unsigned int"}, "Value After Statement Execution": "NULL", "Project Information": "lua"}
{"Programming Language": "C", "Statement Type": "Arithmetic Assignment", "Source Code": "float\nfloat32_le_read (const unsigned char *cptr)\n{\tint\t\texponent, mantissa, negative ;\n\tfloat\tfvalue ;\n\n\tnegative = cptr [3] & 0x80 ;\n\texponent = ((cptr [3] & 0x7F) << 1) | ((cptr [2] & 0x80) ? 1 : 0) ;\n\tmantissa = ((cptr [2] & 0x7F) << 16) | (cptr [1] << 8) | (cptr [0]) ;\n\n\tif (! (exponent || mantissa))\n\t\treturn 0.0 ;\n\n\tmantissa |= 0x800000 ;\n\texponent = exponent ? exponent - 127 : 0 ;\n\n\tfvalue = mantissa ? ((float) mantissa) / ((float) 0x800000) : 0.0 ;\n\n\tif (negative)\n\t\tfvalue *= -1 ;\n\n\tif (exponent > 0)\n\t\tfvalue *= pow (2.0, exponent) ;\n\telse if (exponent < 0)\n\t\tfvalue /= pow (2.0, abs (exponent)) ;\n\n\treturn fvalue ;\n}", "Selected Statement": "exponent = ((cptr [3] & 0x7F) << 1) | ((cptr [2] & 0x80) ? 1 : 0) ;", "Function Input": {}, "Variable Values Before Statement": {"cptr": "0x7fffffffda94 \"\\233\\243\\001\\006\\370\\335\\377\\377d\\243\""}, "Value After Statement Execution": "int", "Project Information": "libsndfile"}
{"Programming Language": "C", "Statement Type": "Arithmetic Assignment", "Source Code": "GLOBAL(void)\njinit_memory_mgr(j_common_ptr cinfo)\n{\n  my_mem_ptr mem;\n  long max_to_use;\n  int pool;\n  size_t test_mac;\n\n  cinfo->mem = NULL;            \n\n  \n  if ((ALIGN_SIZE & (ALIGN_SIZE - 1)) != 0)\n    ERREXIT(cinfo, JERR_BAD_ALIGN_TYPE);\n  \n  test_mac = (size_t)MAX_ALLOC_CHUNK;\n  if ((long)test_mac != MAX_ALLOC_CHUNK ||\n      (MAX_ALLOC_CHUNK % ALIGN_SIZE) != 0)\n    ERREXIT(cinfo, JERR_BAD_ALLOC_CHUNK);\n\n  max_to_use = jpeg_mem_init(cinfo); \n\n  \n  mem = (my_mem_ptr)jpeg_get_small(cinfo, sizeof(my_memory_mgr));\n\n  if (mem == NULL) {\n    jpeg_mem_term(cinfo);       \n    ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, 0);\n  }\n\n  \n  mem->pub.alloc_small = alloc_small;\n  mem->pub.alloc_large = alloc_large;\n  mem->pub.alloc_sarray = alloc_sarray;\n  mem->pub.alloc_barray = alloc_barray;\n  mem->pub.request_virt_sarray = request_virt_sarray;\n  mem->pub.request_virt_barray = request_virt_barray;\n  mem->pub.realize_virt_arrays = realize_virt_arrays;\n  mem->pub.access_virt_sarray = access_virt_sarray;\n  mem->pub.access_virt_barray = access_virt_barray;\n  mem->pub.free_pool = free_pool;\n  mem->pub.self_destruct = self_destruct;\n\n  \n  mem->pub.max_alloc_chunk = MAX_ALLOC_CHUNK;\n\n  \n  mem->pub.max_memory_to_use = max_to_use;\n\n  for (pool = JPOOL_NUMPOOLS - 1; pool >= JPOOL_PERMANENT; pool--) {\n    mem->small_list[pool] = NULL;\n    mem->large_list[pool] = NULL;\n  }\n  mem->virt_sarray_list = NULL;\n  mem->virt_barray_list = NULL;\n\n  mem->total_space_allocated = sizeof(my_memory_mgr);\n\n  \n  cinfo->mem = &mem->pub;\n\n  \n#ifndef NO_GETENV\n  {\n    char memenv[30] = { 0 };\n\n    if (!GETENV_S(memenv, 30, \"JPEGMEM\") && strlen(memenv) > 0) {\n      char ch = 'x';\n\n#ifdef _MSC_VER\n      if (sscanf_s(memenv, \"%ld%c\", &max_to_use, &ch, 1) > 0) {\n#else\n      if (sscanf(memenv, \"%ld%c\", &max_to_use, &ch) > 0) {\n#endif\n        if (ch == 'm' || ch == 'M')\n          max_to_use *= 1000L;\n        mem->pub.max_memory_to_use = max_to_use * 1000L;\n      }\n    }\n  }\n#endif\n\n}", "Selected Statement": "for (pool = JPOOL_NUMPOOLS - 1; pool >= JPOOL_PERMANENT; pool--) {", "Function Input": {}, "Variable Values Before Statement": {"JPOOL_NUMPOOLS": "NULL"}, "Value After Statement Execution": "int", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Arithmetic Assignment", "Source Code": "GLOBAL(void)\njinit_memory_mgr(j_common_ptr cinfo)\n{\n  my_mem_ptr mem;\n  long max_to_use;\n  int pool;\n  size_t test_mac;\n\n  cinfo->mem = NULL;            \n\n  \n  if ((ALIGN_SIZE & (ALIGN_SIZE - 1)) != 0)\n    ERREXIT(cinfo, JERR_BAD_ALIGN_TYPE);\n  \n  test_mac = (size_t)MAX_ALLOC_CHUNK;\n  if ((long)test_mac != MAX_ALLOC_CHUNK ||\n      (MAX_ALLOC_CHUNK % ALIGN_SIZE) != 0)\n    ERREXIT(cinfo, JERR_BAD_ALLOC_CHUNK);\n\n  max_to_use = jpeg_mem_init(cinfo); \n\n  \n  mem = (my_mem_ptr)jpeg_get_small(cinfo, sizeof(my_memory_mgr));\n\n  if (mem == NULL) {\n    jpeg_mem_term(cinfo);       \n    ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, 0);\n  }\n\n  \n  mem->pub.alloc_small = alloc_small;\n  mem->pub.alloc_large = alloc_large;\n  mem->pub.alloc_sarray = alloc_sarray;\n  mem->pub.alloc_barray = alloc_barray;\n  mem->pub.request_virt_sarray = request_virt_sarray;\n  mem->pub.request_virt_barray = request_virt_barray;\n  mem->pub.realize_virt_arrays = realize_virt_arrays;\n  mem->pub.access_virt_sarray = access_virt_sarray;\n  mem->pub.access_virt_barray = access_virt_barray;\n  mem->pub.free_pool = free_pool;\n  mem->pub.self_destruct = self_destruct;\n\n  \n  mem->pub.max_alloc_chunk = MAX_ALLOC_CHUNK;\n\n  \n  mem->pub.max_memory_to_use = max_to_use;\n\n  for (pool = JPOOL_NUMPOOLS - 1; pool >= JPOOL_PERMANENT; pool--) {\n    mem->small_list[pool] = NULL;\n    mem->large_list[pool] = NULL;\n  }\n  mem->virt_sarray_list = NULL;\n  mem->virt_barray_list = NULL;\n\n  mem->total_space_allocated = sizeof(my_memory_mgr);\n\n  \n  cinfo->mem = &mem->pub;\n\n  \n#ifndef NO_GETENV\n  {\n    char memenv[30] = { 0 };\n\n    if (!GETENV_S(memenv, 30, \"JPEGMEM\") && strlen(memenv) > 0) {\n      char ch = 'x';\n\n#ifdef _MSC_VER\n      if (sscanf_s(memenv, \"%ld%c\", &max_to_use, &ch, 1) > 0) {\n#else\n      if (sscanf(memenv, \"%ld%c\", &max_to_use, &ch) > 0) {\n#endif\n        if (ch == 'm' || ch == 'M')\n          max_to_use *= 1000L;\n        mem->pub.max_memory_to_use = max_to_use * 1000L;\n      }\n    }\n  }\n#endif\n\n}", "Selected Statement": "for (pool = JPOOL_NUMPOOLS - 1; pool >= JPOOL_PERMANENT; pool--) {", "Function Input": {}, "Variable Values Before Statement": {"JPOOL_NUMPOOLS": "NULL"}, "Value After Statement Execution": "int", "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Statement Type": "Arithmetic Assignment", "Source Code": "void ssh_set_auth_methods(ssh_session session, int auth_methods)\n{\n    \n    session->auth.supported_methods = (uint32_t)auth_methods & 0x3fU;\n}", "Selected Statement": "session->auth.supported_methods = (uint32_t)auth_methods & 0x3fU;", "Function Input": {"session": {"value": "0x2dd9932e8a4d1d00"}}, "Variable Values Before Statement": {"auth_methods": "int"}, "Value After Statement Execution": "NULL", "Project Information": "libssh"}
{"Programming Language": "C", "Statement Type": "Arithmetic Assignment", "Source Code": "int ssh_config_parse_string(ssh_session session, const char *input)\n{\n    char line[MAX_LINE_SIZE] = {0};\n    const char *c = input, *line_start = input;\n    unsigned int line_num = 0, line_len;\n    int parsing, rv;\n\n    SSH_LOG(SSH_LOG_DEBUG, \"Reading configuration data from string:\");\n    SSH_LOG(SSH_LOG_DEBUG, \"START\\n%s\\nEND\", input);\n\n    parsing = 1;\n    while (1) {\n        line_num++;\n        line_start = c;\n        c = strchr(line_start, '\\n');\n        if (c == NULL) {\n            \n            c = strchr(line_start, '\\0');\n        }\n        if (c == NULL) {\n            \n            SSH_LOG(SSH_LOG_TRACE, \"No trailing '\\\\0' in config string\");\n            return SSH_ERROR;\n        }\n        line_len = c - line_start;\n        if (line_len > MAX_LINE_SIZE - 1) {\n            SSH_LOG(SSH_LOG_TRACE, \"Line %u too long: %u characters\",\n                    line_num, line_len);\n            return SSH_ERROR;\n        }\n        memcpy(line, line_start, line_len);\n        line[line_len] = '\\0';\n        SSH_LOG(SSH_LOG_DEBUG, \"Line %u: %s\", line_num, line);\n        rv = ssh_config_parse_line(session, line, line_num, &parsing, 0, false);\n        if (rv < 0) {\n            return SSH_ERROR;\n        }\n        if (*c == '\\0') {\n            break;\n        }\n        c++;\n    }\n\n    return SSH_OK;\n}", "Selected Statement": "line_len = c - line_start;", "Function Input": {}, "Variable Values Before Statement": {"c": "0x12548a0 \"\"", "line_start": "0x12548a0 \"\""}, "Value After Statement Execution": "unsigned int", "Project Information": "libssh"}
{"Programming Language": "C", "Statement Type": "Arithmetic Assignment", "Source Code": "int ssh_bind_config_parse_string(ssh_bind bind, const char *input)\n{\n    char line[MAX_LINE_SIZE] = {0};\n    const char *c = input, *line_start = input;\n    unsigned int line_num = 0, line_len;\n    uint32_t parser_flags;\n    int rv;\n\n    \n    uint8_t seen[BIND_CFG_MAX] = {0};\n\n    SSH_LOG(SSH_LOG_DEBUG, \"Reading bind configuration data from string:\");\n    SSH_LOG(SSH_LOG_DEBUG, \"START\\n%s\\nEND\", input);\n\n    parser_flags = PARSING;\n    while (1) {\n        line_num++;\n        line_start = c;\n        c = strchr(line_start, '\\n');\n        if (c == NULL) {\n            \n            c = strchr(line_start, '\\0');\n        }\n        if (c == NULL) {\n            \n            SSH_LOG(SSH_LOG_WARN, \"No trailing '\\\\0' in config string\");\n            return SSH_ERROR;\n        }\n        line_len = c - line_start;\n        if (line_len > MAX_LINE_SIZE - 1) {\n            SSH_LOG(SSH_LOG_WARN, \"Line %u too long: %u characters\",\n                    line_num, line_len);\n            return SSH_ERROR;\n        }\n        memcpy(line, line_start, line_len);\n        line[line_len] = '\\0';\n        SSH_LOG(SSH_LOG_DEBUG, \"Line %u: %s\", line_num, line);\n        rv = ssh_bind_config_parse_line(bind, line, line_num, &parser_flags, seen, 0);\n        if (rv < 0) {\n            return SSH_ERROR;\n        }\n        if (*c == '\\0') {\n            break;\n        }\n        c++;\n    }\n\n    return SSH_OK;\n}", "Selected Statement": "line_len = c - line_start;", "Function Input": {"parser_flags": {"value": "8347536"}}, "Variable Values Before Statement": {"c": "0x12578a0 \"\"", "line_start": "0x12578a0 \"\""}, "Value After Statement Execution": "unsigned int", "Project Information": "libssh"}
{"Programming Language": "C", "Statement Type": "Arithmetic Assignment", "Source Code": "OM_uint32 KRB5_CALLCONV\ngss_release_cred(OM_uint32 *minor_status, gss_cred_id_t *cred_handle)\n{\n    OM_uint32\t\tstatus, temp_status;\n    int\t\t\tj;\n    gss_union_cred_t\tunion_cred;\n    gss_mechanism\tmech;\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    *minor_status = 0;\n\n    if (cred_handle == NULL)\n\treturn (GSS_S_NO_CRED | GSS_S_CALL_INACCESSIBLE_READ);\n\n    \n\n    union_cred = (gss_union_cred_t) *cred_handle;\n    if (union_cred == (gss_union_cred_t)GSS_C_NO_CREDENTIAL)\n\treturn (GSS_S_COMPLETE);\n\n    if (GSSINT_CHK_LOOP(union_cred))\n\treturn (GSS_S_NO_CRED | GSS_S_CALL_INACCESSIBLE_READ);\n    *cred_handle = NULL;\n\n    status = GSS_S_COMPLETE;\n\n    for(j=0; j < union_cred->count; j++) {\n\n\tmech = gssint_get_mechanism (&union_cred->mechs_array[j]);\n\n\tif (union_cred->mechs_array[j].elements)\n\t\tfree(union_cred->mechs_array[j].elements);\n\tif (mech) {\n\t    if (mech->gss_release_cred) {\n\t\ttemp_status = mech->gss_release_cred\n\t\t    (\n\t\t     minor_status,\n\t\t     &union_cred->cred_array[j]);\n\n\t\tif (temp_status != GSS_S_COMPLETE) {\n\t\t    map_error(minor_status, mech);\n\t\t    status = GSS_S_NO_CRED;\n\t\t}\n\n\t    } else\n\t\tstatus = GSS_S_UNAVAILABLE;\n\t} else\n\t    status = GSS_S_DEFECTIVE_CREDENTIAL;\n    }\n\n    free(union_cred->cred_array);\n    free(union_cred->mechs_array);\n    free(union_cred);\n\n    return(status);\n}", "Selected Statement": "union_cred = (gss_union_cred_t) *cred_handle;", "Function Input": {"cred_handle": {"value": {"type_category": "unknown", "concrete_type": "gss_cred_id_t"}}, "minor_status": {"value": {"type_category": "unknown", "concrete_type": "OM_uint32", "value": "0"}}}, "Variable Values Before Statement": {"gss_union_cred_t": "NULL", "cred_handle": "NULL"}, "Value After Statement Execution": "gss_union_cred_t", "Project Information": "krb5"}
{"Programming Language": "C", "Statement Type": "Arithmetic Assignment", "Source Code": "uint32_t i_rand_limit(uint32_t upper_bound)\n{\n\ti_assert(upper_bound > 0);\n\n\tuint32_t val;\n\tuint32_t min = UNSIGNED_MINUS(upper_bound) % upper_bound;\n\twhile((val = i_rand()) < min);\n\treturn val % upper_bound;\n}", "Selected Statement": "uint32_t min = UNSIGNED_MINUS(upper_bound) % upper_bound;", "Function Input": {}, "Variable Values Before Statement": {"UNSIGNED_MINUS": "NULL", "upper_bound": "128"}, "Value After Statement Execution": "0", "Project Information": "dovecot"}
