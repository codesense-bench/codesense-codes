{"Programming Language": "C", "Source Code": "void\nk5_buf_init_dynamic(struct k5buf *buf)\n{\n    buf->buftype = K5BUF_DYNAMIC;\n    buf->space = 128;\n    buf->data = malloc(buf->space);\n    if (buf->data == NULL) {\n        set_error(buf);\n        return;\n    }\n    buf->len = 0;\n}", "Selected Statement": "buf->buftype = K5BUF_DYNAMIC;", "Function Input": {"buf": {"value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x65cc6ead\n", "message": "Cannot access memory at address 0x65cc6ead"}}}, "Variable Values Before Statement": {"K5BUF_DYNAMIC": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 1, "Project Information": "krb5"}
{"Programming Language": "C", "Source Code": "static int process_file(const char *name)\n{\n    int rc = -1;\n    blkid_probe pr = blkid_new_probe_from_filename(name);\n    if (pr != NULL) {\n        blkid_probe_enable_partitions(pr, TRUE);\n        blkid_probe_set_partitions_flags(pr, FALSE);\n        blkid_probe_enable_superblocks(pr, TRUE);\n        blkid_probe_set_superblocks_flags(pr, BLKID_SUBLKS_DEFAULT | BLKID_SUBLKS_FSINFO | BLKID_SUBLKS_MAGIC | BLKID_SUBLKS_VERSION | BLKID_SUBLKS_BADCSUM);\n        rc = blkid_do_safeprobe(pr) == -1 ? -1 : 0;\n    }\n    blkid_free_probe(pr);\n    return rc;\n}", "Selected Statement": "int rc = -1;", "Function Input": {"name": {"value": null}}, "Variable Values Before Statement": {"constant": "-1"}, "Value After Statement Execution": "-1", "Block_Size": 1, "Project Information": "util-linux"}
{"Programming Language": "C", "Source Code": "void\nlog_register(void (*cb)(int, const char *))\n{\n\tlogh = cb;\n}", "Selected Statement": "logh = cb;", "Function Input": {}, "Variable Values Before Statement": {"cb": "{void (int, const char *)} 0x55555564e5c0 <donothing>"}, "Value After Statement Execution": "{void (int, const char *)} 0x55555564e5c0 <donothing>", "Block_Size": 1, "Project Information": "lldpd"}
{"Programming Language": "C", "Source Code": "int blkid_probe_enable_superblocks(blkid_probe pr, int enable)\n{\n\tpr->chains[BLKID_CHAIN_SUBLKS].enabled = enable;\n\treturn 0;\n}", "Selected Statement": "pr->chains[BLKID_CHAIN_SUBLKS].enabled = enable;", "Function Input": {"enable": {"value": "0"}, "pr": {"value": "0xff0320"}}, "Variable Values Before Statement": {"enable": "int"}, "Value After Statement Execution": "int", "Block_Size": 1, "Project Information": "util-linux"}
{"Programming Language": "C", "Source Code": "void set_source_file(const char *name)\n{\n\tsource_lineno = 1;\n\tstrncpy(source_file, name, sizeof(source_file)-1); \n\tsource_file[sizeof(source_file)-1] = '\\0';\n\tif (strlen(source_file) && source_file[strlen(source_file)-1] == '\"')\n\t\tsource_file[strlen(source_file)-1] = '\\0';\n}", "Selected Statement": "source_lineno = 1;", "Function Input": {}, "Variable Values Before Statement": {"constant": "1"}, "Value After Statement Execution": "1", "Block_Size": 1, "Project Information": "selinux"}
{"Programming Language": "C", "Source Code": "int mnt_table_parse_stream(struct libmnt_table *tb, FILE *f, const char *filename)\n{\n\tint rc = -1;\n\tint flags = 0;\n\tpid_t tid = -1;\n\tstruct libmnt_parser pa = { .line = 0 };\n\n\tassert(tb);\n\tassert(f);\n\tassert(filename);\n\n\tDBG(TAB, ul_debugobj(tb, \"%s: start parsing [entries=%d, filter=%s]\",\n\t\t\t\tfilename, mnt_table_get_nents(tb),\n\t\t\t\ttb->fltrcb ? \"yes\" : \"not\"));\n\n\tpa.filename = filename;\n\tpa.f = f;\n\n\t\n\tif (tb->fmt == MNT_FMT_SWAPS)\n\t\tflags = MNT_FS_SWAP;\n\telse if (filename && strcmp(filename, _PATH_PROC_MOUNTS) == 0)\n\t\tflags = MNT_FS_KERNEL;\n\n\tdo {\n\t\tstruct libmnt_fs *fs;\n\n\t\tif (feof(f)) {\n\t\t\tDBG(TAB, ul_debugobj(tb, \"end-of-file\"));\n\t\t\tbreak;\n\t\t}\n\t\tfs = mnt_new_fs();\n\t\tif (!fs)\n\t\t\tgoto err;\n\n\t\t\n\t\trc = mnt_table_parse_next(&pa, tb, fs);\n\n\t\tif (rc == 0 && tb->fltrcb && tb->fltrcb(fs, tb->fltrcb_data))\n\t\t\trc = 1;\t\n\n\t\tif (rc == 0 && mnt_table_is_noautofs(tb)) {\n\t\t\tconst char *fstype = mnt_fs_get_fstype(fs);\n\n\t\t\tif (fstype && strcmp(fstype, \"autofs\") == 0 &&\n\t\t\t    mnt_fs_get_option(fs, \"ignore\", NULL, NULL) == 0)\n\t\t\t\trc = 1; \n\t\t}\n\n\t\t\n\t\tif (rc == 0) {\n\t\t\trc = mnt_table_add_fs(tb, fs);\n\t\t\tfs->flags |= flags;\n\n\t\t\tif (rc == 0 && tb->fmt == MNT_FMT_MOUNTINFO) {\n\t\t\t\trc = kernel_fs_postparse(&pa, tb, fs, &tid);\n\t\t\t\tif (rc)\n\t\t\t\t\tmnt_table_remove_fs(tb, fs);\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tmnt_unref_fs(fs);\n\n\t\t\n\t\tif (rc > 0) {\n\t\t\tDBG(TAB, ul_debugobj(tb, \"recoverable error (continue)\"));\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (rc < 0 && !feof(f)) {\n\t\t\tDBG(TAB, ul_debugobj(tb, \"fatal error\"));\n\t\t\tgoto err;\n\t\t}\n\t} while (1);\n\n\tDBG(TAB, ul_debugobj(tb, \"%s: stop parsing (%d entries)\",\n\t\t\t\tfilename, mnt_table_get_nents(tb)));\n\tparser_cleanup(&pa);\n\treturn 0;\nerr:\n\tDBG(TAB, ul_debugobj(tb, \"%s: parse error (rc=%d)\", filename, rc));\n\tparser_cleanup(&pa);\n\treturn rc;\n}", "Selected Statement": "int rc = -1;", "Function Input": {}, "Variable Values Before Statement": {"constant": "-1"}, "Value After Statement Execution": "-1", "Block_Size": 1, "Project Information": "util-linux"}
{"Programming Language": "C", "Source Code": "int\ndwarfstring_constructor(struct dwarfstring_s *g)\n{\n    g->s_data = \"\";\n    g->s_size = 0;\n    g->s_avail = 0;\n    g->s_malloc = FALSE;\n    return TRUE;\n}", "Selected Statement": "g->s_data = \"\";", "Function Input": {"g": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"s_data": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffe51000 <error: Cannot access memory at address 0x7fffffffe51000>"}, "s_size": {"type_category": "unknown", "concrete_type": "size_t", "value": "36028797016885248"}, "s_avail": {"type_category": "unknown", "concrete_type": "size_t", "value": "4237742080"}, "s_malloc": {"type_category": "int", "concrete_type": "unsigned char", "value": "0 '\\000'"}}}}}, "Variable Values Before Statement": {"constant": "\"\""}, "Value After Statement Execution": "\"\"", "Block_Size": 1, "Project Information": "libdwarf"}
{"Programming Language": "C", "Source Code": "size_t crypt_getpagesize(void)\n{\n\tlong r = sysconf(_SC_PAGESIZE);\n\treturn r <= 0 ? DEFAULT_MEM_ALIGNMENT : (size_t)r;\n}", "Selected Statement": "long r = sysconf(_SC_PAGESIZE);", "Function Input": {}, "Variable Values Before Statement": {"_SC_PAGESIZE": "NULL"}, "Value After Statement Execution": "4096", "Function Name": "sysconf", "Block_Size": 1, "Project Information": "cryptsetup"}
{"Programming Language": "C", "Source Code": "int ssh_send_banner(ssh_session session, int server)\n{\n    const char *banner = CLIENT_BANNER_SSH2;\n    const char *terminator = \"\\r\\n\";\n    \n    char buffer[256] = {0};\n    size_t len;\n    int rc = SSH_ERROR;\n\n    if (server == 1) {\n        if (session->opts.custombanner == NULL){\n            session->serverbanner = strdup(banner);\n            if (session->serverbanner == NULL) {\n                goto end;\n            }\n        } else {\n            len = strlen(session->opts.custombanner);\n            session->serverbanner = malloc(len + 8 + 1);\n            if(session->serverbanner == NULL) {\n                goto end;\n            }\n            snprintf(session->serverbanner,\n                     len + 8 + 1,\n                     \"SSH-2.0-%s\",\n                     session->opts.custombanner);\n        }\n\n        snprintf(buffer,\n                 sizeof(buffer),\n                 \"%s%s\",\n                 session->serverbanner,\n                 terminator);\n    } else {\n        session->clientbanner = strdup(banner);\n        if (session->clientbanner == NULL) {\n            goto end;\n        }\n\n        snprintf(buffer,\n                 sizeof(buffer),\n                 \"%s%s\",\n                 session->clientbanner,\n                 terminator);\n    }\n\n    rc = ssh_socket_write(session->socket, buffer, strlen(buffer));\n    if (rc == SSH_ERROR) {\n        goto end;\n    }\n#ifdef WITH_PCAP\n    if (session->pcap_ctx != NULL) {\n        ssh_pcap_context_write(session->pcap_ctx,\n                               SSH_PCAP_DIR_OUT,\n                               buffer,\n                               strlen(buffer),\n                               strlen(buffer));\n    }\n#endif\n\n    rc = SSH_OK;\nend:\n    return rc;\n}", "Selected Statement": "const char *banner = CLIENT_BANNER_SSH2;", "Function Input": {}, "Variable Values Before Statement": {"CLIENT_BANNER_SSH2": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 1, "Project Information": "libssh"}
{"Programming Language": "C", "Source Code": "uint64_t\nCGroupGetMemoryLimit()\n{\n    uint64_t PhysicalMemoryLimit = 0;\n    uint64_t RestrictedMemoryLimit = 0;\n\n    CGroupInitialize();\n\n    PhysicalMemoryLimit = GetPhysicalMemoryLimit();\n\n    if (!GetCGroupRestrictedMemoryLimit(&RestrictedMemoryLimit)) {\n        goto Done;\n    }\n\n    \n    \n    \n    \n    \n    \n    if (RestrictedMemoryLimit > 0x7FFFFFFF00000000) {\n        goto Done;\n    }\n\n    struct rlimit CurrRlimit;\n    size_t RlimitSoftLimit = (size_t)RLIM_INFINITY;\n    if (getrlimit(RLIMIT_AS, &CurrRlimit) == 0) {\n        RlimitSoftLimit = CurrRlimit.rlim_cur;\n    }\n    RestrictedMemoryLimit = (RestrictedMemoryLimit < RlimitSoftLimit) ?\n                             RestrictedMemoryLimit : RlimitSoftLimit;\n\n    \n    \n    \n    PhysicalMemoryLimit = (RestrictedMemoryLimit < PhysicalMemoryLimit) ?\n                             RestrictedMemoryLimit : PhysicalMemoryLimit;\n\n    if (PhysicalMemoryLimit > SIZE_T_MAX)\n    {\n        \n        \n        \n        \n        PhysicalMemoryLimit = SIZE_T_MAX;\n    }\n\nDone:\n\n    CGroupCleanup();\n\n    if (PhysicalMemoryLimit == 0) {\n        PhysicalMemoryLimit = 0x40000000; \n    }\n\n    return PhysicalMemoryLimit;\n}", "Selected Statement": "uint64_t PhysicalMemoryLimit = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 1, "Project Information": "msquic"}
{"Programming Language": "C", "Source Code": "static int look_for_our_target(Dwarf_Debug dbg, struct target_data_s *td,\n                               Dwarf_Error *errp) {\n  Dwarf_Unsigned cu_header_length = 0;\n  Dwarf_Unsigned abbrev_offset = 0;\n  Dwarf_Half address_size = 0;\n  Dwarf_Half version_stamp = 0;\n  Dwarf_Half offset_size = 0;\n  Dwarf_Half extension_size = 0;\n  Dwarf_Unsigned typeoffset = 0;\n  Dwarf_Half header_cu_type = unittype;\n  Dwarf_Bool is_info = g_is_info;\n  int cu_number = 0;\n\n  for (;; ++cu_number) {\n    Dwarf_Die no_die = 0;\n    Dwarf_Die cu_die = 0;\n    int res = DW_DLV_ERROR;\n    Dwarf_Sig8 signature;\n\n    memset(&signature, 0, sizeof(signature));\n    res = dwarf_next_cu_header_d(dbg, is_info, &cu_header_length,\n                                 &version_stamp, &abbrev_offset, &address_size,\n                                 &offset_size, &extension_size, &signature,\n                                 &typeoffset, 0, &header_cu_type, errp);\n    if (res == DW_DLV_ERROR) {\n      if (errp) {\n        char *em = dwarf_errmsg(*errp);\n      }\n      return DW_DLV_NO_ENTRY;\n    }\n    if (res == DW_DLV_NO_ENTRY) {\n      return DW_DLV_NO_ENTRY;\n    }\n    cu_version_stamp = version_stamp;\n    cu_offset_size = offset_size;\n    res = dwarf_siblingof_b(dbg, no_die, is_info, &cu_die, errp);\n    if (res == DW_DLV_ERROR) {\n      if (errp) {\n        char *em = dwarf_errmsg(*errp);\n      }\n      return res;\n    }\n    if (res == DW_DLV_NO_ENTRY) {\n      return res;\n    }\n\n    td->td_cu_die = cu_die;\n    res = get_die_and_siblings(dbg, cu_die, is_info, 0, cu_number, td, errp);\n    if (res == FOUND_SUBPROG) {\n      read_line_data(dbg, td, errp);\n      if (td->td_reportallfound) {\n        return res;\n      }\n      return res;\n    } else if (res == IN_THIS_CU) {\n      if (errp) {\n          char *em = dwarf_errmsg(*errp);\n      }\n      return res;\n    } else if (res == DW_DLV_ERROR) {\n      if (errp) {\n        char *em = dwarf_errmsg(*errp);\n      }\n      return DW_DLV_ERROR;\n    }\n    return DW_DLV_NO_ENTRY;\n  }\n}", "Selected Statement": "Dwarf_Unsigned cu_header_length = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 1, "Project Information": "libdwarf"}
{"Programming Language": "C", "Source Code": "GLOBAL(struct jpeg_error_mgr *)\njpeg_std_error(struct jpeg_error_mgr *err)\n{\n  err->error_exit = error_exit;\n  err->emit_message = emit_message;\n  err->output_message = output_message;\n  err->format_message = format_message;\n  err->reset_error_mgr = reset_error_mgr;\n\n  err->trace_level = 0;         \n  err->num_warnings = 0;        \n  err->msg_code = 0;            \n\n  \n  err->jpeg_message_table = jpeg_std_message_table;\n  err->last_jpeg_message = (int)JMSG_LASTMSGCODE - 1;\n\n  err->addon_message_table = NULL;\n  err->first_addon_message = 0; \n  err->last_addon_message = 0;\n\n  return err;\n}", "Selected Statement": "err->error_exit = error_exit;", "Function Input": {}, "Variable Values Before Statement": {"error_exit": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 1, "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Source Code": "void ByteStream_init(struct ByteStream *bs, const uint8_t *data, size_t size) {\n  bs->data_ = data;\n  bs->size_ = size;\n  bs->pos_ = 0;\n}", "Selected Statement": "bs->size_ = size;", "Function Input": {}, "Variable Values Before Statement": {"size": "0"}, "Value After Statement Execution": "0", "Block_Size": 1, "Project Information": "ruby"}
{"Programming Language": "C", "Source Code": "size_t\nstrlcpy(char *dst, const char *src, size_t size) {\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = size;\n\n\t\n\tif (n != 0U && --n != 0U) {\n\t\tdo {\n\t\t\tif ((*d++ = *s++) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (--n != 0U);\n\t}\n\n\t\n\tif (n == 0U) {\n\t\tif (size != 0U) {\n\t\t\t*d = '\\0'; \n\t\t}\n\t\twhile (*s++) {\n\t\t}\n\t}\n\n\treturn (s - src - 1); \n}", "Selected Statement": "const char *s = src;", "Function Input": {}, "Variable Values Before Statement": {"src": "0x7fffffffde00 \"buffer-0x7fffffffdee8\""}, "Value After Statement Execution": "0x7fffffffde00 \"buffer-0x7fffffffdee8\"", "Block_Size": 1, "Project Information": "bind9"}
{"Programming Language": "C", "Source Code": "void\nscreen_init(struct screen *s, u_int sx, u_int sy, u_int hlimit)\n{\n\ts->grid = grid_create(sx, sy, hlimit);\n\ts->saved_grid = NULL;\n\n\ts->title = xstrdup(\"\");\n\ts->titles = NULL;\n\ts->path = NULL;\n\n\ts->cstyle = SCREEN_CURSOR_DEFAULT;\n\ts->default_cstyle = SCREEN_CURSOR_DEFAULT;\n\ts->mode = MODE_CURSOR;\n\ts->default_mode = 0;\n\ts->ccolour = -1;\n\ts->default_ccolour = -1;\n\ts->tabs = NULL;\n\ts->sel = NULL;\n\n#ifdef ENABLE_SIXEL\n\tTAILQ_INIT(&s->images);\n#endif\n\n\ts->write_list = NULL;\n\ts->hyperlinks = NULL;\n\n\tscreen_reinit(s);\n}", "Selected Statement": "s->grid = grid_create(sx, sy, hlimit);", "Function Input": {"s": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"title": {"type_category": "string", "concrete_type": "string", "value": "0x800000008 <error: Cannot access memory at address 0x800000008>"}, "path": {"type_category": "string", "concrete_type": "NULL"}, "titles": {"type_category": "pointer", "concrete_type": "NULL"}, "grid": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x26ebb10", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xffffffff\n", "message": "Cannot access memory at address 0xffffffff"}}, "cx": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "cy": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "cstyle": {"type_category": "unknown", "concrete_type": "screen_cursor_style", "value": "SCREEN_CURSOR_DEFAULT"}, "default_cstyle": {"type_category": "unknown", "concrete_type": "screen_cursor_style", "value": "SCREEN_CURSOR_DEFAULT"}, "ccolour": {"type_category": "int", "concrete_type": "int", "value": "0"}, "default_ccolour": {"type_category": "int", "concrete_type": "int", "value": "0"}, "rupper": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "rlower": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "mode": {"type_category": "int", "concrete_type": "int", "value": "0"}, "default_mode": {"type_category": "int", "concrete_type": "int", "value": "0"}, "saved_cx": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "saved_cy": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "saved_grid": {"type_category": "pointer", "concrete_type": "NULL"}, "saved_cell": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"data": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"data": {"type_category": "string", "concrete_type": "string", "value": "\"\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\""}, "have": {"type_category": "unknown", "concrete_type": "u_char", "value": "0 '\\000'"}, "size": {"type_category": "unknown", "concrete_type": "u_char", "value": "0 '\\000'"}, "width": {"type_category": "unknown", "concrete_type": "u_char", "value": "0 '\\000'"}}}, "attr": {"type_category": "unknown", "concrete_type": "u_short", "value": "0"}, "flags": {"type_category": "unknown", "concrete_type": "u_char", "value": "0 '\\000'"}, "fg": {"type_category": "int", "concrete_type": "int", "value": "0"}, "bg": {"type_category": "int", "concrete_type": "int", "value": "0"}, "us": {"type_category": "int", "concrete_type": "int", "value": "0"}, "link": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}}}, "saved_flags": {"type_category": "int", "concrete_type": "int", "value": "0"}, "tabs": {"type_category": "string", "concrete_type": "NULL"}, "sel": {"type_category": "pointer", "concrete_type": "NULL"}, "write_list": {"type_category": "pointer", "concrete_type": "NULL"}, "hyperlinks": {"type_category": "pointer", "concrete_type": "NULL"}}}}}, "Variable Values Before Statement": {"sx": "u_int", "sy": "u_int", "hlimit": "u_int"}, "Value After Statement Execution": "NULL", "Function Name": "grid_create", "Block_Size": 1, "Project Information": "tmux"}
{"Programming Language": "C", "Source Code": "DLLEXPORT tjhandle tj3Init(int initType)\n{\n  static const char FUNCTION_NAME[] = \"tj3Init\";\n  tjinstance *this = NULL;\n  tjhandle retval = NULL;\n\n  if (initType < 0 || initType >= TJ_NUMINIT)\n    THROWG(\"Invalid argument\", NULL);\n\n  if ((this = (tjinstance *)malloc(sizeof(tjinstance))) == NULL)\n    THROWG(\"Memory allocation failure\", NULL);\n  memset(this, 0, sizeof(tjinstance));\n  SNPRINTF(this->errStr, JMSG_LENGTH_MAX, \"No error\");\n\n  this->quality = -1;\n  this->subsamp = TJSAMP_UNKNOWN;\n  this->jpegWidth = -1;\n  this->jpegHeight = -1;\n  this->precision = 8;\n  this->colorspace = -1;\n  this->losslessPSV = 1;\n  this->xDensity = 1;\n  this->yDensity = 1;\n  this->scalingFactor = TJUNSCALED;\n\n  switch (initType) {\n  case TJINIT_COMPRESS:  return _tjInitCompress(this);\n  case TJINIT_DECOMPRESS:  return _tjInitDecompress(this);\n  case TJINIT_TRANSFORM:\n    retval = _tjInitCompress(this);\n    if (!retval) return NULL;\n    retval = _tjInitDecompress(this);\n    return retval;\n  }\n\nbailout:\n  return retval;\n}", "Selected Statement": "static const char FUNCTION_NAME[] = \"tj3Init\";", "Function Input": {}, "Variable Values Before Statement": {"constant": "\"tj3Init\""}, "Value After Statement Execution": "\"tj3Init\"", "Block_Size": 1, "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Source Code": "void\nfiber_init(int (*invoke)(fiber_func f, va_list ap))\n{\n\tpage_size = small_getpagesize();\n\tstack_direction = check_stack_direction(__builtin_frame_address(0));\n\tfiber_invoke = invoke;\n\tmain_thread_id = pthread_self();\n\tmain_cord.loop = ev_default_loop(EVFLAG_AUTO | EVFLAG_ALLOCFD);\n\tif (main_cord.loop == NULL)\n\t\tpanic(\"can't init event loop\");\n\tcord_create(&main_cord, \"main\");\n\tfiber_signal_init();\n}", "Selected Statement": "page_size = small_getpagesize();", "Function Input": {}, "Variable Values Before Statement": {}, "Value After Statement Execution": "4096", "Function Name": "small_getpagesize", "Block_Size": 1, "Project Information": "tarantool"}
{"Programming Language": "C", "Source Code": "void\ncolour_palette_init(struct colour_palette *p)\n{\n\tp->fg = 8;\n\tp->bg = 8;\n\tp->palette = NULL;\n\tp->default_palette = NULL;\n}", "Selected Statement": "p->fg = 8;", "Function Input": {}, "Variable Values Before Statement": {"constant": "8"}, "Value After Statement Execution": "8", "Block_Size": 1, "Project Information": "tmux"}
{"Programming Language": "C", "Source Code": "int blkid_probe_enable_partitions(blkid_probe pr, int enable)\n{\n\tpr->chains[BLKID_CHAIN_PARTS].enabled = enable;\n\treturn 0;\n}", "Selected Statement": "pr->chains[BLKID_CHAIN_PARTS].enabled = enable;", "Function Input": {"enable": {"value": "32767"}, "pr": {"value": "0xff0320"}}, "Variable Values Before Statement": {"enable": "int"}, "Value After Statement Execution": "int", "Block_Size": 1, "Project Information": "util-linux"}
{"Programming Language": "C", "Source Code": "int symtab_init(symtab_t * s, unsigned int size)\n{\n\ts->table = hashtab_create(symhash, symcmp, size);\n\tif (!s->table)\n\t\treturn -1;\n\ts->nprim = 0;\n\treturn 0;\n}", "Selected Statement": "s->table = hashtab_create(symhash, symcmp, size);", "Function Input": {}, "Variable Values Before Statement": {"symhash": "NULL", "symcmp": "NULL", "size": "unsigned int"}, "Value After Statement Execution": "0x10be070", "Function Name": "hashtab_create", "Block_Size": 1, "Project Information": "selinux"}
{"Programming Language": "C", "Source Code": "void af_gb_init() {\n  pointer_idx = 0;\n\n   for (int i = 0; i < GB_SIZE; i++) {\n     pointer_arr[i] = NULL;\n   }\n}", "Selected Statement": "pointer_idx = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 2, "Project Information": "apache-httpd"}
{"Programming Language": "C", "Source Code": "void ssh_set_auth_methods(ssh_session session, int auth_methods)\n{\n    \n    session->auth.supported_methods = (uint32_t)auth_methods & 0x3fU;\n}", "Selected Statement": "session->auth.supported_methods = (uint32_t)auth_methods & 0x3fU;", "Function Input": {"session": {"value": "0x2dd9932e8a4d1d00"}}, "Variable Values Before Statement": {"auth_methods": "int"}, "Value After Statement Execution": "NULL", "Block_Size": 2, "Project Information": "libssh"}
{"Programming Language": "C", "Source Code": "void\nk5_buf_init_dynamic(struct k5buf *buf)\n{\n    buf->buftype = K5BUF_DYNAMIC;\n    buf->space = 128;\n    buf->data = malloc(buf->space);\n    if (buf->data == NULL) {\n        set_error(buf);\n        return;\n    }\n    buf->len = 0;\n}", "Selected Statement": "buf->space = 128;", "Function Input": {"buf": {"value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x65cc6ead\n", "message": "Cannot access memory at address 0x65cc6ead"}}}, "Variable Values Before Statement": {"constant": "128"}, "Value After Statement Execution": "128", "Block_Size": 2, "Project Information": "krb5"}
{"Programming Language": "C", "Source Code": "int\n_dwarf_object_read_random(int fd, char *buf, Dwarf_Unsigned loc,\n    Dwarf_Unsigned size, Dwarf_Unsigned filesize, int *errc)\n{\n    Dwarf_Unsigned endpoint = 0;\n    int res = 0;\n\n    if (loc >= filesize) {\n        \n        *errc = DW_DLE_SEEK_OFF_END;\n        return DW_DLV_ERROR;\n    }\n    endpoint = loc+size;\n    if (endpoint < loc) {\n        \n        *errc = DW_DLE_READ_OFF_END;\n        return DW_DLV_ERROR;\n    }\n    if (endpoint > filesize) {\n        \n        *errc = DW_DLE_READ_OFF_END;\n        return DW_DLV_ERROR;\n    }\n    res = _dwarf_seekr(fd,loc,SEEK_SET,0);\n    if (res != DW_DLV_OK) {\n        *errc = DW_DLE_SEEK_ERROR;\n        return DW_DLV_ERROR;\n    }\n    res = _dwarf_readr(fd,buf,size,0);\n    if (res != DW_DLV_OK) {\n        *errc = DW_DLE_READ_ERROR;\n        return DW_DLV_ERROR;\n    }\n    return DW_DLV_OK;\n}", "Selected Statement": "Dwarf_Unsigned endpoint = 0;", "Function Input": {"buf": {"value": "0x3 <error: Cannot access memory at address 0x3>"}, "errc": {"value": null}, "fd": {"value": "-10544"}, "filesize": {"value": "6002422"}, "loc": {"value": "140737348690585"}, "size": {"value": "3"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 2, "Project Information": "libdwarf"}
{"Programming Language": "C", "Source Code": "int\ndwarfstring_constructor(struct dwarfstring_s *g)\n{\n    g->s_data = \"\";\n    g->s_size = 0;\n    g->s_avail = 0;\n    g->s_malloc = FALSE;\n    return TRUE;\n}", "Selected Statement": "g->s_size = 0;", "Function Input": {"g": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"s_data": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffe51000 <error: Cannot access memory at address 0x7fffffffe51000>"}, "s_size": {"type_category": "unknown", "concrete_type": "size_t", "value": "36028797016885248"}, "s_avail": {"type_category": "unknown", "concrete_type": "size_t", "value": "4237742080"}, "s_malloc": {"type_category": "int", "concrete_type": "unsigned char", "value": "0 '\\000'"}}}}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 2, "Project Information": "libdwarf"}
{"Programming Language": "C", "Source Code": "static int process_file(const char *name)\n{\n    int rc = -1;\n    blkid_probe pr = blkid_new_probe_from_filename(name);\n    if (pr != NULL) {\n        blkid_probe_enable_partitions(pr, TRUE);\n        blkid_probe_set_partitions_flags(pr, FALSE);\n        blkid_probe_enable_superblocks(pr, TRUE);\n        blkid_probe_set_superblocks_flags(pr, BLKID_SUBLKS_DEFAULT | BLKID_SUBLKS_FSINFO | BLKID_SUBLKS_MAGIC | BLKID_SUBLKS_VERSION | BLKID_SUBLKS_BADCSUM);\n        rc = blkid_do_safeprobe(pr) == -1 ? -1 : 0;\n    }\n    blkid_free_probe(pr);\n    return rc;\n}", "Selected Statement": "blkid_probe pr = blkid_new_probe_from_filename(name);", "Function Input": {"name": {"value": null}}, "Variable Values Before Statement": {"name": "0x7fffffffdf20 \"/tmp/test-script-fuzz.2FhyGN\""}, "Value After Statement Execution": "blkid_probe", "Function Name": "blkid_new_probe_from_filename", "Block_Size": 2, "Project Information": "util-linux"}
{"Programming Language": "C", "Source Code": "int avtab_init(avtab_t * h)\n{\n\th->htable = NULL;\n\th->nel = 0;\n\treturn 0;\n}", "Selected Statement": "h->nel = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 2, "Project Information": "selinux"}
{"Programming Language": "C", "Source Code": "void\np11_message_clear (void)\n{\n\tchar *buffer;\n\tbuffer = p11_message_storage ();\n\tif (buffer != NULL)\n\t\tbuffer[0] = 0;\n}", "Selected Statement": "buffer = p11_message_storage ();", "Function Input": {}, "Variable Values Before Statement": {}, "Value After Statement Execution": "0x7ffff7c23778 \"\"", "Function Name": "p11_message_storage", "Block_Size": 2, "Project Information": "p11-kit"}
{"Programming Language": "C", "Source Code": "int mnt_table_parse_stream(struct libmnt_table *tb, FILE *f, const char *filename)\n{\n\tint rc = -1;\n\tint flags = 0;\n\tpid_t tid = -1;\n\tstruct libmnt_parser pa = { .line = 0 };\n\n\tassert(tb);\n\tassert(f);\n\tassert(filename);\n\n\tDBG(TAB, ul_debugobj(tb, \"%s: start parsing [entries=%d, filter=%s]\",\n\t\t\t\tfilename, mnt_table_get_nents(tb),\n\t\t\t\ttb->fltrcb ? \"yes\" : \"not\"));\n\n\tpa.filename = filename;\n\tpa.f = f;\n\n\t\n\tif (tb->fmt == MNT_FMT_SWAPS)\n\t\tflags = MNT_FS_SWAP;\n\telse if (filename && strcmp(filename, _PATH_PROC_MOUNTS) == 0)\n\t\tflags = MNT_FS_KERNEL;\n\n\tdo {\n\t\tstruct libmnt_fs *fs;\n\n\t\tif (feof(f)) {\n\t\t\tDBG(TAB, ul_debugobj(tb, \"end-of-file\"));\n\t\t\tbreak;\n\t\t}\n\t\tfs = mnt_new_fs();\n\t\tif (!fs)\n\t\t\tgoto err;\n\n\t\t\n\t\trc = mnt_table_parse_next(&pa, tb, fs);\n\n\t\tif (rc == 0 && tb->fltrcb && tb->fltrcb(fs, tb->fltrcb_data))\n\t\t\trc = 1;\t\n\n\t\tif (rc == 0 && mnt_table_is_noautofs(tb)) {\n\t\t\tconst char *fstype = mnt_fs_get_fstype(fs);\n\n\t\t\tif (fstype && strcmp(fstype, \"autofs\") == 0 &&\n\t\t\t    mnt_fs_get_option(fs, \"ignore\", NULL, NULL) == 0)\n\t\t\t\trc = 1; \n\t\t}\n\n\t\t\n\t\tif (rc == 0) {\n\t\t\trc = mnt_table_add_fs(tb, fs);\n\t\t\tfs->flags |= flags;\n\n\t\t\tif (rc == 0 && tb->fmt == MNT_FMT_MOUNTINFO) {\n\t\t\t\trc = kernel_fs_postparse(&pa, tb, fs, &tid);\n\t\t\t\tif (rc)\n\t\t\t\t\tmnt_table_remove_fs(tb, fs);\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tmnt_unref_fs(fs);\n\n\t\t\n\t\tif (rc > 0) {\n\t\t\tDBG(TAB, ul_debugobj(tb, \"recoverable error (continue)\"));\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (rc < 0 && !feof(f)) {\n\t\t\tDBG(TAB, ul_debugobj(tb, \"fatal error\"));\n\t\t\tgoto err;\n\t\t}\n\t} while (1);\n\n\tDBG(TAB, ul_debugobj(tb, \"%s: stop parsing (%d entries)\",\n\t\t\t\tfilename, mnt_table_get_nents(tb)));\n\tparser_cleanup(&pa);\n\treturn 0;\nerr:\n\tDBG(TAB, ul_debugobj(tb, \"%s: parse error (rc=%d)\", filename, rc));\n\tparser_cleanup(&pa);\n\treturn rc;\n}", "Selected Statement": "int flags = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 2, "Project Information": "util-linux"}
{"Programming Language": "C", "Source Code": "void init_parser(int pass_number)\n{\n\tpolicydb_lineno = 1;\n\tsource_lineno = 1;\n\tpolicydb_errors = 0;\n\tpass = pass_number;\n}", "Selected Statement": "source_lineno = 1;", "Function Input": {"pass_number": {"value": "0"}}, "Variable Values Before Statement": {"constant": "1"}, "Value After Statement Execution": "1", "Block_Size": 2, "Project Information": "selinux"}
{"Programming Language": "C", "Source Code": "static int look_for_our_target(Dwarf_Debug dbg, struct target_data_s *td,\n                               Dwarf_Error *errp) {\n  Dwarf_Unsigned cu_header_length = 0;\n  Dwarf_Unsigned abbrev_offset = 0;\n  Dwarf_Half address_size = 0;\n  Dwarf_Half version_stamp = 0;\n  Dwarf_Half offset_size = 0;\n  Dwarf_Half extension_size = 0;\n  Dwarf_Unsigned typeoffset = 0;\n  Dwarf_Half header_cu_type = unittype;\n  Dwarf_Bool is_info = g_is_info;\n  int cu_number = 0;\n\n  for (;; ++cu_number) {\n    Dwarf_Die no_die = 0;\n    Dwarf_Die cu_die = 0;\n    int res = DW_DLV_ERROR;\n    Dwarf_Sig8 signature;\n\n    memset(&signature, 0, sizeof(signature));\n    res = dwarf_next_cu_header_d(dbg, is_info, &cu_header_length,\n                                 &version_stamp, &abbrev_offset, &address_size,\n                                 &offset_size, &extension_size, &signature,\n                                 &typeoffset, 0, &header_cu_type, errp);\n    if (res == DW_DLV_ERROR) {\n      if (errp) {\n        char *em = dwarf_errmsg(*errp);\n      }\n      return DW_DLV_NO_ENTRY;\n    }\n    if (res == DW_DLV_NO_ENTRY) {\n      return DW_DLV_NO_ENTRY;\n    }\n    cu_version_stamp = version_stamp;\n    cu_offset_size = offset_size;\n    res = dwarf_siblingof_b(dbg, no_die, is_info, &cu_die, errp);\n    if (res == DW_DLV_ERROR) {\n      if (errp) {\n        char *em = dwarf_errmsg(*errp);\n      }\n      return res;\n    }\n    if (res == DW_DLV_NO_ENTRY) {\n      return res;\n    }\n\n    td->td_cu_die = cu_die;\n    res = get_die_and_siblings(dbg, cu_die, is_info, 0, cu_number, td, errp);\n    if (res == FOUND_SUBPROG) {\n      read_line_data(dbg, td, errp);\n      if (td->td_reportallfound) {\n        return res;\n      }\n      return res;\n    } else if (res == IN_THIS_CU) {\n      if (errp) {\n          char *em = dwarf_errmsg(*errp);\n      }\n      return res;\n    } else if (res == DW_DLV_ERROR) {\n      if (errp) {\n        char *em = dwarf_errmsg(*errp);\n      }\n      return DW_DLV_ERROR;\n    }\n    return DW_DLV_NO_ENTRY;\n  }\n}", "Selected Statement": "Dwarf_Unsigned abbrev_offset = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 2, "Project Information": "libdwarf"}
{"Programming Language": "C", "Source Code": "void io_stream_init(struct iostream_private *stream)\n{\n\tif (stream->close == NULL)\n\t\tstream->close = io_stream_default_close;\n\tif (stream->destroy == NULL)\n\t\tstream->destroy = io_stream_default_destroy;\n\tstream->ioloop = current_ioloop;\n\n\tstream->refcount = 1;\n}", "Selected Statement": "stream->close = io_stream_default_close;", "Function Input": {}, "Variable Values Before Statement": {"io_stream_default_close": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 2, "Project Information": "dovecot"}
{"Programming Language": "C", "Source Code": "ssh_bind ssh_bind_new(void) {\n    ssh_bind ptr;\n\n    ptr = calloc(1, sizeof(struct ssh_bind_struct));\n    if (ptr == NULL) {\n        return NULL;\n    }\n    ptr->bindfd = SSH_INVALID_SOCKET;\n    ptr->bindport = 22;\n    ptr->common.log_verbosity = 0;\n\n    return ptr;\n}", "Selected Statement": "ptr = calloc(1, sizeof(struct ssh_bind_struct));", "Function Input": {}, "Variable Values Before Statement": {"1": "1"}, "Value After Statement Execution": "ssh_bind", "Function Name": "calloc", "Block_Size": 2, "Project Information": "libssh"}
{"Programming Language": "C", "Source Code": "int ssh_bind_config_parse_string(ssh_bind bind, const char *input)\n{\n    char line[MAX_LINE_SIZE] = {0};\n    const char *c = input, *line_start = input;\n    unsigned int line_num = 0, line_len;\n    uint32_t parser_flags;\n    int rv;\n\n    \n    uint8_t seen[BIND_CFG_MAX] = {0};\n\n    SSH_LOG(SSH_LOG_DEBUG, \"Reading bind configuration data from string:\");\n    SSH_LOG(SSH_LOG_DEBUG, \"START\\n%s\\nEND\", input);\n\n    parser_flags = PARSING;\n    while (1) {\n        line_num++;\n        line_start = c;\n        c = strchr(line_start, '\\n');\n        if (c == NULL) {\n            \n            c = strchr(line_start, '\\0');\n        }\n        if (c == NULL) {\n            \n            SSH_LOG(SSH_LOG_WARN, \"No trailing '\\\\0' in config string\");\n            return SSH_ERROR;\n        }\n        line_len = c - line_start;\n        if (line_len > MAX_LINE_SIZE - 1) {\n            SSH_LOG(SSH_LOG_WARN, \"Line %u too long: %u characters\",\n                    line_num, line_len);\n            return SSH_ERROR;\n        }\n        memcpy(line, line_start, line_len);\n        line[line_len] = '\\0';\n        SSH_LOG(SSH_LOG_DEBUG, \"Line %u: %s\", line_num, line);\n        rv = ssh_bind_config_parse_line(bind, line, line_num, &parser_flags, seen, 0);\n        if (rv < 0) {\n            return SSH_ERROR;\n        }\n        if (*c == '\\0') {\n            break;\n        }\n        c++;\n    }\n\n    return SSH_OK;\n}", "Selected Statement": "const char *c = input, *line_start = input;", "Function Input": {"parser_flags": {"value": "8347536"}}, "Variable Values Before Statement": {"input": "0x12578a0 \"\""}, "Value After Statement Execution": "0x12578a0 \"\"", "Block_Size": 2, "Project Information": "libssh"}
{"Programming Language": "C", "Source Code": "ssh_agent ssh_agent_new(struct ssh_session_struct *session) {\n  ssh_agent agent = NULL;\n\n  agent = malloc(sizeof(struct ssh_agent_struct));\n  if (agent == NULL) {\n    return NULL;\n  }\n  ZERO_STRUCTP(agent);\n\n  agent->count = 0;\n  agent->sock = ssh_socket_new(session);\n  if (agent->sock == NULL) {\n    SAFE_FREE(agent);\n    return NULL;\n  }\n  agent->channel = NULL;\n  return agent;\n}", "Selected Statement": "agent = malloc(sizeof(struct ssh_agent_struct));", "Function Input": {"agent": {"value": "0x510b29 <ssh_set_blocking+105>"}}, "Variable Values Before Statement": {}, "Value After Statement Execution": "ssh_agent", "Function Name": "malloc", "Block_Size": 2, "Project Information": "libssh"}
{"Programming Language": "C", "Source Code": "double\nclock_monotonic(void)\n{\n\tstruct timespec ts;\n\tint rc = clock_gettime(CLOCK_MONOTONIC, &ts);\n\tif (rc != 0)\n\t\tpanic_syserror(\"clock_gettime failed\");\n\treturn (double) ts.tv_sec + ts.tv_nsec / 1e9;\n}", "Selected Statement": "int rc = clock_gettime(CLOCK_MONOTONIC, &ts);", "Function Input": {}, "Variable Values Before Statement": {"CLOCK_MONOTONIC": "NULL"}, "Value After Statement Execution": "int", "Function Name": "clock_gettime", "Block_Size": 2, "Project Information": "tarantool"}
{"Programming Language": "C", "Source Code": "void\nfiber_init(int (*invoke)(fiber_func f, va_list ap))\n{\n\tpage_size = small_getpagesize();\n\tstack_direction = check_stack_direction(__builtin_frame_address(0));\n\tfiber_invoke = invoke;\n\tmain_thread_id = pthread_self();\n\tmain_cord.loop = ev_default_loop(EVFLAG_AUTO | EVFLAG_ALLOCFD);\n\tif (main_cord.loop == NULL)\n\t\tpanic(\"can't init event loop\");\n\tcord_create(&main_cord, \"main\");\n\tfiber_signal_init();\n}", "Selected Statement": "stack_direction = check_stack_direction(__builtin_frame_address(0));", "Function Input": {}, "Variable Values Before Statement": {}, "Value After Statement Execution": "int", "Function Name": "check_stack_direction", "Block_Size": 2, "Project Information": "tarantool"}
{"Programming Language": "C", "Source Code": "int\ndwarf_formaddr(Dwarf_Attribute attr,\n    Dwarf_Addr * return_addr, Dwarf_Error * error)\n{\n    Dwarf_Debug dbg = 0;\n    Dwarf_Addr ret_addr = 0;\n    Dwarf_CU_Context cu_context = 0;\n    Dwarf_Half attrform = 0;\n    int res = 0;\n\n    res  = get_attr_dbg(&dbg,&cu_context,attr,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    attrform = attr->ar_attribute_form;\n    if (dwarf_addr_form_is_indexed(attrform)) {\n        res = _dwarf_look_in_local_and_tied(\n            attrform,\n            cu_context,\n            attr->ar_debug_ptr,\n            return_addr,\n            error);\n        return res;\n    }\n    if (attrform == DW_FORM_addr ||\n        (cu_context->cc_producer == CC_PROD_METROWERKS &&\n        attrform == DW_FORM_ref_addr)\n            \n        ) {\n        Dwarf_Small *section_end =\n            _dwarf_calculate_info_section_end_ptr(cu_context);\n\n        READ_UNALIGNED_CK(dbg, ret_addr, Dwarf_Addr,\n            attr->ar_debug_ptr,\n            cu_context->cc_address_size,\n            error,section_end);\n        *return_addr = ret_addr;\n        return DW_DLV_OK;\n    }\n    generate_form_error(dbg,error,attrform,\n        DW_DLE_ATTR_FORM_BAD,\n        \"DW_DLE_ATTR_FORM_BAD\",\n        \"dwarf_formaddr\");\n    return DW_DLV_ERROR;\n}", "Selected Statement": "Dwarf_Debug dbg = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 2, "Project Information": "libdwarf"}
{"Programming Language": "C", "Source Code": "void\ncolour_palette_init(struct colour_palette *p)\n{\n\tp->fg = 8;\n\tp->bg = 8;\n\tp->palette = NULL;\n\tp->default_palette = NULL;\n}", "Selected Statement": "p->bg = 8;", "Function Input": {}, "Variable Values Before Statement": {"constant": "8"}, "Value After Statement Execution": "8", "Block_Size": 2, "Project Information": "tmux"}
{"Programming Language": "C", "Source Code": "void dds_cdrstream_desc_init (struct dds_cdrstream_desc *desc, const struct dds_cdrstream_allocator * __restrict allocator,\n    uint32_t size, uint32_t align, uint32_t flagset, const uint32_t *ops, const dds_key_descriptor_t *keys, uint32_t nkeys)\n{\n  desc->size = size;\n  desc->align = align;\n\n  \n  desc->keys.nkeys = nkeys;\n  copy_desc_keys (&desc->keys.keys, allocator, keys, nkeys);\n  copy_desc_keys (&desc->keys.keys_definition_order, allocator, keys, nkeys);\n  if (desc->keys.nkeys > 0)\n    qsort (desc->keys.keys_definition_order, nkeys, sizeof (*desc->keys.keys_definition_order), key_cmp_idx);\n\n  desc->ops.nops = dds_stream_countops (ops, nkeys, keys);\n  desc->ops.ops = allocator->malloc (desc->ops.nops * sizeof (*desc->ops.ops));\n  memcpy (desc->ops.ops, ops, desc->ops.nops * sizeof (*desc->ops.ops));\n\n  \n  desc->flagset = flagset & ~DDS_CDR_CALCULATED_FLAGS;\n  desc->flagset |= dds_stream_key_flags (desc, NULL, NULL);\n}", "Selected Statement": "desc->size = size;", "Function Input": {"size": {"value": "<optimized out>"}}, "Variable Values Before Statement": {"size": "80"}, "Value After Statement Execution": "80", "Block_Size": 2, "Project Information": "cyclonedds"}
{"Programming Language": "C", "Source Code": "void fd_close_on_exec(int fd, bool set)\n{\n\tint flags;\n\n\tflags = fcntl(fd, F_GETFD, 0);\n\tif (flags < 0)\n\t\ti_fatal(\"fcntl(F_GETFD, %d) failed: %m\", fd);\n\n\tflags = set ? (flags | FD_CLOEXEC) : (flags & ~FD_CLOEXEC);\n\tif (fcntl(fd, F_SETFD, flags) < 0)\n\t\ti_fatal(\"fcntl(F_SETFD, %d) failed: %m\", fd);\n}", "Selected Statement": "flags = fcntl(fd, F_GETFD, 0);", "Function Input": {"fd": {"value": "32767"}, "set": {"value": "255"}}, "Variable Values Before Statement": {"fd": "int", "F_GETFD": "NULL", "0": "0"}, "Value After Statement Execution": "int", "Function Name": "fcntl", "Block_Size": 3, "Project Information": "dovecot"}
{"Programming Language": "C", "Source Code": "static inline void\nquota_init(struct quota *quota, size_t total)\n{\n\tuint64_t new_total = (total + (QUOTA_UNIT_SIZE - 1)) /\n\t\t\t\tQUOTA_UNIT_SIZE;\n\tquota->value = new_total << 32;\n}", "Selected Statement": "quota->value = new_total << 32;", "Function Input": {"quota": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"value": {"type_category": "unknown", "concrete_type": "uint64_t", "value": "10740875931435413829"}}}}, "total": {"value": "140737348572320"}}, "Variable Values Before Statement": {"new_total": "4294967295"}, "Value After Statement Execution": "NULL", "Block_Size": 3, "Project Information": "tarantool"}
{"Programming Language": "C", "Source Code": "ssh_poll_handle\nssh_poll_new(socket_t fd, short events, ssh_poll_callback cb, void *userdata)\n{\n    ssh_poll_handle p;\n\n    p = malloc(sizeof(struct ssh_poll_handle_struct));\n    if (p == NULL) {\n        return NULL;\n    }\n    ZERO_STRUCTP(p);\n\n    p->x.fd = fd;\n    p->events = events;\n    p->cb = cb;\n    p->cb_data = userdata;\n\n    return p;\n}", "Selected Statement": "p = malloc(sizeof(struct ssh_poll_handle_struct));", "Function Input": {}, "Variable Values Before Statement": {}, "Value After Statement Execution": "ssh_poll_handle", "Function Name": "malloc", "Block_Size": 3, "Project Information": "libssh"}
{"Programming Language": "C", "Source Code": "void EXPORT_CALL\nlou_registerLogCallback(logcallback callback) {\n\tif (callback == NULL)\n\t\tlogCallbackFunction = defaultLogCallback;\n\telse\n\t\tlogCallbackFunction = callback;\n}", "Selected Statement": "logCallbackFunction = callback;", "Function Input": {}, "Variable Values Before Statement": {"callback": "logcallback"}, "Value After Statement Execution": "logcallback", "Block_Size": 3, "Project Information": "liblouis"}
{"Programming Language": "C", "Source Code": "void\nk5_buf_init_dynamic(struct k5buf *buf)\n{\n    buf->buftype = K5BUF_DYNAMIC;\n    buf->space = 128;\n    buf->data = malloc(buf->space);\n    if (buf->data == NULL) {\n        set_error(buf);\n        return;\n    }\n    buf->len = 0;\n}", "Selected Statement": "buf->data = malloc(buf->space);", "Function Input": {"buf": {"value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x65cc6ead\n", "message": "Cannot access memory at address 0x65cc6ead"}}}, "Variable Values Before Statement": {"buf->space": "128"}, "Value After Statement Execution": "NULL", "Function Name": "malloc", "Block_Size": 3, "Project Information": "krb5"}
{"Programming Language": "C", "Source Code": "void luaX_init (lua_State *L) {\n  int i;\n  TString *e = luaS_newliteral(L, LUA_ENV);  \n  luaC_fix(L, obj2gco(e));  \n  for (i=0; i<NUM_RESERVED; i++) {\n    TString *ts = luaS_new(L, luaX_tokens[i]);\n    luaC_fix(L, obj2gco(ts));  \n    ts->extra = cast_byte(i+1);  \n  }\n}", "Selected Statement": "for (i=0; i<NUM_RESERVED; i++) {", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 3, "Project Information": "lua"}
{"Programming Language": "C", "Source Code": "void\nsldns_buffer_init_frm_data(sldns_buffer *buffer, void *data, size_t size)\n{\n\tmemset(buffer, 0, sizeof(*buffer));\n\tbuffer->_data = data;\n\tbuffer->_capacity = buffer->_limit = size;\n\tbuffer->_fixed = 1;\n}", "Selected Statement": "buffer->_capacity = buffer->_limit = size;", "Function Input": {"buffer": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"_position": {"type_category": "unknown", "concrete_type": "size_t", "value": "0"}, "_limit": {"type_category": "unknown", "concrete_type": "size_t", "value": "18767888"}, "_capacity": {"type_category": "unknown", "concrete_type": "size_t", "value": "0"}, "_data": {"type_category": "string", "concrete_type": "NULL"}, "_fixed": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}, "_status_err": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}}}}, "data": {"value": null}, "size": {"value": "105810743"}}, "Variable Values Before Statement": {"size": "12"}, "Value After Statement Execution": "12", "Block_Size": 3, "Project Information": "unbound"}
{"Programming Language": "C", "Source Code": "static int look_for_our_target(Dwarf_Debug dbg, struct target_data_s *td,\n                               Dwarf_Error *errp) {\n  Dwarf_Unsigned cu_header_length = 0;\n  Dwarf_Unsigned abbrev_offset = 0;\n  Dwarf_Half address_size = 0;\n  Dwarf_Half version_stamp = 0;\n  Dwarf_Half offset_size = 0;\n  Dwarf_Half extension_size = 0;\n  Dwarf_Unsigned typeoffset = 0;\n  Dwarf_Half header_cu_type = unittype;\n  Dwarf_Bool is_info = g_is_info;\n  int cu_number = 0;\n\n  for (;; ++cu_number) {\n    Dwarf_Die no_die = 0;\n    Dwarf_Die cu_die = 0;\n    int res = DW_DLV_ERROR;\n    Dwarf_Sig8 signature;\n\n    memset(&signature, 0, sizeof(signature));\n    res = dwarf_next_cu_header_d(dbg, is_info, &cu_header_length,\n                                 &version_stamp, &abbrev_offset, &address_size,\n                                 &offset_size, &extension_size, &signature,\n                                 &typeoffset, 0, &header_cu_type, errp);\n    if (res == DW_DLV_ERROR) {\n      if (errp) {\n        char *em = dwarf_errmsg(*errp);\n      }\n      return DW_DLV_NO_ENTRY;\n    }\n    if (res == DW_DLV_NO_ENTRY) {\n      return DW_DLV_NO_ENTRY;\n    }\n    cu_version_stamp = version_stamp;\n    cu_offset_size = offset_size;\n    res = dwarf_siblingof_b(dbg, no_die, is_info, &cu_die, errp);\n    if (res == DW_DLV_ERROR) {\n      if (errp) {\n        char *em = dwarf_errmsg(*errp);\n      }\n      return res;\n    }\n    if (res == DW_DLV_NO_ENTRY) {\n      return res;\n    }\n\n    td->td_cu_die = cu_die;\n    res = get_die_and_siblings(dbg, cu_die, is_info, 0, cu_number, td, errp);\n    if (res == FOUND_SUBPROG) {\n      read_line_data(dbg, td, errp);\n      if (td->td_reportallfound) {\n        return res;\n      }\n      return res;\n    } else if (res == IN_THIS_CU) {\n      if (errp) {\n          char *em = dwarf_errmsg(*errp);\n      }\n      return res;\n    } else if (res == DW_DLV_ERROR) {\n      if (errp) {\n        char *em = dwarf_errmsg(*errp);\n      }\n      return DW_DLV_ERROR;\n    }\n    return DW_DLV_NO_ENTRY;\n  }\n}", "Selected Statement": "Dwarf_Half address_size = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 3, "Project Information": "libdwarf"}
{"Programming Language": "C", "Source Code": "GLOBAL(struct jpeg_error_mgr *)\njpeg_std_error(struct jpeg_error_mgr *err)\n{\n  err->error_exit = error_exit;\n  err->emit_message = emit_message;\n  err->output_message = output_message;\n  err->format_message = format_message;\n  err->reset_error_mgr = reset_error_mgr;\n\n  err->trace_level = 0;         \n  err->num_warnings = 0;        \n  err->msg_code = 0;            \n\n  \n  err->jpeg_message_table = jpeg_std_message_table;\n  err->last_jpeg_message = (int)JMSG_LASTMSGCODE - 1;\n\n  err->addon_message_table = NULL;\n  err->first_addon_message = 0; \n  err->last_addon_message = 0;\n\n  return err;\n}", "Selected Statement": "err->output_message = output_message;", "Function Input": {}, "Variable Values Before Statement": {"output_message": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 3, "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Source Code": "void\nfiber_init(int (*invoke)(fiber_func f, va_list ap))\n{\n\tpage_size = small_getpagesize();\n\tstack_direction = check_stack_direction(__builtin_frame_address(0));\n\tfiber_invoke = invoke;\n\tmain_thread_id = pthread_self();\n\tmain_cord.loop = ev_default_loop(EVFLAG_AUTO | EVFLAG_ALLOCFD);\n\tif (main_cord.loop == NULL)\n\t\tpanic(\"can't init event loop\");\n\tcord_create(&main_cord, \"main\");\n\tfiber_signal_init();\n}", "Selected Statement": "fiber_invoke = invoke;", "Function Input": {}, "Variable Values Before Statement": {"invoke": "{int (fiber_func, struct __va_list_tag *)} 0x363400 <fiber_c_invoke>"}, "Value After Statement Execution": "{int (fiber_func, struct __va_list_tag *)} 0x363400 <fiber_c_invoke>", "Block_Size": 3, "Project Information": "tarantool"}
{"Programming Language": "C", "Source Code": "int mnt_table_parse_stream(struct libmnt_table *tb, FILE *f, const char *filename)\n{\n\tint rc = -1;\n\tint flags = 0;\n\tpid_t tid = -1;\n\tstruct libmnt_parser pa = { .line = 0 };\n\n\tassert(tb);\n\tassert(f);\n\tassert(filename);\n\n\tDBG(TAB, ul_debugobj(tb, \"%s: start parsing [entries=%d, filter=%s]\",\n\t\t\t\tfilename, mnt_table_get_nents(tb),\n\t\t\t\ttb->fltrcb ? \"yes\" : \"not\"));\n\n\tpa.filename = filename;\n\tpa.f = f;\n\n\t\n\tif (tb->fmt == MNT_FMT_SWAPS)\n\t\tflags = MNT_FS_SWAP;\n\telse if (filename && strcmp(filename, _PATH_PROC_MOUNTS) == 0)\n\t\tflags = MNT_FS_KERNEL;\n\n\tdo {\n\t\tstruct libmnt_fs *fs;\n\n\t\tif (feof(f)) {\n\t\t\tDBG(TAB, ul_debugobj(tb, \"end-of-file\"));\n\t\t\tbreak;\n\t\t}\n\t\tfs = mnt_new_fs();\n\t\tif (!fs)\n\t\t\tgoto err;\n\n\t\t\n\t\trc = mnt_table_parse_next(&pa, tb, fs);\n\n\t\tif (rc == 0 && tb->fltrcb && tb->fltrcb(fs, tb->fltrcb_data))\n\t\t\trc = 1;\t\n\n\t\tif (rc == 0 && mnt_table_is_noautofs(tb)) {\n\t\t\tconst char *fstype = mnt_fs_get_fstype(fs);\n\n\t\t\tif (fstype && strcmp(fstype, \"autofs\") == 0 &&\n\t\t\t    mnt_fs_get_option(fs, \"ignore\", NULL, NULL) == 0)\n\t\t\t\trc = 1; \n\t\t}\n\n\t\t\n\t\tif (rc == 0) {\n\t\t\trc = mnt_table_add_fs(tb, fs);\n\t\t\tfs->flags |= flags;\n\n\t\t\tif (rc == 0 && tb->fmt == MNT_FMT_MOUNTINFO) {\n\t\t\t\trc = kernel_fs_postparse(&pa, tb, fs, &tid);\n\t\t\t\tif (rc)\n\t\t\t\t\tmnt_table_remove_fs(tb, fs);\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tmnt_unref_fs(fs);\n\n\t\t\n\t\tif (rc > 0) {\n\t\t\tDBG(TAB, ul_debugobj(tb, \"recoverable error (continue)\"));\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (rc < 0 && !feof(f)) {\n\t\t\tDBG(TAB, ul_debugobj(tb, \"fatal error\"));\n\t\t\tgoto err;\n\t\t}\n\t} while (1);\n\n\tDBG(TAB, ul_debugobj(tb, \"%s: stop parsing (%d entries)\",\n\t\t\t\tfilename, mnt_table_get_nents(tb)));\n\tparser_cleanup(&pa);\n\treturn 0;\nerr:\n\tDBG(TAB, ul_debugobj(tb, \"%s: parse error (rc=%d)\", filename, rc));\n\tparser_cleanup(&pa);\n\treturn rc;\n}", "Selected Statement": "pid_t tid = -1;", "Function Input": {}, "Variable Values Before Statement": {"constant": "-1"}, "Value After Statement Execution": "-1", "Block_Size": 3, "Project Information": "util-linux"}
{"Programming Language": "C", "Source Code": "void init_parser(int pass_number)\n{\n\tpolicydb_lineno = 1;\n\tsource_lineno = 1;\n\tpolicydb_errors = 0;\n\tpass = pass_number;\n}", "Selected Statement": "policydb_errors = 0;", "Function Input": {"pass_number": {"value": "0"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 3, "Project Information": "selinux"}
{"Programming Language": "C", "Source Code": "extern int\nonigenc_init(void)\n{\n  if (OnigEncInited != 0) return 0;\n\n  OnigEncInited = 1;\n  return 0;\n}", "Selected Statement": "OnigEncInited = 1;", "Function Input": {}, "Variable Values Before Statement": {"constant": "1"}, "Value After Statement Execution": "1", "Block_Size": 3, "Project Information": "oniguruma"}
{"Programming Language": "C", "Source Code": "float\nfloat32_le_read (const unsigned char *cptr)\n{\tint\t\texponent, mantissa, negative ;\n\tfloat\tfvalue ;\n\n\tnegative = cptr [3] & 0x80 ;\n\texponent = ((cptr [3] & 0x7F) << 1) | ((cptr [2] & 0x80) ? 1 : 0) ;\n\tmantissa = ((cptr [2] & 0x7F) << 16) | (cptr [1] << 8) | (cptr [0]) ;\n\n\tif (! (exponent || mantissa))\n\t\treturn 0.0 ;\n\n\tmantissa |= 0x800000 ;\n\texponent = exponent ? exponent - 127 : 0 ;\n\n\tfvalue = mantissa ? ((float) mantissa) / ((float) 0x800000) : 0.0 ;\n\n\tif (negative)\n\t\tfvalue *= -1 ;\n\n\tif (exponent > 0)\n\t\tfvalue *= pow (2.0, exponent) ;\n\telse if (exponent < 0)\n\t\tfvalue /= pow (2.0, abs (exponent)) ;\n\n\treturn fvalue ;\n}", "Selected Statement": "negative = cptr [3] & 0x80 ;", "Function Input": {}, "Variable Values Before Statement": {"cptr": "0x7fffffffda94 \"\\233\\243\\001\\006\\370\\335\\377\\377d\\243\""}, "Value After Statement Execution": "int", "Block_Size": 3, "Project Information": "libsndfile"}
{"Programming Language": "C", "Source Code": "unsigned int luaO_codeparam (unsigned int p) {\n  if (p >= (cast(lu_mem, 0x1F) << (0xF - 7 - 1)) * 100u)  \n    return 0xFF;  \n  else {\n    p = (cast(l_uint32, p) * 128 + 99) / 100;  \n    if (p < 0x10)  \n      return p;  \n    else {\n      int log = luaO_ceillog2(p + 1) - 5;  \n      return ((p >> log) - 0x10) | ((log + 1) << 4);\n    }\n  }\n}", "Selected Statement": "p = (cast(l_uint32, p) * 128 + 99) / 100;  /* round up the division */", "Function Input": {}, "Variable Values Before Statement": {"cast": "NULL", "l_uint32": "NULL", "p": "unsigned int"}, "Value After Statement Execution": "unsigned int", "Block_Size": 3, "Project Information": "lua"}
{"Programming Language": "C", "Source Code": "void fuzzinit(Fuzzer *fuzzer){\n    struct sockaddr_in server_addr;\n    fuzzer->socket = socket(AF_INET, SOCK_STREAM, 0);\n\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(fuzzer->port);\n    server_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n\n    setsockopt(fuzzer->socket, SOL_SOCKET, SO_REUSEADDR, &(int){1}, sizeof(int));\n\n    bind(fuzzer->socket, (struct sockaddr*)&server_addr, sizeof(server_addr));\n    listen(fuzzer->socket,1);\n}", "Selected Statement": "server_addr.sin_family = AF_INET;", "Function Input": {}, "Variable Values Before Statement": {"AF_INET": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 3, "Project Information": "libmodbus"}
{"Programming Language": "C", "Source Code": "void\nmempool_create_with_order(struct mempool *pool, struct slab_cache *cache,\n\t\t\t  uint32_t objsize, uint8_t order)\n{\n\tassert(order <= cache->order_max);\n\tpool->cache = cache;\n\tslab_list_create(&pool->slabs);\n\tmslab_tree_new(&pool->hot_slabs);\n\tpool->first_hot_slab = NULL;\n\trlist_create(&pool->cold_slabs);\n\tpool->spare = NULL;\n\tpool->objsize = objsize;\n\tpool->slab_order = order;\n\t\n\tuint32_t slab_size = slab_order_size(pool->cache, pool->slab_order);\n\t\n\tpool->objcount = (slab_size - mslab_sizeof()) / objsize;\n\tassert(pool->objcount);\n\tpool->offset = slab_size - pool->objcount * pool->objsize;\n\tpool->slab_ptr_mask = ~(slab_order_size(cache, order) - 1);\n\tpool->small_mempool = NULL;\n}", "Selected Statement": "pool->cache = cache;", "Function Input": {}, "Variable Values Before Statement": {"cache": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 3, "Project Information": "tarantool"}
{"Programming Language": "C", "Source Code": "int pr_log_event_listening(unsigned int log_type) {\n  const char *event_name;\n  int res;\n\n  event_name = get_log_event_name(log_type);\n  if (event_name == NULL) {\n    return FALSE;\n  }\n\n  res = pr_event_listening(event_name);\n  if (res <= 0) {\n    return FALSE;\n  }\n\n  return TRUE;\n}", "Selected Statement": "event_name = get_log_event_name(log_type);", "Function Input": {}, "Variable Values Before Statement": {"log_type": "unsigned int"}, "Value After Statement Execution": "0x672686 \"core.log.tracelog\"", "Function Name": "get_log_event_name", "Block_Size": 3, "Project Information": "proftpd"}
{"Programming Language": "C", "Source Code": "void ixml_membuf_init(ixml_membuf *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tm->buf = NULL;\n\tm->length = (size_t)0;\n\tm->capacity = (size_t)0;\n}", "Selected Statement": "m->size_inc = MEMBUF_DEF_SIZE_INC;", "Function Input": {"m": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"buf": {"type_category": "string", "concrete_type": "string", "value": "0x7fffffffdc80 \"\\300\\334\\377\\377\\377\\177\""}, "length": {"type_category": "unknown", "concrete_type": "size_t", "value": "5004613"}, "capacity": {"type_category": "unknown", "concrete_type": "size_t", "value": "15507792"}, "size_inc": {"type_category": "unknown", "concrete_type": "size_t", "value": "140737488346344"}}}}}, "Variable Values Before Statement": {"MEMBUF_DEF_SIZE_INC": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 3, "Project Information": "pupnp"}
{"Programming Language": "C", "Source Code": "int libfplist_xml_tag_free(\n     libfplist_xml_tag_t **tag,\n     libcerror_error_t **error )\n{\n\tstatic char *function = \"libfplist_xml_tag_free\";\n\tint result            = 1;\n\n\tif( tag == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid XML plist tag.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *tag != NULL )\n\t{\n\t\t\n\n\t\tif( libcdata_array_free(\n\t\t     &( ( *tag )->elements_array ),\n\t\t     (int (*)(intptr_t **, libcerror_error_t **)) &libfplist_xml_tag_free,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_FINALIZE_FAILED,\n\t\t\t \"%s: unable to free elements array.\",\n\t\t\t function );\n\n\t\t\tresult = -1;\n\t\t}\n\t\tif( libcdata_array_free(\n\t\t     &( ( *tag )->attributes_array ),\n\t\t     (int (*)(intptr_t **, libcerror_error_t **)) &libfplist_xml_attribute_free,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_FINALIZE_FAILED,\n\t\t\t \"%s: unable to free attributes array.\",\n\t\t\t function );\n\n\t\t\tresult = -1;\n\t\t}\n\t\tif( ( *tag )->value != NULL )\n\t\t{\n\t\t\tmemory_free(\n\t\t\t ( *tag )->value );\n\t\t}\n\t\tif( ( *tag )->name != NULL )\n\t\t{\n\t\t\tmemory_free(\n\t\t\t ( *tag )->name );\n\t\t}\n\t\tmemory_free(\n\t\t *tag );\n\n\t\t*tag = NULL;\n\t}\n\treturn( result );\n}", "Selected Statement": "static char *function = \"libfplist_xml_tag_free\";", "Function Input": {"error": {"value": {"type_category": "pointer", "concrete_type": "NULL"}}, "tag": {"value": null}}, "Variable Values Before Statement": {"constant": "\"libfplist_xml_tag_free\""}, "Value After Statement Execution": "\"libfplist_xml_tag_free\"", "Block_Size": 3, "Project Information": "libyal"}
{"Programming Language": "C", "Source Code": "void init_parser(int pass_number)\n{\n\tpolicydb_lineno = 1;\n\tsource_lineno = 1;\n\tpolicydb_errors = 0;\n\tpass = pass_number;\n}", "Selected Statement": "pass = pass_number;", "Function Input": {"pass_number": {"value": "0"}}, "Variable Values Before Statement": {"pass_number": "int"}, "Value After Statement Execution": "int", "Block_Size": 4, "Project Information": "selinux"}
{"Programming Language": "C", "Source Code": "pool_t pool_datastack_create(void)\n{\n\tstruct datastack_pool *dpool;\n\n\tdpool = t_new(struct datastack_pool, 1);\n\tdpool->pool = static_data_stack_pool;\n\tdpool->refcount = 1;\n\tdpool->data_stack_frame = data_stack_frame_id;\n\treturn &dpool->pool;\n}", "Selected Statement": "dpool->pool = static_data_stack_pool;", "Function Input": {}, "Variable Values Before Statement": {"static_data_stack_pool": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 4, "Project Information": "dovecot"}
{"Programming Language": "C", "Source Code": "void    msg_vstream_init(const char *name, VSTREAM *vp)\n{\n    static int first_call = 1;\n\n    msg_tag = name;\n    msg_stream = vp;\n    if (first_call) {\n\tfirst_call = 0;\n\tmsg_output(msg_vstream_print);\n    }\n}", "Selected Statement": "msg_stream = vp;", "Function Input": {}, "Variable Values Before Statement": {"vp": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 4, "Project Information": "postfix"}
{"Programming Language": "C", "Source Code": "static int write_rsa_hostkey(const char *rsakey_path)\n{\n    FILE *fp = NULL;\n    size_t nwritten;\n\n    fp = fopen(rsakey_path, \"wb\");\n    if (fp == NULL) {\n        return -1;\n    }\n\n    nwritten = fwrite(kRSAPrivateKeyPEM, 1, strlen(kRSAPrivateKeyPEM), fp);\n    fclose(fp);\n\n    if (nwritten != strlen(kRSAPrivateKeyPEM)) {\n        return -1;\n    }\n\n    return 0;\n}", "Selected Statement": "fp = fopen(rsakey_path, \"wb\");", "Function Input": {}, "Variable Values Before Statement": {"rsakey_path": "0x72c8f4 \"/tmp/libssh_fuzzer_private_key\"", "\"wb\"": "\"wb\""}, "Value After Statement Execution": "NULL", "Function Name": "fopen", "Block_Size": 4, "Project Information": "libssh"}
{"Programming Language": "C", "Source Code": "void\nscreen_init(struct screen *s, u_int sx, u_int sy, u_int hlimit)\n{\n\ts->grid = grid_create(sx, sy, hlimit);\n\ts->saved_grid = NULL;\n\n\ts->title = xstrdup(\"\");\n\ts->titles = NULL;\n\ts->path = NULL;\n\n\ts->cstyle = SCREEN_CURSOR_DEFAULT;\n\ts->default_cstyle = SCREEN_CURSOR_DEFAULT;\n\ts->mode = MODE_CURSOR;\n\ts->default_mode = 0;\n\ts->ccolour = -1;\n\ts->default_ccolour = -1;\n\ts->tabs = NULL;\n\ts->sel = NULL;\n\n#ifdef ENABLE_SIXEL\n\tTAILQ_INIT(&s->images);\n#endif\n\n\ts->write_list = NULL;\n\ts->hyperlinks = NULL;\n\n\tscreen_reinit(s);\n}", "Selected Statement": "s->title = xstrdup(\"\");", "Function Input": {"s": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"title": {"type_category": "string", "concrete_type": "string", "value": "0x800000008 <error: Cannot access memory at address 0x800000008>"}, "path": {"type_category": "string", "concrete_type": "NULL"}, "titles": {"type_category": "pointer", "concrete_type": "NULL"}, "grid": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x26ebb10", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xffffffff\n", "message": "Cannot access memory at address 0xffffffff"}}, "cx": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "cy": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "cstyle": {"type_category": "unknown", "concrete_type": "screen_cursor_style", "value": "SCREEN_CURSOR_DEFAULT"}, "default_cstyle": {"type_category": "unknown", "concrete_type": "screen_cursor_style", "value": "SCREEN_CURSOR_DEFAULT"}, "ccolour": {"type_category": "int", "concrete_type": "int", "value": "0"}, "default_ccolour": {"type_category": "int", "concrete_type": "int", "value": "0"}, "rupper": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "rlower": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "mode": {"type_category": "int", "concrete_type": "int", "value": "0"}, "default_mode": {"type_category": "int", "concrete_type": "int", "value": "0"}, "saved_cx": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "saved_cy": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "saved_grid": {"type_category": "pointer", "concrete_type": "NULL"}, "saved_cell": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"data": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"data": {"type_category": "string", "concrete_type": "string", "value": "\"\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\""}, "have": {"type_category": "unknown", "concrete_type": "u_char", "value": "0 '\\000'"}, "size": {"type_category": "unknown", "concrete_type": "u_char", "value": "0 '\\000'"}, "width": {"type_category": "unknown", "concrete_type": "u_char", "value": "0 '\\000'"}}}, "attr": {"type_category": "unknown", "concrete_type": "u_short", "value": "0"}, "flags": {"type_category": "unknown", "concrete_type": "u_char", "value": "0 '\\000'"}, "fg": {"type_category": "int", "concrete_type": "int", "value": "0"}, "bg": {"type_category": "int", "concrete_type": "int", "value": "0"}, "us": {"type_category": "int", "concrete_type": "int", "value": "0"}, "link": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}}}, "saved_flags": {"type_category": "int", "concrete_type": "int", "value": "0"}, "tabs": {"type_category": "string", "concrete_type": "NULL"}, "sel": {"type_category": "pointer", "concrete_type": "NULL"}, "write_list": {"type_category": "pointer", "concrete_type": "NULL"}, "hyperlinks": {"type_category": "pointer", "concrete_type": "NULL"}}}}}, "Variable Values Before Statement": {"\"\"": "\"\""}, "Value After Statement Execution": "0x1cbc950 \"\"", "Function Name": "xstrdup", "Block_Size": 4, "Project Information": "tmux"}
{"Programming Language": "C", "Source Code": "static int read_source_policy(policydb_t *p, const uint8_t *data, size_t size)\n{\n\tint fd, rc;\n\tssize_t wr;\n\n\tfd = memfd_create(\"fuzz-input\", MFD_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\twr = full_write(fd, data, size);\n\tif (wr < 0 || (size_t)wr != size) {\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\tfsync(fd);\n\n\tyynerrs = 0;\n\n\tyyin = fdopen(fd, \"r\");\n\tif (!yyin) {\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\trewind(yyin);\n\n\tset_source_file(\"fuzz-input\");\n\n\tid_queue = queue_create();\n\tif (id_queue == NULL) {\n\t\tfclose(yyin);\n\t\tyylex_destroy();\n\t\treturn -1;\n\t}\n\n\tpolicydbp = p;\n\tmlspol = p->mls;\n\n\tinit_parser(1);\n\n\tif (!setjmp(fuzzing_pre_parse_stack_state)) {\n\t\tqueue_destroy(id_queue);\n\t\tfclose(yyin);\n\t\tyylex_destroy();\n\t\treturn -1;\n\t}\n\n\trc = yyparse();\n\t\n\tassert(rc || !policydb_errors);\n\tif (rc || policydb_errors) {\n\t\tqueue_destroy(id_queue);\n\t\tfclose(yyin);\n\t\tyylex_destroy();\n\t\treturn -1;\n\t}\n\n\trewind(yyin);\n\tinit_parser(2);\n\tset_source_file(\"fuzz-input\");\n\tyyrestart(yyin);\n\n\trc = yyparse();\n\tassert(rc || !policydb_errors);\n\tif (rc || policydb_errors) {\n\t\tqueue_destroy(id_queue);\n\t\tfclose(yyin);\n\t\tyylex_destroy();\n\t\treturn -1;\n\t}\n\n\tqueue_destroy(id_queue);\n\tfclose(yyin);\n\tyylex_destroy();\n\n\treturn 0;\n}", "Selected Statement": "fd = memfd_create(\"fuzz-input\", MFD_CLOEXEC);", "Function Input": {"fd": {"value": "0"}}, "Variable Values Before Statement": {"\"fuzz-input\"": "\"fuzz-input\"", "MFD_CLOEXEC": "NULL"}, "Value After Statement Execution": "int", "Function Name": "memfd_create", "Block_Size": 4, "Project Information": "selinux"}
{"Programming Language": "C", "Source Code": "int stun_is_command_message_str(const uint8_t *buf, size_t blen) {\n  if (buf && blen >= STUN_HEADER_LENGTH) {\n    if (!STUN_VALID_CHANNEL(nswap16(((const uint16_t *)buf)[0]))) {\n      if ((((uint8_t)buf[0]) & ((uint8_t)(0xC0))) == 0) {\n        if (nswap32(((const uint32_t *)(buf))[1]) == STUN_MAGIC_COOKIE) {\n          uint16_t len = nswap16(((const uint16_t *)(buf))[1]);\n          if ((len & 0x0003) == 0) {\n            if ((size_t)(len + STUN_HEADER_LENGTH) == blen) {\n              return 1;\n            }\n          }\n        }\n      }\n    }\n  }\n  return 0;\n}", "Selected Statement": "uint16_t len = nswap16(((const uint16_t *)(buf))[1]);", "Function Input": {}, "Variable Values Before Statement": {}, "Value After Statement Execution": "64256", "Function Name": "nswap16", "Block_Size": 4, "Project Information": "coturn"}
{"Programming Language": "C", "Source Code": "void io_stream_init(struct iostream_private *stream)\n{\n\tif (stream->close == NULL)\n\t\tstream->close = io_stream_default_close;\n\tif (stream->destroy == NULL)\n\t\tstream->destroy = io_stream_default_destroy;\n\tstream->ioloop = current_ioloop;\n\n\tstream->refcount = 1;\n}", "Selected Statement": "stream->destroy = io_stream_default_destroy;", "Function Input": {}, "Variable Values Before Statement": {"io_stream_default_destroy": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 4, "Project Information": "dovecot"}
{"Programming Language": "C", "Source Code": "int device_alloc(struct crypt_device *cd, struct device **device, const char *path)\n{\n\tstruct device *dev;\n\tint r;\n\n\tr = device_alloc_no_check(&dev, path);\n\tif (r < 0)\n\t\treturn r;\n\n\tif (dev) {\n\t\tr = device_ready(cd, dev);\n\t\tif (!r) {\n\t\t\tdev->init_done = 1;\n\t\t} else if (r == -ENOTBLK) {\n\t\t\t\n\t\t} else if (r < 0) {\n\t\t\tfree(dev->path);\n\t\t\tfree(dev);\n\t\t\treturn -ENOTBLK;\n\t\t}\n\t}\n\n\t*device = dev;\n\treturn 0;\n}", "Selected Statement": "r = device_alloc_no_check(&dev, path);", "Function Input": {}, "Variable Values Before Statement": {"path": "0x7fffffffddf0 \"/tmp/test-script-fuzz.o5sGzP\""}, "Value After Statement Execution": "int", "Function Name": "device_alloc_no_check", "Block_Size": 4, "Project Information": "cryptsetup"}
{"Programming Language": "C", "Source Code": "int dwarf_load_rnglists(\n    Dwarf_Debug dbg,\n    Dwarf_Unsigned *rnglists_count,\n    Dwarf_Error *error)\n{\n    int res = DW_DLV_ERROR;\n    Dwarf_Rnglists_Context *cxt = 0;\n    Dwarf_Unsigned count = 0;\n\n    CHECK_DBG(dbg,error,\"dwarf_load_rnglists\");\n    if (dbg->de_rnglists_context) {\n        if (rnglists_count) {\n            *rnglists_count = dbg->de_rnglists_context_count;\n        }\n        return DW_DLV_OK;\n    }\n    if (!dbg->de_debug_rnglists.dss_size) {\n        \n        return DW_DLV_NO_ENTRY;\n    }\n    if (!dbg->de_debug_rnglists.dss_data) {\n        res = _dwarf_load_section(dbg, &dbg->de_debug_rnglists,\n            error);\n        if (res != DW_DLV_OK) {\n            return res;\n        }\n    }\n    res = internal_load_rnglists_contexts(dbg,&cxt,&count,error);\n    if (res == DW_DLV_ERROR) {\n        return res;\n    }\n    dbg->de_rnglists_context = cxt;\n    dbg->de_rnglists_context_count = count;\n    if (rnglists_count) {\n        *rnglists_count = count;\n    }\n    return DW_DLV_OK;\n}", "Selected Statement": "int res = DW_DLV_ERROR;", "Function Input": {}, "Variable Values Before Statement": {"DW_DLV_ERROR": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 4, "Project Information": "libdwarf"}
{"Programming Language": "C", "Source Code": "void http_parser_create(struct http_parser *parser)\n{\n parser->hdr_value_start = NULL;\n parser->hdr_value_end = NULL;\n parser->http_major = -1;\n parser->http_minor = -1;\n parser->hdr_name = NULL;\n parser->hdr_name_idx = 0;\n}", "Selected Statement": "parser->http_minor = -1;", "Function Input": {"parser": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"hdr_value_start": {"type_category": "string", "concrete_type": "string", "value": "0x8c48348707e8b49 <error: Cannot access memory at address 0x8c48348707e8b49>"}, "hdr_value_end": {"type_category": "string", "concrete_type": "string", "value": "0x634c1e95e415b <error: Cannot access memory at address 0x634c1e95e415b>"}, "http_major": {"type_category": "int", "concrete_type": "int", "value": "1398161868"}, "http_minor": {"type_category": "int", "concrete_type": "int", "value": "-24557232"}, "hdr_name": {"type_category": "string", "concrete_type": "string", "value": "0x48000664c2058d48 <error: Cannot access memory at address 0x48000664c2058d48>"}, "hdr_name_idx": {"type_category": "int", "concrete_type": "int", "value": "-1958213751"}}}}}, "Variable Values Before Statement": {"constant": "-1"}, "Value After Statement Execution": "-1", "Block_Size": 4, "Project Information": "tarantool"}
{"Programming Language": "C", "Source Code": "void\np11_message_clear (void)\n{\n\tchar *buffer;\n\tbuffer = p11_message_storage ();\n\tif (buffer != NULL)\n\t\tbuffer[0] = 0;\n}", "Selected Statement": "buffer[0] = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 4, "Project Information": "p11-kit"}
{"Programming Language": "C", "Source Code": "void\nlldpd_port_cleanup(struct lldpd_port *port, int all)\n{\n#ifdef ENABLE_LLDPMED\n\tint i;\n\tif (all)\n\t\tfor (i = 0; i < LLDP_MED_LOCFORMAT_LAST; i++)\n\t\t\tfree(port->p_med_location[i].data);\n#endif\n#ifdef ENABLE_DOT1\n\tlldpd_vlan_cleanup(port);\n\tlldpd_ppvid_cleanup(port);\n\tlldpd_pi_cleanup(port);\n#endif\n\t\n\n\tif (all) {\n\t\tfree(port->p_id);\n\t\tport->p_id = NULL;\n\t\tfree(port->p_descr);\n\t\tport->p_descr = NULL;\n\t\tfree(port->p_lastframe);\n\t\tif (port->p_chassis) { \n\t\t\tport->p_chassis->c_refcount--;\n\t\t\tport->p_chassis = NULL;\n\t\t}\n#ifdef ENABLE_CUSTOM\n\t\tlldpd_custom_list_cleanup(port);\n#endif\n\t}\n}", "Selected Statement": "for (i = 0; i < LLDP_MED_LOCFORMAT_LAST; i++)", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 4, "Project Information": "lldpd"}
{"Programming Language": "C", "Source Code": "void af_gb_init() {\n  pointer_idx = 0;\n\n   for (int i = 0; i < GB_SIZE; i++) {\n     pointer_arr[i] = NULL;\n   }\n}", "Selected Statement": "for (int i = 0; i < GB_SIZE; i++) {", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 4, "Project Information": "apache-httpd"}
{"Programming Language": "C", "Source Code": "void var_expand_extensions_init(void)\n{\n\ti_array_init(&var_expand_extensions, 32);\n\n\t\n\tfor(const struct hash_method **meth = hash_methods;\n\t    *meth != NULL;\n\t    meth++) {\n\t\tstruct var_expand_extension_func_table *func =\n\t\t\tarray_append_space(&var_expand_extensions);\n\t\tfunc->key = (*meth)->name;\n\t\tfunc->func = var_expand_hash;\n\t}\n\n\t\n\tstruct var_expand_extension_func_table *func =\n\t\tarray_append_space(&var_expand_extensions);\n\tfunc->key = \"pkcs5\";\n\tfunc->func = var_expand_hash;\n\n\t\n\tfunc = array_append_space(&var_expand_extensions);\n\tfunc->key = \"if\";\n\tfunc->func = var_expand_if;\n\n\t\n\tfunc = array_append_space(&var_expand_extensions);\n\tfunc->key = \"system\";\n\tfunc->func = var_expand_system;\n\n\t\n\tfunc = array_append_space(&var_expand_extensions);\n\tfunc->key = \"process\";\n\tfunc->func = var_expand_process;\n}", "Selected Statement": "for(const struct hash_method **meth = hash_methods;", "Function Input": {}, "Variable Values Before Statement": {"hash_methods": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 4, "Project Information": "dovecot"}
{"Programming Language": "C", "Source Code": "GLOBAL(struct jpeg_error_mgr *)\njpeg_std_error(struct jpeg_error_mgr *err)\n{\n  err->error_exit = error_exit;\n  err->emit_message = emit_message;\n  err->output_message = output_message;\n  err->format_message = format_message;\n  err->reset_error_mgr = reset_error_mgr;\n\n  err->trace_level = 0;         \n  err->num_warnings = 0;        \n  err->msg_code = 0;            \n\n  \n  err->jpeg_message_table = jpeg_std_message_table;\n  err->last_jpeg_message = (int)JMSG_LASTMSGCODE - 1;\n\n  err->addon_message_table = NULL;\n  err->first_addon_message = 0; \n  err->last_addon_message = 0;\n\n  return err;\n}", "Selected Statement": "err->format_message = format_message;", "Function Input": {}, "Variable Values Before Statement": {"format_message": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 4, "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Source Code": "blkid_probe blkid_new_probe_from_filename(const char *filename)\n{\n\tint fd;\n\tblkid_probe pr = NULL;\n\n\tfd = open(filename, O_RDONLY|O_CLOEXEC|O_NONBLOCK);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tpr = blkid_new_probe();\n\tif (!pr)\n\t\tgoto err;\n\n\tif (blkid_probe_set_device(pr, fd, 0, 0))\n\t\tgoto err;\n\n\tpr->flags |= BLKID_FL_PRIVATE_FD;\n\treturn pr;\nerr:\n\tclose(fd);\n\tblkid_free_probe(pr);\n\treturn NULL;\n}", "Selected Statement": "fd = open(filename, O_RDONLY|O_CLOEXEC|O_NONBLOCK);", "Function Input": {}, "Variable Values Before Statement": {"filename": "0x7fffffffdf20 \"/tmp/test-script-fuzz.2FhyGN\""}, "Value After Statement Execution": "int", "Function Name": "open", "Block_Size": 4, "Project Information": "util-linux"}
{"Programming Language": "C", "Source Code": "void luaX_init (lua_State *L) {\n  int i;\n  TString *e = luaS_newliteral(L, LUA_ENV);  \n  luaC_fix(L, obj2gco(e));  \n  for (i=0; i<NUM_RESERVED; i++) {\n    TString *ts = luaS_new(L, luaX_tokens[i]);\n    luaC_fix(L, obj2gco(ts));  \n    ts->extra = cast_byte(i+1);  \n  }\n}", "Selected Statement": "TString *ts = luaS_new(L, luaX_tokens[i]);", "Function Input": {}, "Variable Values Before Statement": {"L": "NULL"}, "Value After Statement Execution": "NULL", "Function Name": "luaS_new", "Block_Size": 4, "Project Information": "lua"}
{"Programming Language": "C", "Source Code": "int symtab_init(symtab_t * s, unsigned int size)\n{\n\ts->table = hashtab_create(symhash, symcmp, size);\n\tif (!s->table)\n\t\treturn -1;\n\ts->nprim = 0;\n\treturn 0;\n}", "Selected Statement": "s->nprim = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 4, "Project Information": "selinux"}
{"Programming Language": "C", "Source Code": "void\nfiber_init(int (*invoke)(fiber_func f, va_list ap))\n{\n\tpage_size = small_getpagesize();\n\tstack_direction = check_stack_direction(__builtin_frame_address(0));\n\tfiber_invoke = invoke;\n\tmain_thread_id = pthread_self();\n\tmain_cord.loop = ev_default_loop(EVFLAG_AUTO | EVFLAG_ALLOCFD);\n\tif (main_cord.loop == NULL)\n\t\tpanic(\"can't init event loop\");\n\tcord_create(&main_cord, \"main\");\n\tfiber_signal_init();\n}", "Selected Statement": "main_thread_id = pthread_self();", "Function Input": {}, "Variable Values Before Statement": {}, "Value After Statement Execution": "pthread_t", "Function Name": "pthread_self", "Block_Size": 4, "Project Information": "tarantool"}
{"Programming Language": "C", "Source Code": "void\np11_virtual_init (p11_virtual *virt,\n                  CK_X_FUNCTION_LIST *funcs,\n                  void *lower_module,\n                  p11_destroyer lower_destroy)\n{\n\tmemcpy (virt, funcs, sizeof (CK_X_FUNCTION_LIST));\n\tvirt->lower_module = lower_module;\n\tvirt->lower_destroy = lower_destroy;\n}", "Selected Statement": "virt->lower_module = lower_module;", "Function Input": {}, "Variable Values Before Statement": {"lower_module": "VOID"}, "Value After Statement Execution": "VOID", "Block_Size": 5, "Project Information": "p11-kit"}
{"Programming Language": "C", "Source Code": "int libcdata_array_initialize(\n     libcdata_array_t **array,\n     int number_of_entries,\n     libcerror_error_t **error )\n{\n\tlibcdata_internal_array_t *internal_array = NULL;\n\tstatic char *function                     = \"libcdata_array_initialize\";\n\tsize_t entries_size                       = 0;\n\tint number_of_allocated_entries           = 0;\n\n\tif( array == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid array.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *array != NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\n\t\t \"%s: invalid array value already set.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( number_of_entries < 0 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_LESS_THAN_ZERO,\n\t\t \"%s: invalid number of entries value less than zero.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tinternal_array = memory_allocate_structure(\n\t                  libcdata_internal_array_t );\n\n\tif( internal_array == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create array.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     internal_array,\n\t     0,\n\t     sizeof( libcdata_internal_array_t ) ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear array.\",\n\t\t function );\n\n\t\tmemory_free(\n\t\t internal_array );\n\n\t\treturn( -1 );\n\t}\n\t\n\tif( number_of_entries >= (int) ( INT_MAX - 16 ) )\n\t{\n\t\tnumber_of_allocated_entries = INT_MAX;\n\t}\n\telse\n\t{\n\t\tnumber_of_allocated_entries = ( number_of_entries & ~( 15 ) ) + 16;\n\t}\n#if SIZEOF_INT <= SIZEOF_SIZE_T\n\tif( (size_t) number_of_allocated_entries > (size_t) ( SSIZE_MAX / sizeof( intptr_t * ) ) )\n#else\n\tif( number_of_allocated_entries > (int) ( SSIZE_MAX / sizeof( intptr_t * ) ) )\n#endif\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_EXCEEDS_MAXIMUM,\n\t\t \"%s: invalid number of allocated entries value exceeds maximum.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tentries_size = sizeof( intptr_t * ) * number_of_allocated_entries;\n\n\tif( entries_size > (size_t) LIBCDATA_ARRAY_ENTRIES_MEMORY_LIMIT )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_EXCEEDS_MAXIMUM,\n\t\t \"%s: invalid entries size value exceeds maximum.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tinternal_array->entries = (intptr_t **) memory_allocate(\n\t                                         entries_size );\n\n\tif( internal_array->entries == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create array entries.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     internal_array->entries,\n\t     0,\n\t     entries_size ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear array entries.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tinternal_array->number_of_allocated_entries = number_of_allocated_entries;\n\tinternal_array->number_of_entries           = number_of_entries;\n\n#if defined( HAVE_MULTI_THREAD_SUPPORT ) && !defined( HAVE_LOCAL_LIBCDATA )\n\tif( libcthreads_read_write_lock_initialize(\n\t     &( internal_array->read_write_lock ),\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to initialize read/write lock.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n#endif\n\t*array = (libcdata_array_t *) internal_array;\n\n\treturn( 1 );\n\non_error:\n\tif( internal_array != NULL )\n\t{\n\t\tif( internal_array->entries != NULL )\n\t\t{\n\t\t\tmemory_free(\n\t\t\t internal_array->entries );\n\t\t}\n\t\tmemory_free(\n\t\t internal_array );\n\t}\n\treturn( -1 );\n}", "Selected Statement": "static char *function                     = \"libcdata_array_initialize\";", "Function Input": {"array": {"value": {"type_category": "pointer", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x200\n", "message": "Cannot access memory at address 0x200"}}, "error": {"value": {"type_category": "pointer", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x7366780800000200\n", "message": "Cannot access memory at address 0x7366780800000200"}}, "number_of_entries": {"value": "116"}}, "Variable Values Before Statement": {"constant": "\"libcdata_array_initialize\""}, "Value After Statement Execution": "\"libcdata_array_initialize\"", "Block_Size": 5, "Project Information": "libyal"}
{"Programming Language": "C", "Source Code": "void test_deflate(unsigned char *compr, size_t comprLen)\n{\n    z_stream c_stream; \n    int err;\n    unsigned long len = dataLen;\n\n    c_stream.zalloc = zalloc;\n    c_stream.zfree = zfree;\n    c_stream.opaque = NULL;\n\n    err = deflateInit(&c_stream, Z_DEFAULT_COMPRESSION);\n    CHECK_ERR(err, \"deflateInit\");\n\n    c_stream.next_in = (Bytef *)data;\n    c_stream.next_out = compr;\n\n    while (c_stream.total_in != len && c_stream.total_out < comprLen)\n    {\n        c_stream.avail_in = c_stream.avail_out = 1; \n        err = deflate(&c_stream, Z_NO_FLUSH);\n        CHECK_ERR(err, \"deflate small 1\");\n    }\n\n    \n    for (;;)\n    {\n        c_stream.avail_out = 1;\n        err = deflate(&c_stream, Z_FINISH);\n        if (err == Z_STREAM_END)\n            break;\n        CHECK_ERR(err, \"deflate small 2\");\n    }\n\n    err = deflateEnd(&c_stream);\n    CHECK_ERR(err, \"deflateEnd\");\n}", "Selected Statement": "c_stream.zalloc = zalloc;", "Function Input": {"compr": {"value": "0xf77f80 \"=\""}, "comprLen": {"value": "140737488346736"}}, "Variable Values Before Statement": {"zalloc": "mz_alloc_func"}, "Value After Statement Execution": "mz_alloc_func", "Block_Size": 5, "Project Information": "miniz"}
{"Programming Language": "C", "Source Code": "void test_large_deflate(unsigned char *compr, size_t comprLen,\n                        unsigned char *uncompr, size_t uncomprLen)\n{\n    z_stream c_stream; \n    int err;\n\n    c_stream.zalloc = zalloc;\n    c_stream.zfree = zfree;\n    c_stream.opaque = NULL;\n\n    err = deflateInit(&c_stream, Z_BEST_COMPRESSION);\n    CHECK_ERR(err, \"deflateInit\");\n\n    c_stream.next_out = compr;\n    c_stream.avail_out = (unsigned int)comprLen;\n\n    \n    c_stream.next_in = uncompr;\n    c_stream.avail_in = (unsigned int)uncomprLen;\n    err = deflate(&c_stream, Z_NO_FLUSH);\n    CHECK_ERR(err, \"deflate large 1\");\n\n    if (c_stream.avail_in != 0)\n    {\n        fprintf(stderr, \"deflate not greedy\\n\");\n        exit(1);\n    }\n\n    \n    c_stream.next_in = compr;\n    diff = (unsigned int)(c_stream.next_out - compr);\n    c_stream.avail_in = diff;\n\n    deflate(&c_stream, Z_NO_FLUSH);\n    err = deflate(&c_stream, Z_FINISH);\n\n    if (err != Z_STREAM_END)\n    {\n        fprintf(stderr, \"deflate large should report Z_STREAM_END\\n\");\n        exit(1);\n    }\n    err = deflateEnd(&c_stream);\n    CHECK_ERR(err, \"deflateEnd\");\n}", "Selected Statement": "c_stream.zalloc = zalloc;", "Function Input": {"compr": {"value": "0xf77f80 \"\\n\""}, "comprLen": {"value": "140737488346736"}, "uncompr": {"value": "0x1 <error: Cannot access memory at address 0x1>"}, "uncomprLen": {"value": "16325344"}}, "Variable Values Before Statement": {"zalloc": "mz_alloc_func"}, "Value After Statement Execution": "mz_alloc_func", "Block_Size": 5, "Project Information": "miniz"}
{"Programming Language": "C", "Source Code": "void\ninit_parse_tree(struct sudoers_parse_tree *parse_tree, char *lhost, char *shost,\n    struct sudoers_context *ctx, struct sudo_nss *nss)\n{\n    TAILQ_INIT(&parse_tree->userspecs);\n    TAILQ_INIT(&parse_tree->defaults);\n    parse_tree->aliases = NULL;\n    parse_tree->shost = shost;\n    parse_tree->lhost = lhost;\n    parse_tree->ctx = ctx;\n    parse_tree->nss = nss;\n}", "Selected Statement": "parse_tree->shost = shost;", "Function Input": {}, "Variable Values Before Statement": {"shost": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 5, "Project Information": "sudoers"}
{"Programming Language": "C", "Source Code": "int dwarf_load_rnglists(\n    Dwarf_Debug dbg,\n    Dwarf_Unsigned *rnglists_count,\n    Dwarf_Error *error)\n{\n    int res = DW_DLV_ERROR;\n    Dwarf_Rnglists_Context *cxt = 0;\n    Dwarf_Unsigned count = 0;\n\n    CHECK_DBG(dbg,error,\"dwarf_load_rnglists\");\n    if (dbg->de_rnglists_context) {\n        if (rnglists_count) {\n            *rnglists_count = dbg->de_rnglists_context_count;\n        }\n        return DW_DLV_OK;\n    }\n    if (!dbg->de_debug_rnglists.dss_size) {\n        \n        return DW_DLV_NO_ENTRY;\n    }\n    if (!dbg->de_debug_rnglists.dss_data) {\n        res = _dwarf_load_section(dbg, &dbg->de_debug_rnglists,\n            error);\n        if (res != DW_DLV_OK) {\n            return res;\n        }\n    }\n    res = internal_load_rnglists_contexts(dbg,&cxt,&count,error);\n    if (res == DW_DLV_ERROR) {\n        return res;\n    }\n    dbg->de_rnglists_context = cxt;\n    dbg->de_rnglists_context_count = count;\n    if (rnglists_count) {\n        *rnglists_count = count;\n    }\n    return DW_DLV_OK;\n}", "Selected Statement": "Dwarf_Rnglists_Context *cxt = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 5, "Project Information": "libdwarf"}
{"Programming Language": "C", "Source Code": "int CheckXML(char *filename){\n\n    int rc;\n    DOMString s;\n    IXML_Document *doc = NULL;\n\n    rc = ixmlLoadDocumentEx(filename, &doc);\n    if (rc != IXML_SUCCESS) {\n        return rc;\n    }\n\n    s = ixmlPrintDocument(doc);\n    if (s == NULL || s[0] == '\\0') {\n        ixmlDocument_free(doc);\n        return 1;\n    }\n\n    ixmlFreeDOMString(s);\n    ixmlDocument_free(doc);\n\n    return 0;\n}", "Selected Statement": "rc = ixmlLoadDocumentEx(filename, &doc);", "Function Input": {"filename": {"value": "0xa <error: Cannot access memory at address 0xa>"}}, "Variable Values Before Statement": {"filename": "0x7fffffffdd60 \"/tmp/libfuzzer.61\""}, "Value After Statement Execution": "int", "Function Name": "ixmlLoadDocumentEx", "Block_Size": 5, "Project Information": "pupnp"}
{"Programming Language": "C", "Source Code": "static int look_for_our_target(Dwarf_Debug dbg, struct target_data_s *td,\n                               Dwarf_Error *errp) {\n  Dwarf_Unsigned cu_header_length = 0;\n  Dwarf_Unsigned abbrev_offset = 0;\n  Dwarf_Half address_size = 0;\n  Dwarf_Half version_stamp = 0;\n  Dwarf_Half offset_size = 0;\n  Dwarf_Half extension_size = 0;\n  Dwarf_Unsigned typeoffset = 0;\n  Dwarf_Half header_cu_type = unittype;\n  Dwarf_Bool is_info = g_is_info;\n  int cu_number = 0;\n\n  for (;; ++cu_number) {\n    Dwarf_Die no_die = 0;\n    Dwarf_Die cu_die = 0;\n    int res = DW_DLV_ERROR;\n    Dwarf_Sig8 signature;\n\n    memset(&signature, 0, sizeof(signature));\n    res = dwarf_next_cu_header_d(dbg, is_info, &cu_header_length,\n                                 &version_stamp, &abbrev_offset, &address_size,\n                                 &offset_size, &extension_size, &signature,\n                                 &typeoffset, 0, &header_cu_type, errp);\n    if (res == DW_DLV_ERROR) {\n      if (errp) {\n        char *em = dwarf_errmsg(*errp);\n      }\n      return DW_DLV_NO_ENTRY;\n    }\n    if (res == DW_DLV_NO_ENTRY) {\n      return DW_DLV_NO_ENTRY;\n    }\n    cu_version_stamp = version_stamp;\n    cu_offset_size = offset_size;\n    res = dwarf_siblingof_b(dbg, no_die, is_info, &cu_die, errp);\n    if (res == DW_DLV_ERROR) {\n      if (errp) {\n        char *em = dwarf_errmsg(*errp);\n      }\n      return res;\n    }\n    if (res == DW_DLV_NO_ENTRY) {\n      return res;\n    }\n\n    td->td_cu_die = cu_die;\n    res = get_die_and_siblings(dbg, cu_die, is_info, 0, cu_number, td, errp);\n    if (res == FOUND_SUBPROG) {\n      read_line_data(dbg, td, errp);\n      if (td->td_reportallfound) {\n        return res;\n      }\n      return res;\n    } else if (res == IN_THIS_CU) {\n      if (errp) {\n          char *em = dwarf_errmsg(*errp);\n      }\n      return res;\n    } else if (res == DW_DLV_ERROR) {\n      if (errp) {\n        char *em = dwarf_errmsg(*errp);\n      }\n      return DW_DLV_ERROR;\n    }\n    return DW_DLV_NO_ENTRY;\n  }\n}", "Selected Statement": "Dwarf_Half offset_size = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 5, "Project Information": "libdwarf"}
{"Programming Language": "C", "Source Code": "int\nutf8_isvalid(const char *s)\n{\n\tstruct utf8_data ud;\n\tconst char\t*end;\n\tenum utf8_state\t more;\n\n\tend = s + strlen(s);\n\twhile (s < end) {\n\t\tif ((more = utf8_open(&ud, *s)) == UTF8_MORE) {\n\t\t\twhile (++s < end && more == UTF8_MORE)\n\t\t\t\tmore = utf8_append(&ud, *s);\n\t\t\tif (more == UTF8_DONE)\n\t\t\t\tcontinue;\n\t\t\treturn (0);\n\t\t}\n\t\tif (*s < 0x20 || *s > 0x7e)\n\t\t\treturn (0);\n\t\ts++;\n\t}\n\treturn (1);\n}", "Selected Statement": "end = s + strlen(s);", "Function Input": {}, "Variable Values Before Statement": {"s": "0x7fffffffdddc \"\"", "strlen": "NULL"}, "Value After Statement Execution": "0x7fffffffdddc \"\"", "Block_Size": 5, "Project Information": "tmux"}
{"Programming Language": "C", "Source Code": "void module_compiler_reset(void)\n{\n\twhile (stack_top)\n\t\tpop_stack();\n\n\tlast_block = NULL;\n\tnext_decl_id = 1;\n}", "Selected Statement": "next_decl_id = 1;", "Function Input": {}, "Variable Values Before Statement": {"constant": "1"}, "Value After Statement Execution": "1", "Block_Size": 5, "Project Information": "selinux"}
{"Programming Language": "C", "Source Code": "void ssh_packet_register_socket_callback(ssh_session session, ssh_socket s)\n{\n    struct ssh_socket_callbacks_struct *callbacks = &session->socket_callbacks;\n\n    callbacks->data = ssh_packet_socket_callback;\n    callbacks->connected = NULL;\n    callbacks->controlflow = ssh_packet_socket_controlflow_callback;\n    callbacks->userdata = session;\n    ssh_socket_set_callbacks(s, callbacks);\n}", "Selected Statement": "callbacks->controlflow = ssh_packet_socket_controlflow_callback;", "Function Input": {"session": {"value": "0x222ed1fd0aa1f200"}}, "Variable Values Before Statement": {"ssh_packet_socket_controlflow_callback": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 5, "Project Information": "libssh"}
{"Programming Language": "C", "Source Code": "static isc_result_t\nparse_message(isc_buffer_t *input, dns_message_t **messagep) {\n\tisc_result_t result;\n\tdns_message_t *message = NULL;\n\n\tdns_message_create(mctx, NULL, NULL, DNS_MESSAGE_INTENTPARSE, &message);\n\n\tresult = dns_message_parse(message, input, DNS_MESSAGEPARSE_BESTEFFORT);\n\tif (result == DNS_R_RECOVERABLE) {\n\t\tresult = ISC_R_SUCCESS;\n\t}\n\n\tif (result == ISC_R_SUCCESS && messagep != NULL) {\n\t\t*messagep = message;\n\t} else {\n\t\tdns_message_detach(&message);\n\t}\n\n\treturn (result);\n}", "Selected Statement": "result = dns_message_parse(message, input, DNS_MESSAGEPARSE_BESTEFFORT);", "Function Input": {}, "Variable Values Before Statement": {"message": {"magic": "1297303360", "references": "1", "id": "0", "flags": "0", "rcode": "0", "opcode": "0", "rdclass": "0", "counts": [{"type_category": "int", "concrete_type": "unsigned int", "value": "0"}, {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}, {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}, {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}], "sections": [{"type_category": "struct", "concrete_type": "STRUCT", "value": {"head": {"type_category": "pointer", "concrete_type": "NULL"}, "tail": {"type_category": "pointer", "concrete_type": "NULL"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"head": {"type_category": "pointer", "concrete_type": "NULL"}, "tail": {"type_category": "pointer", "concrete_type": "NULL"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"head": {"type_category": "pointer", "concrete_type": "NULL"}, "tail": {"type_category": "pointer", "concrete_type": "NULL"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"head": {"type_category": "pointer", "concrete_type": "NULL"}, "tail": {"type_category": "pointer", "concrete_type": "NULL"}}}], "cursors": [{"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}, {"type_category": "pointer", "concrete_type": "NULL"}], "opt": null, "sig0": null, "tsig": null, "state": "-1", "from_to_wire": "DNS_MESSAGE_INTENTPARSE", "header_ok": "0", "question_ok": "0", "tcp_continuation": "0", "verified_sig": "0", "verify_attempted": "0", "free_query": "0", "free_saved": "0", "cc_ok": "0", "cc_bad": "0", "cc_echoed": "0", "tkey": "0", "rdclass_set": "0", "fuzzing": "0", "free_pools": "1", "opt_reserved": "0", "sig_reserved": "0", "reserved": "0", "padding": "0", "padding_off": "0", "buffer": null, "cctx": null, "mctx": null, "namepool": "{magic = 1296387440, mctx = 0x1892a50, link = {prev = 0x0, next = 0x18961f0}, items = 0x0, size = 536, allocated = 0, freecount = 0, freemax = 8192, fillcount = 1024, gets = 0, name = \"dns_fixedname_p\"}", "rdspool": "{magic = 1296387440, mctx = 0x1892a50, link = {prev = 0x1897d10, next = 0x0}, items = 0x0, size = 112, allocated = 0, freecount = 0, freemax = 8192, fillcount = 1024, gets = 0, name = \"dns_rdataset_po\"}", "scratchpad": null, "cleanup": null, "rdatas": null, "rdatalists": null, "offsets": null, "freerdata": null, "freerdatalist": null, "tsigstatus": "0", "querytsigstatus": "0", "tsigname": null, "querytsig": null, "tsigkey": null, "tsigctx": null, "sigstart": "-1", "timeadjust": "0", "sig0name": null, "sig0key": null, "sig0status": "0", "query": null, "saved": null, "fuzztime": "0", "order": null, "order_arg": null, "indent": null, "minttl": [{"type_category": "struct", "concrete_type": "STRUCT", "value": {"is_set": {"type_category": "unknown", "concrete_type": "_Bool", "value": "false"}, "ttl": {"type_category": "unknown", "concrete_type": "dns_ttl_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"is_set": {"type_category": "unknown", "concrete_type": "_Bool", "value": "false"}, "ttl": {"type_category": "unknown", "concrete_type": "dns_ttl_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"is_set": {"type_category": "unknown", "concrete_type": "_Bool", "value": "false"}, "ttl": {"type_category": "unknown", "concrete_type": "dns_ttl_t", "value": "0"}}}, {"type_category": "struct", "concrete_type": "STRUCT", "value": {"is_set": {"type_category": "unknown", "concrete_type": "_Bool", "value": "false"}, "ttl": {"type_category": "unknown", "concrete_type": "dns_ttl_t", "value": "0"}}}]}, "input": {"magic": "1114990113", "base": null, "length": "0", "used": "0", "current": "0", "active": "0", "extra": "0", "dynamic": "false", "link": null, "mctx": null}, "DNS_MESSAGEPARSE_BESTEFFORT": "NULL"}, "Value After Statement Execution": "isc_result_t", "Function Name": "dns_message_parse", "Block_Size": 5, "Project Information": "bind9"}
{"Programming Language": "C", "Source Code": "OM_uint32\ngssint_get_mech_type(gss_OID OID, gss_buffer_t token)\n{\n    \n    if (token->length >= sizeof(NTLMSSP_SIGNATURE) &&\n\tmemcmp(token->value, NTLMSSP_SIGNATURE,\n\t       sizeof(NTLMSSP_SIGNATURE)) == 0) {\n\t*OID = gss_ntlm_mechanism_oid_desc;\n    } else if (token->length != 0 &&\n\t       ((char *)token->value)[0] == 0x6E) {\n \t\n\t*OID = gss_krb5_mechanism_oid_desc;\n    } else if (token->length == 0) {\n\t*OID = gss_spnego_mechanism_oid_desc;\n    } else {\n\treturn gssint_get_mech_type_oid(OID, token);\n    }\n\n    return (GSS_S_COMPLETE);\n}", "Selected Statement": "*OID = gss_ntlm_mechanism_oid_desc;", "Function Input": {"token": {"value": "0x7fffffffde20"}}, "Variable Values Before Statement": {"gss_ntlm_mechanism_oid_desc": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 5, "Project Information": "krb5"}
{"Programming Language": "C", "Source Code": "int libfwnt_huffman_tree_initialize(\n     libfwnt_huffman_tree_t **huffman_tree,\n     int number_of_symbols,\n     uint8_t maximum_code_size,\n     libcerror_error_t **error )\n{\n\tstatic char *function = \"libfwnt_huffman_tree_initialize\";\n\tsize_t array_size     = 0;\n\n\tif( huffman_tree == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid Huffman tree.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *huffman_tree != NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\n\t\t \"%s: invalid Huffman tree value already set.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( ( number_of_symbols < 0 )\n\t || ( number_of_symbols > 1024 ) )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: invalid number of symbols value out of bounds.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( maximum_code_size > 32 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: invalid maximum code size value out of bounds.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\t*huffman_tree = memory_allocate_structure(\n\t                 libfwnt_huffman_tree_t );\n\n\tif( *huffman_tree == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create Huffman tree.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     *huffman_tree,\n\t     0,\n\t     sizeof( libfwnt_huffman_tree_t ) ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear Huffman tree.\",\n\t\t function );\n\n\t\tmemory_free(\n\t\t *huffman_tree );\n\n\t\t*huffman_tree = NULL;\n\n\t\treturn( -1 );\n\t}\n\tarray_size = sizeof( int ) * number_of_symbols;\n\n\t( *huffman_tree )->symbols = (int *) memory_allocate(\n\t                                      array_size );\n\n\tif( ( *huffman_tree )->symbols == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create symbols.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     ( *huffman_tree )->symbols,\n\t     0,\n\t     array_size ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear symbols.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tarray_size = sizeof( int ) * ( maximum_code_size + 1 );\n\n\t( *huffman_tree )->code_size_counts = (int *) memory_allocate(\n\t                                               array_size );\n\n\tif( ( *huffman_tree )->code_size_counts == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create code size counts.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     ( *huffman_tree )->code_size_counts,\n\t     0,\n\t     array_size ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear code size counts.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\t( *huffman_tree )->maximum_code_size = maximum_code_size;\n\n\treturn( 1 );\n\non_error:\n\tif( *huffman_tree != NULL )\n\t{\n\t\tif( ( *huffman_tree )->code_size_counts != NULL )\n\t\t{\n\t\t\tmemory_free(\n\t\t\t ( *huffman_tree )->code_size_counts );\n\t\t}\n\t\tif( ( *huffman_tree )->symbols != NULL )\n\t\t{\n\t\t\tmemory_free(\n\t\t\t ( *huffman_tree )->symbols );\n\t\t}\n\t\tmemory_free(\n\t\t *huffman_tree );\n\n\t\t*huffman_tree = NULL;\n\t}\n\treturn( -1 );\n}", "Selected Statement": "static char *function = \"libfwnt_huffman_tree_initialize\";", "Function Input": {"error": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7ffffffedaac", "value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x8000\n", "message": "Cannot access memory at address 0x8000"}}}, "huffman_tree": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf5a860", "value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"maximum_code_size": {"type_category": "unknown", "concrete_type": "uint8_t", "value": "96 '`'"}, "symbols": {"type_category": "pointer", "concrete_type": "NULL"}, "code_size_counts": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x10bed10", "value": {"type_category": "int", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x20\n", "message": "Cannot access memory at address 0x20"}}}}}}, "maximum_code_size": {"value": "1 '\\001'"}, "number_of_symbols": {"value": "16777216"}}, "Variable Values Before Statement": {"constant": "\"libfwnt_huffman_tree_initialize\""}, "Value After Statement Execution": "\"libfwnt_huffman_tree_initialize\"", "Block_Size": 5, "Project Information": "libyal"}
{"Programming Language": "C", "Source Code": "void test_flush(unsigned char *compr, size_t *comprLen)\n{\n    z_stream c_stream; \n    int err;\n    unsigned int len = dataLen;\n\n    c_stream.zalloc = zalloc;\n    c_stream.zfree = zfree;\n    c_stream.opaque = NULL;\n\n    err = deflateInit(&c_stream, Z_DEFAULT_COMPRESSION);\n    CHECK_ERR(err, \"deflateInit\");\n\n    c_stream.next_in = (Bytef *)data;\n    c_stream.next_out = compr;\n    c_stream.avail_in = 3;\n    c_stream.avail_out = (unsigned int)*comprLen;\n    err = deflate(&c_stream, Z_FULL_FLUSH);\n    CHECK_ERR(err, \"deflate flush 1\");\n\n    compr[3]++; \n    c_stream.avail_in = len - 3;\n\n    err = deflate(&c_stream, Z_FINISH);\n\n    if (err != Z_STREAM_END)\n    {\n        CHECK_ERR(err, \"deflate flush 2\");\n    }\n\n    err = deflateEnd(&c_stream);\n    CHECK_ERR(err, \"deflateEnd\");\n\n    *comprLen = (size_t)c_stream.total_out;\n}", "Selected Statement": "c_stream.zalloc = zalloc;", "Function Input": {"compr": {"value": "0xf77f80 \"\\a\""}, "comprLen": {"value": {"type_category": "unknown", "concrete_type": "size_t", "value": "140737488346800"}}}, "Variable Values Before Statement": {"zalloc": "mz_alloc_func"}, "Value After Statement Execution": "mz_alloc_func", "Block_Size": 5, "Project Information": "miniz"}
{"Programming Language": "C", "Source Code": "int policydb_init(policydb_t * p)\n{\n\tint i, rc;\n\n\tmemset(p, 0, sizeof(policydb_t));\n\n\tfor (i = 0; i < SYM_NUM; i++) {\n\t\tp->sym_val_to_name[i] = NULL;\n\t\trc = symtab_init(&p->symtab[i], symtab_sizes[i]);\n\t\tif (rc)\n\t\t\tgoto err;\n\t}\n\n\t\n\tfor (i = 0; i < SYM_NUM; i++) {\n\t\tif (symtab_init(&p->scope[i], symtab_sizes[i])) {\n\t\t\tgoto err;\n\t\t}\n\t}\n\tif ((p->global = avrule_block_create()) == NULL ||\n\t    (p->global->branch_list = avrule_decl_create(1)) == NULL) {\n\t\tgoto err;\n\t}\n\tp->decl_val_to_struct = NULL;\n\n\trc = avtab_init(&p->te_avtab);\n\tif (rc)\n\t\tgoto err;\n\n\trc = roles_init(p);\n\tif (rc)\n\t\tgoto err;\n\n\trc = cond_policydb_init(p);\n\tif (rc)\n\t\tgoto err;\n\n\tp->filename_trans = hashtab_create(filenametr_hash, filenametr_cmp, (1 << 10));\n\tif (!p->filename_trans) {\n\t\trc = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tp->range_tr = hashtab_create(rangetr_hash, rangetr_cmp, 256);\n\tif (!p->range_tr) {\n\t\trc = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tebitmap_init(&p->policycaps);\n\tebitmap_init(&p->permissive_map);\n\n\treturn 0;\nerr:\n\thashtab_destroy(p->filename_trans);\n\thashtab_destroy(p->range_tr);\n\tfor (i = 0; i < SYM_NUM; i++) {\n\t\thashtab_destroy(p->symtab[i].table);\n\t\thashtab_destroy(p->scope[i].table);\n\t}\n\tavrule_block_list_destroy(p->global);\n\treturn rc;\n}", "Selected Statement": "for (i = 0; i < SYM_NUM; i++) {", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 5, "Project Information": "selinux"}
{"Programming Language": "C", "Source Code": "int\ndwarf_get_debugfission_for_key(Dwarf_Debug dbg,\n    Dwarf_Sig8  *key  ,\n    const char  *key_type  ,\n    Dwarf_Debug_Fission_Per_CU *  percu_out,\n    Dwarf_Error *error)\n{\n    int sres = 0;\n    Dwarf_Unsigned percu_index = 0;\n    Dwarf_Xu_Index_Header xuhdr = 0;\n\n    CHECK_DBG(dbg,error,\"dwarf_get_debugfission_for_key()\");\n    if (!key || !key_type || !percu_out) {\n        _dwarf_error_string(0,error,DW_DLE_XU_TYPE_ARG_ERROR,\n            \"DW_DLE_XU_TYPE_ARG_ERROR: dw_key, dw_keytype, or \"\n            \"Dwarf_Debug_Fission_Per_CU pointer* to return \"\n            \"is not valid\");\n        return DW_DLV_ERROR;\n    }\n\n    sres = _dwarf_load_debug_info(dbg,error);\n    if (sres == DW_DLV_ERROR) {\n        return sres;\n    }\n    sres = _dwarf_load_debug_types(dbg,error);\n    if (sres == DW_DLV_ERROR) {\n        return sres;\n    }\n    \n    sres = _dwarf_get_xuhdr(dbg,key_type, &xuhdr,error);\n    if (sres != DW_DLV_OK) {\n        return sres;\n    }\n    \n    sres = _dwarf_search_fission_for_key(dbg,\n        xuhdr,key,&percu_index,error);\n    if (sres != DW_DLV_OK) {\n        return sres;\n    }\n    sres = transform_xu_to_dfp(xuhdr,percu_index,key,\n        key_type,percu_out,error);\n    return sres;\n}", "Selected Statement": "int sres = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 5, "Project Information": "libdwarf"}
{"Programming Language": "C", "Source Code": "void\ncsv_create(struct csv *csv)\n{\n\tmemset(csv, 0, sizeof(struct csv));\n\tcsv->delimiter= ',';\n\tcsv->quote_char = '\\\"';\n\tcsv->realloc = realloc;\n\tcsv->emit_field = csv_emit_field_empty;\n\tcsv->emit_row = csv_emit_row_empty;\n}", "Selected Statement": "csv->emit_field = csv_emit_field_empty;", "Function Input": {}, "Variable Values Before Statement": {"csv_emit_field_empty": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 5, "Project Information": "tarantool"}
{"Programming Language": "C", "Source Code": "int libuna_utf8_string_size_from_utf8_stream(\n     const uint8_t *utf8_stream,\n     size_t utf8_stream_size,\n     size_t *utf8_string_size,\n     libcerror_error_t **error )\n{\n\tstatic char *function                        = \"libuna_utf8_string_size_from_utf8_stream\";\n\tsize_t utf8_stream_index                     = 0;\n\tlibuna_unicode_character_t unicode_character = 0;\n\n\tif( utf8_stream == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid UTF-8 stream.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( utf8_stream_size > (size_t) SSIZE_MAX )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM,\n\t\t \"%s: invalid UTF-8 stream size value exceeds maximum.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( utf8_string_size == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid UTF-8 string size.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\t*utf8_string_size = 0;\n\n\tif( utf8_stream_size == 0 )\n\t{\n\t\treturn( 1 );\n\t}\n\t\n\tif( utf8_stream_size >= 3 )\n\t{\n\t\tif( ( utf8_stream[ 0 ] == 0x0ef )\n\t\t && ( utf8_stream[ 1 ] == 0x0bb )\n\t\t && ( utf8_stream[ 2 ] == 0x0bf ) )\n\t\t{\n\t\t\tutf8_stream_index += 3;\n\t\t}\n\t}\n\twhile( utf8_stream_index < utf8_stream_size )\n\t{\n\t\t\n\t\tif( libuna_unicode_character_copy_from_utf8(\n\t\t     &unicode_character,\n\t\t     utf8_stream,\n\t\t     utf8_stream_size,\n\t\t     &utf8_stream_index,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_CONVERSION,\n\t\t\t LIBCERROR_CONVERSION_ERROR_INPUT_FAILED,\n\t\t\t \"%s: unable to copy Unicode character from UTF-8 stream.\",\n\t\t\t function );\n\n\t\t\treturn( -1 );\n\t\t}\n\t\t\n\t\tif( libuna_unicode_character_size_to_utf8(\n\t\t     unicode_character,\n\t\t     utf8_string_size,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_CONVERSION,\n\t\t\t LIBCERROR_CONVERSION_ERROR_INPUT_FAILED,\n\t\t\t \"%s: unable to unable to determine size of Unicode character in UTF-8.\",\n\t\t\t function );\n\n\t\t\treturn( -1 );\n\t\t}\n\t\tif( unicode_character == 0 )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif( unicode_character != 0 )\n\t{\n\t\t*utf8_string_size += 1;\n\t}\n\treturn( 1 );\n}", "Selected Statement": "static char *function                        = \"libuna_utf8_string_size_from_utf8_stream\";", "Function Input": {"error": {"value": null}, "utf8_string_size": {"value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x200\n", "message": "Cannot access memory at address 0x200"}}}, "Variable Values Before Statement": {"constant": "\"libuna_utf8_string_size_from_utf8_stream\""}, "Value After Statement Execution": "\"libuna_utf8_string_size_from_utf8_stream\"", "Block_Size": 5, "Project Information": "libyal"}
{"Programming Language": "C", "Source Code": "int\ndwarf_formaddr(Dwarf_Attribute attr,\n    Dwarf_Addr * return_addr, Dwarf_Error * error)\n{\n    Dwarf_Debug dbg = 0;\n    Dwarf_Addr ret_addr = 0;\n    Dwarf_CU_Context cu_context = 0;\n    Dwarf_Half attrform = 0;\n    int res = 0;\n\n    res  = get_attr_dbg(&dbg,&cu_context,attr,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    attrform = attr->ar_attribute_form;\n    if (dwarf_addr_form_is_indexed(attrform)) {\n        res = _dwarf_look_in_local_and_tied(\n            attrform,\n            cu_context,\n            attr->ar_debug_ptr,\n            return_addr,\n            error);\n        return res;\n    }\n    if (attrform == DW_FORM_addr ||\n        (cu_context->cc_producer == CC_PROD_METROWERKS &&\n        attrform == DW_FORM_ref_addr)\n            \n        ) {\n        Dwarf_Small *section_end =\n            _dwarf_calculate_info_section_end_ptr(cu_context);\n\n        READ_UNALIGNED_CK(dbg, ret_addr, Dwarf_Addr,\n            attr->ar_debug_ptr,\n            cu_context->cc_address_size,\n            error,section_end);\n        *return_addr = ret_addr;\n        return DW_DLV_OK;\n    }\n    generate_form_error(dbg,error,attrform,\n        DW_DLE_ATTR_FORM_BAD,\n        \"DW_DLE_ATTR_FORM_BAD\",\n        \"dwarf_formaddr\");\n    return DW_DLV_ERROR;\n}", "Selected Statement": "Dwarf_Half attrform = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 5, "Project Information": "libdwarf"}
{"Programming Language": "C", "Source Code": "static int look_for_our_target(Dwarf_Debug dbg, struct target_data_s *td,\n                               Dwarf_Error *errp) {\n  Dwarf_Unsigned cu_header_length = 0;\n  Dwarf_Unsigned abbrev_offset = 0;\n  Dwarf_Half address_size = 0;\n  Dwarf_Half version_stamp = 0;\n  Dwarf_Half offset_size = 0;\n  Dwarf_Half extension_size = 0;\n  Dwarf_Unsigned typeoffset = 0;\n  Dwarf_Half header_cu_type = unittype;\n  Dwarf_Bool is_info = g_is_info;\n  int cu_number = 0;\n\n  for (;; ++cu_number) {\n    Dwarf_Die no_die = 0;\n    Dwarf_Die cu_die = 0;\n    int res = DW_DLV_ERROR;\n    Dwarf_Sig8 signature;\n\n    memset(&signature, 0, sizeof(signature));\n    res = dwarf_next_cu_header_d(dbg, is_info, &cu_header_length,\n                                 &version_stamp, &abbrev_offset, &address_size,\n                                 &offset_size, &extension_size, &signature,\n                                 &typeoffset, 0, &header_cu_type, errp);\n    if (res == DW_DLV_ERROR) {\n      if (errp) {\n        char *em = dwarf_errmsg(*errp);\n      }\n      return DW_DLV_NO_ENTRY;\n    }\n    if (res == DW_DLV_NO_ENTRY) {\n      return DW_DLV_NO_ENTRY;\n    }\n    cu_version_stamp = version_stamp;\n    cu_offset_size = offset_size;\n    res = dwarf_siblingof_b(dbg, no_die, is_info, &cu_die, errp);\n    if (res == DW_DLV_ERROR) {\n      if (errp) {\n        char *em = dwarf_errmsg(*errp);\n      }\n      return res;\n    }\n    if (res == DW_DLV_NO_ENTRY) {\n      return res;\n    }\n\n    td->td_cu_die = cu_die;\n    res = get_die_and_siblings(dbg, cu_die, is_info, 0, cu_number, td, errp);\n    if (res == FOUND_SUBPROG) {\n      read_line_data(dbg, td, errp);\n      if (td->td_reportallfound) {\n        return res;\n      }\n      return res;\n    } else if (res == IN_THIS_CU) {\n      if (errp) {\n          char *em = dwarf_errmsg(*errp);\n      }\n      return res;\n    } else if (res == DW_DLV_ERROR) {\n      if (errp) {\n        char *em = dwarf_errmsg(*errp);\n      }\n      return DW_DLV_ERROR;\n    }\n    return DW_DLV_NO_ENTRY;\n  }\n}", "Selected Statement": "Dwarf_Half extension_size = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 6, "Project Information": "libdwarf"}
{"Programming Language": "C", "Source Code": "void ssh_packet_register_socket_callback(ssh_session session, ssh_socket s)\n{\n    struct ssh_socket_callbacks_struct *callbacks = &session->socket_callbacks;\n\n    callbacks->data = ssh_packet_socket_callback;\n    callbacks->connected = NULL;\n    callbacks->controlflow = ssh_packet_socket_controlflow_callback;\n    callbacks->userdata = session;\n    ssh_socket_set_callbacks(s, callbacks);\n}", "Selected Statement": "callbacks->userdata = session;", "Function Input": {"session": {"value": "0x222ed1fd0aa1f200"}}, "Variable Values Before Statement": {"session": "ssh_session"}, "Value After Statement Execution": "ssh_session", "Block_Size": 6, "Project Information": "libssh"}
{"Programming Language": "C", "Source Code": "void\ncsv_create(struct csv *csv)\n{\n\tmemset(csv, 0, sizeof(struct csv));\n\tcsv->delimiter= ',';\n\tcsv->quote_char = '\\\"';\n\tcsv->realloc = realloc;\n\tcsv->emit_field = csv_emit_field_empty;\n\tcsv->emit_row = csv_emit_row_empty;\n}", "Selected Statement": "csv->emit_row = csv_emit_row_empty;", "Function Input": {}, "Variable Values Before Statement": {"csv_emit_row_empty": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 6, "Project Information": "tarantool"}
{"Programming Language": "C", "Source Code": "int libfshfs_extents_record_read_data(\n     libfshfs_fork_descriptor_t *fork_descriptor,\n     uint16_t extents_start_block_number,\n     const uint8_t *data,\n     size_t data_size,\n     libcerror_error_t **error )\n{\n\tstatic char *function                 = \"libfshfs_extents_record_read_data\";\n\tsize_t data_offset                    = 0;\n\tuint32_t physical_extent_block_number = 0;\n\tuint16_t extent_block_number          = 0;\n\tuint16_t extent_number_of_blocks      = 0;\n\tint extent_index                      = 0;\n\n\tif( fork_descriptor == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid fork descriptor.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( data == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_MISSING,\n\t\t \"%s: invalid data.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( data_size > (size_t) SSIZE_MAX )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: invalid data size value out of bounds.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n#if defined( HAVE_DEBUG_OUTPUT )\n\tif( libcnotify_verbose != 0 )\n\t{\n\t\tlibcnotify_printf(\n\t\t \"%s: extents records data:\\n\",\n\t\t function );\n\t\tlibcnotify_print_data(\n\t\t data,\n\t\t data_size,\n\t\t LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA );\n\t}\n#endif\n\tif( data_size != 12 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_UNSUPPORTED_VALUE,\n\t\t \"%s: unsupported extents record data size: %\" PRIzd \"\\n\",\n\t\t function,\n\t\t data_size );\n\n\t\treturn( -1 );\n\t}\n\twhile( data_offset < 12 )\n\t{\n\t\tbyte_stream_copy_to_uint16_big_endian(\n\t\t &( data[ data_offset ] ),\n\t\t extent_block_number );\n\n\t\tdata_offset += 2;\n\n\t\tbyte_stream_copy_to_uint16_big_endian(\n\t\t &( data[ data_offset ] ),\n\t\t extent_number_of_blocks );\n\n\t\tdata_offset += 2;\n\n\t\tphysical_extent_block_number = extent_block_number;\n\n\t\tif( extent_number_of_blocks > 0 )\n\t\t{\n\t\t\tphysical_extent_block_number += extents_start_block_number;\n\t\t}\n#if defined( HAVE_DEBUG_OUTPUT )\n\t\tif( libcnotify_verbose != 0 )\n\t\t{\n\t\t\tlibcnotify_printf(\n\t\t\t \"%s: extent: %d block number\\t\\t: %\" PRIu32 \" (%\" PRIu16 \")\\n\",\n\t\t\t function,\n\t\t\t extent_index,\n\t\t\t physical_extent_block_number,\n\t\t\t extent_block_number );\n\n\t\t\tlibcnotify_printf(\n\t\t\t \"%s: extent: %d number of blocks\\t\\t: %\" PRIu16 \"\\n\",\n\t\t\t function,\n\t\t\t extent_index,\n\t\t\t extent_number_of_blocks );\n\t\t}\n#endif \n\n\t\tfork_descriptor->extents[ extent_index ][ 0 ] = physical_extent_block_number;\n\t\tfork_descriptor->extents[ extent_index ][ 1 ] = extent_number_of_blocks;\n\n\t\tfork_descriptor->number_of_blocks_in_extents += extent_number_of_blocks;\n\n\t\textent_index++;\n\t}\n#if defined( HAVE_DEBUG_OUTPUT )\n\tif( libcnotify_verbose != 0 )\n\t{\n\t\tlibcnotify_printf(\n\t\t \"\\n\" );\n\t}\n#endif\n\treturn( 1 );\n}", "Selected Statement": "static char *function                 = \"libfshfs_extents_record_read_data\";", "Function Input": {"data": {"value": "0x600 <error: Cannot access memory at address 0x600>"}, "data_size": {"value": "4809124"}, "error": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd8e0", "value": {"type_category": "unknown", "concrete_type": "libcerror_error_t", "value": "140737488346128"}}}, "extents_start_block_number": {"value": "0"}, "fork_descriptor": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"size": {"type_category": "unknown", "concrete_type": "uint64_t", "value": "0"}, "number_of_blocks": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, "extents": {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}]}, "number_of_blocks_in_extents": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}}}, "Variable Values Before Statement": {"constant": "\"libfshfs_extents_record_read_data\""}, "Value After Statement Execution": "\"libfshfs_extents_record_read_data\"", "Block_Size": 6, "Project Information": "libyal"}
{"Programming Language": "C", "Source Code": "int\ndwarf_init_b(int fd,\n    unsigned        group_number,\n    Dwarf_Handler   errhand,\n    Dwarf_Ptr       errarg,\n    Dwarf_Debug *   ret_dbg,\n    Dwarf_Error *   error)\n{\n    unsigned ftype = 0;\n    unsigned endian = 0;\n    unsigned offsetsize = 0;\n    unsigned universalnumber = 0;\n    Dwarf_Unsigned   filesize = 0;\n    int res = 0;\n    int errcode = 0;\n\n    if (!ret_dbg) {\n        DWARF_DBG_ERROR(NULL,DW_DLE_DWARF_INIT_DBG_NULL,DW_DLV_ERROR);\n    }\n    \n    *ret_dbg = 0;\n    res = dwarf_object_detector_fd(fd, &ftype,\n        &endian,&offsetsize,&filesize,&errcode);\n    if (res == DW_DLV_NO_ENTRY) {\n        return res;\n    }\n    if (res == DW_DLV_ERROR) {\n        \n        DWARF_DBG_ERROR(NULL, DW_DLE_FILE_WRONG_TYPE, DW_DLV_ERROR);\n    }\n    switch(ftype) {\n    case DW_FTYPE_ELF: {\n        int res2 = 0;\n\n        res2 = _dwarf_elf_nlsetup(fd,\"\",\n            ftype,endian,offsetsize,filesize,\n            group_number,errhand,errarg,ret_dbg,error);\n        if (res2 != DW_DLV_OK) {\n            return res2;\n        }\n        set_global_paths_init(*ret_dbg,error);\n        return res2;\n        }\n    case DW_FTYPE_APPLEUNIVERSAL:\n    case DW_FTYPE_MACH_O: {\n        int resm = 0;\n\n        resm = _dwarf_macho_setup(fd,\"\",\n            universalnumber,\n            ftype,endian,offsetsize,filesize,\n            group_number,errhand,errarg,ret_dbg,error);\n        if (resm != DW_DLV_OK) {\n            return resm;\n        }\n        set_global_paths_init(*ret_dbg,error);\n        return resm;\n        }\n\n    case DW_FTYPE_PE: {\n        int resp = 0;\n\n        resp = _dwarf_pe_setup(fd,\n            \"\",\n            ftype,endian,offsetsize,filesize,\n            group_number,errhand,errarg,ret_dbg,error);\n        if (resp != DW_DLV_OK) {\n            return resp;\n        }\n        set_global_paths_init(*ret_dbg,error);\n        return resp;\n        }\n    default: break;\n    }\n    DWARF_DBG_ERROR(NULL, DW_DLE_FILE_WRONG_TYPE, DW_DLV_ERROR);\n    \n}", "Selected Statement": "unsigned ftype = 0;", "Function Input": {"error": {"value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xfe02dd63e9f26600\n", "message": "Cannot access memory at address 0xfe02dd63e9f26600"}}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 6, "Project Information": "libdwarf"}
{"Programming Language": "C", "Source Code": "void test_deflate(unsigned char *compr, size_t comprLen)\n{\n    z_stream c_stream; \n    int err;\n    unsigned long len = dataLen;\n\n    c_stream.zalloc = zalloc;\n    c_stream.zfree = zfree;\n    c_stream.opaque = NULL;\n\n    err = deflateInit(&c_stream, Z_DEFAULT_COMPRESSION);\n    CHECK_ERR(err, \"deflateInit\");\n\n    c_stream.next_in = (Bytef *)data;\n    c_stream.next_out = compr;\n\n    while (c_stream.total_in != len && c_stream.total_out < comprLen)\n    {\n        c_stream.avail_in = c_stream.avail_out = 1; \n        err = deflate(&c_stream, Z_NO_FLUSH);\n        CHECK_ERR(err, \"deflate small 1\");\n    }\n\n    \n    for (;;)\n    {\n        c_stream.avail_out = 1;\n        err = deflate(&c_stream, Z_FINISH);\n        if (err == Z_STREAM_END)\n            break;\n        CHECK_ERR(err, \"deflate small 2\");\n    }\n\n    err = deflateEnd(&c_stream);\n    CHECK_ERR(err, \"deflateEnd\");\n}", "Selected Statement": "c_stream.zfree = zfree;", "Function Input": {"compr": {"value": "0xf77f80 \"=\""}, "comprLen": {"value": "140737488346736"}}, "Variable Values Before Statement": {"zfree": "mz_free_func"}, "Value After Statement Execution": "mz_free_func", "Block_Size": 6, "Project Information": "miniz"}
{"Programming Language": "C", "Source Code": "int libcdata_array_initialize(\n     libcdata_array_t **array,\n     int number_of_entries,\n     libcerror_error_t **error )\n{\n\tlibcdata_internal_array_t *internal_array = NULL;\n\tstatic char *function                     = \"libcdata_array_initialize\";\n\tsize_t entries_size                       = 0;\n\tint number_of_allocated_entries           = 0;\n\n\tif( array == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid array.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *array != NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\n\t\t \"%s: invalid array value already set.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( number_of_entries < 0 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_LESS_THAN_ZERO,\n\t\t \"%s: invalid number of entries value less than zero.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tinternal_array = memory_allocate_structure(\n\t                  libcdata_internal_array_t );\n\n\tif( internal_array == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create array.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     internal_array,\n\t     0,\n\t     sizeof( libcdata_internal_array_t ) ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear array.\",\n\t\t function );\n\n\t\tmemory_free(\n\t\t internal_array );\n\n\t\treturn( -1 );\n\t}\n\t\n\tif( number_of_entries >= (int) ( INT_MAX - 16 ) )\n\t{\n\t\tnumber_of_allocated_entries = INT_MAX;\n\t}\n\telse\n\t{\n\t\tnumber_of_allocated_entries = ( number_of_entries & ~( 15 ) ) + 16;\n\t}\n#if SIZEOF_INT <= SIZEOF_SIZE_T\n\tif( (size_t) number_of_allocated_entries > (size_t) ( SSIZE_MAX / sizeof( intptr_t * ) ) )\n#else\n\tif( number_of_allocated_entries > (int) ( SSIZE_MAX / sizeof( intptr_t * ) ) )\n#endif\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_EXCEEDS_MAXIMUM,\n\t\t \"%s: invalid number of allocated entries value exceeds maximum.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tentries_size = sizeof( intptr_t * ) * number_of_allocated_entries;\n\n\tif( entries_size > (size_t) LIBCDATA_ARRAY_ENTRIES_MEMORY_LIMIT )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_EXCEEDS_MAXIMUM,\n\t\t \"%s: invalid entries size value exceeds maximum.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tinternal_array->entries = (intptr_t **) memory_allocate(\n\t                                         entries_size );\n\n\tif( internal_array->entries == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create array entries.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     internal_array->entries,\n\t     0,\n\t     entries_size ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear array entries.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tinternal_array->number_of_allocated_entries = number_of_allocated_entries;\n\tinternal_array->number_of_entries           = number_of_entries;\n\n#if defined( HAVE_MULTI_THREAD_SUPPORT ) && !defined( HAVE_LOCAL_LIBCDATA )\n\tif( libcthreads_read_write_lock_initialize(\n\t     &( internal_array->read_write_lock ),\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to initialize read/write lock.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n#endif\n\t*array = (libcdata_array_t *) internal_array;\n\n\treturn( 1 );\n\non_error:\n\tif( internal_array != NULL )\n\t{\n\t\tif( internal_array->entries != NULL )\n\t\t{\n\t\t\tmemory_free(\n\t\t\t internal_array->entries );\n\t\t}\n\t\tmemory_free(\n\t\t internal_array );\n\t}\n\treturn( -1 );\n}", "Selected Statement": "size_t entries_size                       = 0;", "Function Input": {"array": {"value": {"type_category": "pointer", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x200\n", "message": "Cannot access memory at address 0x200"}}, "error": {"value": {"type_category": "pointer", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x7366780800000200\n", "message": "Cannot access memory at address 0x7366780800000200"}}, "number_of_entries": {"value": "116"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 6, "Project Information": "libyal"}
{"Programming Language": "C", "Source Code": "isc_result_t\nisc_parse_uint32(uint32_t *uip, const char *string, int base) {\n\tunsigned long n;\n\tuint32_t r;\n\tchar *e;\n\tif (!isalnum((unsigned char)(string[0]))) {\n\t\treturn (ISC_R_BADNUMBER);\n\t}\n\terrno = 0;\n\tn = strtoul(string, &e, base);\n\tif (*e != '\\0') {\n\t\treturn (ISC_R_BADNUMBER);\n\t}\n\t\n\tr = (uint32_t)n;\n\tif ((n == ULONG_MAX && errno == ERANGE) || (n != (unsigned long)r)) {\n\t\treturn (ISC_R_RANGE);\n\t}\n\t*uip = r;\n\treturn (ISC_R_SUCCESS);\n}", "Selected Statement": "errno = 0;", "Function Input": {"base": {"value": "-1"}, "string": {"value": "0x7ffffffed9b0 \"\\260\\334\\376\\377\\377\\177\""}, "uip": {"value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xffffffff00000000\n", "message": "Cannot access memory at address 0xffffffff00000000"}}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 6, "Project Information": "bind9"}
{"Programming Language": "C", "Source Code": "int libfmapi_checksum_calculate_weak_crc32(\n     uint32_t *checksum,\n     const uint8_t *buffer,\n     size_t size,\n     uint32_t initial_value,\n     libcerror_error_t **error )\n{\n\tstatic char *function  = \"libfmapi_checksum_calculate_weak_crc32\";\n\tsize_t buffer_offset   = 0;\n\tuint32_t safe_checksum = 0;\n\tuint32_t table_index   = 0;\n\n\tif( checksum == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid checksum.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( buffer == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid buffer.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( size > (size_t) SSIZE_MAX )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM,\n\t\t \"%s: invalid size value exceeds maximum.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n        if( libfmapi_checksum_crc32_table_computed == 0 )\n\t{\n\t\tlibfmapi_checksum_initialize_crc32_table(\n\t\t 0xedb88320UL );\n\t}\n\tsafe_checksum = initial_value;\n\n        for( buffer_offset = 0;\n\t     buffer_offset < size;\n\t     buffer_offset++ )\n\t{\n\t\ttable_index = ( safe_checksum ^ buffer[ buffer_offset ] ) & 0x000000ffUL;\n\n\t\tsafe_checksum = libfmapi_checksum_crc32_table[ table_index ] ^ ( safe_checksum >> 8 );\n        }\n\t*checksum = safe_checksum;\n\n        return( 1 );\n}", "Selected Statement": "static char *function  = \"libfmapi_checksum_calculate_weak_crc32\";", "Function Input": {}, "Variable Values Before Statement": {"constant": "\"libfmapi_checksum_calculate_weak_crc32\""}, "Value After Statement Execution": "\"libfmapi_checksum_calculate_weak_crc32\"", "Block_Size": 6, "Project Information": "libyal"}
{"Programming Language": "C", "Source Code": "void test_flush(unsigned char *compr, size_t *comprLen)\n{\n    z_stream c_stream; \n    int err;\n    unsigned int len = dataLen;\n\n    c_stream.zalloc = zalloc;\n    c_stream.zfree = zfree;\n    c_stream.opaque = NULL;\n\n    err = deflateInit(&c_stream, Z_DEFAULT_COMPRESSION);\n    CHECK_ERR(err, \"deflateInit\");\n\n    c_stream.next_in = (Bytef *)data;\n    c_stream.next_out = compr;\n    c_stream.avail_in = 3;\n    c_stream.avail_out = (unsigned int)*comprLen;\n    err = deflate(&c_stream, Z_FULL_FLUSH);\n    CHECK_ERR(err, \"deflate flush 1\");\n\n    compr[3]++; \n    c_stream.avail_in = len - 3;\n\n    err = deflate(&c_stream, Z_FINISH);\n\n    if (err != Z_STREAM_END)\n    {\n        CHECK_ERR(err, \"deflate flush 2\");\n    }\n\n    err = deflateEnd(&c_stream);\n    CHECK_ERR(err, \"deflateEnd\");\n\n    *comprLen = (size_t)c_stream.total_out;\n}", "Selected Statement": "c_stream.zfree = zfree;", "Function Input": {"compr": {"value": "0xf77f80 \"\\a\""}, "comprLen": {"value": {"type_category": "unknown", "concrete_type": "size_t", "value": "140737488346800"}}}, "Variable Values Before Statement": {"zfree": "mz_free_func"}, "Value After Statement Execution": "mz_free_func", "Block_Size": 6, "Project Information": "miniz"}
{"Programming Language": "C", "Source Code": "GLOBAL(void)\njpeg_destroy(j_common_ptr cinfo)\n{\n  \n  \n  if (cinfo->mem != NULL)\n    (*cinfo->mem->self_destruct) (cinfo);\n  cinfo->mem = NULL;            \n  cinfo->global_state = 0;      \n}", "Selected Statement": "cinfo->global_state = 0;      /* mark it destroyed */", "Function Input": {"cinfo": {"value": "0x7ffff7de8807"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 6, "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Source Code": "int libfsfat_block_tree_node_initialize(\n     libfsfat_block_tree_node_t **block_tree_node,\n     off64_t offset,\n     size64_t size,\n     size64_t leaf_value_size,\n     libcerror_error_t **error )\n{\n\tstatic char *function  = \"libfsfat_block_tree_node_initialize\";\n\tsize64_t sub_node_size = 0;\n\n\tif( block_tree_node == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid block tree node.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *block_tree_node != NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\n\t\t \"%s: invalid block tree node value already set.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( offset < 0 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: invalid offset value out of bounds.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( ( size == 0 )\n\t || ( size > (size64_t) ( INT64_MAX - offset ) ) )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: invalid size value out of bounds.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( leaf_value_size == 0 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: invalid leaf value size value out of bounds.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\t*block_tree_node = memory_allocate_structure(\n\t                    libfsfat_block_tree_node_t );\n\n\tif( *block_tree_node == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create block tree node.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     *block_tree_node,\n\t     0,\n\t     sizeof( libfsfat_block_tree_node_t ) ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear block tree node.\",\n\t\t function );\n\n\t\tmemory_free(\n\t\t *block_tree_node );\n\n\t\t*block_tree_node = NULL;\n\n\t\treturn( -1 );\n\t}\n\tif( libcdata_array_initialize(\n\t     &( ( *block_tree_node )->sub_nodes_array ),\n\t     LIBFSFAT_BLOCK_TREE_NUMBER_OF_SUB_NODES,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create sub nodes array.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tsub_node_size = leaf_value_size;\n\n\twhile( ( size / sub_node_size ) > LIBFSFAT_BLOCK_TREE_NUMBER_OF_SUB_NODES )\n\t{\n\t\tsub_node_size *= LIBFSFAT_BLOCK_TREE_NUMBER_OF_SUB_NODES;\n\t}\n\t( *block_tree_node )->start_offset  = offset;\n\t( *block_tree_node )->end_offset    = offset + size;\n\t( *block_tree_node )->size          = size;\n\t( *block_tree_node )->sub_node_size = sub_node_size;\n\n\tif( sub_node_size == leaf_value_size )\n\t{\n\t\t( *block_tree_node )->is_leaf_node = 1;\n\t}\n\treturn( 1 );\n\non_error:\n\tif( *block_tree_node != NULL )\n\t{\n\t\tmemory_free(\n\t\t *block_tree_node );\n\n\t\t*block_tree_node = NULL;\n\t}\n\treturn( -1 );\n}", "Selected Statement": "static char *function  = \"libfsfat_block_tree_node_initialize\";", "Function Input": {"block_tree_node": {"value": {"type_category": "pointer", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x204\n", "message": "Cannot access memory at address 0x204"}}, "error": {"value": null}, "leaf_value_size": {"value": "140737488345584"}, "offset": {"value": "2199023255553"}, "size": {"value": "262144"}}, "Variable Values Before Statement": {"constant": "\"libfsfat_block_tree_node_initialize\""}, "Value After Statement Execution": "\"libfsfat_block_tree_node_initialize\"", "Block_Size": 6, "Project Information": "libyal"}
{"Programming Language": "C", "Source Code": "int libuna_utf8_string_size_from_utf8_stream(\n     const uint8_t *utf8_stream,\n     size_t utf8_stream_size,\n     size_t *utf8_string_size,\n     libcerror_error_t **error )\n{\n\tstatic char *function                        = \"libuna_utf8_string_size_from_utf8_stream\";\n\tsize_t utf8_stream_index                     = 0;\n\tlibuna_unicode_character_t unicode_character = 0;\n\n\tif( utf8_stream == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid UTF-8 stream.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( utf8_stream_size > (size_t) SSIZE_MAX )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM,\n\t\t \"%s: invalid UTF-8 stream size value exceeds maximum.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( utf8_string_size == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid UTF-8 string size.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\t*utf8_string_size = 0;\n\n\tif( utf8_stream_size == 0 )\n\t{\n\t\treturn( 1 );\n\t}\n\t\n\tif( utf8_stream_size >= 3 )\n\t{\n\t\tif( ( utf8_stream[ 0 ] == 0x0ef )\n\t\t && ( utf8_stream[ 1 ] == 0x0bb )\n\t\t && ( utf8_stream[ 2 ] == 0x0bf ) )\n\t\t{\n\t\t\tutf8_stream_index += 3;\n\t\t}\n\t}\n\twhile( utf8_stream_index < utf8_stream_size )\n\t{\n\t\t\n\t\tif( libuna_unicode_character_copy_from_utf8(\n\t\t     &unicode_character,\n\t\t     utf8_stream,\n\t\t     utf8_stream_size,\n\t\t     &utf8_stream_index,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_CONVERSION,\n\t\t\t LIBCERROR_CONVERSION_ERROR_INPUT_FAILED,\n\t\t\t \"%s: unable to copy Unicode character from UTF-8 stream.\",\n\t\t\t function );\n\n\t\t\treturn( -1 );\n\t\t}\n\t\t\n\t\tif( libuna_unicode_character_size_to_utf8(\n\t\t     unicode_character,\n\t\t     utf8_string_size,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_CONVERSION,\n\t\t\t LIBCERROR_CONVERSION_ERROR_INPUT_FAILED,\n\t\t\t \"%s: unable to unable to determine size of Unicode character in UTF-8.\",\n\t\t\t function );\n\n\t\t\treturn( -1 );\n\t\t}\n\t\tif( unicode_character == 0 )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif( unicode_character != 0 )\n\t{\n\t\t*utf8_string_size += 1;\n\t}\n\treturn( 1 );\n}", "Selected Statement": "size_t utf8_stream_index                     = 0;", "Function Input": {"error": {"value": null}, "utf8_string_size": {"value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x200\n", "message": "Cannot access memory at address 0x200"}}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 6, "Project Information": "libyal"}
{"Programming Language": "C", "Source Code": "int libfsext_checksum_calculate_crc32(\n     uint32_t *checksum,\n     const uint8_t *buffer,\n     size_t size,\n     uint32_t initial_value,\n     libcerror_error_t **error )\n{\n\tstatic char *function  = \"libfsext_checksum_calculate_crc32\";\n\tsize_t buffer_offset   = 0;\n\tuint32_t safe_checksum = 0;\n\tuint32_t table_index   = 0;\n\n\tif( checksum == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid checksum.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( buffer == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid buffer.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( size > (size_t) SSIZE_MAX )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM,\n\t\t \"%s: invalid size value exceeds maximum.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n        if( libfsext_checksum_crc32_table_computed == 0 )\n\t{\n\t\tlibfsext_checksum_initialize_crc32_table(\n\t\t 0x82f63b78UL );\n\t}\n\tsafe_checksum = initial_value ^ (uint32_t) 0xffffffffUL;\n\n        for( buffer_offset = 0;\n\t     buffer_offset < size;\n\t     buffer_offset++ )\n\t{\n\t\ttable_index = ( safe_checksum ^ buffer[ buffer_offset ] ) & 0x000000ffUL;\n\n\t\tsafe_checksum = libfsext_checksum_crc32_table[ table_index ] ^ ( safe_checksum >> 8 );\n        }\n        *checksum = safe_checksum ^ 0xffffffffUL;\n\n\treturn( 1 );\n}", "Selected Statement": "static char *function  = \"libfsext_checksum_calculate_crc32\";", "Function Input": {}, "Variable Values Before Statement": {"constant": "\"libfsext_checksum_calculate_crc32\""}, "Value After Statement Execution": "\"libfsext_checksum_calculate_crc32\"", "Block_Size": 6, "Project Information": "libyal"}
{"Programming Language": "C", "Source Code": "void test_large_deflate(unsigned char *compr, size_t comprLen,\n                        unsigned char *uncompr, size_t uncomprLen)\n{\n    z_stream c_stream; \n    int err;\n\n    c_stream.zalloc = zalloc;\n    c_stream.zfree = zfree;\n    c_stream.opaque = NULL;\n\n    err = deflateInit(&c_stream, Z_BEST_COMPRESSION);\n    CHECK_ERR(err, \"deflateInit\");\n\n    c_stream.next_out = compr;\n    c_stream.avail_out = (unsigned int)comprLen;\n\n    \n    c_stream.next_in = uncompr;\n    c_stream.avail_in = (unsigned int)uncomprLen;\n    err = deflate(&c_stream, Z_NO_FLUSH);\n    CHECK_ERR(err, \"deflate large 1\");\n\n    if (c_stream.avail_in != 0)\n    {\n        fprintf(stderr, \"deflate not greedy\\n\");\n        exit(1);\n    }\n\n    \n    c_stream.next_in = compr;\n    diff = (unsigned int)(c_stream.next_out - compr);\n    c_stream.avail_in = diff;\n\n    deflate(&c_stream, Z_NO_FLUSH);\n    err = deflate(&c_stream, Z_FINISH);\n\n    if (err != Z_STREAM_END)\n    {\n        fprintf(stderr, \"deflate large should report Z_STREAM_END\\n\");\n        exit(1);\n    }\n    err = deflateEnd(&c_stream);\n    CHECK_ERR(err, \"deflateEnd\");\n}", "Selected Statement": "c_stream.zfree = zfree;", "Function Input": {"compr": {"value": "0xf77f80 \"\\n\""}, "comprLen": {"value": "140737488346736"}, "uncompr": {"value": "0x1 <error: Cannot access memory at address 0x1>"}, "uncomprLen": {"value": "16325344"}}, "Variable Values Before Statement": {"zfree": "mz_free_func"}, "Value After Statement Execution": "mz_free_func", "Block_Size": 6, "Project Information": "miniz"}
{"Programming Language": "C", "Source Code": "ssh_bind ssh_bind_new(void) {\n    ssh_bind ptr;\n\n    ptr = calloc(1, sizeof(struct ssh_bind_struct));\n    if (ptr == NULL) {\n        return NULL;\n    }\n    ptr->bindfd = SSH_INVALID_SOCKET;\n    ptr->bindport = 22;\n    ptr->common.log_verbosity = 0;\n\n    return ptr;\n}", "Selected Statement": "ptr->bindfd = SSH_INVALID_SOCKET;", "Function Input": {}, "Variable Values Before Statement": {"SSH_INVALID_SOCKET": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 6, "Project Information": "libssh"}
{"Programming Language": "C", "Source Code": "int libagdb_compressed_blocks_stream_initialize(\n     libfdata_stream_t **compressed_blocks_stream,\n     libfdata_list_t *compressed_blocks_list,\n     libfcache_cache_t *compressed_blocks_cache,\n     libcerror_error_t **error )\n{\n\tlibagdb_compressed_blocks_stream_data_handle_t *data_handle = NULL;\n\tstatic char *function                                       = \"libagdb_compressed_blocks_stream_initialize\";\n\toff64_t segment_offset                                      = 0;\n\tsize64_t segment_size                                       = 0;\n\tint element_index                                           = 0;\n\tint number_of_elements                                      = 0;\n\tint segment_index                                           = 0;\n\n\tif( compressed_blocks_stream == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid compressed block stream.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( compressed_blocks_list == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid compressed blocks list.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( libagdb_compressed_blocks_stream_data_handle_initialize(\n\t     &data_handle,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create data handle.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( data_handle == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_MISSING,\n\t\t \"%s: missing data handle.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tdata_handle->compressed_blocks_list  = compressed_blocks_list;\n\tdata_handle->compressed_blocks_cache = compressed_blocks_cache;\n\n\tif( libfdata_stream_initialize(\n\t     compressed_blocks_stream,\n\t     (intptr_t *) data_handle,\n\t     (int (*)(intptr_t **, libcerror_error_t **)) &libagdb_compressed_blocks_stream_data_handle_free,\n\t     NULL,\n\t     NULL,\n\t     (ssize_t (*)(intptr_t *, intptr_t *, int, int, uint8_t *, size_t, uint32_t, uint8_t, libcerror_error_t **)) &libagdb_compressed_blocks_stream_data_handle_read_segment_data,\n\t     NULL,\n\t     (off64_t (*)(intptr_t *, intptr_t *, int, int, off64_t, libcerror_error_t **)) &libagdb_compressed_blocks_stream_data_handle_seek_segment_offset,\n\t     LIBFDATA_DATA_HANDLE_FLAG_MANAGED,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create stream.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( libfdata_list_get_number_of_elements(\n\t     compressed_blocks_list,\n\t     &number_of_elements,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_GET_FAILED,\n\t\t \"%s: unable to retrieve number of compressed blocks list elements.\",\n\t\t function );\n\n\t\tdata_handle = NULL;\n\n\t\tgoto on_error;\n\t}\n\tfor( element_index = 0;\n\t     element_index < number_of_elements;\n\t     element_index++ )\n\t{\n\t\tif( libfdata_list_get_mapped_size_by_index(\n\t\t     compressed_blocks_list,\n\t\t     element_index,\n\t\t     &segment_size,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_GET_FAILED,\n\t\t\t \"%s: unable to retrieve compressed blocks list element: %d mapped size.\",\n\t\t\t function,\n\t\t\t element_index );\n\n\t\t\tdata_handle = NULL;\n\n\t\t\tgoto on_error;\n\t\t}\n\t\tif( libfdata_stream_append_segment(\n\t\t     *compressed_blocks_stream,\n\t\t     &segment_index,\n\t\t     0,\n\t\t     segment_offset,\n\t\t     segment_size,\n\t\t     0,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_APPEND_FAILED,\n\t\t\t \"%s: unable to append compressed blocks stream segment: %d.\",\n\t\t\t function,\n\t\t\t element_index );\n\n\t\t\tdata_handle = NULL;\n\n\t\t\tgoto on_error;\n\t\t}\n\t\tsegment_offset += segment_size;\n\t}\n\treturn( 1 );\n\non_error:\n\tif( *compressed_blocks_stream != NULL )\n\t{\n\t\tlibfdata_stream_free(\n\t\t compressed_blocks_stream,\n\t\t NULL );\n\t}\n\tif( data_handle != NULL )\n\t{\n\t\tlibagdb_compressed_blocks_stream_data_handle_free(\n\t\t &data_handle,\n\t\t NULL );\n\t}\n\treturn( -1 );\n}", "Selected Statement": "static char *function                                       = \"libagdb_compressed_blocks_stream_initialize\";", "Function Input": {"compressed_blocks_cache": {"value": null}, "compressed_blocks_list": {"value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x801087060\n", "message": "Cannot access memory at address 0x801087060"}}, "compressed_blocks_stream": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x11e6400", "value": {"type_category": "unknown", "concrete_type": "libfdata_stream_t", "value": "17303920"}}}, "error": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x108a300", "value": {"type_category": "unknown", "concrete_type": "libcerror_error_t", "value": "34359738384"}}}}, "Variable Values Before Statement": {"constant": "\"libagdb_compressed_blocks_stream_initialize\""}, "Value After Statement Execution": "\"libagdb_compressed_blocks_stream_initialize\"", "Block_Size": 6, "Project Information": "libyal"}
{"Programming Language": "C", "Source Code": "void http_parser_create(struct http_parser *parser)\n{\n parser->hdr_value_start = NULL;\n parser->hdr_value_end = NULL;\n parser->http_major = -1;\n parser->http_minor = -1;\n parser->hdr_name = NULL;\n parser->hdr_name_idx = 0;\n}", "Selected Statement": "parser->hdr_name_idx = 0;", "Function Input": {"parser": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"hdr_value_start": {"type_category": "string", "concrete_type": "string", "value": "0x8c48348707e8b49 <error: Cannot access memory at address 0x8c48348707e8b49>"}, "hdr_value_end": {"type_category": "string", "concrete_type": "string", "value": "0x634c1e95e415b <error: Cannot access memory at address 0x634c1e95e415b>"}, "http_major": {"type_category": "int", "concrete_type": "int", "value": "1398161868"}, "http_minor": {"type_category": "int", "concrete_type": "int", "value": "-24557232"}, "hdr_name": {"type_category": "string", "concrete_type": "string", "value": "0x48000664c2058d48 <error: Cannot access memory at address 0x48000664c2058d48>"}, "hdr_name_idx": {"type_category": "int", "concrete_type": "int", "value": "-1958213751"}}}}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 6, "Project Information": "tarantool"}
{"Programming Language": "C", "Source Code": "int\ndwarf_object_detector_fd(int fd,\n    unsigned *ftype,\n    unsigned *endian,\n    unsigned *offsetsize,\n    Dwarf_Unsigned  *filesize,\n    int *errcode)\n{\n    Dwarf_Unsigned fileoffsetbase = 0;\n    int res = 0;\n\n    res = _dwarf_object_detector_fd_a(fd,\n        ftype,endian,offsetsize,\n        fileoffsetbase,filesize,\n        errcode);\n    return res;\n}", "Selected Statement": "Dwarf_Unsigned fileoffsetbase = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 6, "Project Information": "libdwarf"}
{"Programming Language": "C", "Source Code": "int\ndwarf_get_debugfission_for_key(Dwarf_Debug dbg,\n    Dwarf_Sig8  *key  ,\n    const char  *key_type  ,\n    Dwarf_Debug_Fission_Per_CU *  percu_out,\n    Dwarf_Error *error)\n{\n    int sres = 0;\n    Dwarf_Unsigned percu_index = 0;\n    Dwarf_Xu_Index_Header xuhdr = 0;\n\n    CHECK_DBG(dbg,error,\"dwarf_get_debugfission_for_key()\");\n    if (!key || !key_type || !percu_out) {\n        _dwarf_error_string(0,error,DW_DLE_XU_TYPE_ARG_ERROR,\n            \"DW_DLE_XU_TYPE_ARG_ERROR: dw_key, dw_keytype, or \"\n            \"Dwarf_Debug_Fission_Per_CU pointer* to return \"\n            \"is not valid\");\n        return DW_DLV_ERROR;\n    }\n\n    sres = _dwarf_load_debug_info(dbg,error);\n    if (sres == DW_DLV_ERROR) {\n        return sres;\n    }\n    sres = _dwarf_load_debug_types(dbg,error);\n    if (sres == DW_DLV_ERROR) {\n        return sres;\n    }\n    \n    sres = _dwarf_get_xuhdr(dbg,key_type, &xuhdr,error);\n    if (sres != DW_DLV_OK) {\n        return sres;\n    }\n    \n    sres = _dwarf_search_fission_for_key(dbg,\n        xuhdr,key,&percu_index,error);\n    if (sres != DW_DLV_OK) {\n        return sres;\n    }\n    sres = transform_xu_to_dfp(xuhdr,percu_index,key,\n        key_type,percu_out,error);\n    return sres;\n}", "Selected Statement": "Dwarf_Unsigned percu_index = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 6, "Project Information": "libdwarf"}
{"Programming Language": "C", "Source Code": "void IxmlPrintf(const char *DbgFileName,\n\tint DbgLineNo,\n\tconst char *FunctionName,\n\tconst char *FmtStr,\n\t...)\n{\n\tva_list ArgList;\n\n\tFILE *fp = stdout;\n\tfprintf(fp, \"(%s::%s), line %d\", DbgFileName, FunctionName, DbgLineNo);\n\tif (FmtStr) {\n\t\tfprintf(fp, \": \");\n\t\tva_start(ArgList, FmtStr);\n\t\tvfprintf(fp, FmtStr, ArgList);\n\t\tfflush(fp);\n\t\tva_end(ArgList);\n\t} else {\n\t\tfprintf(fp, \"\\n\");\n\t}\n}", "Selected Statement": "FILE *fp = stdout;", "Function Input": {"DbgFileName": {"value": "0xeca330 \"\\260\\243\\354\""}, "DbgLineNo": {"value": "118"}, "FmtStr": {"value": "0x7fffffffd8a0 \"@\\331\\377\""}, "FunctionName": {"value": "0x4c82df <Parser_skipWhiteSpaces+175> \"H\\203\\370\""}}, "Variable Values Before Statement": {"stdout": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 7, "Project Information": "pupnp"}
{"Programming Language": "C", "Source Code": "ssh_bind ssh_bind_new(void) {\n    ssh_bind ptr;\n\n    ptr = calloc(1, sizeof(struct ssh_bind_struct));\n    if (ptr == NULL) {\n        return NULL;\n    }\n    ptr->bindfd = SSH_INVALID_SOCKET;\n    ptr->bindport = 22;\n    ptr->common.log_verbosity = 0;\n\n    return ptr;\n}", "Selected Statement": "ptr->bindport = 22;", "Function Input": {}, "Variable Values Before Statement": {"constant": "22"}, "Value After Statement Execution": "22", "Block_Size": 7, "Project Information": "libssh"}
{"Programming Language": "C", "Source Code": "void\nclock_lowres_signal_init(void)\n{\n#ifndef NDEBUG\n\towner = pthread_self();\n#endif\n\tclock_lowres_monotonic_clock_value = clock_monotonic();\n\tstruct sigaction sa;\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_handler = clock_lowres_tick;\n\tsa.sa_flags = SA_RESTART;\n\tif (tt_sigaction(SIGALRM, &sa, NULL) == -1)\n\t\tpanic_syserror(\"cannot set low resolution clock timer signal\");\n\n\tstruct itimerval timer;\n\ttimer.it_interval = resolution;\n\ttimer.it_value = resolution;\n\tif (setitimer(ITIMER_REAL, &timer, NULL) == -1)\n\t\tpanic_syserror(\"cannot set low resolution clock timer\");\n}", "Selected Statement": "sa.sa_handler = clock_lowres_tick;", "Function Input": {}, "Variable Values Before Statement": {"clock_lowres_tick": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 7, "Project Information": "tarantool"}
{"Programming Language": "C", "Source Code": "int libfshfs_extents_record_read_data(\n     libfshfs_fork_descriptor_t *fork_descriptor,\n     uint16_t extents_start_block_number,\n     const uint8_t *data,\n     size_t data_size,\n     libcerror_error_t **error )\n{\n\tstatic char *function                 = \"libfshfs_extents_record_read_data\";\n\tsize_t data_offset                    = 0;\n\tuint32_t physical_extent_block_number = 0;\n\tuint16_t extent_block_number          = 0;\n\tuint16_t extent_number_of_blocks      = 0;\n\tint extent_index                      = 0;\n\n\tif( fork_descriptor == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid fork descriptor.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( data == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_MISSING,\n\t\t \"%s: invalid data.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( data_size > (size_t) SSIZE_MAX )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: invalid data size value out of bounds.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n#if defined( HAVE_DEBUG_OUTPUT )\n\tif( libcnotify_verbose != 0 )\n\t{\n\t\tlibcnotify_printf(\n\t\t \"%s: extents records data:\\n\",\n\t\t function );\n\t\tlibcnotify_print_data(\n\t\t data,\n\t\t data_size,\n\t\t LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA );\n\t}\n#endif\n\tif( data_size != 12 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_UNSUPPORTED_VALUE,\n\t\t \"%s: unsupported extents record data size: %\" PRIzd \"\\n\",\n\t\t function,\n\t\t data_size );\n\n\t\treturn( -1 );\n\t}\n\twhile( data_offset < 12 )\n\t{\n\t\tbyte_stream_copy_to_uint16_big_endian(\n\t\t &( data[ data_offset ] ),\n\t\t extent_block_number );\n\n\t\tdata_offset += 2;\n\n\t\tbyte_stream_copy_to_uint16_big_endian(\n\t\t &( data[ data_offset ] ),\n\t\t extent_number_of_blocks );\n\n\t\tdata_offset += 2;\n\n\t\tphysical_extent_block_number = extent_block_number;\n\n\t\tif( extent_number_of_blocks > 0 )\n\t\t{\n\t\t\tphysical_extent_block_number += extents_start_block_number;\n\t\t}\n#if defined( HAVE_DEBUG_OUTPUT )\n\t\tif( libcnotify_verbose != 0 )\n\t\t{\n\t\t\tlibcnotify_printf(\n\t\t\t \"%s: extent: %d block number\\t\\t: %\" PRIu32 \" (%\" PRIu16 \")\\n\",\n\t\t\t function,\n\t\t\t extent_index,\n\t\t\t physical_extent_block_number,\n\t\t\t extent_block_number );\n\n\t\t\tlibcnotify_printf(\n\t\t\t \"%s: extent: %d number of blocks\\t\\t: %\" PRIu16 \"\\n\",\n\t\t\t function,\n\t\t\t extent_index,\n\t\t\t extent_number_of_blocks );\n\t\t}\n#endif \n\n\t\tfork_descriptor->extents[ extent_index ][ 0 ] = physical_extent_block_number;\n\t\tfork_descriptor->extents[ extent_index ][ 1 ] = extent_number_of_blocks;\n\n\t\tfork_descriptor->number_of_blocks_in_extents += extent_number_of_blocks;\n\n\t\textent_index++;\n\t}\n#if defined( HAVE_DEBUG_OUTPUT )\n\tif( libcnotify_verbose != 0 )\n\t{\n\t\tlibcnotify_printf(\n\t\t \"\\n\" );\n\t}\n#endif\n\treturn( 1 );\n}", "Selected Statement": "size_t data_offset                    = 0;", "Function Input": {"data": {"value": "0x600 <error: Cannot access memory at address 0x600>"}, "data_size": {"value": "4809124"}, "error": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd8e0", "value": {"type_category": "unknown", "concrete_type": "libcerror_error_t", "value": "140737488346128"}}}, "extents_start_block_number": {"value": "0"}, "fork_descriptor": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"size": {"type_category": "unknown", "concrete_type": "uint64_t", "value": "0"}, "number_of_blocks": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, "extents": {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}]}, "number_of_blocks_in_extents": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 7, "Project Information": "libyal"}
{"Programming Language": "C", "Source Code": "int policydb_init(policydb_t * p)\n{\n\tint i, rc;\n\n\tmemset(p, 0, sizeof(policydb_t));\n\n\tfor (i = 0; i < SYM_NUM; i++) {\n\t\tp->sym_val_to_name[i] = NULL;\n\t\trc = symtab_init(&p->symtab[i], symtab_sizes[i]);\n\t\tif (rc)\n\t\t\tgoto err;\n\t}\n\n\t\n\tfor (i = 0; i < SYM_NUM; i++) {\n\t\tif (symtab_init(&p->scope[i], symtab_sizes[i])) {\n\t\t\tgoto err;\n\t\t}\n\t}\n\tif ((p->global = avrule_block_create()) == NULL ||\n\t    (p->global->branch_list = avrule_decl_create(1)) == NULL) {\n\t\tgoto err;\n\t}\n\tp->decl_val_to_struct = NULL;\n\n\trc = avtab_init(&p->te_avtab);\n\tif (rc)\n\t\tgoto err;\n\n\trc = roles_init(p);\n\tif (rc)\n\t\tgoto err;\n\n\trc = cond_policydb_init(p);\n\tif (rc)\n\t\tgoto err;\n\n\tp->filename_trans = hashtab_create(filenametr_hash, filenametr_cmp, (1 << 10));\n\tif (!p->filename_trans) {\n\t\trc = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tp->range_tr = hashtab_create(rangetr_hash, rangetr_cmp, 256);\n\tif (!p->range_tr) {\n\t\trc = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tebitmap_init(&p->policycaps);\n\tebitmap_init(&p->permissive_map);\n\n\treturn 0;\nerr:\n\thashtab_destroy(p->filename_trans);\n\thashtab_destroy(p->range_tr);\n\tfor (i = 0; i < SYM_NUM; i++) {\n\t\thashtab_destroy(p->symtab[i].table);\n\t\thashtab_destroy(p->scope[i].table);\n\t}\n\tavrule_block_list_destroy(p->global);\n\treturn rc;\n}", "Selected Statement": "rc = symtab_init(&p->symtab[i], symtab_sizes[i]);", "Function Input": {}, "Variable Values Before Statement": {}, "Value After Statement Execution": "int", "Function Name": "symtab_init", "Block_Size": 7, "Project Information": "selinux"}
{"Programming Language": "C", "Source Code": "void io_stream_init(struct iostream_private *stream)\n{\n\tif (stream->close == NULL)\n\t\tstream->close = io_stream_default_close;\n\tif (stream->destroy == NULL)\n\t\tstream->destroy = io_stream_default_destroy;\n\tstream->ioloop = current_ioloop;\n\n\tstream->refcount = 1;\n}", "Selected Statement": "stream->refcount = 1;", "Function Input": {}, "Variable Values Before Statement": {"constant": "1"}, "Value After Statement Execution": "1", "Block_Size": 7, "Project Information": "dovecot"}
{"Programming Language": "C", "Source Code": "static int look_for_our_target(Dwarf_Debug dbg, struct target_data_s *td,\n                               Dwarf_Error *errp) {\n  Dwarf_Unsigned cu_header_length = 0;\n  Dwarf_Unsigned abbrev_offset = 0;\n  Dwarf_Half address_size = 0;\n  Dwarf_Half version_stamp = 0;\n  Dwarf_Half offset_size = 0;\n  Dwarf_Half extension_size = 0;\n  Dwarf_Unsigned typeoffset = 0;\n  Dwarf_Half header_cu_type = unittype;\n  Dwarf_Bool is_info = g_is_info;\n  int cu_number = 0;\n\n  for (;; ++cu_number) {\n    Dwarf_Die no_die = 0;\n    Dwarf_Die cu_die = 0;\n    int res = DW_DLV_ERROR;\n    Dwarf_Sig8 signature;\n\n    memset(&signature, 0, sizeof(signature));\n    res = dwarf_next_cu_header_d(dbg, is_info, &cu_header_length,\n                                 &version_stamp, &abbrev_offset, &address_size,\n                                 &offset_size, &extension_size, &signature,\n                                 &typeoffset, 0, &header_cu_type, errp);\n    if (res == DW_DLV_ERROR) {\n      if (errp) {\n        char *em = dwarf_errmsg(*errp);\n      }\n      return DW_DLV_NO_ENTRY;\n    }\n    if (res == DW_DLV_NO_ENTRY) {\n      return DW_DLV_NO_ENTRY;\n    }\n    cu_version_stamp = version_stamp;\n    cu_offset_size = offset_size;\n    res = dwarf_siblingof_b(dbg, no_die, is_info, &cu_die, errp);\n    if (res == DW_DLV_ERROR) {\n      if (errp) {\n        char *em = dwarf_errmsg(*errp);\n      }\n      return res;\n    }\n    if (res == DW_DLV_NO_ENTRY) {\n      return res;\n    }\n\n    td->td_cu_die = cu_die;\n    res = get_die_and_siblings(dbg, cu_die, is_info, 0, cu_number, td, errp);\n    if (res == FOUND_SUBPROG) {\n      read_line_data(dbg, td, errp);\n      if (td->td_reportallfound) {\n        return res;\n      }\n      return res;\n    } else if (res == IN_THIS_CU) {\n      if (errp) {\n          char *em = dwarf_errmsg(*errp);\n      }\n      return res;\n    } else if (res == DW_DLV_ERROR) {\n      if (errp) {\n        char *em = dwarf_errmsg(*errp);\n      }\n      return DW_DLV_ERROR;\n    }\n    return DW_DLV_NO_ENTRY;\n  }\n}", "Selected Statement": "Dwarf_Unsigned typeoffset = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 7, "Project Information": "libdwarf"}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;\n}", "Selected Statement": "uri->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);", "Function Input": {}, "Variable Values Before Statement": {"uri_raw.scheme": "NULL", "uri_raw.scheme_len": "0"}, "Value After Statement Execution": "NULL", "Function Name": "XSTRNDUP", "Block_Size": 7, "Project Information": "tarantool"}
{"Programming Language": "C", "Source Code": "void\ninit_parse_tree(struct sudoers_parse_tree *parse_tree, char *lhost, char *shost,\n    struct sudoers_context *ctx, struct sudo_nss *nss)\n{\n    TAILQ_INIT(&parse_tree->userspecs);\n    TAILQ_INIT(&parse_tree->defaults);\n    parse_tree->aliases = NULL;\n    parse_tree->shost = shost;\n    parse_tree->lhost = lhost;\n    parse_tree->ctx = ctx;\n    parse_tree->nss = nss;\n}", "Selected Statement": "parse_tree->ctx = ctx;", "Function Input": {}, "Variable Values Before Statement": {"ctx": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 7, "Project Information": "sudoers"}
{"Programming Language": "C", "Source Code": "int libfvde_checksum_calculate_weak_crc32(\n     uint32_t *checksum,\n     const uint8_t *buffer,\n     size_t size,\n     uint32_t initial_value,\n     libcerror_error_t **error )\n{\n\tstatic char *function = \"libfvde_checkcum_calculate_weak_crc32\";\n\tsize_t buffer_offset  = 0;\n\tuint32_t table_index  = 0;\n\n\tif( checksum == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid checksum.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( buffer == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid buffer.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( size > (size_t) SSIZE_MAX )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM,\n\t\t \"%s: invalid size value exceeds maximum.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n        if( libfvde_checksum_crc32_table_computed == 0 )\n\t{\n\t\tlibfvde_checksum_initialize_crc32_table(\n\t\t 0x82f63b78UL );\n\t}\n\t*checksum = initial_value;\n\n        for( buffer_offset = 0;\n\t     buffer_offset < size;\n\t     buffer_offset++ )\n\t{\n\t\ttable_index = ( *checksum ^ buffer[ buffer_offset ] ) & 0x000000ffUL;\n\n\t\t*checksum = libfvde_checksum_crc32_table[ table_index ] ^ ( *checksum >> 8 );\n        }\n\treturn( 1 );\n}", "Selected Statement": "size_t buffer_offset  = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 7, "Project Information": "libyal"}
{"Programming Language": "C", "Source Code": "void dds_cdrstream_desc_init (struct dds_cdrstream_desc *desc, const struct dds_cdrstream_allocator * __restrict allocator,\n    uint32_t size, uint32_t align, uint32_t flagset, const uint32_t *ops, const dds_key_descriptor_t *keys, uint32_t nkeys)\n{\n  desc->size = size;\n  desc->align = align;\n\n  \n  desc->keys.nkeys = nkeys;\n  copy_desc_keys (&desc->keys.keys, allocator, keys, nkeys);\n  copy_desc_keys (&desc->keys.keys_definition_order, allocator, keys, nkeys);\n  if (desc->keys.nkeys > 0)\n    qsort (desc->keys.keys_definition_order, nkeys, sizeof (*desc->keys.keys_definition_order), key_cmp_idx);\n\n  desc->ops.nops = dds_stream_countops (ops, nkeys, keys);\n  desc->ops.ops = allocator->malloc (desc->ops.nops * sizeof (*desc->ops.ops));\n  memcpy (desc->ops.ops, ops, desc->ops.nops * sizeof (*desc->ops.ops));\n\n  \n  desc->flagset = flagset & ~DDS_CDR_CALCULATED_FLAGS;\n  desc->flagset |= dds_stream_key_flags (desc, NULL, NULL);\n}", "Selected Statement": "desc->keys.nkeys = nkeys;", "Function Input": {"size": {"value": "<optimized out>"}}, "Variable Values Before Statement": {"nkeys": "0"}, "Value After Statement Execution": "0", "Block_Size": 7, "Project Information": "cyclonedds"}
{"Programming Language": "C", "Source Code": "int libfmapi_checksum_calculate_weak_crc32(\n     uint32_t *checksum,\n     const uint8_t *buffer,\n     size_t size,\n     uint32_t initial_value,\n     libcerror_error_t **error )\n{\n\tstatic char *function  = \"libfmapi_checksum_calculate_weak_crc32\";\n\tsize_t buffer_offset   = 0;\n\tuint32_t safe_checksum = 0;\n\tuint32_t table_index   = 0;\n\n\tif( checksum == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid checksum.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( buffer == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid buffer.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( size > (size_t) SSIZE_MAX )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM,\n\t\t \"%s: invalid size value exceeds maximum.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n        if( libfmapi_checksum_crc32_table_computed == 0 )\n\t{\n\t\tlibfmapi_checksum_initialize_crc32_table(\n\t\t 0xedb88320UL );\n\t}\n\tsafe_checksum = initial_value;\n\n        for( buffer_offset = 0;\n\t     buffer_offset < size;\n\t     buffer_offset++ )\n\t{\n\t\ttable_index = ( safe_checksum ^ buffer[ buffer_offset ] ) & 0x000000ffUL;\n\n\t\tsafe_checksum = libfmapi_checksum_crc32_table[ table_index ] ^ ( safe_checksum >> 8 );\n        }\n\t*checksum = safe_checksum;\n\n        return( 1 );\n}", "Selected Statement": "size_t buffer_offset   = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 7, "Project Information": "libyal"}
{"Programming Language": "C", "Source Code": "int\nparse_packet(sldns_buffer* pkt, struct msg_parse* msg, struct regional* region)\n{\n\tint ret;\n\tif(sldns_buffer_remaining(pkt) < LDNS_HEADER_SIZE)\n\t\treturn LDNS_RCODE_FORMERR;\n\t\n\tsldns_buffer_read(pkt, &msg->id, sizeof(uint16_t));\n\tmsg->flags = sldns_buffer_read_u16(pkt);\n\tmsg->qdcount = sldns_buffer_read_u16(pkt);\n\tmsg->ancount = sldns_buffer_read_u16(pkt);\n\tmsg->nscount = sldns_buffer_read_u16(pkt);\n\tmsg->arcount = sldns_buffer_read_u16(pkt);\n\tif(msg->qdcount > 1)\n\t\treturn LDNS_RCODE_FORMERR;\n\tif((ret = parse_query_section(pkt, msg)) != 0)\n\t\treturn ret;\n\tif((ret = parse_section(pkt, msg, region, LDNS_SECTION_ANSWER,\n\t\tmsg->ancount, &msg->an_rrsets)) != 0)\n\t\treturn ret;\n\tif((ret = parse_section(pkt, msg, region, LDNS_SECTION_AUTHORITY,\n\t\tmsg->nscount, &msg->ns_rrsets)) != 0)\n\t\treturn ret;\n\tif(sldns_buffer_remaining(pkt) == 0 && msg->arcount == 1) {\n\t\t\n\t} else if((ret = parse_section(pkt, msg, region,\n\t\tLDNS_SECTION_ADDITIONAL, msg->arcount, &msg->ar_rrsets)) != 0)\n\t\treturn ret;\n\t\n\t\t\n\t\n\tmsg->rrset_count = msg->an_rrsets + msg->ns_rrsets + msg->ar_rrsets;\n\treturn 0;\n}", "Selected Statement": "msg->qdcount = sldns_buffer_read_u16(pkt);", "Function Input": {"pkt": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"_position": {"type_category": "unknown", "concrete_type": "size_t", "value": "0"}, "_limit": {"type_category": "unknown", "concrete_type": "size_t", "value": "12"}, "_capacity": {"type_category": "unknown", "concrete_type": "size_t", "value": "3546920299816956257"}, "_data": {"type_category": "string", "concrete_type": "string", "value": "0x31 <error: Cannot access memory at address 0x31>"}, "_fixed": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}, "_status_err": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}}}}}, "Variable Values Before Statement": {"pkt": {"_position": "6", "_limit": "12", "_capacity": "12", "_data": "0x11e62d0 \"\"", "_fixed": "1", "_status_err": "0"}}, "Value After Statement Execution": "0", "Function Name": "sldns_buffer_read_u16", "Block_Size": 7, "Project Information": "unbound"}
{"Programming Language": "C", "Source Code": "int libfsext_checksum_calculate_crc32(\n     uint32_t *checksum,\n     const uint8_t *buffer,\n     size_t size,\n     uint32_t initial_value,\n     libcerror_error_t **error )\n{\n\tstatic char *function  = \"libfsext_checksum_calculate_crc32\";\n\tsize_t buffer_offset   = 0;\n\tuint32_t safe_checksum = 0;\n\tuint32_t table_index   = 0;\n\n\tif( checksum == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid checksum.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( buffer == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid buffer.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( size > (size_t) SSIZE_MAX )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM,\n\t\t \"%s: invalid size value exceeds maximum.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n        if( libfsext_checksum_crc32_table_computed == 0 )\n\t{\n\t\tlibfsext_checksum_initialize_crc32_table(\n\t\t 0x82f63b78UL );\n\t}\n\tsafe_checksum = initial_value ^ (uint32_t) 0xffffffffUL;\n\n        for( buffer_offset = 0;\n\t     buffer_offset < size;\n\t     buffer_offset++ )\n\t{\n\t\ttable_index = ( safe_checksum ^ buffer[ buffer_offset ] ) & 0x000000ffUL;\n\n\t\tsafe_checksum = libfsext_checksum_crc32_table[ table_index ] ^ ( safe_checksum >> 8 );\n        }\n        *checksum = safe_checksum ^ 0xffffffffUL;\n\n\treturn( 1 );\n}", "Selected Statement": "size_t buffer_offset   = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 7, "Project Information": "libyal"}
{"Programming Language": "C", "Source Code": "int sldns_wire2str_edns_subnet_print(char** s, size_t* sl, uint8_t* data,\n\tsize_t len)\n{\n\tint w = 0;\n\tuint16_t family;\n\tuint8_t source, scope;\n\tif(len < 4) {\n\t\tw += sldns_str_print(s, sl, \"malformed subnet \");\n\t\tw += print_hex_buf(s, sl, data, len);\n\t\treturn w;\n\t}\n\tfamily = sldns_read_uint16(data);\n\tsource = data[2];\n\tscope = data[3];\n\tif(family == 1) {\n\t\t\n\t\tchar buf[64];\n\t\tuint8_t ip4[4];\n\t\tmemset(ip4, 0, sizeof(ip4));\n\t\tif(len-4 > 4) {\n\t\t\tw += sldns_str_print(s, sl, \"trailingdata:\");\n\t\t\tw += print_hex_buf(s, sl, data+4+4, len-4-4);\n\t\t\tw += sldns_str_print(s, sl, \" \");\n\t\t\tlen = 4+4;\n\t\t}\n\t\tmemmove(ip4, data+4, len-4);\n\t\tif(!inet_ntop(AF_INET, ip4, buf, (socklen_t)sizeof(buf))) {\n\t\t\tw += sldns_str_print(s, sl, \"ip4ntoperror \");\n\t\t\tw += print_hex_buf(s, sl, data+4+4, len-4-4);\n\t\t} else {\n\t\t\tw += sldns_str_print(s, sl, \"%s\", buf);\n\t\t}\n\t} else if(family == 2) {\n\t\t\n\t\tchar buf[64];\n\t\tuint8_t ip6[16];\n\t\tmemset(ip6, 0, sizeof(ip6));\n\t\tif(len-4 > 16) {\n\t\t\tw += sldns_str_print(s, sl, \"trailingdata:\");\n\t\t\tw += print_hex_buf(s, sl, data+4+16, len-4-16);\n\t\t\tw += sldns_str_print(s, sl, \" \");\n\t\t\tlen = 4+16;\n\t\t}\n\t\tmemmove(ip6, data+4, len-4);\n#ifdef AF_INET6\n\t\tif(!inet_ntop(AF_INET6, ip6, buf, (socklen_t)sizeof(buf))) {\n\t\t\tw += sldns_str_print(s, sl, \"ip6ntoperror \");\n\t\t\tw += print_hex_buf(s, sl, data+4+4, len-4-4);\n\t\t} else {\n\t\t\tw += sldns_str_print(s, sl, \"%s\", buf);\n\t\t}\n#else\n\t\tw += print_hex_buf(s, sl, data+4+4, len-4-4);\n#endif\n\t} else {\n\t\t\n\t\tw += sldns_str_print(s, sl, \"family %d \",\n\t\t\t(int)family);\n\t\tw += print_hex_buf(s, sl, data, len);\n\t}\n\tw += sldns_str_print(s, sl, \"/%d scope /%d\", (int)source, (int)scope);\n\treturn w;\n}", "Selected Statement": "w += print_hex_buf(s, sl, data, len);", "Function Input": {"s": {"value": {"type_category": "string", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3\n", "message": "Cannot access memory at address 0x3"}}}, "Variable Values Before Statement": {"s": "NULL", "sl": "0", "data": "0x11ea371 \"\\n\\003\\367\\377\\177\"", "len": "2"}, "Value After Statement Execution": "int", "Function Name": "print_hex_buf", "Block_Size": 7, "Project Information": "unbound"}
{"Programming Language": "C", "Source Code": "bool ddsrt_prng_makeseed (struct ddsrt_prng_seed *seed)\n{\n  FILE *rndfile;\n  memset (seed->key, 0, sizeof (seed->key));\n  if ((rndfile = fopen (\"/dev/urandom\", \"rb\")) == NULL)\n    return false;\n  else\n  {\n    size_t n = fread (seed->key, sizeof (seed->key), 1, rndfile);\n    fclose (rndfile);\n    return (n == 1);\n  }\n}", "Selected Statement": "size_t n = fread (seed->key, sizeof (seed->key), 1, rndfile);", "Function Input": {}, "Variable Values Before Statement": {"1": "1", "rndfile": "NULL"}, "Value After Statement Execution": "1", "Function Name": "fread", "Block_Size": 7, "Project Information": "cyclonedds"}
{"Programming Language": "C", "Source Code": "int\nbufferevent_pair_new(struct event_base *base, int options,\n    struct bufferevent *pair[2])\n{\n\tstruct bufferevent_pair *bufev1 = NULL, *bufev2 = NULL;\n\tint tmp_options;\n\n\toptions |= BEV_OPT_DEFER_CALLBACKS;\n\ttmp_options = options & ~BEV_OPT_THREADSAFE;\n\n\tbufev1 = bufferevent_pair_elt_new(base, options);\n\tif (!bufev1)\n\t\treturn -1;\n\tbufev2 = bufferevent_pair_elt_new(base, tmp_options);\n\tif (!bufev2) {\n\t\tbufferevent_free(downcast(bufev1));\n\t\treturn -1;\n\t}\n\n\tif (options & BEV_OPT_THREADSAFE) {\n\t\t\n\t\tbufferevent_enable_locking_(downcast(bufev2), bufev1->bev.lock);\n\t}\n\n\tbufev1->partner = bufev2;\n\tbufev2->partner = bufev1;\n\n\tevbuffer_freeze(downcast(bufev1)->input, 0);\n\tevbuffer_freeze(downcast(bufev1)->output, 1);\n\tevbuffer_freeze(downcast(bufev2)->input, 0);\n\tevbuffer_freeze(downcast(bufev2)->output, 1);\n\n\tpair[0] = downcast(bufev1);\n\tpair[1] = downcast(bufev2);\n\n\treturn 0;\n}", "Selected Statement": "options |= BEV_OPT_DEFER_CALLBACKS;", "Function Input": {}, "Variable Values Before Statement": {"BEV_OPT_DEFER_CALLBACKS": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 7, "Project Information": "tmux"}
{"Programming Language": "C", "Source Code": "void fd_close_on_exec(int fd, bool set)\n{\n\tint flags;\n\n\tflags = fcntl(fd, F_GETFD, 0);\n\tif (flags < 0)\n\t\ti_fatal(\"fcntl(F_GETFD, %d) failed: %m\", fd);\n\n\tflags = set ? (flags | FD_CLOEXEC) : (flags & ~FD_CLOEXEC);\n\tif (fcntl(fd, F_SETFD, flags) < 0)\n\t\ti_fatal(\"fcntl(F_SETFD, %d) failed: %m\", fd);\n}", "Selected Statement": "flags = set ? (flags | FD_CLOEXEC) : (flags & ~FD_CLOEXEC);", "Function Input": {"fd": {"value": "32767"}, "set": {"value": "255"}}, "Variable Values Before Statement": {"set": "_Bool"}, "Value After Statement Execution": "_Bool", "Block_Size": 7, "Project Information": "dovecot"}
{"Programming Language": "C", "Source Code": "void luaS_init (lua_State *L) {\n  global_State *g = G(L);\n  int i, j;\n  stringtable *tb = &G(L)->strt;\n  tb->hash = luaM_newvector(L, MINSTRTABSIZE, TString*);\n  tablerehash(tb->hash, 0, MINSTRTABSIZE);  \n  tb->size = MINSTRTABSIZE;\n  \n  g->memerrmsg = luaS_newliteral(L, MEMERRMSG);\n  luaC_fix(L, obj2gco(g->memerrmsg));  \n  for (i = 0; i < STRCACHE_N; i++)  \n    for (j = 0; j < STRCACHE_M; j++)\n      g->strcache[i][j] = g->memerrmsg;\n}", "Selected Statement": "g->memerrmsg = luaS_newliteral(L, MEMERRMSG);", "Function Input": {}, "Variable Values Before Statement": {"L": "NULL", "MEMERRMSG": "NULL"}, "Value After Statement Execution": "{next = 0xf59850, tt = 4 '\\004', marked = 8 '\\b', extra = 0 '\\000', shrlen = 17 '\\021', hash = 1174080900, u = {lnglen = 0, hnext = 0x0}, contents = 0x756f6e6520746f6e &lt;error: Cannot access memory at address 0x756f6e6520746f6e&gt;, falloc = 0x726f6d656d206867, ud = 0x79}", "Function Name": "luaS_newliteral", "Block_Size": 7, "Project Information": "lua"}
{"Programming Language": "C", "Source Code": "unsigned int luaO_codeparam (unsigned int p) {\n  if (p >= (cast(lu_mem, 0x1F) << (0xF - 7 - 1)) * 100u)  \n    return 0xFF;  \n  else {\n    p = (cast(l_uint32, p) * 128 + 99) / 100;  \n    if (p < 0x10)  \n      return p;  \n    else {\n      int log = luaO_ceillog2(p + 1) - 5;  \n      return ((p >> log) - 0x10) | ((log + 1) << 4);\n    }\n  }\n}", "Selected Statement": "int log = luaO_ceillog2(p + 1) - 5;  /* preserve 5 bits */", "Function Input": {}, "Variable Values Before Statement": {"luaO_ceillog2": "NULL", "p": "unsigned int"}, "Value After Statement Execution": "NULL", "Block_Size": 7, "Project Information": "lua"}
{"Programming Language": "C", "Source Code": "static int look_for_our_target(Dwarf_Debug dbg, struct target_data_s *td,\n                               Dwarf_Error *errp) {\n  Dwarf_Unsigned cu_header_length = 0;\n  Dwarf_Unsigned abbrev_offset = 0;\n  Dwarf_Half address_size = 0;\n  Dwarf_Half version_stamp = 0;\n  Dwarf_Half offset_size = 0;\n  Dwarf_Half extension_size = 0;\n  Dwarf_Unsigned typeoffset = 0;\n  Dwarf_Half header_cu_type = unittype;\n  Dwarf_Bool is_info = g_is_info;\n  int cu_number = 0;\n\n  for (;; ++cu_number) {\n    Dwarf_Die no_die = 0;\n    Dwarf_Die cu_die = 0;\n    int res = DW_DLV_ERROR;\n    Dwarf_Sig8 signature;\n\n    memset(&signature, 0, sizeof(signature));\n    res = dwarf_next_cu_header_d(dbg, is_info, &cu_header_length,\n                                 &version_stamp, &abbrev_offset, &address_size,\n                                 &offset_size, &extension_size, &signature,\n                                 &typeoffset, 0, &header_cu_type, errp);\n    if (res == DW_DLV_ERROR) {\n      if (errp) {\n        char *em = dwarf_errmsg(*errp);\n      }\n      return DW_DLV_NO_ENTRY;\n    }\n    if (res == DW_DLV_NO_ENTRY) {\n      return DW_DLV_NO_ENTRY;\n    }\n    cu_version_stamp = version_stamp;\n    cu_offset_size = offset_size;\n    res = dwarf_siblingof_b(dbg, no_die, is_info, &cu_die, errp);\n    if (res == DW_DLV_ERROR) {\n      if (errp) {\n        char *em = dwarf_errmsg(*errp);\n      }\n      return res;\n    }\n    if (res == DW_DLV_NO_ENTRY) {\n      return res;\n    }\n\n    td->td_cu_die = cu_die;\n    res = get_die_and_siblings(dbg, cu_die, is_info, 0, cu_number, td, errp);\n    if (res == FOUND_SUBPROG) {\n      read_line_data(dbg, td, errp);\n      if (td->td_reportallfound) {\n        return res;\n      }\n      return res;\n    } else if (res == IN_THIS_CU) {\n      if (errp) {\n          char *em = dwarf_errmsg(*errp);\n      }\n      return res;\n    } else if (res == DW_DLV_ERROR) {\n      if (errp) {\n        char *em = dwarf_errmsg(*errp);\n      }\n      return DW_DLV_ERROR;\n    }\n    return DW_DLV_NO_ENTRY;\n  }\n}", "Selected Statement": "Dwarf_Half header_cu_type = unittype;", "Function Input": {}, "Variable Values Before Statement": {"unittype": "int"}, "Value After Statement Execution": "int", "Block_Size": 8, "Project Information": "libdwarf"}
{"Programming Language": "C", "Source Code": "GLOBAL(cjpeg_source_ptr)\njinit_read_ppm(j_compress_ptr cinfo)\n{\n  ppm_source_ptr source;\n\n  \n  source = (ppm_source_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(ppm_source_struct));\n  \n  source->pub.start_input = start_input_ppm;\n  source->pub.finish_input = finish_input_ppm;\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n  source->pub.max_pixels = 0;\n#endif\n\n  return (cjpeg_source_ptr)source;\n}", "Selected Statement": "source->pub.start_input = start_input_ppm;", "Function Input": {}, "Variable Values Before Statement": {"start_input_ppm": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 8, "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;\n}", "Selected Statement": "uri->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);", "Function Input": {}, "Variable Values Before Statement": {"uri_raw.login": "NULL", "uri_raw.login_len": "0"}, "Value After Statement Execution": "NULL", "Function Name": "XSTRNDUP", "Block_Size": 8, "Project Information": "tarantool"}
{"Programming Language": "C", "Source Code": "int\ndwarf_init_b(int fd,\n    unsigned        group_number,\n    Dwarf_Handler   errhand,\n    Dwarf_Ptr       errarg,\n    Dwarf_Debug *   ret_dbg,\n    Dwarf_Error *   error)\n{\n    unsigned ftype = 0;\n    unsigned endian = 0;\n    unsigned offsetsize = 0;\n    unsigned universalnumber = 0;\n    Dwarf_Unsigned   filesize = 0;\n    int res = 0;\n    int errcode = 0;\n\n    if (!ret_dbg) {\n        DWARF_DBG_ERROR(NULL,DW_DLE_DWARF_INIT_DBG_NULL,DW_DLV_ERROR);\n    }\n    \n    *ret_dbg = 0;\n    res = dwarf_object_detector_fd(fd, &ftype,\n        &endian,&offsetsize,&filesize,&errcode);\n    if (res == DW_DLV_NO_ENTRY) {\n        return res;\n    }\n    if (res == DW_DLV_ERROR) {\n        \n        DWARF_DBG_ERROR(NULL, DW_DLE_FILE_WRONG_TYPE, DW_DLV_ERROR);\n    }\n    switch(ftype) {\n    case DW_FTYPE_ELF: {\n        int res2 = 0;\n\n        res2 = _dwarf_elf_nlsetup(fd,\"\",\n            ftype,endian,offsetsize,filesize,\n            group_number,errhand,errarg,ret_dbg,error);\n        if (res2 != DW_DLV_OK) {\n            return res2;\n        }\n        set_global_paths_init(*ret_dbg,error);\n        return res2;\n        }\n    case DW_FTYPE_APPLEUNIVERSAL:\n    case DW_FTYPE_MACH_O: {\n        int resm = 0;\n\n        resm = _dwarf_macho_setup(fd,\"\",\n            universalnumber,\n            ftype,endian,offsetsize,filesize,\n            group_number,errhand,errarg,ret_dbg,error);\n        if (resm != DW_DLV_OK) {\n            return resm;\n        }\n        set_global_paths_init(*ret_dbg,error);\n        return resm;\n        }\n\n    case DW_FTYPE_PE: {\n        int resp = 0;\n\n        resp = _dwarf_pe_setup(fd,\n            \"\",\n            ftype,endian,offsetsize,filesize,\n            group_number,errhand,errarg,ret_dbg,error);\n        if (resp != DW_DLV_OK) {\n            return resp;\n        }\n        set_global_paths_init(*ret_dbg,error);\n        return resp;\n        }\n    default: break;\n    }\n    DWARF_DBG_ERROR(NULL, DW_DLE_FILE_WRONG_TYPE, DW_DLV_ERROR);\n    \n}", "Selected Statement": "unsigned offsetsize = 0;", "Function Input": {"error": {"value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xfe02dd63e9f26600\n", "message": "Cannot access memory at address 0xfe02dd63e9f26600"}}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 8, "Project Information": "libdwarf"}
{"Programming Language": "C", "Source Code": "GLOBAL(boolean)\nkeymatch(char *arg, const char *keyword, int minchars)\n{\n  register int ca, ck;\n  register int nmatched = 0;\n\n  while ((ca = *arg++) != '\\0') {\n    if ((ck = *keyword++) == '\\0')\n      return FALSE;             \n    if (isupper(ca))            \n      ca = tolower(ca);\n    if (ca != ck)\n      return FALSE;             \n    nmatched++;                 \n  }\n  \n  if (nmatched < minchars)\n    return FALSE;\n  return TRUE;                  \n}", "Selected Statement": "ca = tolower(ca);", "Function Input": {}, "Variable Values Before Statement": {"ca": "int"}, "Value After Statement Execution": "int", "Function Name": "tolower", "Block_Size": 8, "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Source Code": "int libagdb_compressed_blocks_stream_initialize(\n     libfdata_stream_t **compressed_blocks_stream,\n     libfdata_list_t *compressed_blocks_list,\n     libfcache_cache_t *compressed_blocks_cache,\n     libcerror_error_t **error )\n{\n\tlibagdb_compressed_blocks_stream_data_handle_t *data_handle = NULL;\n\tstatic char *function                                       = \"libagdb_compressed_blocks_stream_initialize\";\n\toff64_t segment_offset                                      = 0;\n\tsize64_t segment_size                                       = 0;\n\tint element_index                                           = 0;\n\tint number_of_elements                                      = 0;\n\tint segment_index                                           = 0;\n\n\tif( compressed_blocks_stream == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid compressed block stream.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( compressed_blocks_list == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid compressed blocks list.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( libagdb_compressed_blocks_stream_data_handle_initialize(\n\t     &data_handle,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create data handle.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( data_handle == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_MISSING,\n\t\t \"%s: missing data handle.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tdata_handle->compressed_blocks_list  = compressed_blocks_list;\n\tdata_handle->compressed_blocks_cache = compressed_blocks_cache;\n\n\tif( libfdata_stream_initialize(\n\t     compressed_blocks_stream,\n\t     (intptr_t *) data_handle,\n\t     (int (*)(intptr_t **, libcerror_error_t **)) &libagdb_compressed_blocks_stream_data_handle_free,\n\t     NULL,\n\t     NULL,\n\t     (ssize_t (*)(intptr_t *, intptr_t *, int, int, uint8_t *, size_t, uint32_t, uint8_t, libcerror_error_t **)) &libagdb_compressed_blocks_stream_data_handle_read_segment_data,\n\t     NULL,\n\t     (off64_t (*)(intptr_t *, intptr_t *, int, int, off64_t, libcerror_error_t **)) &libagdb_compressed_blocks_stream_data_handle_seek_segment_offset,\n\t     LIBFDATA_DATA_HANDLE_FLAG_MANAGED,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create stream.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( libfdata_list_get_number_of_elements(\n\t     compressed_blocks_list,\n\t     &number_of_elements,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_GET_FAILED,\n\t\t \"%s: unable to retrieve number of compressed blocks list elements.\",\n\t\t function );\n\n\t\tdata_handle = NULL;\n\n\t\tgoto on_error;\n\t}\n\tfor( element_index = 0;\n\t     element_index < number_of_elements;\n\t     element_index++ )\n\t{\n\t\tif( libfdata_list_get_mapped_size_by_index(\n\t\t     compressed_blocks_list,\n\t\t     element_index,\n\t\t     &segment_size,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_GET_FAILED,\n\t\t\t \"%s: unable to retrieve compressed blocks list element: %d mapped size.\",\n\t\t\t function,\n\t\t\t element_index );\n\n\t\t\tdata_handle = NULL;\n\n\t\t\tgoto on_error;\n\t\t}\n\t\tif( libfdata_stream_append_segment(\n\t\t     *compressed_blocks_stream,\n\t\t     &segment_index,\n\t\t     0,\n\t\t     segment_offset,\n\t\t     segment_size,\n\t\t     0,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_APPEND_FAILED,\n\t\t\t \"%s: unable to append compressed blocks stream segment: %d.\",\n\t\t\t function,\n\t\t\t element_index );\n\n\t\t\tdata_handle = NULL;\n\n\t\t\tgoto on_error;\n\t\t}\n\t\tsegment_offset += segment_size;\n\t}\n\treturn( 1 );\n\non_error:\n\tif( *compressed_blocks_stream != NULL )\n\t{\n\t\tlibfdata_stream_free(\n\t\t compressed_blocks_stream,\n\t\t NULL );\n\t}\n\tif( data_handle != NULL )\n\t{\n\t\tlibagdb_compressed_blocks_stream_data_handle_free(\n\t\t &data_handle,\n\t\t NULL );\n\t}\n\treturn( -1 );\n}", "Selected Statement": "size64_t segment_size                                       = 0;", "Function Input": {"compressed_blocks_cache": {"value": null}, "compressed_blocks_list": {"value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x801087060\n", "message": "Cannot access memory at address 0x801087060"}}, "compressed_blocks_stream": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x11e6400", "value": {"type_category": "unknown", "concrete_type": "libfdata_stream_t", "value": "17303920"}}}, "error": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x108a300", "value": {"type_category": "unknown", "concrete_type": "libcerror_error_t", "value": "34359738384"}}}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 8, "Project Information": "libyal"}
{"Programming Language": "C", "Source Code": "int libfsext_checksum_calculate_crc32(\n     uint32_t *checksum,\n     const uint8_t *buffer,\n     size_t size,\n     uint32_t initial_value,\n     libcerror_error_t **error )\n{\n\tstatic char *function  = \"libfsext_checksum_calculate_crc32\";\n\tsize_t buffer_offset   = 0;\n\tuint32_t safe_checksum = 0;\n\tuint32_t table_index   = 0;\n\n\tif( checksum == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid checksum.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( buffer == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid buffer.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( size > (size_t) SSIZE_MAX )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM,\n\t\t \"%s: invalid size value exceeds maximum.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n        if( libfsext_checksum_crc32_table_computed == 0 )\n\t{\n\t\tlibfsext_checksum_initialize_crc32_table(\n\t\t 0x82f63b78UL );\n\t}\n\tsafe_checksum = initial_value ^ (uint32_t) 0xffffffffUL;\n\n        for( buffer_offset = 0;\n\t     buffer_offset < size;\n\t     buffer_offset++ )\n\t{\n\t\ttable_index = ( safe_checksum ^ buffer[ buffer_offset ] ) & 0x000000ffUL;\n\n\t\tsafe_checksum = libfsext_checksum_crc32_table[ table_index ] ^ ( safe_checksum >> 8 );\n        }\n        *checksum = safe_checksum ^ 0xffffffffUL;\n\n\treturn( 1 );\n}", "Selected Statement": "uint32_t safe_checksum = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 8, "Project Information": "libyal"}
{"Programming Language": "C", "Source Code": "void\nclock_lowres_signal_init(void)\n{\n#ifndef NDEBUG\n\towner = pthread_self();\n#endif\n\tclock_lowres_monotonic_clock_value = clock_monotonic();\n\tstruct sigaction sa;\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_handler = clock_lowres_tick;\n\tsa.sa_flags = SA_RESTART;\n\tif (tt_sigaction(SIGALRM, &sa, NULL) == -1)\n\t\tpanic_syserror(\"cannot set low resolution clock timer signal\");\n\n\tstruct itimerval timer;\n\ttimer.it_interval = resolution;\n\ttimer.it_value = resolution;\n\tif (setitimer(ITIMER_REAL, &timer, NULL) == -1)\n\t\tpanic_syserror(\"cannot set low resolution clock timer\");\n}", "Selected Statement": "sa.sa_flags = SA_RESTART;", "Function Input": {}, "Variable Values Before Statement": {"SA_RESTART": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 8, "Project Information": "tarantool"}
{"Programming Language": "C", "Source Code": "ssh_agent ssh_agent_new(struct ssh_session_struct *session) {\n  ssh_agent agent = NULL;\n\n  agent = malloc(sizeof(struct ssh_agent_struct));\n  if (agent == NULL) {\n    return NULL;\n  }\n  ZERO_STRUCTP(agent);\n\n  agent->count = 0;\n  agent->sock = ssh_socket_new(session);\n  if (agent->sock == NULL) {\n    SAFE_FREE(agent);\n    return NULL;\n  }\n  agent->channel = NULL;\n  return agent;\n}", "Selected Statement": "agent->count = 0;", "Function Input": {"agent": {"value": "0x510b29 <ssh_set_blocking+105>"}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 8, "Project Information": "libssh"}
{"Programming Language": "C", "Source Code": "void\ninit_parse_tree(struct sudoers_parse_tree *parse_tree, char *lhost, char *shost,\n    struct sudoers_context *ctx, struct sudo_nss *nss)\n{\n    TAILQ_INIT(&parse_tree->userspecs);\n    TAILQ_INIT(&parse_tree->defaults);\n    parse_tree->aliases = NULL;\n    parse_tree->shost = shost;\n    parse_tree->lhost = lhost;\n    parse_tree->ctx = ctx;\n    parse_tree->nss = nss;\n}", "Selected Statement": "parse_tree->nss = nss;", "Function Input": {}, "Variable Values Before Statement": {"nss": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 8, "Project Information": "sudoers"}
{"Programming Language": "C", "Source Code": "ssh_socket ssh_socket_new(ssh_session session)\n{\n    ssh_socket s;\n\n    s = calloc(1, sizeof(struct ssh_socket_struct));\n    if (s == NULL) {\n        ssh_set_error_oom(session);\n        return NULL;\n    }\n    s->fd = SSH_INVALID_SOCKET;\n    s->last_errno = -1;\n    s->fd_is_socket = 1;\n    s->session = session;\n    s->in_buffer = ssh_buffer_new();\n    if (s->in_buffer == NULL) {\n        ssh_set_error_oom(session);\n        SAFE_FREE(s);\n        return NULL;\n    }\n    s->out_buffer=ssh_buffer_new();\n    if (s->out_buffer == NULL) {\n        ssh_set_error_oom(session);\n        SSH_BUFFER_FREE(s->in_buffer);\n        SAFE_FREE(s);\n        return NULL;\n    }\n    s->read_wontblock = 0;\n    s->write_wontblock = 0;\n    s->data_except = 0;\n    s->poll_handle = NULL;\n    s->state=SSH_SOCKET_NONE;\n    return s;\n}", "Selected Statement": "s->fd = SSH_INVALID_SOCKET;", "Function Input": {}, "Variable Values Before Statement": {"SSH_INVALID_SOCKET": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 8, "Project Information": "libssh"}
{"Programming Language": "C", "Source Code": "void\nscreen_init(struct screen *s, u_int sx, u_int sy, u_int hlimit)\n{\n\ts->grid = grid_create(sx, sy, hlimit);\n\ts->saved_grid = NULL;\n\n\ts->title = xstrdup(\"\");\n\ts->titles = NULL;\n\ts->path = NULL;\n\n\ts->cstyle = SCREEN_CURSOR_DEFAULT;\n\ts->default_cstyle = SCREEN_CURSOR_DEFAULT;\n\ts->mode = MODE_CURSOR;\n\ts->default_mode = 0;\n\ts->ccolour = -1;\n\ts->default_ccolour = -1;\n\ts->tabs = NULL;\n\ts->sel = NULL;\n\n#ifdef ENABLE_SIXEL\n\tTAILQ_INIT(&s->images);\n#endif\n\n\ts->write_list = NULL;\n\ts->hyperlinks = NULL;\n\n\tscreen_reinit(s);\n}", "Selected Statement": "s->cstyle = SCREEN_CURSOR_DEFAULT;", "Function Input": {"s": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"title": {"type_category": "string", "concrete_type": "string", "value": "0x800000008 <error: Cannot access memory at address 0x800000008>"}, "path": {"type_category": "string", "concrete_type": "NULL"}, "titles": {"type_category": "pointer", "concrete_type": "NULL"}, "grid": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x26ebb10", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xffffffff\n", "message": "Cannot access memory at address 0xffffffff"}}, "cx": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "cy": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "cstyle": {"type_category": "unknown", "concrete_type": "screen_cursor_style", "value": "SCREEN_CURSOR_DEFAULT"}, "default_cstyle": {"type_category": "unknown", "concrete_type": "screen_cursor_style", "value": "SCREEN_CURSOR_DEFAULT"}, "ccolour": {"type_category": "int", "concrete_type": "int", "value": "0"}, "default_ccolour": {"type_category": "int", "concrete_type": "int", "value": "0"}, "rupper": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "rlower": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "mode": {"type_category": "int", "concrete_type": "int", "value": "0"}, "default_mode": {"type_category": "int", "concrete_type": "int", "value": "0"}, "saved_cx": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "saved_cy": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "saved_grid": {"type_category": "pointer", "concrete_type": "NULL"}, "saved_cell": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"data": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"data": {"type_category": "string", "concrete_type": "string", "value": "\"\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\""}, "have": {"type_category": "unknown", "concrete_type": "u_char", "value": "0 '\\000'"}, "size": {"type_category": "unknown", "concrete_type": "u_char", "value": "0 '\\000'"}, "width": {"type_category": "unknown", "concrete_type": "u_char", "value": "0 '\\000'"}}}, "attr": {"type_category": "unknown", "concrete_type": "u_short", "value": "0"}, "flags": {"type_category": "unknown", "concrete_type": "u_char", "value": "0 '\\000'"}, "fg": {"type_category": "int", "concrete_type": "int", "value": "0"}, "bg": {"type_category": "int", "concrete_type": "int", "value": "0"}, "us": {"type_category": "int", "concrete_type": "int", "value": "0"}, "link": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}}}, "saved_flags": {"type_category": "int", "concrete_type": "int", "value": "0"}, "tabs": {"type_category": "string", "concrete_type": "NULL"}, "sel": {"type_category": "pointer", "concrete_type": "NULL"}, "write_list": {"type_category": "pointer", "concrete_type": "NULL"}, "hyperlinks": {"type_category": "pointer", "concrete_type": "NULL"}}}}}, "Variable Values Before Statement": {"SCREEN_CURSOR_DEFAULT": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 8, "Project Information": "tmux"}
{"Programming Language": "C", "Source Code": "int libfmapi_checksum_calculate_weak_crc32(\n     uint32_t *checksum,\n     const uint8_t *buffer,\n     size_t size,\n     uint32_t initial_value,\n     libcerror_error_t **error )\n{\n\tstatic char *function  = \"libfmapi_checksum_calculate_weak_crc32\";\n\tsize_t buffer_offset   = 0;\n\tuint32_t safe_checksum = 0;\n\tuint32_t table_index   = 0;\n\n\tif( checksum == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid checksum.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( buffer == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid buffer.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( size > (size_t) SSIZE_MAX )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM,\n\t\t \"%s: invalid size value exceeds maximum.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n        if( libfmapi_checksum_crc32_table_computed == 0 )\n\t{\n\t\tlibfmapi_checksum_initialize_crc32_table(\n\t\t 0xedb88320UL );\n\t}\n\tsafe_checksum = initial_value;\n\n        for( buffer_offset = 0;\n\t     buffer_offset < size;\n\t     buffer_offset++ )\n\t{\n\t\ttable_index = ( safe_checksum ^ buffer[ buffer_offset ] ) & 0x000000ffUL;\n\n\t\tsafe_checksum = libfmapi_checksum_crc32_table[ table_index ] ^ ( safe_checksum >> 8 );\n        }\n\t*checksum = safe_checksum;\n\n        return( 1 );\n}", "Selected Statement": "uint32_t safe_checksum = 0;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 8, "Project Information": "libyal"}
{"Programming Language": "C", "Source Code": "int\nparse_packet(sldns_buffer* pkt, struct msg_parse* msg, struct regional* region)\n{\n\tint ret;\n\tif(sldns_buffer_remaining(pkt) < LDNS_HEADER_SIZE)\n\t\treturn LDNS_RCODE_FORMERR;\n\t\n\tsldns_buffer_read(pkt, &msg->id, sizeof(uint16_t));\n\tmsg->flags = sldns_buffer_read_u16(pkt);\n\tmsg->qdcount = sldns_buffer_read_u16(pkt);\n\tmsg->ancount = sldns_buffer_read_u16(pkt);\n\tmsg->nscount = sldns_buffer_read_u16(pkt);\n\tmsg->arcount = sldns_buffer_read_u16(pkt);\n\tif(msg->qdcount > 1)\n\t\treturn LDNS_RCODE_FORMERR;\n\tif((ret = parse_query_section(pkt, msg)) != 0)\n\t\treturn ret;\n\tif((ret = parse_section(pkt, msg, region, LDNS_SECTION_ANSWER,\n\t\tmsg->ancount, &msg->an_rrsets)) != 0)\n\t\treturn ret;\n\tif((ret = parse_section(pkt, msg, region, LDNS_SECTION_AUTHORITY,\n\t\tmsg->nscount, &msg->ns_rrsets)) != 0)\n\t\treturn ret;\n\tif(sldns_buffer_remaining(pkt) == 0 && msg->arcount == 1) {\n\t\t\n\t} else if((ret = parse_section(pkt, msg, region,\n\t\tLDNS_SECTION_ADDITIONAL, msg->arcount, &msg->ar_rrsets)) != 0)\n\t\treturn ret;\n\t\n\t\t\n\t\n\tmsg->rrset_count = msg->an_rrsets + msg->ns_rrsets + msg->ar_rrsets;\n\treturn 0;\n}", "Selected Statement": "msg->ancount = sldns_buffer_read_u16(pkt);", "Function Input": {"pkt": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"_position": {"type_category": "unknown", "concrete_type": "size_t", "value": "0"}, "_limit": {"type_category": "unknown", "concrete_type": "size_t", "value": "12"}, "_capacity": {"type_category": "unknown", "concrete_type": "size_t", "value": "3546920299816956257"}, "_data": {"type_category": "string", "concrete_type": "string", "value": "0x31 <error: Cannot access memory at address 0x31>"}, "_fixed": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}, "_status_err": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}}}}}, "Variable Values Before Statement": {"pkt": {"_position": "8", "_limit": "12", "_capacity": "12", "_data": "0x11e62d0 \"\"", "_fixed": "1", "_status_err": "0"}}, "Value After Statement Execution": "0", "Function Name": "sldns_buffer_read_u16", "Block_Size": 8, "Project Information": "unbound"}
{"Programming Language": "C", "Source Code": "int libfplist_xml_parser_parse_buffer(\n     libfplist_property_list_t *property_list,\n     uint8_t *buffer,\n     size_t buffer_size,\n     libcerror_error_t **error )\n{\n\tlibfplist_xml_parser_state_t parser_state;\n\t\n\tYY_BUFFER_STATE buffer_state = NULL;\n\tstatic char *function        = \"libfplist_xml_parser_parse_buffer\";\n\tint result                   = -1;\n\n\tif( buffer == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid buffer.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tbuffer_state = libfplist_xml_scanner__scan_buffer(\n\t                (char *) buffer,\n\t                buffer_size );\n\n\tlibfplist_xml_scanner_buffer_offset = 0;\n\n\tif( buffer_state != NULL )\n\t{\n\t\tparser_state.property_list = property_list;\n\t\tparser_state.error         = error;\n\t\tparser_state.root_tag      = NULL;\n\t\tparser_state.current_tag   = NULL;\n\t\tparser_state.parent_tag    = NULL;\n\n\t\tif( libfplist_xml_scanner_parse(\n\t\t     &parser_state ) == 0 )\n\t\t{\n\t\t\tif( libfplist_property_list_set_root_tag(\n\t\t\t     property_list,\n\t\t\t     parser_state.root_tag,\n\t\t\t     error ) != 1 )\n\t\t\t{\n\t\t\t\tlibcerror_error_set(\n\t\t\t\t error,\n\t\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t\t LIBCERROR_RUNTIME_ERROR_GET_FAILED,\n\t\t\t\t \"%s: unable to set root tag.\",\n\t\t\t\t function );\n\n\t\t\t\tresult = -1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tparser_state.root_tag = NULL;\n\n\t\t\t\tresult = 1;\n\t\t\t}\n\t\t}\n\t\tlibfplist_xml_scanner__delete_buffer(\n\t\t buffer_state );\n\t}\n\tlibfplist_xml_scanner_lex_destroy();\n\n\tif( parser_state.root_tag != NULL )\n\t{\n\t\tlibfplist_xml_tag_free(\n\t\t &( parser_state.root_tag ),\n\t\t NULL );\n\t}\n\treturn( result );\n}", "Selected Statement": "static char *function        = \"libfplist_xml_parser_parse_buffer\";", "Function Input": {"buffer": {"value": "0x11f6eb0 \"\\340\\v\\342\\367\\377\\177\""}, "buffer_size": {"value": "4096"}, "error": {"value": {"type_category": "pointer", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x1000\n", "message": "Cannot access memory at address 0x1000"}}, "property_list": {"value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x2\n", "message": "Cannot access memory at address 0x2"}}}, "Variable Values Before Statement": {"constant": "\"libfplist_xml_parser_parse_buffer\""}, "Value After Statement Execution": "\"libfplist_xml_parser_parse_buffer\"", "Block_Size": 8, "Project Information": "libyal"}
{"Programming Language": "C", "Source Code": "GLOBAL(struct jpeg_error_mgr *)\njpeg_std_error(struct jpeg_error_mgr *err)\n{\n  err->error_exit = error_exit;\n  err->emit_message = emit_message;\n  err->output_message = output_message;\n  err->format_message = format_message;\n  err->reset_error_mgr = reset_error_mgr;\n\n  err->trace_level = 0;         \n  err->num_warnings = 0;        \n  err->msg_code = 0;            \n\n  \n  err->jpeg_message_table = jpeg_std_message_table;\n  err->last_jpeg_message = (int)JMSG_LASTMSGCODE - 1;\n\n  err->addon_message_table = NULL;\n  err->first_addon_message = 0; \n  err->last_addon_message = 0;\n\n  return err;\n}", "Selected Statement": "err->num_warnings = 0;        /* no warnings emitted yet */", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 8, "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Source Code": "int libesedb_checksum_calculate_little_endian_xor32(\n     uint32_t *checksum_value,\n     const uint8_t *buffer,\n     size_t size,\n     uint32_t initial_value,\n     libcerror_error_t **error )\n{\n\tlibesedb_aligned_t *aligned_buffer_iterator = NULL;\n\tuint8_t *buffer_iterator                    = NULL;\n\tstatic char *function                       = \"libesedb_checksum_calculate_little_endian_xor32\";\n\tlibesedb_aligned_t value_aligned            = 0;\n\tuint32_t big_endian_value_32bit             = 0;\n\tuint32_t safe_checksum_value                = 0;\n\tuint32_t value_32bit                        = 0;\n\tuint8_t alignment_count                     = 0;\n\tuint8_t alignment_size                      = 0;\n\tuint8_t byte_count                          = 0;\n\tuint8_t byte_order                          = 0;\n\tuint8_t byte_size                           = 0;\n\n\tif( checksum_value == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid checksum value.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( buffer == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid buffer.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( size > (size_t) SSIZE_MAX )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM,\n\t\t \"%s: invalid size value exceeds maximum.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tsafe_checksum_value = initial_value;\n\n\tbuffer_iterator = (uint8_t *) buffer;\n\n\t\n\tif( ( ( sizeof( libesedb_aligned_t ) % 4 ) == 0 )\n\t && ( size > ( 2 * sizeof( libesedb_aligned_t ) ) ) )\n\t{\n\t\t\n\t\talignment_size = (uint8_t) ( (intptr_t) buffer_iterator % sizeof( libesedb_aligned_t ) );\n\n\t\tif( alignment_size > 0 )\n\t\t{\n\t\t\tbyte_size = sizeof( libesedb_aligned_t ) - alignment_size;\n\n\t\t\t\n\t\t\twhile( byte_size != 0 )\n\t\t\t{\n\t\t\t\tvalue_32bit = 0;\n\t\t\t\tbyte_count  = 1;\n\n\t\t\t\tif( byte_size >= 4 )\n\t\t\t\t{\n\t\t\t\t\tvalue_32bit |= buffer_iterator[ 3 ];\n\t\t\t\t\tvalue_32bit <<= 8;\n\n\t\t\t\t\tbyte_count++;\n\t\t\t\t}\n\t\t\t\tif( byte_size >= 3 )\n\t\t\t\t{\n\t\t\t\t\tvalue_32bit |= buffer_iterator[ 2 ];\n\t\t\t\t\tvalue_32bit <<= 8;\n\n\t\t\t\t\tbyte_count++;\n\t\t\t\t}\n\t\t\t\tif( byte_size >= 2 )\n\t\t\t\t{\n\t\t\t\t\tvalue_32bit |= buffer_iterator[ 1 ];\n\t\t\t\t\tvalue_32bit <<= 8;\n\n\t\t\t\t\tbyte_count++;\n\t\t\t\t}\n\t\t\t\tvalue_32bit |= buffer_iterator[ 0 ];\n\n\t\t\t\tbuffer_iterator += byte_count;\n\t\t\t\tbyte_size       -= byte_count;\n\n\t\t\t\tsafe_checksum_value ^= value_32bit;\n\t\t\t}\n\t\t\tsize -= byte_count;\n\t\t}\n\t\taligned_buffer_iterator = (libesedb_aligned_t *) buffer_iterator;\n\n\t\tif( *buffer_iterator != (uint8_t) ( *aligned_buffer_iterator & 0xff ) )\n\t\t{\n\t\t\tbyte_order = _BYTE_STREAM_ENDIAN_BIG;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbyte_order = _BYTE_STREAM_ENDIAN_LITTLE;\n\t\t}\n\t\t\n\t\twhile( size > sizeof( libesedb_aligned_t ) )\n\t\t{\n\t\t\tvalue_aligned ^= *aligned_buffer_iterator;\n\n\t\t\taligned_buffer_iterator++;\n\n\t\t\tsize -= sizeof( libesedb_aligned_t );\n\t\t}\n\t\t\n\t\tif( alignment_size > 0 )\n\t\t{\n\t\t\tbyte_count      = ( alignment_size % 4 ) * 8;\n\t\t\talignment_count = ( sizeof( libesedb_aligned_t ) - alignment_size ) * 8;\n\n\t\t\tif( byte_order == _BYTE_STREAM_ENDIAN_BIG )\n\t\t\t{\n\t\t\t\t\n\t\t\t\tbig_endian_value_32bit = (uint32_t) ( ( value_aligned >> alignment_count ) << byte_count );\n\n\t\t\t\t\n\t\t\t\tvalue_32bit = ( ( big_endian_value_32bit & 0x000000ffUL ) << 24 )\n\t\t\t\t            | ( ( big_endian_value_32bit & 0x0000ff00UL ) << 8 )\n\t\t\t\t            | ( ( big_endian_value_32bit >> 8 ) & 0x0000ff00UL )\n\t\t\t\t            | ( ( big_endian_value_32bit >> 24 ) & 0x000000ffUL );\n\n\t\t\t\t\n\t\t\t\tvalue_aligned <<= alignment_count;\n\t\t\t}\n\t\t\telse if( byte_order == _BYTE_STREAM_ENDIAN_LITTLE )\n\t\t\t{\n\t\t\t\tvalue_32bit = (uint32_t) ( value_aligned << byte_count );\n\n\t\t\t\t\n\t\t\t\tvalue_aligned >>= alignment_count;\n\t\t\t}\n\t\t\tsafe_checksum_value ^= value_32bit;\n\t\t}\n\t\t\n\t\tbyte_size = (uint8_t) sizeof( libesedb_aligned_t );\n\n\t\twhile( byte_size != 0 )\n\t\t{\n\t\t\tbyte_count = ( ( byte_size / 4 ) - 1 ) * 32;\n\n\t\t\tif( byte_order == _BYTE_STREAM_ENDIAN_BIG )\n\t\t\t{\n\t\t\t\tbig_endian_value_32bit = (uint32_t) ( ( value_aligned >> byte_count ) & 0xffffffffUL );\n\n\t\t\t\t\n\t\t\t\tvalue_32bit = ( ( big_endian_value_32bit & 0x000000ffUL ) << 24 )\n\t\t\t\t            | ( ( big_endian_value_32bit & 0x0000ff00UL ) << 8 )\n\t\t\t\t            | ( ( big_endian_value_32bit >> 8 ) & 0x0000ff00UL )\n\t\t\t\t            | ( ( big_endian_value_32bit >> 24 ) & 0x000000ffUL );\n\t\t\t}\n\t\t\telse if( byte_order == _BYTE_STREAM_ENDIAN_LITTLE )\n\t\t\t{\n\t\t\t\tvalue_32bit = (uint32_t) value_aligned;\n\n\t\t\t\tvalue_aligned >>= byte_count;\n\t\t\t}\n\t\t\tbyte_size -= 4;\n\n\t\t\tsafe_checksum_value ^= value_32bit;\n\t\t}\n\t\t\n\t\tbuffer_iterator = (uint8_t *) aligned_buffer_iterator;\n\n\t\tbyte_size = 4 - ( alignment_size % 4 );\n\n\t\tif( byte_size != 4 )\n\t\t{\n\t\t\tvalue_32bit   = buffer_iterator[ 0 ];\n\t\t\tvalue_32bit <<= 8;\n\n\t\t\tif( byte_size >= 2 )\n\t\t\t{\n\t\t\t\tvalue_32bit |= buffer_iterator[ 1 ];\n\t\t\t}\n\t\t\tvalue_32bit <<= 8;\n\n\t\t\tif( byte_size >= 3 )\n\t\t\t{\n\t\t\t\tvalue_32bit |= buffer_iterator[ 2 ];\n\t\t\t}\n\t\t\tvalue_32bit <<= 8;\n\n\t\t\tbuffer_iterator += byte_size;\n\t\t\tsize            -= byte_size;\n\n\t\t\tsafe_checksum_value ^= value_32bit;\n\t\t}\n\t}\n\twhile( size > 0 )\n\t{\n\t\tvalue_32bit = 0;\n\t\tbyte_count  = 1;\n\n\t\tif( size >= 4 )\n\t\t{\n\t\t\tvalue_32bit |= buffer_iterator[ 3 ];\n\t\t\tvalue_32bit <<= 8;\n\n\t\t\tbyte_count++;\n\t\t}\n\t\tif( size >= 3 )\n\t\t{\n\t\t\tvalue_32bit |= buffer_iterator[ 2 ];\n\t\t\tvalue_32bit <<= 8;\n\n\t\t\tbyte_count++;\n\t\t}\n\t\tif( size >= 2 )\n\t\t{\n\t\t\tvalue_32bit |= buffer_iterator[ 1 ];\n\t\t\tvalue_32bit <<= 8;\n\n\t\t\tbyte_count++;\n\t\t}\n\t\tvalue_32bit |= buffer_iterator[ 0 ];\n\n\t\tbuffer_iterator += byte_count;\n\t\tsize            -= byte_count;\n\n\t\tsafe_checksum_value ^= value_32bit;\n\t}\n\t*checksum_value = safe_checksum_value;\n\n\treturn( 1 );\n}", "Selected Statement": "static char *function                       = \"libesedb_checksum_calculate_little_endian_xor32\";", "Function Input": {"buffer": {"value": "0x117ca50 \"\""}, "error": {"value": {"type_category": "pointer", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x29c\n", "message": "Cannot access memory at address 0x29c"}}, "initial_value": {"value": "0"}, "size": {"value": "672"}}, "Variable Values Before Statement": {"constant": "\"libesedb_checksum_calculate_little_endian_xor32\""}, "Value After Statement Execution": "\"libesedb_checksum_calculate_little_endian_xor32\"", "Block_Size": 8, "Project Information": "libyal"}
{"Programming Language": "C", "Source Code": "blkid_probe blkid_new_probe_from_filename(const char *filename)\n{\n\tint fd;\n\tblkid_probe pr = NULL;\n\n\tfd = open(filename, O_RDONLY|O_CLOEXEC|O_NONBLOCK);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tpr = blkid_new_probe();\n\tif (!pr)\n\t\tgoto err;\n\n\tif (blkid_probe_set_device(pr, fd, 0, 0))\n\t\tgoto err;\n\n\tpr->flags |= BLKID_FL_PRIVATE_FD;\n\treturn pr;\nerr:\n\tclose(fd);\n\tblkid_free_probe(pr);\n\treturn NULL;\n}", "Selected Statement": "pr = blkid_new_probe();", "Function Input": {}, "Variable Values Before Statement": {}, "Value After Statement Execution": "blkid_probe", "Function Name": "blkid_new_probe", "Block_Size": 8, "Project Information": "util-linux"}
{"Programming Language": "C", "Source Code": "void lib_signals_init(void)\n{\n\tint i;\n\n\tsignals_initialized = TRUE;\n\tio_loop_add_switch_callback(lib_signals_ioloop_switched);\n\tio_loop_add_destroy_callback(lib_signals_ioloop_destroyed);\n\n\t\n\tfor (i = 0; i < MAX_SIGNAL_VALUE; i++) {\n\t\tif (signal_handlers[i] != NULL)\n\t\t\tlib_signals_set(i, signal_handlers[i]->flags);\n\t}\n}", "Selected Statement": "for (i = 0; i < MAX_SIGNAL_VALUE; i++) {", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 8, "Project Information": "dovecot"}
{"Programming Language": "C", "Source Code": "int mdb_set_default_backend(MdbHandle *mdb, const char *backend_name)\n{\n\tMdbBackend *backend;\n\n    if (!mdb->backends) {\n        mdb_init_backends(mdb);\n    }\n\tbackend = (MdbBackend *) g_hash_table_lookup(mdb->backends, backend_name);\n\tif (backend) {\n\t\tmdb->default_backend = backend;\n\t\tg_free(mdb->backend_name); \n\t\tmdb->backend_name = (char *) g_strdup(backend_name);\n\t\tmdb->relationships_table = NULL;\n\t\tif (backend->date_fmt) {\n\t\t\tmdb_set_date_fmt(mdb, backend->date_fmt);\n\t\t} else {\n\t\t\tmdb_set_date_fmt(mdb, \"%x %X\");\n\t\t}\n\t\tif (backend->shortdate_fmt) {\n\t\t\tmdb_set_shortdate_fmt(mdb, backend->shortdate_fmt);\n\t\t} else {\n\t\t\tmdb_set_shortdate_fmt(mdb, \"%x\");\n\t\t}\n\t}\n\treturn (backend != NULL);\n}", "Selected Statement": "mdb->default_backend = backend;", "Function Input": {}, "Variable Values Before Statement": {"backend": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 8, "Project Information": "mdbtools"}
{"Programming Language": "C", "Source Code": "GLOBAL(void)\njinit_input_controller(j_decompress_ptr cinfo)\n{\n  my_inputctl_ptr inputctl;\n\n  \n  inputctl = (my_inputctl_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,\n                                sizeof(my_input_controller));\n  cinfo->inputctl = (struct jpeg_input_controller *)inputctl;\n  \n  inputctl->pub.consume_input = consume_markers;\n  inputctl->pub.reset_input_controller = reset_input_controller;\n  inputctl->pub.start_input_pass = start_input_pass;\n  inputctl->pub.finish_input_pass = finish_input_pass;\n  \n  inputctl->pub.has_multiple_scans = FALSE; \n  inputctl->pub.eoi_reached = FALSE;\n  inputctl->inheaders = TRUE;\n}", "Selected Statement": "inputctl->pub.consume_input = consume_markers;", "Function Input": {"cinfo": {"value": "0x106b2a8"}}, "Variable Values Before Statement": {"consume_markers": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 9, "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Source Code": "int libfshfs_extents_record_read_data(\n     libfshfs_fork_descriptor_t *fork_descriptor,\n     uint16_t extents_start_block_number,\n     const uint8_t *data,\n     size_t data_size,\n     libcerror_error_t **error )\n{\n\tstatic char *function                 = \"libfshfs_extents_record_read_data\";\n\tsize_t data_offset                    = 0;\n\tuint32_t physical_extent_block_number = 0;\n\tuint16_t extent_block_number          = 0;\n\tuint16_t extent_number_of_blocks      = 0;\n\tint extent_index                      = 0;\n\n\tif( fork_descriptor == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid fork descriptor.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( data == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_MISSING,\n\t\t \"%s: invalid data.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( data_size > (size_t) SSIZE_MAX )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: invalid data size value out of bounds.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n#if defined( HAVE_DEBUG_OUTPUT )\n\tif( libcnotify_verbose != 0 )\n\t{\n\t\tlibcnotify_printf(\n\t\t \"%s: extents records data:\\n\",\n\t\t function );\n\t\tlibcnotify_print_data(\n\t\t data,\n\t\t data_size,\n\t\t LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA );\n\t}\n#endif\n\tif( data_size != 12 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_UNSUPPORTED_VALUE,\n\t\t \"%s: unsupported extents record data size: %\" PRIzd \"\\n\",\n\t\t function,\n\t\t data_size );\n\n\t\treturn( -1 );\n\t}\n\twhile( data_offset < 12 )\n\t{\n\t\tbyte_stream_copy_to_uint16_big_endian(\n\t\t &( data[ data_offset ] ),\n\t\t extent_block_number );\n\n\t\tdata_offset += 2;\n\n\t\tbyte_stream_copy_to_uint16_big_endian(\n\t\t &( data[ data_offset ] ),\n\t\t extent_number_of_blocks );\n\n\t\tdata_offset += 2;\n\n\t\tphysical_extent_block_number = extent_block_number;\n\n\t\tif( extent_number_of_blocks > 0 )\n\t\t{\n\t\t\tphysical_extent_block_number += extents_start_block_number;\n\t\t}\n#if defined( HAVE_DEBUG_OUTPUT )\n\t\tif( libcnotify_verbose != 0 )\n\t\t{\n\t\t\tlibcnotify_printf(\n\t\t\t \"%s: extent: %d block number\\t\\t: %\" PRIu32 \" (%\" PRIu16 \")\\n\",\n\t\t\t function,\n\t\t\t extent_index,\n\t\t\t physical_extent_block_number,\n\t\t\t extent_block_number );\n\n\t\t\tlibcnotify_printf(\n\t\t\t \"%s: extent: %d number of blocks\\t\\t: %\" PRIu16 \"\\n\",\n\t\t\t function,\n\t\t\t extent_index,\n\t\t\t extent_number_of_blocks );\n\t\t}\n#endif \n\n\t\tfork_descriptor->extents[ extent_index ][ 0 ] = physical_extent_block_number;\n\t\tfork_descriptor->extents[ extent_index ][ 1 ] = extent_number_of_blocks;\n\n\t\tfork_descriptor->number_of_blocks_in_extents += extent_number_of_blocks;\n\n\t\textent_index++;\n\t}\n#if defined( HAVE_DEBUG_OUTPUT )\n\tif( libcnotify_verbose != 0 )\n\t{\n\t\tlibcnotify_printf(\n\t\t \"\\n\" );\n\t}\n#endif\n\treturn( 1 );\n}", "Selected Statement": "uint16_t extent_block_number          = 0;", "Function Input": {"data": {"value": "0x600 <error: Cannot access memory at address 0x600>"}, "data_size": {"value": "4809124"}, "error": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd8e0", "value": {"type_category": "unknown", "concrete_type": "libcerror_error_t", "value": "140737488346128"}}}, "extents_start_block_number": {"value": "0"}, "fork_descriptor": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"size": {"type_category": "unknown", "concrete_type": "uint64_t", "value": "0"}, "number_of_blocks": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, "extents": {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}]}, "number_of_blocks_in_extents": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 9, "Project Information": "libyal"}
{"Programming Language": "C", "Source Code": "ssh_socket ssh_socket_new(ssh_session session)\n{\n    ssh_socket s;\n\n    s = calloc(1, sizeof(struct ssh_socket_struct));\n    if (s == NULL) {\n        ssh_set_error_oom(session);\n        return NULL;\n    }\n    s->fd = SSH_INVALID_SOCKET;\n    s->last_errno = -1;\n    s->fd_is_socket = 1;\n    s->session = session;\n    s->in_buffer = ssh_buffer_new();\n    if (s->in_buffer == NULL) {\n        ssh_set_error_oom(session);\n        SAFE_FREE(s);\n        return NULL;\n    }\n    s->out_buffer=ssh_buffer_new();\n    if (s->out_buffer == NULL) {\n        ssh_set_error_oom(session);\n        SSH_BUFFER_FREE(s->in_buffer);\n        SAFE_FREE(s);\n        return NULL;\n    }\n    s->read_wontblock = 0;\n    s->write_wontblock = 0;\n    s->data_except = 0;\n    s->poll_handle = NULL;\n    s->state=SSH_SOCKET_NONE;\n    return s;\n}", "Selected Statement": "s->last_errno = -1;", "Function Input": {}, "Variable Values Before Statement": {"constant": "-1"}, "Value After Statement Execution": "-1", "Block_Size": 9, "Project Information": "libssh"}
{"Programming Language": "C", "Source Code": "ssize_t\ndatetime_parse_full(struct datetime *date, const char *str, size_t len,\n\t\t    const char *tzsuffix, int32_t offset)\n{\n\tsize_t n;\n\tdt_t dt;\n\tconst char *svp = str;\n\tchar c;\n\tint sec_of_day = 0, nanosecond = 0;\n\tint16_t tzindex = 0;\n\n\tn = dt_parse_iso_date(str, len, &dt);\n\tif (n == 0)\n\t\treturn 0;\n\n\tstr += n;\n\tlen -= n;\n\tif (len <= 0)\n\t\tgoto exit;\n\n\tc = *str++;\n\tif (c != 'T' && c != 't' && c != ' ')\n\t\treturn 0;\n\tlen--;\n\tif (len <= 0)\n\t\tgoto exit;\n\n\tn = dt_parse_iso_time(str, len, &sec_of_day, &nanosecond);\n\tif (n == 0)\n\t\treturn 0;\n\n\tstr += n;\n\tlen -= n;\n\tif (len <= 0)\n\t\tgoto exit;\n\n\t\n\ttime_t base = dt_epoch(dt) + sec_of_day - offset * 60;\n\tssize_t l;\n\tif (tzsuffix != NULL) {\n\t\tl = parse_tz_suffix(tzsuffix, strlen(tzsuffix), base,\n\t\t\t\t    &tzindex, &offset);\n\t\tif (l < 0)\n\t\t\treturn l;\n\t\tgoto exit;\n\t}\n\n\tif (*str == ' ') {\n\t\tstr++;\n\t\tlen--;\n\t}\n\tif (len <= 0)\n\t\tgoto exit;\n\n\tl = parse_tz_suffix(str, len, base, &tzindex, &offset);\n\tif (l < 0)\n\t\treturn l;\n\tstr += l;\n\nexit:\n\tdate->epoch = dt_epoch(dt) + sec_of_day - offset * 60;\n\tdate->nsec = nanosecond;\n\tdate->tzoffset = offset;\n\tdate->tzindex = tzindex;\n\n\treturn str - svp;\n}", "Selected Statement": "n = dt_parse_iso_date(str, len, &dt);", "Function Input": {}, "Variable Values Before Statement": {"str": "0xe70cd0 \"\"", "len": "0"}, "Value After Statement Execution": "0", "Function Name": "dt_parse_iso_date", "Block_Size": 9, "Project Information": "tarantool"}
{"Programming Language": "C", "Source Code": "static int write_rsa_hostkey(const char *rsakey_path)\n{\n    FILE *fp = NULL;\n    size_t nwritten;\n\n    fp = fopen(rsakey_path, \"wb\");\n    if (fp == NULL) {\n        return -1;\n    }\n\n    nwritten = fwrite(kRSAPrivateKeyPEM, 1, strlen(kRSAPrivateKeyPEM), fp);\n    fclose(fp);\n\n    if (nwritten != strlen(kRSAPrivateKeyPEM)) {\n        return -1;\n    }\n\n    return 0;\n}", "Selected Statement": "nwritten = fwrite(kRSAPrivateKeyPEM, 1, strlen(kRSAPrivateKeyPEM), fp);", "Function Input": {}, "Variable Values Before Statement": {"kRSAPrivateKeyPEM": "\"-----BEGIN RSA PRIVATE KEY-----\\nMIIEowIBAAKCAQEArAOREUWlBXJAKZ5hABYyxnRayDZP1bJeLbPVK+npxemrhHyZ\\ngjdbY3ADot+JRyWjvll2w2GI+3blt0j+x/ZWwjMKu/QYcycYp5HL01goxOxuusZb\\ni+KiHRGB6z0EMdXM7U82U7lA/j//HyZppyDjUDniWabXQJge8ksGXGTiFeAJ/687\\nuV+JJcjGPxAGFQxzyjitf/FrL9S0WGKZbyqeGDzyeBZ1NLIuaiOORyLGSW4duHLD\\nN78EmsJnwqg2gJQmRSaD4BNZMjtbfiFcSL9Uw4XQFTsWugUDEY1AU4c5g11nhzHz\\nBi9qMOt5DzrZQpD4j0gA2LOHpHhoOdg1ZuHrGQIDAQABAoIBAFJTaqy/jllq8vZ4\\nTKiD900wBvrns5HtSlHJTe80hqQoT+Sa1cWSxPR0eekL32Hjy9igbMzZ83uWzh7I\\nmtgNODy9vRdznfgO8CfTCaBfAzQsjFpr8QikMT6EUI/LpiRL1UaGsNOlSEvnSS0Z\\nb1uDzAdrjL+nsEHEDJud+K9jwSkCRifVMy7fLfaum+YKpdeEz7K2Mgm5pJ/Vg+9s\\nvI2V1q7HAOI4eUVTgJNHXy5ediRJlajQHf/lNUzHKqn7iH+JRl01gt62X8roG62b\\nTbFylbheqMm9awuSF2ucOcx+guuwhkPir8BEMb08j3hiK+TfwPdY0F6QH4OhiKK7\\nMTqTVgECgYEA0vmmu5GOBtwRmq6gVNCHhdLDQWaxAZqQRmRbzxVhFpbv0GjbQEF7\\ntttq3fjDrzDf6CE9RtZWw2BUSXVq+IXB/bXb1kgWU2xWywm+OFDk9OXQs8ui+MY7\\nFiP3yuq3YJob2g5CCsVQWl2CHvWGmTLhE1ODll39t7Y1uwdcDobJN+ECgYEA0LlR\\nhfMjydWmwqooU9TDjXNBmwufyYlNFTH351amYgFUDpNf35SMCP4hDosUw/zCTDpc\\n+1w04BJJfkH1SNvXSOilpdaYRTYuryDvGmWC66K2KX1nLErhlhs17CwzV997nYgD\\nH3OOU4HfqIKmdGbjvWlkmY+mLHyG10bbpOTbujkCgYAc68xHejSWDCT9p2KjPdLW\\nLYZGuOUa6y1L+QX85Vlh118Ymsczj8Z90qZbt3Zb1b9b+vKDe255agMj7syzNOLa\\n/MseHNOyq+9Z9gP1hGFekQKDIy88GzCOYG/fiT2KKJYY1kuHXnUdbiQgSlghODBS\\njehD/K6DOJ80/FVKSH/dAQKBgQDJ+apTzpZhJ2f5k6L2jDq3VEK2ACedZEm9Kt9T\\nc1wKFnL6r83kkuB3i0L9ycRMavixvwBfFDjuY4POs5Dh8ip/mPFCa0hqISZHvbzi\\ndDyePJO9zmXaTJPDJ42kfpkofVAnfohXFQEy+cguTk848J+MmMIKfyE0h0QMabr9\\n86BUsQKBgEVgoi4RXwmtGovtMew01ORPV9MOX3v+VnsCgD4/56URKOAngiS70xEP\\nONwNbTCWuuv43HGzJoVFiAMGnQP1BAJ7gkHkjSegOGKkiw12EPUWhFcMg+GkgPhc\\npOqNt/VMBPjJ/ysHJqmLfQK9A35JV6Cmdphe+OIl28bcKhAOz8Dw\\n-----END RSA PRIVATE KEY-----\\n\"", "1": "1", "fp": "NULL"}, "Value After Statement Execution": "1675", "Function Name": "fwrite", "Block_Size": 9, "Project Information": "libssh"}
{"Programming Language": "C", "Source Code": "GLOBAL(cjpeg_source_ptr)\njinit_read_bmp(j_compress_ptr cinfo, boolean use_inversion_array)\n{\n  bmp_source_ptr source;\n\n  \n  source = (bmp_source_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(bmp_source_struct));\n  source->cinfo = cinfo;        \n  \n  source->pub.start_input = start_input_bmp;\n  source->pub.finish_input = finish_input_bmp;\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n  source->pub.max_pixels = 0;\n#endif\n\n  source->use_inversion_array = use_inversion_array;\n\n  return (cjpeg_source_ptr)source;\n}", "Selected Statement": "source->pub.start_input = start_input_bmp;", "Function Input": {}, "Variable Values Before Statement": {"start_input_bmp": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 9, "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Source Code": "static int look_for_our_target(Dwarf_Debug dbg, struct target_data_s *td,\n                               Dwarf_Error *errp) {\n  Dwarf_Unsigned cu_header_length = 0;\n  Dwarf_Unsigned abbrev_offset = 0;\n  Dwarf_Half address_size = 0;\n  Dwarf_Half version_stamp = 0;\n  Dwarf_Half offset_size = 0;\n  Dwarf_Half extension_size = 0;\n  Dwarf_Unsigned typeoffset = 0;\n  Dwarf_Half header_cu_type = unittype;\n  Dwarf_Bool is_info = g_is_info;\n  int cu_number = 0;\n\n  for (;; ++cu_number) {\n    Dwarf_Die no_die = 0;\n    Dwarf_Die cu_die = 0;\n    int res = DW_DLV_ERROR;\n    Dwarf_Sig8 signature;\n\n    memset(&signature, 0, sizeof(signature));\n    res = dwarf_next_cu_header_d(dbg, is_info, &cu_header_length,\n                                 &version_stamp, &abbrev_offset, &address_size,\n                                 &offset_size, &extension_size, &signature,\n                                 &typeoffset, 0, &header_cu_type, errp);\n    if (res == DW_DLV_ERROR) {\n      if (errp) {\n        char *em = dwarf_errmsg(*errp);\n      }\n      return DW_DLV_NO_ENTRY;\n    }\n    if (res == DW_DLV_NO_ENTRY) {\n      return DW_DLV_NO_ENTRY;\n    }\n    cu_version_stamp = version_stamp;\n    cu_offset_size = offset_size;\n    res = dwarf_siblingof_b(dbg, no_die, is_info, &cu_die, errp);\n    if (res == DW_DLV_ERROR) {\n      if (errp) {\n        char *em = dwarf_errmsg(*errp);\n      }\n      return res;\n    }\n    if (res == DW_DLV_NO_ENTRY) {\n      return res;\n    }\n\n    td->td_cu_die = cu_die;\n    res = get_die_and_siblings(dbg, cu_die, is_info, 0, cu_number, td, errp);\n    if (res == FOUND_SUBPROG) {\n      read_line_data(dbg, td, errp);\n      if (td->td_reportallfound) {\n        return res;\n      }\n      return res;\n    } else if (res == IN_THIS_CU) {\n      if (errp) {\n          char *em = dwarf_errmsg(*errp);\n      }\n      return res;\n    } else if (res == DW_DLV_ERROR) {\n      if (errp) {\n        char *em = dwarf_errmsg(*errp);\n      }\n      return DW_DLV_ERROR;\n    }\n    return DW_DLV_NO_ENTRY;\n  }\n}", "Selected Statement": "Dwarf_Bool is_info = g_is_info;", "Function Input": {}, "Variable Values Before Statement": {"g_is_info": "Dwarf_Bool"}, "Value After Statement Execution": "Dwarf_Bool", "Block_Size": 9, "Project Information": "libdwarf"}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;\n}", "Selected Statement": "uri->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);", "Function Input": {}, "Variable Values Before Statement": {"uri_raw.password": "NULL", "uri_raw.password_len": "0"}, "Value After Statement Execution": "NULL", "Function Name": "XSTRNDUP", "Block_Size": 9, "Project Information": "tarantool"}
{"Programming Language": "C", "Source Code": "void\nscreen_init(struct screen *s, u_int sx, u_int sy, u_int hlimit)\n{\n\ts->grid = grid_create(sx, sy, hlimit);\n\ts->saved_grid = NULL;\n\n\ts->title = xstrdup(\"\");\n\ts->titles = NULL;\n\ts->path = NULL;\n\n\ts->cstyle = SCREEN_CURSOR_DEFAULT;\n\ts->default_cstyle = SCREEN_CURSOR_DEFAULT;\n\ts->mode = MODE_CURSOR;\n\ts->default_mode = 0;\n\ts->ccolour = -1;\n\ts->default_ccolour = -1;\n\ts->tabs = NULL;\n\ts->sel = NULL;\n\n#ifdef ENABLE_SIXEL\n\tTAILQ_INIT(&s->images);\n#endif\n\n\ts->write_list = NULL;\n\ts->hyperlinks = NULL;\n\n\tscreen_reinit(s);\n}", "Selected Statement": "s->default_cstyle = SCREEN_CURSOR_DEFAULT;", "Function Input": {"s": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"title": {"type_category": "string", "concrete_type": "string", "value": "0x800000008 <error: Cannot access memory at address 0x800000008>"}, "path": {"type_category": "string", "concrete_type": "NULL"}, "titles": {"type_category": "pointer", "concrete_type": "NULL"}, "grid": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x26ebb10", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xffffffff\n", "message": "Cannot access memory at address 0xffffffff"}}, "cx": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "cy": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "cstyle": {"type_category": "unknown", "concrete_type": "screen_cursor_style", "value": "SCREEN_CURSOR_DEFAULT"}, "default_cstyle": {"type_category": "unknown", "concrete_type": "screen_cursor_style", "value": "SCREEN_CURSOR_DEFAULT"}, "ccolour": {"type_category": "int", "concrete_type": "int", "value": "0"}, "default_ccolour": {"type_category": "int", "concrete_type": "int", "value": "0"}, "rupper": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "rlower": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "mode": {"type_category": "int", "concrete_type": "int", "value": "0"}, "default_mode": {"type_category": "int", "concrete_type": "int", "value": "0"}, "saved_cx": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "saved_cy": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}, "saved_grid": {"type_category": "pointer", "concrete_type": "NULL"}, "saved_cell": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"data": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"data": {"type_category": "string", "concrete_type": "string", "value": "\"\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\""}, "have": {"type_category": "unknown", "concrete_type": "u_char", "value": "0 '\\000'"}, "size": {"type_category": "unknown", "concrete_type": "u_char", "value": "0 '\\000'"}, "width": {"type_category": "unknown", "concrete_type": "u_char", "value": "0 '\\000'"}}}, "attr": {"type_category": "unknown", "concrete_type": "u_short", "value": "0"}, "flags": {"type_category": "unknown", "concrete_type": "u_char", "value": "0 '\\000'"}, "fg": {"type_category": "int", "concrete_type": "int", "value": "0"}, "bg": {"type_category": "int", "concrete_type": "int", "value": "0"}, "us": {"type_category": "int", "concrete_type": "int", "value": "0"}, "link": {"type_category": "unknown", "concrete_type": "u_int", "value": "0"}}}, "saved_flags": {"type_category": "int", "concrete_type": "int", "value": "0"}, "tabs": {"type_category": "string", "concrete_type": "NULL"}, "sel": {"type_category": "pointer", "concrete_type": "NULL"}, "write_list": {"type_category": "pointer", "concrete_type": "NULL"}, "hyperlinks": {"type_category": "pointer", "concrete_type": "NULL"}}}}}, "Variable Values Before Statement": {"SCREEN_CURSOR_DEFAULT": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 9, "Project Information": "tmux"}
{"Programming Language": "C", "Source Code": "void\nWS_Init(struct ws *ws, const char *id, void *space, unsigned len)\n{\n\tstruct ws_emu *we;\n\n\tDSLb(DBG_WORKSPACE,\n\t    \"WS_Init(%p, \\\"%s\\\", %p, %u)\", ws, id, space, len);\n\tassert(space != NULL);\n\tassert(PAOK(space));\n\tassert(len >= sizeof *we);\n\n\tlen = PRNDDN(len - 1);\n\tINIT_OBJ(ws, WS_MAGIC);\n\tws->s = space;\n\tws->e = ws->s + len;\n\n\tassert(id[0] & 0x20);\t\t\n\tbstrcpy(ws->id, id);\n\n\twe = space;\n\tINIT_OBJ(we, WS_EMU_MAGIC);\n\tVTAILQ_INIT(&we->head);\n\twe->len = len;\n\n\tWS_Assert(ws);\n}", "Selected Statement": "len = PRNDDN(len - 1);", "Function Input": {"ws": {"value": null}}, "Variable Values Before Statement": {}, "Value After Statement Execution": "unsigned int", "Function Name": "PRNDDN", "Block_Size": 9, "Project Information": "varnish"}
{"Programming Language": "C", "Source Code": "int Parser_LoadDocument(\n\t\n\tIXML_Document **retDoc,\n\t\n\tconst char *xmlFileName,\n\t\n\tint file)\n{\n\tint rc = IXML_SUCCESS;\n\tParser *xmlParser = NULL;\n\n\txmlParser = Parser_init();\n\tif (xmlParser == NULL) {\n\t\treturn IXML_INSUFFICIENT_MEMORY;\n\t}\n\n\trc = Parser_readFileOrBuffer(xmlParser, xmlFileName, file);\n\tif (rc != IXML_SUCCESS) {\n\t\tParser_free(xmlParser);\n\t\treturn rc;\n\t}\n\n\txmlParser->curPtr = xmlParser->dataBuffer;\n\trc = Parser_parseDocument(retDoc, xmlParser);\n\treturn rc;\n}", "Selected Statement": "int rc = IXML_SUCCESS;", "Function Input": {}, "Variable Values Before Statement": {"IXML_SUCCESS": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 9, "Project Information": "pupnp"}
{"Programming Language": "C", "Source Code": "void hostpid_init(void)\n{\n\tstatic char pid[MAX_INT_STRLEN];\n\tchar hostname[256];\n\tconst char *value;\n\n\t\n\ti_free_and_null(my_hostname_dup);\n\ti_free_and_null(my_domain);\n\n\tvalue = getenv(MY_HOSTNAME_ENV);\n\tif (value == NULL) {\n\t\tif (gethostname(hostname, sizeof(hostname)-1) < 0)\n\t\t\ti_fatal(\"gethostname() failed: %m\");\n\t\thostname[sizeof(hostname)-1] = '\\0';\n\t\tvalue = hostname;\n\t}\n\n\tif (value[0] == '\\0' ||\n\t    strcspn(value, HOSTNAME_DISALLOWED_CHARS) != strlen(value))\n\t\ti_fatal(\"Invalid system hostname: '%s'\", value);\n\tmy_hostname_dup = i_strdup(value);\n\tmy_hostname = my_hostname_dup;\n\n\ti_snprintf(pid, sizeof(pid), \"%lld\", (long long)getpid());\n\tmy_pid = pid;\n}", "Selected Statement": "value = getenv(MY_HOSTNAME_ENV);", "Function Input": {}, "Variable Values Before Statement": {"MY_HOSTNAME_ENV": "NULL"}, "Value After Statement Execution": "NULL", "Function Name": "getenv", "Block_Size": 9, "Project Information": "dovecot"}
{"Programming Language": "C", "Source Code": "krb5_error_code\nndr_dec_delegation_info(krb5_data *data, struct pac_s4u_delegation_info **out)\n{\n    krb5_error_code ret;\n    struct pac_s4u_delegation_info *di = NULL;\n    struct k5input in;\n    uint32_t i, object_buffer_length, nservices;\n    uint8_t version, endianness, common_header_length;\n\n    *out = NULL;\n\n    di = k5alloc(sizeof(*di), &ret);\n    if (di == NULL)\n        return ret;\n\n    k5_input_init(&in, data->data, data->length);\n\n    \n    version = k5_input_get_byte(&in);\n    endianness = k5_input_get_byte(&in);\n    common_header_length = k5_input_get_uint16_le(&in);\n    (void)k5_input_get_uint32_le(&in); \n    if (version != 1 || endianness != 0x10 || common_header_length != 8) {\n        ret = EINVAL;\n        goto error;\n    }\n\n    \n    object_buffer_length = k5_input_get_uint32_le(&in);\n    if (data->length < 16 || object_buffer_length != data->length - 16) {\n        ret = EINVAL;\n        goto error;\n    }\n\n    (void)k5_input_get_uint32_le(&in); \n\n    \n\n    \n    (void)k5_input_get_uint32_le(&in);\n    \n    (void)k5_input_get_uint16_le(&in);\n    \n    (void)k5_input_get_uint16_le(&in);\n    \n    (void)k5_input_get_uint32_le(&in);\n\n    \n    (void)k5_input_get_uint32_le(&in);\n\n    \n    (void)k5_input_get_uint32_le(&in);\n\n    ret = dec_wchar_pointer(&in, &di->proxy_target);\n    if (ret)\n        goto error;\n    nservices = k5_input_get_uint32_le(&in);\n\n    \n    if (nservices > data->length / 8) {\n        ret = ERANGE;\n        goto error;\n    }\n    (void)k5_input_get_bytes(&in, 8 * nservices);\n\n    \n    di->transited_services = k5calloc(nservices + 1, sizeof(char *), &ret);\n    if (di->transited_services == NULL)\n        goto error;\n\n    for (i = 0; i < nservices; i++) {\n        ret = dec_wchar_pointer(&in, &di->transited_services[i]);\n        if (ret)\n            goto error;\n        di->transited_services_length++;\n    }\n\n    ret = in.status;\n    if (ret)\n        goto error;\n\n    *out = di;\n    return 0;\n\nerror:\n    ndr_free_delegation_info(di);\n    return ret;\n}", "Selected Statement": "di = k5alloc(sizeof(*di), &ret);", "Function Input": {"in": {"value": {"ptr": {"type_category": "string", "concrete_type": "NULL"}, "len": {"type_category": "unknown", "concrete_type": "size_t", "value": "4242681"}, "status": {"type_category": "unknown", "concrete_type": "int32_t", "value": "5350024"}}}, "out": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0xf3bbe0", "value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x1332bcc00081001\n", "message": "Cannot access memory at address 0x1332bcc00081001"}}}}, "Variable Values Before Statement": {}, "Value After Statement Execution": {"proxy_target": null, "transited_services_length": "0", "transited_services": null}, "Function Name": "k5alloc", "Block_Size": 9, "Project Information": "krb5"}
{"Programming Language": "C", "Source Code": "int device_alloc(struct crypt_device *cd, struct device **device, const char *path)\n{\n\tstruct device *dev;\n\tint r;\n\n\tr = device_alloc_no_check(&dev, path);\n\tif (r < 0)\n\t\treturn r;\n\n\tif (dev) {\n\t\tr = device_ready(cd, dev);\n\t\tif (!r) {\n\t\t\tdev->init_done = 1;\n\t\t} else if (r == -ENOTBLK) {\n\t\t\t\n\t\t} else if (r < 0) {\n\t\t\tfree(dev->path);\n\t\t\tfree(dev);\n\t\t\treturn -ENOTBLK;\n\t\t}\n\t}\n\n\t*device = dev;\n\treturn 0;\n}", "Selected Statement": "r = device_ready(cd, dev);", "Function Input": {}, "Variable Values Before Statement": {"cd": "NULL", "dev": {"path": "0x1825970 \"/tmp/test-script-fuzz.o5sGzP\"", "file_path": null, "loop_fd": "-1", "ro_dev_fd": "-1", "dev_fd": "-1", "dev_fd_excl": "-1", "lh": null, "o_direct": "1", "init_done": "0", "alignment": "4096", "block_size": "4096", "loop_block_size": "0"}}, "Value After Statement Execution": "int", "Function Name": "device_ready", "Block_Size": 9, "Project Information": "cryptsetup"}
{"Programming Language": "C", "Source Code": "int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud) {\n  l_uint32 oldnCcalls = L->nCcalls;\n  struct lua_longjmp lj;\n  lj.status = LUA_OK;\n  lj.previous = L->errorJmp;  \n  L->errorJmp = &lj;\n  LUAI_TRY(L, &lj,\n    (*f)(L, ud);\n  );\n  L->errorJmp = lj.previous;  \n  L->nCcalls = oldnCcalls;\n  return lj.status;\n}", "Selected Statement": "L->nCcalls = oldnCcalls;", "Function Input": {"L": {"value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x3000000040\n", "message": "Cannot access memory at address 0x3000000040"}}}, "Variable Values Before Statement": {"oldnCcalls": "l_uint32"}, "Value After Statement Execution": "l_uint32", "Block_Size": 9, "Project Information": "lua"}
{"Programming Language": "C", "Source Code": "int strappend(char **a, const char *b)\n{\n\tsize_t al, bl;\n\tchar *tmp;\n\n\tif (!a)\n\t\treturn -EINVAL;\n\tif (!b || !*b)\n\t\treturn 0;\n\tif (!*a) {\n\t\t*a = strdup(b);\n\t\treturn !*a ? -ENOMEM : 0;\n\t}\n\n\tal = strlen(*a);\n\tbl = strlen(b);\n\n\ttmp = realloc(*a, al + bl + 1);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\t*a = tmp;\n\tmemcpy((*a) + al, b, bl + 1);\n\treturn 0;\n}", "Selected Statement": "*a = strdup(b);", "Function Input": {}, "Variable Values Before Statement": {"b": "0x1056ca0 \"#\\n\""}, "Value After Statement Execution": "NULL", "Function Name": "strdup", "Block_Size": 9, "Project Information": "util-linux"}
{"Programming Language": "C", "Source Code": "GLOBAL(void)\njinit_input_controller(j_decompress_ptr cinfo)\n{\n  my_inputctl_ptr inputctl;\n\n  \n  inputctl = (my_inputctl_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,\n                                sizeof(my_input_controller));\n  cinfo->inputctl = (struct jpeg_input_controller *)inputctl;\n  \n  inputctl->pub.consume_input = consume_markers;\n  inputctl->pub.reset_input_controller = reset_input_controller;\n  inputctl->pub.start_input_pass = start_input_pass;\n  inputctl->pub.finish_input_pass = finish_input_pass;\n  \n  inputctl->pub.has_multiple_scans = FALSE; \n  inputctl->pub.eoi_reached = FALSE;\n  inputctl->inheaders = TRUE;\n}", "Selected Statement": "inputctl->pub.consume_input = consume_markers;", "Function Input": {"cinfo": {"value": "0x110a298"}}, "Variable Values Before Statement": {"consume_markers": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 9, "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Source Code": "ssh_agent ssh_agent_new(struct ssh_session_struct *session) {\n  ssh_agent agent = NULL;\n\n  agent = malloc(sizeof(struct ssh_agent_struct));\n  if (agent == NULL) {\n    return NULL;\n  }\n  ZERO_STRUCTP(agent);\n\n  agent->count = 0;\n  agent->sock = ssh_socket_new(session);\n  if (agent->sock == NULL) {\n    SAFE_FREE(agent);\n    return NULL;\n  }\n  agent->channel = NULL;\n  return agent;\n}", "Selected Statement": "agent->sock = ssh_socket_new(session);", "Function Input": {"agent": {"value": "0x510b29 <ssh_set_blocking+105>"}}, "Variable Values Before Statement": {"session": {"common": null, "socket": null, "serverbanner": null, "clientbanner": null, "protoversion": "0", "server": "0", "client": "0", "openssh": "0", "send_seq": "0", "recv_seq": "0", "last_rekey_time": null, "connected": "0", "alive": "0", "flags": "1", "extensions": "0", "banner": null, "peer_discon_msg": null, "disconnect_message": null, "in_buffer": "0x125aaa0", "in_packet": null, "out_buffer": "0x125aa30", "out_queue": null, "pending_call_state": "SSH_PENDING_CALL_NONE", "session_state": "SSH_SESSION_STATE_NONE", "packet_state": "PACKET_STATE_INIT", "dh_handshake_state": "DH_STATE_INIT", "global_req_state": "SSH_CHANNEL_REQ_STATE_NONE", "agent_state": null, "auth": null, "send_first_kex_follows": "false", "first_kex_follows_guess_wrong": "false", "in_hashbuf": null, "out_hashbuf": null, "current_crypto": null, "next_crypto": null, "channels": null, "maxchannel": "42", "agent": null, "kbdint": null, "gssapi": null, "srv": null, "ssh_message_list": null, "ssh_message_callback": null, "ssh_message_callback_data": null, "server_callbacks": null, "ssh_connection_callback": null, "default_packet_callbacks": null, "packet_callbacks": null, "socket_callbacks": null, "default_poll_ctx": null, "pcap_ctx": null, "opts": null, "socket_counter": null, "raw_counter": null}}, "Value After Statement Execution": "NULL", "Function Name": "ssh_socket_new", "Block_Size": 9, "Project Information": "libssh"}
{"Programming Language": "C", "Source Code": "int\nparse_packet(sldns_buffer* pkt, struct msg_parse* msg, struct regional* region)\n{\n\tint ret;\n\tif(sldns_buffer_remaining(pkt) < LDNS_HEADER_SIZE)\n\t\treturn LDNS_RCODE_FORMERR;\n\t\n\tsldns_buffer_read(pkt, &msg->id, sizeof(uint16_t));\n\tmsg->flags = sldns_buffer_read_u16(pkt);\n\tmsg->qdcount = sldns_buffer_read_u16(pkt);\n\tmsg->ancount = sldns_buffer_read_u16(pkt);\n\tmsg->nscount = sldns_buffer_read_u16(pkt);\n\tmsg->arcount = sldns_buffer_read_u16(pkt);\n\tif(msg->qdcount > 1)\n\t\treturn LDNS_RCODE_FORMERR;\n\tif((ret = parse_query_section(pkt, msg)) != 0)\n\t\treturn ret;\n\tif((ret = parse_section(pkt, msg, region, LDNS_SECTION_ANSWER,\n\t\tmsg->ancount, &msg->an_rrsets)) != 0)\n\t\treturn ret;\n\tif((ret = parse_section(pkt, msg, region, LDNS_SECTION_AUTHORITY,\n\t\tmsg->nscount, &msg->ns_rrsets)) != 0)\n\t\treturn ret;\n\tif(sldns_buffer_remaining(pkt) == 0 && msg->arcount == 1) {\n\t\t\n\t} else if((ret = parse_section(pkt, msg, region,\n\t\tLDNS_SECTION_ADDITIONAL, msg->arcount, &msg->ar_rrsets)) != 0)\n\t\treturn ret;\n\t\n\t\t\n\t\n\tmsg->rrset_count = msg->an_rrsets + msg->ns_rrsets + msg->ar_rrsets;\n\treturn 0;\n}", "Selected Statement": "msg->nscount = sldns_buffer_read_u16(pkt);", "Function Input": {"pkt": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"_position": {"type_category": "unknown", "concrete_type": "size_t", "value": "0"}, "_limit": {"type_category": "unknown", "concrete_type": "size_t", "value": "12"}, "_capacity": {"type_category": "unknown", "concrete_type": "size_t", "value": "3546920299816956257"}, "_data": {"type_category": "string", "concrete_type": "string", "value": "0x31 <error: Cannot access memory at address 0x31>"}, "_fixed": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}, "_status_err": {"type_category": "int", "concrete_type": "unsigned int", "value": "0"}}}}}, "Variable Values Before Statement": {"pkt": {"_position": "10", "_limit": "12", "_capacity": "12", "_data": "0x11e62d0 \"\"", "_fixed": "1", "_status_err": "0"}}, "Value After Statement Execution": "3072", "Function Name": "sldns_buffer_read_u16", "Block_Size": 9, "Project Information": "unbound"}
{"Programming Language": "C", "Source Code": "void luaS_init (lua_State *L) {\n  global_State *g = G(L);\n  int i, j;\n  stringtable *tb = &G(L)->strt;\n  tb->hash = luaM_newvector(L, MINSTRTABSIZE, TString*);\n  tablerehash(tb->hash, 0, MINSTRTABSIZE);  \n  tb->size = MINSTRTABSIZE;\n  \n  g->memerrmsg = luaS_newliteral(L, MEMERRMSG);\n  luaC_fix(L, obj2gco(g->memerrmsg));  \n  for (i = 0; i < STRCACHE_N; i++)  \n    for (j = 0; j < STRCACHE_M; j++)\n      g->strcache[i][j] = g->memerrmsg;\n}", "Selected Statement": "for (i = 0; i < STRCACHE_N; i++)  /* fill cache with valid strings */", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 9, "Project Information": "lua"}
{"Programming Language": "C", "Source Code": "void\np11_rpc_message_init (p11_rpc_message *msg,\n                      p11_buffer *input,\n                      p11_buffer *output)\n{\n\tassert (input != NULL);\n\tassert (output != NULL);\n\tassert (output->ffree != NULL);\n\tassert (output->frealloc != NULL);\n\n\tmemset (msg, 0, sizeof (*msg));\n\n\tmsg->output = output;\n\tmsg->input = input;\n}", "Selected Statement": "msg->output = output;", "Function Input": {"input": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"data": {"type_category": "pointer", "concrete_type": "VOID"}, "len": {"type_category": "unknown", "concrete_type": "size_t", "value": "7171829"}, "flags": {"type_category": "int", "concrete_type": "int", "value": "0"}, "size": {"type_category": "unknown", "concrete_type": "size_t", "value": "140737488346912"}, "frealloc": {"type_category": "pointer", "concrete_type": "NULL"}, "ffree": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffde38", "value": {"type_category": "unknown", "concrete_type": "unknown", "value": "{void (void *)} 0x7fffffffde80"}}}}}, "msg": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"call_id": {"type_category": "int", "concrete_type": "int", "value": "0"}, "call_type": {"type_category": "unknown", "concrete_type": "p11_rpc_message_type", "value": "0"}, "signature": {"type_category": "string", "concrete_type": "NULL"}, "input": {"type_category": "pointer", "concrete_type": "NULL"}, "output": {"type_category": "pointer", "concrete_type": "NULL"}, "parsed": {"type_category": "unknown", "concrete_type": "size_t", "value": "0"}, "sigverify": {"type_category": "string", "concrete_type": "NULL"}, "extra": {"type_category": "pointer", "concrete_type": "NULL"}}}}, "output": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"data": {"type_category": "pointer", "concrete_type": "VOID"}, "len": {"type_category": "unknown", "concrete_type": "size_t", "value": "13906552813760349578"}, "flags": {"type_category": "int", "concrete_type": "int", "value": "-1570962040"}, "size": {"type_category": "unknown", "concrete_type": "size_t", "value": "13963209366481488104"}, "frealloc": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x6f4030 <thread_local_message+32>", "value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x98b4864fffffdd0\n", "message": "Cannot access memory at address 0x98b4864fffffdd0"}}, "ffree": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x6f4038 <thread_local_message+40>", "value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xf830fc83948\n", "message": "Cannot access memory at address 0xf830fc83948"}}}}}}, "Variable Values Before Statement": {"output": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 10, "Project Information": "p11-kit"}
{"Programming Language": "C", "Source Code": "int\nuri_create(struct uri *uri, const char *str)\n{\n\tmemset(uri, 0, sizeof(struct uri));\n\tif (str == NULL)\n\t\treturn 0;\n\tstruct uri_raw uri_raw;\n\tif (uri_raw_parse(&uri_raw, str) != 0)\n\t\treturn -1;\n\turi->scheme = XSTRNDUP(uri_raw.scheme, uri_raw.scheme_len);\n\turi->login = XSTRNDUP(uri_raw.login, uri_raw.login_len);\n\turi->password = XSTRNDUP(uri_raw.password, uri_raw.password_len);\n\turi->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);\n\turi->service = XSTRNDUP(uri_raw.service, uri_raw.service_len);\n\turi->path = XSTRNDUP(uri_raw.path, uri_raw.path_len);\n\turi->query = XSTRNDUP(uri_raw.query, uri_raw.query_len);\n\turi->fragment = XSTRNDUP(uri_raw.fragment, uri_raw.fragment_len);\n\turi->host_hint = uri_raw.host_hint;\n\tif (uri->query != NULL)\n\t\turi_create_params(uri, uri->query);\n\treturn 0;\n}", "Selected Statement": "uri->host = XSTRNDUP(uri_raw.host, uri_raw.host_len);", "Function Input": {}, "Variable Values Before Statement": {"uri_raw.host": "0xd0b580 \";E\"", "uri_raw.host_len": "2"}, "Value After Statement Execution": "0xd0f4b0 \";E\"", "Function Name": "XSTRNDUP", "Block_Size": 10, "Project Information": "tarantool"}
{"Programming Language": "C", "Source Code": "nxt_int_t\nnxt_lib_start(const char *app, char **argv, char ***envp)\n{\n    int           n;\n    nxt_int_t     flags;\n    nxt_bool_t    update;\n    nxt_thread_t  *thread;\n\n    flags = nxt_stderr_start();\n\n    nxt_log_start(app);\n\n    nxt_pid = getpid();\n    nxt_ppid = getppid();\n    nxt_euid = geteuid();\n    nxt_egid = getegid();\n\n#if (NXT_DEBUG)\n\n    nxt_main_log.level = NXT_LOG_DEBUG;\n\n#if (NXT_HAVE_MALLOPT)\n    \n    mallopt(M_PERTURB, 0x55);\n#endif\n\n#if (NXT_MACOSX)\n    \n    setenv(\"MallocScribble\", \"1\", 0);\n#endif\n\n#endif \n\n    \n\n    nxt_thread_init_data(nxt_thread_context);\n    thread = nxt_thread();\n    thread->log = &nxt_main_log;\n\n    thread->handle = nxt_thread_handle();\n    thread->time.signal = -1;\n    nxt_thread_time_update(thread);\n\n    nxt_main_task.thread = thread;\n    nxt_main_task.log = thread->log;\n    nxt_main_task.ident = nxt_task_next_ident();\n\n    if (nxt_strerror_start() != NXT_OK) {\n        return NXT_ERROR;\n    }\n\n    if (flags != -1) {\n        nxt_debug(&nxt_main_task, \"stderr flags: 0x%04Xd\", flags);\n    }\n\n#ifdef _SC_NPROCESSORS_ONLN\n    \n    n = sysconf(_SC_NPROCESSORS_ONLN);\n\n#elif (NXT_HPUX)\n    n = mpctl(MPC_GETNUMSPUS, NULL, NULL);\n\n#else\n    n = 0;\n\n#endif\n\n    nxt_debug(&nxt_main_task, \"ncpu: %d\", n);\n\n    if (n > 1) {\n        nxt_ncpu = n;\n    }\n\n    nxt_thread_spin_init(nxt_ncpu, 0);\n\n    nxt_random_init(&thread->random);\n\n    nxt_pagesize = getpagesize();\n\n    nxt_debug(&nxt_main_task, \"pagesize: %ui\", nxt_pagesize);\n\n    if (argv != NULL) {\n        update = (argv[0] == app);\n\n        nxt_process_arguments(&nxt_main_task, argv, envp);\n\n        if (update) {\n            nxt_log_start(nxt_process_argv[0]);\n        }\n    }\n\n    return NXT_OK;\n}", "Selected Statement": "nxt_pid = getpid();", "Function Input": {"app": {"value": "0x622e00 <vtable for std::__Fuzzer::ios_base::failure+8> \"\\260.b\""}, "argv": {"value": {"type_category": "string", "concrete_type": "string", "value": "0x8c48348707e8b49 <error: Cannot access memory at address 0x8c48348707e8b49>"}}, "envp": {"value": null}}, "Variable Values Before Statement": {}, "Value After Statement Execution": "NULL", "Function Name": "getpid", "Block_Size": 10, "Project Information": "unit"}
{"Programming Language": "C", "Source Code": "int\ndwarf_crc32 (Dwarf_Debug dbg,unsigned char *crcbuf,\n    Dwarf_Error *error)\n{\n    \n    \n\n    \n    Dwarf_Unsigned   fsize = 0;\n    \n    Dwarf_Unsigned  readlenu = 10000;\n    Dwarf_Unsigned  size_left = 0;\n    const unsigned char *readbuf = 0;\n    unsigned int   tcrc = 0;\n    unsigned int   init = 0;\n    int            fd = -1;\n    Dwarf_Unsigned   sz = 0;\n    int            res = 0;\n\n    CHECK_DBG(dbg,error,\"dwarf_crc32()\");\n    if (!crcbuf) {\n        return DW_DLV_NO_ENTRY;\n    }\n    if (!dbg->de_owns_fd) {\n        return DW_DLV_NO_ENTRY;\n    }\n    fd = dbg->de_fd;\n    if (fd < 0) {\n        return DW_DLV_NO_ENTRY;\n    }\n    fd = dbg->de_fd;\n    if (dbg->de_filesize) {\n        fsize = (size_t)dbg->de_filesize;\n    } else {\n        res = _dwarf_seekr(fd,0,SEEK_END,&sz);\n        if (res != DW_DLV_OK) {\n            _dwarf_error_string(dbg,error,DW_DLE_SEEK_ERROR,\n                \"DW_DLE_SEEK_ERROR: dwarf_crc32 seek \"\n                \"to end fails\");\n            return DW_DLV_ERROR;\n        }\n        fsize = sz;\n    }\n    if (fsize <= (Dwarf_Unsigned)500) {\n        \n        return DW_DLV_NO_ENTRY;\n    }\n    size_left = fsize;\n    res = _dwarf_seekr(fd,0,SEEK_SET,0);\n    if (res != DW_DLV_OK) {\n        _dwarf_error_string(dbg,error,DW_DLE_SEEK_ERROR,\n            \"DW_DLE_SEEK_ERROR: dwarf_crc32 seek \"\n            \"to start fails\");\n        return DW_DLV_ERROR;\n    }\n    readbuf = (unsigned char *)malloc(readlenu);\n    if (!readbuf) {\n        _dwarf_error_string(dbg,error,DW_DLE_ALLOC_FAIL,\n            \"DW_DLE_ALLOC_FAIL: dwarf_crc32 read buffer\"\n            \" alloc fails\");\n        return DW_DLV_ERROR;\n    }\n    while (size_left > 0) {\n        if (size_left < readlenu) {\n            readlenu = size_left;\n        }\n        res = _dwarf_readr(fd,(char *)readbuf,readlenu,0);\n        if (res != DW_DLV_OK) {\n            _dwarf_error_string(dbg,error,DW_DLE_READ_ERROR,\n                \"DW_DLE_READ_ERROR: dwarf_crc32 read fails \");\n            free((unsigned char*)readbuf);\n            return DW_DLV_ERROR;\n        }\n        \n        tcrc = (unsigned int)dwarf_basic_crc32(readbuf,\n            (unsigned long)readlenu,\n            (unsigned long)init);\n        init = tcrc;\n        size_left -= readlenu;\n    }\n    \n    free((unsigned char*)readbuf);\n    memcpy(crcbuf,(void *)&tcrc,4);\n    return DW_DLV_OK;\n}", "Selected Statement": "Dwarf_Unsigned  size_left = 0;", "Function Input": {"crcbuf": {"value": null}, "dbg": {"value": "0xfd1bf0"}, "error": {"value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0x100000003\n", "message": "Cannot access memory at address 0x100000003"}}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 10, "Project Information": "libdwarf"}
{"Programming Language": "C", "Source Code": "GLOBAL(void)\njinit_input_controller(j_decompress_ptr cinfo)\n{\n  my_inputctl_ptr inputctl;\n\n  \n  inputctl = (my_inputctl_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,\n                                sizeof(my_input_controller));\n  cinfo->inputctl = (struct jpeg_input_controller *)inputctl;\n  \n  inputctl->pub.consume_input = consume_markers;\n  inputctl->pub.reset_input_controller = reset_input_controller;\n  inputctl->pub.start_input_pass = start_input_pass;\n  inputctl->pub.finish_input_pass = finish_input_pass;\n  \n  inputctl->pub.has_multiple_scans = FALSE; \n  inputctl->pub.eoi_reached = FALSE;\n  inputctl->inheaders = TRUE;\n}", "Selected Statement": "inputctl->pub.reset_input_controller = reset_input_controller;", "Function Input": {"cinfo": {"value": "0x106b2a8"}}, "Variable Values Before Statement": {"reset_input_controller": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 10, "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Source Code": "void luaT_init (lua_State *L) {\n  static const char *const luaT_eventname[] = {  \n    \"__index\", \"__newindex\",\n    \"__gc\", \"__mode\", \"__len\", \"__eq\",\n    \"__add\", \"__sub\", \"__mul\", \"__mod\", \"__pow\",\n    \"__div\", \"__idiv\",\n    \"__band\", \"__bor\", \"__bxor\", \"__shl\", \"__shr\",\n    \"__unm\", \"__bnot\", \"__lt\", \"__le\",\n    \"__concat\", \"__call\", \"__close\"\n  };\n  int i;\n  for (i=0; i<TM_N; i++) {\n    G(L)->tmname[i] = luaS_new(L, luaT_eventname[i]);\n    luaC_fix(L, obj2gco(G(L)->tmname[i]));  \n  }\n}", "Selected Statement": "for (i=0; i<TM_N; i++) {", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 10, "Project Information": "lua"}
{"Programming Language": "C", "Source Code": "int\ndwarf_init_b(int fd,\n    unsigned        group_number,\n    Dwarf_Handler   errhand,\n    Dwarf_Ptr       errarg,\n    Dwarf_Debug *   ret_dbg,\n    Dwarf_Error *   error)\n{\n    unsigned ftype = 0;\n    unsigned endian = 0;\n    unsigned offsetsize = 0;\n    unsigned universalnumber = 0;\n    Dwarf_Unsigned   filesize = 0;\n    int res = 0;\n    int errcode = 0;\n\n    if (!ret_dbg) {\n        DWARF_DBG_ERROR(NULL,DW_DLE_DWARF_INIT_DBG_NULL,DW_DLV_ERROR);\n    }\n    \n    *ret_dbg = 0;\n    res = dwarf_object_detector_fd(fd, &ftype,\n        &endian,&offsetsize,&filesize,&errcode);\n    if (res == DW_DLV_NO_ENTRY) {\n        return res;\n    }\n    if (res == DW_DLV_ERROR) {\n        \n        DWARF_DBG_ERROR(NULL, DW_DLE_FILE_WRONG_TYPE, DW_DLV_ERROR);\n    }\n    switch(ftype) {\n    case DW_FTYPE_ELF: {\n        int res2 = 0;\n\n        res2 = _dwarf_elf_nlsetup(fd,\"\",\n            ftype,endian,offsetsize,filesize,\n            group_number,errhand,errarg,ret_dbg,error);\n        if (res2 != DW_DLV_OK) {\n            return res2;\n        }\n        set_global_paths_init(*ret_dbg,error);\n        return res2;\n        }\n    case DW_FTYPE_APPLEUNIVERSAL:\n    case DW_FTYPE_MACH_O: {\n        int resm = 0;\n\n        resm = _dwarf_macho_setup(fd,\"\",\n            universalnumber,\n            ftype,endian,offsetsize,filesize,\n            group_number,errhand,errarg,ret_dbg,error);\n        if (resm != DW_DLV_OK) {\n            return resm;\n        }\n        set_global_paths_init(*ret_dbg,error);\n        return resm;\n        }\n\n    case DW_FTYPE_PE: {\n        int resp = 0;\n\n        resp = _dwarf_pe_setup(fd,\n            \"\",\n            ftype,endian,offsetsize,filesize,\n            group_number,errhand,errarg,ret_dbg,error);\n        if (resp != DW_DLV_OK) {\n            return resp;\n        }\n        set_global_paths_init(*ret_dbg,error);\n        return resp;\n        }\n    default: break;\n    }\n    DWARF_DBG_ERROR(NULL, DW_DLE_FILE_WRONG_TYPE, DW_DLV_ERROR);\n    \n}", "Selected Statement": "Dwarf_Unsigned   filesize = 0;", "Function Input": {"error": {"value": {"type_category": "unknown", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xfe02dd63e9f26600\n", "message": "Cannot access memory at address 0xfe02dd63e9f26600"}}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 10, "Project Information": "libdwarf"}
{"Programming Language": "C", "Source Code": "ssh_socket ssh_socket_new(ssh_session session)\n{\n    ssh_socket s;\n\n    s = calloc(1, sizeof(struct ssh_socket_struct));\n    if (s == NULL) {\n        ssh_set_error_oom(session);\n        return NULL;\n    }\n    s->fd = SSH_INVALID_SOCKET;\n    s->last_errno = -1;\n    s->fd_is_socket = 1;\n    s->session = session;\n    s->in_buffer = ssh_buffer_new();\n    if (s->in_buffer == NULL) {\n        ssh_set_error_oom(session);\n        SAFE_FREE(s);\n        return NULL;\n    }\n    s->out_buffer=ssh_buffer_new();\n    if (s->out_buffer == NULL) {\n        ssh_set_error_oom(session);\n        SSH_BUFFER_FREE(s->in_buffer);\n        SAFE_FREE(s);\n        return NULL;\n    }\n    s->read_wontblock = 0;\n    s->write_wontblock = 0;\n    s->data_except = 0;\n    s->poll_handle = NULL;\n    s->state=SSH_SOCKET_NONE;\n    return s;\n}", "Selected Statement": "s->fd_is_socket = 1;", "Function Input": {}, "Variable Values Before Statement": {"constant": "1"}, "Value After Statement Execution": "1", "Block_Size": 10, "Project Information": "libssh"}
{"Programming Language": "C", "Source Code": "GLOBAL(void)\njinit_input_controller(j_decompress_ptr cinfo)\n{\n  my_inputctl_ptr inputctl;\n\n  \n  inputctl = (my_inputctl_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,\n                                sizeof(my_input_controller));\n  cinfo->inputctl = (struct jpeg_input_controller *)inputctl;\n  \n  inputctl->pub.consume_input = consume_markers;\n  inputctl->pub.reset_input_controller = reset_input_controller;\n  inputctl->pub.start_input_pass = start_input_pass;\n  inputctl->pub.finish_input_pass = finish_input_pass;\n  \n  inputctl->pub.has_multiple_scans = FALSE; \n  inputctl->pub.eoi_reached = FALSE;\n  inputctl->inheaders = TRUE;\n}", "Selected Statement": "inputctl->pub.reset_input_controller = reset_input_controller;", "Function Input": {"cinfo": {"value": "0x110a298"}}, "Variable Values Before Statement": {"reset_input_controller": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 10, "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Source Code": "GLOBAL(void)\njinit_marker_reader(j_decompress_ptr cinfo)\n{\n  my_marker_ptr marker;\n  int i;\n\n  \n  marker = (my_marker_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,\n                                sizeof(my_marker_reader));\n  cinfo->marker = (struct jpeg_marker_reader *)marker;\n  \n  marker->pub.reset_marker_reader = reset_marker_reader;\n  marker->pub.read_markers = read_markers;\n  marker->pub.read_restart_marker = read_restart_marker;\n  \n  marker->process_COM = skip_variable;\n  marker->length_limit_COM = 0;\n  for (i = 0; i < 16; i++) {\n    marker->process_APPn[i] = skip_variable;\n    marker->length_limit_APPn[i] = 0;\n  }\n  marker->process_APPn[0] = get_interesting_appn;\n  marker->process_APPn[14] = get_interesting_appn;\n  \n  reset_marker_reader(cinfo);\n}", "Selected Statement": "marker->pub.reset_marker_reader = reset_marker_reader;", "Function Input": {"cinfo": {"value": "0xffffdfd7"}}, "Variable Values Before Statement": {"reset_marker_reader": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 10, "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Source Code": "GLOBAL(void)\njinit_marker_reader(j_decompress_ptr cinfo)\n{\n  my_marker_ptr marker;\n  int i;\n\n  \n  marker = (my_marker_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,\n                                sizeof(my_marker_reader));\n  cinfo->marker = (struct jpeg_marker_reader *)marker;\n  \n  marker->pub.reset_marker_reader = reset_marker_reader;\n  marker->pub.read_markers = read_markers;\n  marker->pub.read_restart_marker = read_restart_marker;\n  \n  marker->process_COM = skip_variable;\n  marker->length_limit_COM = 0;\n  for (i = 0; i < 16; i++) {\n    marker->process_APPn[i] = skip_variable;\n    marker->length_limit_APPn[i] = 0;\n  }\n  marker->process_APPn[0] = get_interesting_appn;\n  marker->process_APPn[14] = get_interesting_appn;\n  \n  reset_marker_reader(cinfo);\n}", "Selected Statement": "marker->pub.reset_marker_reader = reset_marker_reader;", "Function Input": {"cinfo": {"value": "0xffffdfe7"}}, "Variable Values Before Statement": {"reset_marker_reader": "NULL"}, "Value After Statement Execution": "NULL", "Block_Size": 10, "Project Information": "libjpeg-turbo"}
{"Programming Language": "C", "Source Code": "float\nfloat32_le_read (const unsigned char *cptr)\n{\tint\t\texponent, mantissa, negative ;\n\tfloat\tfvalue ;\n\n\tnegative = cptr [3] & 0x80 ;\n\texponent = ((cptr [3] & 0x7F) << 1) | ((cptr [2] & 0x80) ? 1 : 0) ;\n\tmantissa = ((cptr [2] & 0x7F) << 16) | (cptr [1] << 8) | (cptr [0]) ;\n\n\tif (! (exponent || mantissa))\n\t\treturn 0.0 ;\n\n\tmantissa |= 0x800000 ;\n\texponent = exponent ? exponent - 127 : 0 ;\n\n\tfvalue = mantissa ? ((float) mantissa) / ((float) 0x800000) : 0.0 ;\n\n\tif (negative)\n\t\tfvalue *= -1 ;\n\n\tif (exponent > 0)\n\t\tfvalue *= pow (2.0, exponent) ;\n\telse if (exponent < 0)\n\t\tfvalue /= pow (2.0, abs (exponent)) ;\n\n\treturn fvalue ;\n}", "Selected Statement": "mantissa |= 0x800000 ;", "Function Input": {}, "Variable Values Before Statement": {"constant": "0x800000"}, "Value After Statement Execution": "0x800000", "Block_Size": 10, "Project Information": "libsndfile"}
{"Programming Language": "C", "Source Code": "int libfshfs_extents_record_read_data(\n     libfshfs_fork_descriptor_t *fork_descriptor,\n     uint16_t extents_start_block_number,\n     const uint8_t *data,\n     size_t data_size,\n     libcerror_error_t **error )\n{\n\tstatic char *function                 = \"libfshfs_extents_record_read_data\";\n\tsize_t data_offset                    = 0;\n\tuint32_t physical_extent_block_number = 0;\n\tuint16_t extent_block_number          = 0;\n\tuint16_t extent_number_of_blocks      = 0;\n\tint extent_index                      = 0;\n\n\tif( fork_descriptor == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid fork descriptor.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( data == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_MISSING,\n\t\t \"%s: invalid data.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( data_size > (size_t) SSIZE_MAX )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: invalid data size value out of bounds.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n#if defined( HAVE_DEBUG_OUTPUT )\n\tif( libcnotify_verbose != 0 )\n\t{\n\t\tlibcnotify_printf(\n\t\t \"%s: extents records data:\\n\",\n\t\t function );\n\t\tlibcnotify_print_data(\n\t\t data,\n\t\t data_size,\n\t\t LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA );\n\t}\n#endif\n\tif( data_size != 12 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_UNSUPPORTED_VALUE,\n\t\t \"%s: unsupported extents record data size: %\" PRIzd \"\\n\",\n\t\t function,\n\t\t data_size );\n\n\t\treturn( -1 );\n\t}\n\twhile( data_offset < 12 )\n\t{\n\t\tbyte_stream_copy_to_uint16_big_endian(\n\t\t &( data[ data_offset ] ),\n\t\t extent_block_number );\n\n\t\tdata_offset += 2;\n\n\t\tbyte_stream_copy_to_uint16_big_endian(\n\t\t &( data[ data_offset ] ),\n\t\t extent_number_of_blocks );\n\n\t\tdata_offset += 2;\n\n\t\tphysical_extent_block_number = extent_block_number;\n\n\t\tif( extent_number_of_blocks > 0 )\n\t\t{\n\t\t\tphysical_extent_block_number += extents_start_block_number;\n\t\t}\n#if defined( HAVE_DEBUG_OUTPUT )\n\t\tif( libcnotify_verbose != 0 )\n\t\t{\n\t\t\tlibcnotify_printf(\n\t\t\t \"%s: extent: %d block number\\t\\t: %\" PRIu32 \" (%\" PRIu16 \")\\n\",\n\t\t\t function,\n\t\t\t extent_index,\n\t\t\t physical_extent_block_number,\n\t\t\t extent_block_number );\n\n\t\t\tlibcnotify_printf(\n\t\t\t \"%s: extent: %d number of blocks\\t\\t: %\" PRIu16 \"\\n\",\n\t\t\t function,\n\t\t\t extent_index,\n\t\t\t extent_number_of_blocks );\n\t\t}\n#endif \n\n\t\tfork_descriptor->extents[ extent_index ][ 0 ] = physical_extent_block_number;\n\t\tfork_descriptor->extents[ extent_index ][ 1 ] = extent_number_of_blocks;\n\n\t\tfork_descriptor->number_of_blocks_in_extents += extent_number_of_blocks;\n\n\t\textent_index++;\n\t}\n#if defined( HAVE_DEBUG_OUTPUT )\n\tif( libcnotify_verbose != 0 )\n\t{\n\t\tlibcnotify_printf(\n\t\t \"\\n\" );\n\t}\n#endif\n\treturn( 1 );\n}", "Selected Statement": "uint16_t extent_number_of_blocks      = 0;", "Function Input": {"data": {"value": "0x600 <error: Cannot access memory at address 0x600>"}, "data_size": {"value": "4809124"}, "error": {"value": {"type_category": "pointer", "concrete_type": "POINTER", "address": "0x7fffffffd8e0", "value": {"type_category": "unknown", "concrete_type": "libcerror_error_t", "value": "140737488346128"}}}, "extents_start_block_number": {"value": "0"}, "fork_descriptor": {"value": {"type_category": "struct", "concrete_type": "STRUCT", "value": {"size": {"type_category": "unknown", "concrete_type": "uint64_t", "value": "0"}, "number_of_blocks": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, "extents": {"type_category": "array", "concrete_type": "ARRAY", "value": [{"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}, {"type_category": "array", "concrete_type": "uint32_t", "value": [{"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}, {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}]}]}, "number_of_blocks_in_extents": {"type_category": "unknown", "concrete_type": "uint32_t", "value": "0"}}}}}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 10, "Project Information": "libyal"}
{"Programming Language": "C", "Source Code": "int ssh_send_banner(ssh_session session, int server)\n{\n    const char *banner = CLIENT_BANNER_SSH2;\n    const char *terminator = \"\\r\\n\";\n    \n    char buffer[256] = {0};\n    size_t len;\n    int rc = SSH_ERROR;\n\n    if (server == 1) {\n        if (session->opts.custombanner == NULL){\n            session->serverbanner = strdup(banner);\n            if (session->serverbanner == NULL) {\n                goto end;\n            }\n        } else {\n            len = strlen(session->opts.custombanner);\n            session->serverbanner = malloc(len + 8 + 1);\n            if(session->serverbanner == NULL) {\n                goto end;\n            }\n            snprintf(session->serverbanner,\n                     len + 8 + 1,\n                     \"SSH-2.0-%s\",\n                     session->opts.custombanner);\n        }\n\n        snprintf(buffer,\n                 sizeof(buffer),\n                 \"%s%s\",\n                 session->serverbanner,\n                 terminator);\n    } else {\n        session->clientbanner = strdup(banner);\n        if (session->clientbanner == NULL) {\n            goto end;\n        }\n\n        snprintf(buffer,\n                 sizeof(buffer),\n                 \"%s%s\",\n                 session->clientbanner,\n                 terminator);\n    }\n\n    rc = ssh_socket_write(session->socket, buffer, strlen(buffer));\n    if (rc == SSH_ERROR) {\n        goto end;\n    }\n#ifdef WITH_PCAP\n    if (session->pcap_ctx != NULL) {\n        ssh_pcap_context_write(session->pcap_ctx,\n                               SSH_PCAP_DIR_OUT,\n                               buffer,\n                               strlen(buffer),\n                               strlen(buffer));\n    }\n#endif\n\n    rc = SSH_OK;\nend:\n    return rc;\n}", "Selected Statement": "session->serverbanner = strdup(banner);", "Function Input": {}, "Variable Values Before Statement": {"banner": "0x72e0a0 \"SSH-2.0-libssh_0.10.90\""}, "Value After Statement Execution": "NULL", "Function Name": "strdup", "Block_Size": 10, "Project Information": "libssh"}
{"Programming Language": "C", "Source Code": "int parse_msg(\n\t\tchar *const buf, const unsigned int len, struct sip_msg *const msg)\n{\n\n\tchar *tmp;\n\tchar *rest;\n\tstruct msg_start *fl;\n\tint offset;\n\thdr_flags_t flags;\n\n\t\n\tfor(tmp = buf; (tmp - buf < len)\n\t\t\t\t   && (*tmp == '\\n' || *tmp == '\\r' || *tmp == '\\0'\n\t\t\t\t\t\t   || *tmp == '\\t' || *tmp == ' ');\n\t\t\ttmp++)\n\t\t;\n\toffset = tmp - buf;\n\tfl = &(msg->first_line);\n\trest = parse_first_line(tmp, len - offset, fl);\n\toffset += rest - tmp;\n\ttmp = rest;\n\tswitch(fl->type) {\n\t\tcase SIP_INVALID:\n\t\t\tDBG(\"invalid message\\n\");\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SIP_REQUEST:\n\t\t\tDBG(\"SIP Request:\\n\");\n\t\t\tDBG(\" method:  <%.*s>\\n\", fl->u.request.method.len,\n\t\t\t\t\tZSW(fl->u.request.method.s));\n\t\t\tDBG(\" uri:     <%.*s>\\n\", fl->u.request.uri.len,\n\t\t\t\t\tZSW(fl->u.request.uri.s));\n\t\t\tDBG(\" version: <%.*s>\\n\", fl->u.request.version.len,\n\t\t\t\t\tZSW(fl->u.request.version.s));\n\t\t\tflags = HDR_VIA_F;\n\t\t\tbreak;\n\t\tcase SIP_REPLY:\n\t\t\tDBG(\"SIP Reply  (status):\\n\");\n\t\t\tDBG(\" version: <%.*s>\\n\", fl->u.reply.version.len,\n\t\t\t\t\tZSW(fl->u.reply.version.s));\n\t\t\tDBG(\" status:  <%.*s>\\n\", fl->u.reply.status.len,\n\t\t\t\t\tZSW(fl->u.reply.status.s));\n\t\t\tDBG(\" reason:  <%.*s>\\n\", fl->u.reply.reason.len,\n\t\t\t\t\tZSW(fl->u.reply.reason.s));\n\t\t\t\n\t\t\t\n\t\t\tflags = HDR_VIA_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDBG(\"unknown type %d\\n\", fl->type);\n\t\t\tgoto error;\n\t}\n\tmsg->unparsed = tmp;\n\t\n\tif(parse_headers(msg, flags, 0) == -1)\n\t\tgoto error;\n\n#ifdef EXTRA_DEBUG\n\t\n\tif(msg->via1) {\n\t\tDBG(\"first via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\", msg->via1->name.len,\n\t\t\t\tZSW(msg->via1->name.s), msg->via1->version.len,\n\t\t\t\tZSW(msg->via1->version.s), msg->via1->transport.len,\n\t\t\t\tZSW(msg->via1->transport.s), msg->via1->host.len,\n\t\t\t\tZSW(msg->via1->host.s), msg->via1->port_str.len,\n\t\t\t\tZSW(msg->via1->port_str.s), msg->via1->port);\n\t\tif(msg->via1->params.s)\n\t\t\tDBG(\";<%.*s>\", msg->via1->params.len, ZSW(msg->via1->params.s));\n\t\tif(msg->via1->comment.s)\n\t\t\tDBG(\" <%.*s>\", msg->via1->comment.len, ZSW(msg->via1->comment.s));\n\t\tDBG(\"\\n\");\n\t}\n\tif(msg->via2) {\n\t\tDBG(\"second via: <%.*s/%.*s/%.*s> <%.*s:%.*s(%d)>\", msg->via2->name.len,\n\t\t\t\tZSW(msg->via2->name.s), msg->via2->version.len,\n\t\t\t\tZSW(msg->via2->version.s), msg->via2->transport.len,\n\t\t\t\tZSW(msg->via2->transport.s), msg->via2->host.len,\n\t\t\t\tZSW(msg->via2->host.s), msg->via2->port_str.len,\n\t\t\t\tZSW(msg->via2->port_str.s), msg->via2->port);\n\t\tif(msg->via2->params.s)\n\t\t\tDBG(\";<%.*s>\", msg->via2->params.len, ZSW(msg->via2->params.s));\n\t\tif(msg->via2->comment.s)\n\t\t\tDBG(\" <%.*s>\", msg->via2->comment.len, ZSW(msg->via2->comment.s));\n\t\tDBG(\"\\n\");\n\t}\n#endif\n\n\n#ifdef EXTRA_DEBUG\n\tDBG(\"exiting parse_msg\\n\");\n#endif\n\n\treturn 0;\n\nerror:\n\t\n\tLOG(cfg_get(core, core_cfg, sip_parser_log),\n\t\t\t\"ERROR: parse_msg: message=<%.*s>\\n\", (int)msg->len,\n\t\t\tZSW(ksr_buf_oneline(msg->buf, (int)msg->len)));\n\treturn -1;\n}", "Selected Statement": "for(tmp = buf; (tmp - buf < len)", "Function Input": {"flags": {"value": "140737322669824"}, "msg": {"value": {"type_category": "struct", "concrete_type": "error", "error_type": "gdb.MemoryError", "stacktrace": "Traceback (most recent call last):\n  File \"/tracer/var_utils.py\", line 72, in serialize_value_to_json\n    if str(value) == \"0x0\":\ngdb.MemoryError: Cannot access memory at address 0xffff00001f80\n", "message": "Cannot access memory at address 0xffff00001f80"}}}, "Variable Values Before Statement": {"buf": "\"\""}, "Value After Statement Execution": "\"\"", "Block_Size": 10, "Project Information": "kamailio"}
{"Programming Language": "C", "Source Code": "void luaS_init (lua_State *L) {\n  global_State *g = G(L);\n  int i, j;\n  stringtable *tb = &G(L)->strt;\n  tb->hash = luaM_newvector(L, MINSTRTABSIZE, TString*);\n  tablerehash(tb->hash, 0, MINSTRTABSIZE);  \n  tb->size = MINSTRTABSIZE;\n  \n  g->memerrmsg = luaS_newliteral(L, MEMERRMSG);\n  luaC_fix(L, obj2gco(g->memerrmsg));  \n  for (i = 0; i < STRCACHE_N; i++)  \n    for (j = 0; j < STRCACHE_M; j++)\n      g->strcache[i][j] = g->memerrmsg;\n}", "Selected Statement": "for (j = 0; j < STRCACHE_M; j++)", "Function Input": {}, "Variable Values Before Statement": {"constant": "0"}, "Value After Statement Execution": "0", "Block_Size": 10, "Project Information": "lua"}
{"Programming Language": "C", "Source Code": "int imap_bodystructure_parse_full(const char *bodystructure,\n\tpool_t pool, struct message_part **parts,\n\tconst char **error_r)\n{\n\tstruct istream *input;\n\tstruct imap_parser *parser;\n\tconst struct imap_arg *args;\n\tint ret;\n\n\ti_assert(*parts == NULL || (*parts)->next == NULL);\n\n\tinput = i_stream_create_from_data(bodystructure, strlen(bodystructure));\n\t(void)i_stream_read(input);\n\n\tparser = imap_parser_create(input, NULL, SIZE_MAX);\n\tret = imap_parser_finish_line(parser, 0,\n\t\t\t\t      IMAP_PARSE_FLAG_LITERAL_TYPE, &args);\n\tif (ret < 0) {\n\t\t*error_r = t_strdup_printf(\"IMAP parser failed: %s\",\n\t\t\t\t\t   imap_parser_get_error(parser, NULL));\n\t} else if (ret == 0) {\n\t\t*error_r = \"Empty bodystructure\";\n\t\tret = -1;\n\t} else {\n\t\tT_BEGIN {\n\t\t\tret = imap_bodystructure_parse_args\n\t\t\t\t(args, pool, parts, error_r);\n\t\t} T_END_PASS_STR_IF(ret < 0, error_r);\n\t}\n\n\tif (ret < 0) {\n\t\t\n\t\timap_bodystructure_reset_data(*parts);\n\t}\n\n\timap_parser_unref(&parser);\n\ti_stream_destroy(&input);\n\treturn ret;\n}", "Selected Statement": "input = i_stream_create_from_data(bodystructure, strlen(bodystructure));", "Function Input": {}, "Variable Values Before Statement": {"bodystructure": "0x103c098 \"\""}, "Value After Statement Execution": {"v_offset": "0", "stream_errno": "0", "mmaped": "false", "blocking": "true", "closed": "false", "readable_fd": "false", "seekable": "true", "eof": "false", "real_stream": null}, "Function Name": "i_stream_create_from_data", "Block_Size": 10, "Project Information": "dovecot"}
{"Programming Language": "C", "Source Code": "void\ndns_message_create(isc_mem_t *mctx, isc_mempool_t *namepool,\n\t\t   isc_mempool_t *rdspool, dns_message_intent_t intent,\n\t\t   dns_message_t **msgp) {\n\tREQUIRE(mctx != NULL);\n\tREQUIRE(msgp != NULL);\n\tREQUIRE(*msgp == NULL);\n\tREQUIRE(intent == DNS_MESSAGE_INTENTPARSE ||\n\t\tintent == DNS_MESSAGE_INTENTRENDER);\n\tREQUIRE((namepool != NULL && rdspool != NULL) ||\n\t\t(namepool == NULL && rdspool == NULL));\n\n\tdns_message_t *msg = isc_mem_get(mctx, sizeof(dns_message_t));\n\t*msg = (dns_message_t){\n\t\t.from_to_wire = intent,\n\t\t.references = ISC_REFCOUNT_INITIALIZER(1),\n\t\t.scratchpad = ISC_LIST_INITIALIZER,\n\t\t.cleanup = ISC_LIST_INITIALIZER,\n\t\t.rdatas = ISC_LIST_INITIALIZER,\n\t\t.rdatalists = ISC_LIST_INITIALIZER,\n\t\t.offsets = ISC_LIST_INITIALIZER,\n\t\t.freerdata = ISC_LIST_INITIALIZER,\n\t\t.freerdatalist = ISC_LIST_INITIALIZER,\n\t\t.magic = DNS_MESSAGE_MAGIC,\n\t\t.namepool = namepool,\n\t\t.rdspool = rdspool,\n\t\t.free_pools = (namepool == NULL && rdspool == NULL),\n\t};\n\n\tisc_mem_attach(mctx, &msg->mctx);\n\n\tif (msg->free_pools) {\n\t\tdns_message_createpools(mctx, &msg->namepool, &msg->rdspool);\n\t}\n\n\tmsginit(msg);\n\n\tfor (size_t i = 0; i < DNS_SECTION_MAX; i++) {\n\t\tISC_LIST_INIT(msg->sections[i]);\n\t}\n\n\tisc_buffer_t *dynbuf = NULL;\n\tisc_buffer_allocate(mctx, &dynbuf, SCRATCHPAD_SIZE);\n\tISC_LIST_APPEND(msg->scratchpad, dynbuf, link);\n\n\t*msgp = msg;\n}", "Selected Statement": "dns_message_t *msg = isc_mem_get(mctx, sizeof(dns_message_t));", "Function Input": {}, "Variable Values Before Statement": {"mctx": {"magic": "1298492739", "flags": "4", "jemalloc_flags": "0", "jemalloc_arena": "4294967295", "debugging": "0", "lock": null, "checkfree": "true", "references": "1", "name": "\"\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\"", "inuse": "1568", "hi_called": "false", "is_overmem": "false", "hi_water": "0", "lo_water": "0", "pools": null, "poolcnt": "0", "debuglist": null, "debuglistcnt": "0", "link": null}}, "Value After Statement Execution": "NULL", "Function Name": "isc_mem_get", "Block_Size": 10, "Project Information": "bind9"}
{"Programming Language": "C", "Source Code": "ssh_session ssh_new(void)\n{\n    ssh_session session;\n    char *id = NULL;\n    int rc;\n\n    session = calloc(1, sizeof (struct ssh_session_struct));\n    if (session == NULL) {\n        return NULL;\n    }\n\n    session->next_crypto = crypto_new();\n    if (session->next_crypto == NULL) {\n        goto err;\n    }\n\n    session->socket = ssh_socket_new(session);\n    if (session->socket == NULL) {\n        goto err;\n    }\n\n    session->out_buffer = ssh_buffer_new();\n    if (session->out_buffer == NULL) {\n        goto err;\n    }\n\n    session->in_buffer = ssh_buffer_new();\n    if (session->in_buffer == NULL) {\n        goto err;\n    }\n\n    session->out_queue = ssh_list_new();\n    if (session->out_queue == NULL) {\n        goto err;\n    }\n\n    session->alive = 0;\n    session->auth.supported_methods = 0;\n    ssh_set_blocking(session, 1);\n    session->maxchannel = FIRST_CHANNEL;\n\n    session->agent = ssh_agent_new(session);\n    if (session->agent == NULL) {\n        goto err;\n    }\n\n    \n    session->opts.StrictHostKeyChecking = 1;\n    session->opts.port = 22;\n    session->opts.fd = -1;\n    session->opts.compressionlevel = 7;\n    session->opts.nodelay = 0;\n    session->opts.identities_only = false;\n    session->opts.control_master = SSH_CONTROL_MASTER_NO;\n\n    session->opts.flags = SSH_OPT_FLAG_PASSWORD_AUTH |\n                          SSH_OPT_FLAG_PUBKEY_AUTH |\n                          SSH_OPT_FLAG_KBDINT_AUTH |\n                          SSH_OPT_FLAG_GSSAPI_AUTH;\n\n    session->opts.exp_flags = 0;\n\n    session->opts.identity = ssh_list_new();\n    if (session->opts.identity == NULL) {\n        goto err;\n    }\n    session->opts.identity_non_exp = ssh_list_new();\n    if (session->opts.identity_non_exp == NULL) {\n        goto err;\n    }\n\n    session->opts.certificate = ssh_list_new();\n    if (session->opts.certificate == NULL) {\n        goto err;\n    }\n    session->opts.certificate_non_exp = ssh_list_new();\n    if (session->opts.certificate_non_exp == NULL) {\n        goto err;\n    }\n    \n\n    id = strdup(\"%d/id_ed25519\");\n    if (id == NULL) {\n        goto err;\n    }\n\n    rc = ssh_list_append(session->opts.identity_non_exp, id);\n    if (rc == SSH_ERROR) {\n        goto err;\n    }\n\n#ifdef HAVE_ECC\n    id = strdup(\"%d/id_ecdsa\");\n    if (id == NULL) {\n        goto err;\n    }\n    rc = ssh_list_append(session->opts.identity_non_exp, id);\n    if (rc == SSH_ERROR) {\n        goto err;\n    }\n#endif\n\n    id = strdup(\"%d/id_rsa\");\n    if (id == NULL) {\n        goto err;\n    }\n    rc = ssh_list_append(session->opts.identity_non_exp, id);\n    if (rc == SSH_ERROR) {\n        goto err;\n    }\n\n    \n    session->session_state = SSH_SESSION_STATE_NONE;\n    session->pending_call_state = SSH_PENDING_CALL_NONE;\n    session->packet_state = PACKET_STATE_INIT;\n    session->dh_handshake_state = DH_STATE_INIT;\n    session->global_req_state = SSH_CHANNEL_REQ_STATE_NONE;\n\n    session->auth.state = SSH_AUTH_STATE_NONE;\n    session->auth.service_state = SSH_AUTH_SERVICE_NONE;\n\n    return session;\n\nerr:\n    free(id);\n    ssh_free(session);\n    return NULL;\n}", "Selected Statement": "session->next_crypto = crypto_new();", "Function Input": {}, "Variable Values Before Statement": {}, "Value After Statement Execution": "NULL", "Function Name": "crypto_new", "Block_Size": 10, "Project Information": "libssh"}
{"Programming Language": "C", "Source Code": "ssh_poll_handle\nssh_poll_new(socket_t fd, short events, ssh_poll_callback cb, void *userdata)\n{\n    ssh_poll_handle p;\n\n    p = malloc(sizeof(struct ssh_poll_handle_struct));\n    if (p == NULL) {\n        return NULL;\n    }\n    ZERO_STRUCTP(p);\n\n    p->x.fd = fd;\n    p->events = events;\n    p->cb = cb;\n    p->cb_data = userdata;\n\n    return p;\n}", "Selected Statement": "p->events = events;", "Function Input": {}, "Variable Values Before Statement": {"events": "0"}, "Value After Statement Execution": "0", "Block_Size": 10, "Project Information": "libssh"}
