{"index": 0, "idx": 0, "code": "def secrets_dir(env=os.getenv('D2_ENVIRONMENT', None),\n                basedir=os.getenv('D2_SECRETS_BASEDIR', None)):\n    if env is not None:\n        env_str = str(env)\n    else:\n        cwd = os.getcwd()\n        default_file = os.path.join(cwd, '.python_secrets_environment')\n        if os.path.exists(default_file):\n            with open(default_file, 'r') as f:\n                env_str = f.read().strip()\n        else:\n            env_str = os.path.basename(cwd)\n    if basedir is None:\n        basedir = os.path.join(\n                HOME,\n                'secrets' if sys.platform.startswith('win') else '.secrets')\n    return os.path.join(basedir, env_str)", "input": "'testing', '/home/XXX/.tsecrets'", "output": "'/home/XXX/.tsecrets/testing'", "cyclomatic_complexity": 4, "code_length": 17, "category": "Medium", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 2, "idx": 1, "code": "def _identify_environment(environment=None):\n    \n    cwd = os.getcwd()\n    if environment is None:\n        env_file = os.path.join(cwd, '.python_secrets_environment')\n        if os.path.exists(env_file):\n            with open(env_file, 'r') as f:\n                environment = f.read().replace('\\n', '')\n        else:\n            environment = os.getenv('D2_ENVIRONMENT',\n                                    os.path.basename(cwd))\n    return environment", "input": "'testing'", "output": "'testing'", "cyclomatic_complexity": 3, "code_length": 11, "category": "Easy", "quantized_value_input": "Alphabetic String", "quantized_value_output": "Alphabetic String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 45, "idx": 2, "code": "def client_factory(client_name, **kwargs):\n    \n    \n    dir_name = os.path.dirname(os.path.abspath(__file__))\n    error_msg = 'No client found for name %s' % client_name\n    client_key = client_name.upper()\n\n    \n    try:\n        client_vals = BALANCING_AUTHORITIES[client_key]\n        module_name = client_vals['module']\n\n        class_name = client_vals['class']\n    except KeyError:\n        raise ValueError(error_msg)\n\n    \n    try:\n        fp, pathname, description = imp.find_module(module_name, [dir_name])\n    except ImportError:\n        raise ValueError(error_msg)\n\n    \n    try:\n        mod = imp.load_module(module_name, fp, pathname, description)\n    finally:\n        \n        if fp:\n            fp.close()\n\n    \n    try:\n        client_inst = getattr(mod, class_name)(**kwargs)\n    except AttributeError:\n        raise ValueError(error_msg)\n\n    \n    client_inst.NAME = client_name\n\n    return client_inst", "input": "'BPA', {}", "output": "{options={}, NAME='BPA'}", "cyclomatic_complexity": 8, "code_length": 25, "category": "Hard", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 54, "idx": 3, "code": "def get_generation(ba_name, **kwargs):\n    \n    c = client_factory(ba_name)\n    data = c.get_generation(**kwargs)\n    \n    \n    if len(data) == 0:\n        msg = '%s: No generation data at %s with args %s' % (ba_name, datetime.utcnow().isoformat(),\n                                                    kwargs)\n        logger.warn(msg)\n    \n    \n    return data", "input": "'CAISO', {'latest': True}", "output": "[]", "cyclomatic_complexity": 2, "code_length": 8, "category": "Super Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Empty List", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty List", "len(value) > 0": "Non-Empty List"}}
{"index": 55, "idx": 4, "code": "def get_load(ba_name, **kwargs):\n    \n    c = client_factory(ba_name)\n    data = c.get_load(**kwargs)\n    \n    \n    if len(data) == 0:\n        msg = '%s: No load data at %s with args %s' % (ba_name, datetime.utcnow().isoformat(),\n                                                    kwargs)\n        logger.warn(msg)\n    \n    \n    return data", "input": "'PJM', {'latest': True}", "output": "[]", "cyclomatic_complexity": 2, "code_length": 8, "category": "Super Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Empty List", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty List", "len(value) > 0": "Non-Empty List"}}
{"index": 56, "idx": 5, "code": "def get_trade(ba_name, **kwargs):\n    \n    c = client_factory(ba_name)\n    data = c.get_trade(**kwargs)\n    \n    \n    if len(data) == 0:\n        msg = '%s: No trade data at %s with args %s' % (ba_name, datetime.utcnow().isoformat(),\n                                                    kwargs)\n        logger.warn(msg)\n    \n    \n    return data", "input": "'NYISO', {'latest': True}", "output": "[{'timestamp': Timestamp('2024-04-03 22:45:00+0000', tz='UTC'), 'net_exp_MW': -1022.76, 'ba_name': 'NYISO', 'freq': '5m', 'market': 'RT5M'}]", "cyclomatic_complexity": 2, "code_length": 8, "category": "Super Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 74, "idx": 6, "code": "def get_retry_after(headers):\n    \n    \n    \n\n    try:\n        retry_after = headers['retry-after']\n    except KeyError:\n        return None\n\n    if not retry_after:  \n        return None\n\n    retry_after = retry_after.strip()\n\n    \n    \n\n    try:\n        \n        seconds = int(retry_after)\n    except ValueError:\n        \n        retry_date_tuple = email.utils.parsedate_tz(retry_after)\n        if retry_date_tuple is None:\n            logger.warning('Invalid Retry-After header: %s', retry_after)\n            return None\n        retry_date = email.utils.mktime_tz(retry_date_tuple)\n        seconds = retry_date - time.time()\n\n    if seconds < 0:\n        seconds = 0\n\n    return seconds", "input": "{'retry-after': '42'}", "output": "42", "cyclomatic_complexity": 8, "code_length": 20, "category": "Hard", "quantized_value_input": "Non-Empty dictionary", "quantized_value_output": "Positive Large", "input_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}, "output_mapping_info": {"value == 0": "zero", "0 < value <= 10": "Positive Regular", "value > 10": "Positive Large", "-10 <= value < 0": "Negative Regular", "value < -10": "Negative Large"}}
{"index": 86, "idx": 7, "code": "def kilometers(meters=0, miles=0, feet=0, nautical=0):\n    \n    ret = 0.\n    if meters:\n        ret += meters / 1000.\n    if feet:\n        ret += feet / ft(1.)\n    if nautical:\n        ret += nautical / nm(1.)\n    ret += miles * 1.609344\n    return ret", "input": "0, 0, 0, 0", "output": "0.0", "cyclomatic_complexity": 4, "code_length": 10, "category": "Medium", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "zero", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"value == 0.0": "zero", "0.0 < value <= 1.0": "Positive Small", "1.0 < value <= 10.0": "Positive Regular", "value > 10.0": "Positive Large", "-1.0 <= value < 0.0": "Negative Small", "-10.0 <= value < -1.0": "Negative Regular", "value < -10.0": "Negative Large"}}
{"index": 87, "idx": 8, "code": "def measure(self, a, b):\n        \n        \n        raise NotImplementedError(\"Distance is an abstract class\")", "input": "REPR FAILED, (10, 10, 10), (20, 20, 10), 6371.009", "output": "1544.7597432330397", "cyclomatic_complexity": 1, "code_length": 2, "category": "Super Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Positive Large", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"value == 0.0": "zero", "0.0 < value <= 1.0": "Positive Small", "1.0 < value <= 10.0": "Positive Regular", "value > 10.0": "Positive Large", "-1.0 <= value < 0.0": "Negative Small", "-10.0 <= value < -1.0": "Negative Regular", "value < -10.0": "Negative Large"}}
{"index": 88, "idx": 9, "code": "def feet(kilometers=0, meters=0, miles=0, nautical=0):\n    \n    ret = 0.\n    if nautical:\n        kilometers += nautical / nm(1.)\n    if meters:\n        kilometers += meters / 1000.\n    if kilometers:\n        miles += mi(kilometers=kilometers)\n    ret += miles * 5280\n    return ret", "input": "1.0, 0, 0, 0", "output": "3280.839895013123", "cyclomatic_complexity": 4, "code_length": 10, "category": "Medium", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Positive Large", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"value == 0.0": "zero", "0.0 < value <= 1.0": "Positive Small", "1.0 < value <= 10.0": "Positive Regular", "value > 10.0": "Positive Large", "-1.0 <= value < 0.0": "Negative Small", "-10.0 <= value < -1.0": "Negative Regular", "value < -10.0": "Negative Large"}}
{"index": 89, "idx": 10, "code": "def nautical(kilometers=0, meters=0, miles=0, feet=0):\n    \n    ret = 0.\n    if feet:\n        kilometers += feet / ft(1.)\n    if miles:\n        kilometers += km(miles=miles)\n    if meters:\n        kilometers += meters / 1000.\n    ret += kilometers / 1.852\n    return ret", "input": "1.0, 0, 0, 0", "output": "0.5399568034557235", "cyclomatic_complexity": 4, "code_length": 10, "category": "Medium", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Positive Small", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"value == 0.0": "zero", "0.0 < value <= 1.0": "Positive Small", "1.0 < value <= 10.0": "Positive Regular", "value > 10.0": "Positive Large", "-1.0 <= value < 0.0": "Negative Small", "-10.0 <= value < -1.0": "Negative Regular", "value < -10.0": "Negative Large"}}
{"index": 97, "idx": 11, "code": "def format_decimal(self, altitude=None):\n        \n        coordinates = [str(self.latitude), str(self.longitude)]\n\n        if altitude is None:\n            altitude = bool(self.altitude)\n        if altitude:\n            if not isinstance(altitude, str):\n                altitude = 'km'\n            coordinates.append(self.format_altitude(altitude))\n\n        return \", \".join(coordinates)", "input": "Point(41.5, 81.0, 2.5), None, 2.5, 41.5, 81.0", "output": "'41.5, 81.0, 2.5km'", "cyclomatic_complexity": 4, "code_length": 9, "category": "Medium", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 110, "idx": 12, "code": "def xldate_as_tuple(xldate, datemode):\n    if datemode not in (0, 1):\n        raise XLDateBadDatemode(datemode)\n    if xldate == 0.00:\n        return (0, 0, 0, 0, 0, 0)\n    if xldate < 0.00:\n        raise XLDateNegative(xldate)\n    xldays = int(xldate)\n    frac = xldate - xldays\n    seconds = int(round(frac * 86400.0))\n    assert 0 <= seconds <= 86400\n    if seconds == 86400:\n        hour = minute = second = 0\n        xldays += 1\n    else:\n        \n        minutes, second = divmod(seconds, 60)\n        \n        hour, minute = divmod(minutes, 60)\n    if xldays >= _XLDAYS_TOO_LARGE[datemode]:\n        raise XLDateTooLarge(xldate)\n\n    if xldays == 0:\n        return (0, 0, 0, hour, minute, second)\n\n    if xldays < 61 and datemode == 0:\n        raise XLDateAmbiguous(xldate)\n\n    jdn = xldays + _JDN_delta[datemode]\n    yreg = (ifd(ifd(jdn * 4 + 274277, 146097) * 3, 4) + jdn + 1363) * 4 + 3\n    mp = ifd(yreg % 1461, 4) * 535 + 333\n    d = ifd(mp % 16384, 535) + 1\n    \n    mp >>= 14\n    if mp >= 10:\n        return (ifd(yreg, 1461) - 4715, mp - 9, d, hour, minute, second)\n    else:\n        return (ifd(yreg, 1461) - 4716, mp + 3, d, hour, minute, second)", "input": "2741.0, 0", "output": "(1907, 7, 3, 0, 0, 0)", "cyclomatic_complexity": 9, "code_length": 32, "category": "Hard", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Non-Empty tuple", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}}
{"index": 111, "idx": 13, "code": "def xldate_from_date_tuple(date_tuple, datemode):\n    \n    year, month, day = date_tuple\n\n    if datemode not in (0, 1):\n        raise XLDateBadDatemode(datemode)\n\n    if year == 0 and month == 0 and day == 0:\n        return 0.00\n\n    if not (1900 <= year <= 9999):\n        raise XLDateBadTuple(\"Invalid year: %r\" % ((year, month, day),))\n    if not (1 <= month <= 12):\n        raise XLDateBadTuple(\"Invalid month: %r\" % ((year, month, day),))\n    if  day < 1 \\\n    or (day > _days_in_month[month] and not(day == 29 and month == 2 and _leap(year))):\n        raise XLDateBadTuple(\"Invalid day: %r\" % ((year, month, day),))\n\n    Yp = year + 4716\n    M = month\n    if M <= 2:\n        Yp = Yp - 1\n        Mp = M + 9\n    else:\n        Mp = M - 3\n    jdn = ifd(1461 * Yp, 4) + ifd(979 * Mp + 16, 32) + \\\n        day - 1364 - ifd(ifd(Yp + 184, 100) * 3, 4)\n    xldays = jdn - _JDN_delta[datemode]\n    if xldays <= 0:\n        raise XLDateBadTuple(\"Invalid (year, month, day): %r\" % ((year, month, day),))\n    if xldays < 61 and datemode == 0:\n        raise XLDateAmbiguous(\"Before 1900-03-01: %r\" % ((year, month, day),))\n    return float(xldays)", "input": "(1907, 7, 3), 0", "output": "2741.0", "cyclomatic_complexity": 9, "code_length": 28, "category": "Hard", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Positive Large", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"value == 0.0": "zero", "0.0 < value <= 1.0": "Positive Small", "1.0 < value <= 10.0": "Positive Regular", "value > 10.0": "Positive Large", "-1.0 <= value < 0.0": "Negative Small", "-10.0 <= value < -1.0": "Negative Regular", "value < -10.0": "Negative Large"}}
{"index": 138, "idx": 14, "code": "def cast_tuple(val, length = None):\n    if isinstance(val, list):\n        val = tuple(val)\n\n    output = val if isinstance(val, tuple) else ((val,) * default(length, 1))\n\n    if exists(length):\n        assert len(output) == length\n\n    return output", "input": "1, 4", "output": "(1, 1, 1, 1)", "cyclomatic_complexity": 3, "code_length": 7, "category": "Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Non-Empty tuple", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}}
{"index": 140, "idx": 15, "code": "def _add_notice_to_docstring(doc, no_doc_str, notice):\n    \n    if not doc:\n        lines = [no_doc_str]\n\n    else:\n        lines = _normalize_docstring(doc).splitlines()\n\n    notice = [''] + notice\n\n    if len(lines) > 1:\n        \n        if lines[1].strip():\n            notice.append('')\n\n        lines[1:1] = notice\n    else:\n        lines += notice\n\n    return '\\n'.join(lines)", "input": "None, 'DEPRECATED FUNCTION', ['\\n            .. warning::\\n                **THIS FUNCTION IS DEPRECATED:** It will be removed after after 2018-09-30.\\n                *Instructions for updating:* This API is deprecated. Please use as `tl.logging.warning`.\\n        ']", "output": "'DEPRECATED FUNCTION\\n\\n\\n            .. warning::\\n                **THIS FUNCTION IS DEPRECATED:** It will be removed after after 2018-09-30.\\n                *Instructions for updating:* This API is deprecated. Please use as `tl.logging.warning`.\\n        '", "cyclomatic_complexity": 4, "code_length": 13, "category": "Medium", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 164, "idx": 16, "code": "def make_version_tuple(vstr=None):\n    if vstr is None:\n        vstr = __version__\n    if vstr[0] == \"v\":\n        vstr = vstr[1:]\n    components = []\n    for component in vstr.split(\"+\")[0].split(\".\"):\n        try:\n            components.append(int(component))\n        except ValueError:\n            break\n    return tuple(components)", "input": "'v0.1.1'", "output": "(0, 1, 1)", "cyclomatic_complexity": 6, "code_length": 12, "category": "Hard", "quantized_value_input": "Mixed String", "quantized_value_output": "Non-Empty tuple", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}}
{"index": 179, "idx": 17, "code": "def get_versions(default={\"version\": \"unknown\", \"full\": \"\"}, verbose=False):\n    \n    \n    \n    \n\n    keywords = {\"refnames\": git_refnames, \"full\": git_full}\n    ver = git_versions_from_keywords(keywords, tag_prefix, verbose)\n    if ver:\n        return rep_by_pep440(ver)\n\n    try:\n        root = os.path.abspath(__file__)\n        \n        \n        \n        for i in range(len(versionfile_source.split(os.sep))):\n            root = os.path.dirname(root)\n    except NameError:\n        return default\n\n    return rep_by_pep440(\n        git_versions_from_vcs(tag_prefix, root, verbose)\n        or versions_from_parentdir(parentdir_prefix, root, verbose)\n        or default)", "input": "{'version': 'unknown', 'full': ''}, False", "output": "{'version': '0.1.2', 'full': '1ef835aee49f536a5a499db71927deac87f4152e'}", "cyclomatic_complexity": 5, "code_length": 15, "category": "Medium", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Non-Empty dictionary", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}}
{"index": 180, "idx": 18, "code": "def git_versions_from_vcs(tag_prefix, root, verbose=False):\n    \n    \n    \n    \n\n    if not os.path.exists(os.path.join(root, \".git\")):\n        if verbose:\n            print(\"no .git in %s\" % root)\n        return {}\n\n    GITS = [\"git\"]\n    if sys.platform == \"win32\":\n        GITS = [\"git.cmd\", \"git.exe\"]\n    stdout = run_command(GITS, [\"describe\", \"--tags\", \"--dirty\", \"--always\"],\n                         cwd=root)\n    if stdout is None:\n        return {}\n    if not stdout.startswith(tag_prefix):\n        if verbose:\n            print(\"tag '%s' doesn't start with prefix '%s'\"\n                  % (stdout, tag_prefix))\n        return {}\n    tag = stdout[len(tag_prefix):]\n    stdout = run_command(GITS, [\"rev-parse\", \"HEAD\"], cwd=root)\n    if stdout is None:\n        return {}\n    full = stdout.strip()\n    if tag.endswith(\"-dirty\"):\n        full += \"-dirty\"\n    return {\"version\": tag, \"full\": full}", "input": "'v', '/local/rcs/XXX/code/pytrace-collector/logs/pypibugs/tried/andsor+pydevs/andsor+pydevs', False", "output": "{'version': '0.1.2', 'full': '1ef835aee49f536a5a499db71927deac87f4152e'}", "cyclomatic_complexity": 9, "code_length": 25, "category": "Hard", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Non-Empty dictionary", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}}
{"index": 181, "idx": 19, "code": "def run_command(commands, args, cwd=None, verbose=False, hide_stderr=False):\n    assert isinstance(commands, list)\n    p = None\n    for c in commands:\n        try:\n            \n            p = subprocess.Popen([c] + args, cwd=cwd, stdout=subprocess.PIPE,\n                                 stderr=(subprocess.PIPE if hide_stderr\n                                         else None))\n            break\n        except EnvironmentError:\n            e = sys.exc_info()[1]\n            if e.errno == errno.ENOENT:\n                continue\n            if verbose:\n                print(\"unable to run %s\" % args[0])\n                print(e)\n            return None\n    else:\n        if verbose:\n            print(\"unable to find command, tried %s\" % (commands,))\n        return None\n    stdout = p.communicate()[0].strip()\n    if sys.version >= '3':\n        stdout = stdout.decode()\n    if p.returncode != 0:\n        if verbose:\n            print(\"unable to run %s (error)\" % args[0])\n        return None\n    return stdout", "input": "['git'], ['describe', '--tags', '--dirty', '--always'], '/local/rcs/XXX/code/pytrace-collector/logs/pypibugs/tried/andsor+pydevs/andsor+pydevs', False, False", "output": "'v0.1.2'", "cyclomatic_complexity": 10, "code_length": 29, "category": "Hard", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 203, "idx": 20, "code": "def preprocess_python(code):\n    \n\n    code = code.strip()\n\n    \n    \n    if not any(line.strip().startswith((\"!\", \"%\")) for line in code.split(\"\\n\")):\n        code = add_active_line_prints(code)\n\n    \n    \n\n    \n    \n    code_lines = code.split(\"\\n\")\n    code_lines = [c for c in code_lines if c.strip() != \"\"]\n    code = \"\\n\".join(code_lines)\n\n    return code", "input": "'import getpass\\nimport os\\nimport platform'", "output": "\"print('##active_line1##')\\nimport getpass\\nprint('##active_line2##')\\nimport os\\nprint('##active_line3##')\\nimport platform\"", "cyclomatic_complexity": 2, "code_length": 8, "category": "Super Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 216, "idx": 21, "code": "def calculate_r_wheels(tyre_dimensions):\n    \n    if 'diameter' in tyre_dimensions:\n        if tyre_dimensions['code'] == 'pax':\n            return tyre_dimensions['diameter'] / 2000  \n        return tyre_dimensions['diameter'] * 0.0254  \n    a = tyre_dimensions['aspect_ratio'] / 100  \n    w = tyre_dimensions['nominal_section_width']\n    if tyre_dimensions.get('code', 'iso') == 'iso':\n        w /= 1000  \n    else:\n        w *= 0.0254  \n\n    dr = tyre_dimensions['rim_diameter'] * 0.0254  \n    return a * w + dr / 2", "input": "{'code': 'iso', 'carcass': 'R', 'nominal_section_width': 265.0, 'use': 'LT', 'load_range': 'D', 'rim_diameter': 15.0, 'aspect_ratio': 75.0}", "output": "0.38925", "cyclomatic_complexity": 4, "code_length": 13, "category": "Medium", "quantized_value_input": "Non-Empty dictionary", "quantized_value_output": "Positive Small", "input_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}, "output_mapping_info": {"value == 0.0": "zero", "0.0 < value <= 1.0": "Positive Small", "1.0 < value <= 10.0": "Positive Regular", "value > 10.0": "Positive Large", "-1.0 <= value < 0.0": "Negative Small", "-10.0 <= value < -1.0": "Negative Regular", "value < -10.0": "Negative Large"}}
{"index": 217, "idx": 22, "code": "def calculate_tyre_dimensions(tyre_code):\n    \n    import schema\n    it = [\n        ('iso', _re_tyre_code_iso),\n        ('numeric', _re_tyre_code_numeric),\n        ('pax', _re_tyre_code_pax)\n    ]\n    for c, _r in it:\n        try:\n            m = _r.match(tyre_code).groupdict()\n            m['code'] = c\n            if c == 'numeric' and 'aspect_ratio' not in m:\n                b = m['nominal_section_width'].split('.')[-1][-1] == '5'\n                m['aspect_ratio'] = '82' if b else '92'\n            return _format_tyre_dimensions(m)\n        except (AttributeError, schema.SchemaError):\n            pass\n    raise ValueError('Invalid tyre code: %s', tyre_code)", "input": "'205-640 R 440 A 94 T (94 V, 97 H)'", "output": "{'nominal_section_width': 205.0, 'diameter': 640.0, 'carcass': 'R', 'rim_diameter': 440.0, 'load_range': 'A', 'load_index': '94', 'speed_rating': 'T', 'additional_marks': '(94 V, 97 H)', 'code': 'pax'}", "cyclomatic_complexity": 5, "code_length": 18, "category": "Medium", "quantized_value_input": "Mixed String", "quantized_value_output": "Non-Empty dictionary", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}}
{"index": 222, "idx": 23, "code": "def parse_cmd_flags(cmd_flags=None):\n    \n    flags = sh.combine_dicts(cmd_flags or {}, base={\n        'only_summary': False,\n        'hard_validation': False,\n        'declaration_mode': False,\n        'enable_selector': False,\n        'type_approval_mode': False,\n        'encryption_keys': None,\n        'sign_key': None,\n        'output_template': sh.NONE,\n        'encryption_keys_passwords': None,\n        'output_folder': './outputs',\n        'augmented_summary': False\n    })\n    flags['declaration_mode'] |= flags['type_approval_mode']\n    flags['hard_validation'] |= flags['declaration_mode']\n    if flags['declaration_mode'] and not flags['type_approval_mode'] and \\\n            flags['enable_selector']:\n        log.info(\n            'Since CO2MPAS is launched in declaration mode the option '\n            '--enable-selector is not used.\\n'\n            'If you want to use it remove -DM from the cmd.'\n        )\n        flags['enable_selector'] = False\n    return sh.selector(_cmd_flags, flags, output_type='list')", "input": "{'type_approval_mode': True, 'encryption_keys': '/local/rcs/XXX/code/pytrace-collector/logs/pypibugs/tried/JRCSTU+co2mpas-ta/JRCSTU+co2mpas-ta/tests/files/keys/dice.co2mpas.keys', 'output_folder': './outputs', 'sign_key': './DICE_KEYS/sign.co2mpas.key', 'only_summary': False, 'augmented_summary': False, 'hard_validation': False, 'declaration_mode': False, 'enable_selector': False, 'encryption_keys_passwords': './DICE_KEYS/secret.passwords'}", "output": "[False, True, True, False, True, '/local/rcs/XXX/code/pytrace-collector/logs/pypibugs/tried/JRCSTU+co2mpas-ta/JRCSTU+co2mpas-ta/tests/files/keys/dice.co2mpas.keys', './DICE_KEYS/sign.co2mpas.key', none, './outputs', './DICE_KEYS/secret.passwords', False]", "cyclomatic_complexity": 2, "code_length": 25, "category": "Super Easy", "quantized_value_input": "Non-Empty dictionary", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 226, "idx": 24, "code": "def _co2mpas_info2df(start_time, main_flags=None):\n    import socket\n    import datetime\n    from co2mpas import __version__\n    from ..load.schema import define_flags_schema\n    time_elapsed = (datetime.datetime.today() - start_time).total_seconds()\n    hostname = socket.gethostname()\n    info = [\n        ('CO2MPAS version', __version__),\n        ('Simulation started', start_time.strftime('%Y/%m/%d-%H:%M:%S')),\n        ('Time elapsed', '%.3f sec' % time_elapsed),\n        ('Hostname', hostname),\n    ]\n\n    if main_flags:\n        main_flags = define_flags_schema(read=False).validate(main_flags)\n        info.extend(sorted(main_flags.items()))\n    import pandas as pd\n    df = pd.DataFrame(info, columns=['Parameter', 'Value'])\n    df.set_index(['Parameter'], inplace=True)\n    setattr(df, 'name', 'info')\n    return df", "input": "datetime.datetime(2024, 4, 3, 16, 28, 9, 62286), None", "output": "                                  ValueParameter                              CO2MPAS version                   4.1.6Simulation started  2024/04/03-16:28:09Time elapsed                103.530 secHostname                           thor", "cyclomatic_complexity": 2, "code_length": 21, "category": "Super Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 237, "idx": 25, "code": "def parse_all(raw_dict: Dict[str, List[str]]) -> Mapping[str, Any]:\n    \n    processed_data = {}\n    raw_dict.setdefault(\"CR\", [])\n    for key, seq in raw_dict.items():\n        processed_data.update(parse(key, seq))\n    return processed_data", "input": "{'AU': ['L Antuan'], 'PY': ['2008'], 'J9': ['P IEEE'], 'VL': ['69'], 'BP': ['1810'], 'DI': ['DOI 10.1109/JPROC.2008.2004315']}", "output": "{'AU': ['L Antuan'], 'authors': ['L Antuan'], 'PY': 2008, 'year_published': 2008, 'year': 2008, 'publication_year': 2008, 'J9': 'P IEEE', 'source_abbreviation': 'P IEEE', 'VL': '69', 'volume': '69', 'BP': '1810', 'beginning_page': '1810', 'DI': 'DOI 10.1109/JPROC.2008.2004315', 'digital_object_identifier': 'DOI 10.1109/JPROC.2008.2004315', 'DOI': 'DOI 10.1109/JPROC.2008.2004315', 'CR': [], 'cited_references': [], 'references': [], 'citations': []}", "cyclomatic_complexity": 2, "code_length": 6, "category": "Super Easy", "quantized_value_input": "Non-Empty dictionary", "quantized_value_output": "Non-Empty dictionary", "input_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}, "output_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}}
{"index": 251, "idx": 26, "code": "def _get_builtin_metadata(dataset_name):\n    if dataset_name == \"coco\":\n        return _get_coco_instances_meta()\n    if dataset_name == \"coco_panoptic_separated\":\n        return _get_coco_panoptic_separated_meta()\n    elif dataset_name == \"coco_panoptic_standard\":\n        meta = {}\n        \n        \n        \n        \n        \n        \n        thing_classes = [k[\"name\"] for k in COCO_CATEGORIES]\n        thing_colors = [k[\"color\"] for k in COCO_CATEGORIES]\n        stuff_classes = [k[\"name\"] for k in COCO_CATEGORIES]\n        stuff_colors = [k[\"color\"] for k in COCO_CATEGORIES]\n\n        meta[\"thing_classes\"] = thing_classes\n        meta[\"thing_colors\"] = thing_colors\n        meta[\"stuff_classes\"] = stuff_classes\n        meta[\"stuff_colors\"] = stuff_colors\n\n        \n        \n        \n        \n        \n        \n        \n        \n        thing_dataset_id_to_contiguous_id = {}\n        stuff_dataset_id_to_contiguous_id = {}\n\n        for i, cat in enumerate(COCO_CATEGORIES):\n            if cat[\"isthing\"]:\n                thing_dataset_id_to_contiguous_id[cat[\"id\"]] = i\n            else:\n                stuff_dataset_id_to_contiguous_id[cat[\"id\"]] = i\n\n        meta[\"thing_dataset_id_to_contiguous_id\"] = thing_dataset_id_to_contiguous_id\n        meta[\"stuff_dataset_id_to_contiguous_id\"] = stuff_dataset_id_to_contiguous_id\n\n        return meta\n    elif dataset_name == \"coco_person\":\n        return {\n            \"thing_classes\": [\"person\"],\n            \"keypoint_names\": COCO_PERSON_KEYPOINT_NAMES,\n            \"keypoint_flip_map\": COCO_PERSON_KEYPOINT_FLIP_MAP,\n            \"keypoint_connection_rules\": KEYPOINT_CONNECTION_RULES,\n        }\n    elif dataset_name == \"cityscapes\":\n        \n        CITYSCAPES_THING_CLASSES = [\n            \"person\", \"rider\", \"car\", \"truck\",\n            \"bus\", \"train\", \"motorcycle\", \"bicycle\",\n        ]\n        CITYSCAPES_STUFF_CLASSES = [\n            \"road\", \"sidewalk\", \"building\", \"wall\", \"fence\", \"pole\", \"traffic light\",\n            \"traffic sign\", \"vegetation\", \"terrain\", \"sky\", \"person\", \"rider\", \"car\",\n            \"truck\", \"bus\", \"train\", \"motorcycle\", \"bicycle\",\n        ]\n        \n        return {\n            \"thing_classes\": CITYSCAPES_THING_CLASSES,\n            \"stuff_classes\": CITYSCAPES_STUFF_CLASSES,\n        }\n    raise KeyError(\"No built-in metadata for dataset {}\".format(dataset_name))", "input": "'cityscapes'", "output": "{'thing_classes': ['person', 'rider', 'car', 'truck', 'bus', 'train', 'motorcycle', 'bicycle'], 'stuff_classes': ['road', 'sidewalk', 'building', 'wall', 'fence', 'pole', 'traffic light', 'traffic sign', 'vegetation', 'terrain', 'sky', 'person', 'rider', 'car', 'truck', 'bus', 'train', 'motorcycle', 'bicycle']}", "cyclomatic_complexity": 8, "code_length": 47, "category": "Hard", "quantized_value_input": "Alphabetic String", "quantized_value_output": "Non-Empty dictionary", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}}
{"index": 254, "idx": 27, "code": "def set(self, **kwargs):\n        \n        for k, v in kwargs.items():\n            setattr(self, k, v)\n        return self", "input": "Metadata(name='voc_2007_trainval'), {'thing_classes': ['aeroplane', 'bicycle', 'bird', 'boat', 'bottle', 'bus', 'car', 'cat', 'chair', 'cow', 'diningtable', 'dog', 'horse', 'motorbike', 'person', 'pottedplant', 'sheep', 'sofa', 'train', 'tvmonitor'], 'dirname': 'datasets/VOC2007', 'year': 2007, 'split': 'trainval'}, 'voc_2007_trainval'", "output": "Metadata(name='voc_2007_trainval', thing_classes=['aeroplane', 'bicycle', 'bird', 'boat', 'bottle', 'bus', 'car', 'cat', 'chair', 'cow', 'diningtable', 'dog', 'horse', 'motorbike', 'person', 'pottedplant', 'sheep', 'sofa', 'train', 'tvmonitor'], dirname='datasets/VOC2007', year=2007, split='trainval')", "cyclomatic_complexity": 2, "code_length": 4, "category": "Super Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 270, "idx": 28, "code": "def freeze_module(module: nn.Module, name=None) -> nn.Module:\n    \n    for param_name, parameter in module.named_parameters():\n        if name is None or name in param_name:\n            parameter.requires_grad = False\n\n    \n    for module_name, sub_module in module.named_modules():\n        \n        if name is None or name in module_name:\n            sub_module.eval()\n\n    return module", "input": "BatchNorm2d(10, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True), None", "output": "BatchNorm2d(10, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)", "cyclomatic_complexity": 5, "code_length": 8, "category": "Medium", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 274, "idx": 29, "code": "def fmt_dtype(hdf_dt):\n    \n    size = hdf_dt.get_size()\n\n    if isinstance(hdf_dt, h5t.TypeIntegerID):\n        \n        for candidate, descr in int_types_by_size().get(size, ()):\n            if hdf_dt == candidate:\n                return descr\n        un = 'un' if hdf_dt.get_sign() == h5t.SGN_NONE else ''\n        return \"{}-byte {}signed integer\".format(size, un)\n    elif isinstance(hdf_dt, h5t.TypeFloatID):\n        \n        for candidate, descr in float_types_by_size().get(size, ()):\n            if hdf_dt == candidate:\n                return descr\n        return \"custom {}-byte float\".format(size)\n    elif isinstance(hdf_dt, h5t.TypeBitfieldID):\n        return \"{}-byte bitfield\".format(size)\n    elif isinstance(hdf_dt, h5t.TypeTimeID):\n        return \"time\"  \n    elif isinstance(hdf_dt, h5t.TypeOpaqueID):\n        s = \"{}-byte opaque\".format(size)\n        tag = hdf_dt.get_tag()\n        if tag:\n            s += ' ({})'.format(tag.decode('utf-8', 'replace'))\n        return s\n    elif isinstance(hdf_dt, h5t.TypeStringID):\n        cset = cset_names.get(hdf_dt.get_cset(), '?cset')\n        if hdf_dt.is_variable_str():\n            return \"{} string\".format(cset)\n        else:\n            return \"{}-byte {} string\".format(size, cset)\n    elif isinstance(hdf_dt, h5t.TypeVlenID):\n        return \"vlen array of \" + fmt_dtype(hdf_dt.get_super())\n    elif isinstance(hdf_dt, h5t.TypeArrayID):\n        shape = fmt_shape(hdf_dt.get_array_dims())\n        return \"{} array of {}\".format(shape, fmt_dtype(hdf_dt.get_super()))\n\n    elif isinstance(hdf_dt, h5t.TypeCompoundID):\n        return \"({})\".format(\", \".join(\n            \"{}: {}\".format(\n                hdf_dt.get_member_name(i).decode('utf-8', 'replace'),\n                fmt_dtype(hdf_dt.get_member_type(i))\n            )\n            for i in range(hdf_dt.get_nmembers())\n        ))\n    elif isinstance(hdf_dt, h5t.TypeEnumID):\n        nmembers = hdf_dt.get_nmembers()\n        if nmembers >= 5:\n            return \"enum ({} options)\".format(nmembers)\n        else:\n            return \"enum ({})\".format(\", \".join(\n                hdf_dt.get_member_name(i).decode('utf-8', 'replace')\n                for i in range(nmembers)\n            ))\n    elif isinstance(hdf_dt, h5t.TypeReferenceID):\n        return \"region ref\" if hdf_dt == h5t.STD_REF_DSETREG else \"object ref\"\n\n    return \"unrecognised {}-byte datatype\".format(size)", "input": "REPR FAILED", "output": "'float32'", "cyclomatic_complexity": 19, "code_length": 54, "category": "Hard", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 276, "idx": 30, "code": "def dtype_description(hdf_dt):\n    \n    size = hdf_dt.get_size()\n\n    if isinstance(hdf_dt, h5t.TypeIntegerID):\n        \n        for candidate, descr in int_types_by_size().get(size, ()):\n            if hdf_dt == candidate:\n                un = 'un' if hdf_dt.get_sign() == h5t.SGN_NONE else ''\n                return '{}-bit {}signed integer'.format(size * 8, un)\n\n    elif isinstance(hdf_dt, h5t.TypeFloatID):\n        \n        for candidate, descr in float_types_by_size().get(size, ()):\n            if hdf_dt == candidate:\n                return '{}-bit floating point'.format(size * 8)\n\n    return None", "input": "REPR FAILED", "output": "'32-bit floating point'", "cyclomatic_complexity": 7, "code_length": 12, "category": "Hard", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 299, "idx": 31, "code": "def wrap_text(text, width):\n        \n        out = []\n        for paragraph in text.splitlines():\n            \n            \n            \n            lines = wrap(paragraph, width=width) or ['']\n            out.extend(lines)\n        return out", "input": "'four score\\nand seven\\n\\n', 6", "output": "['four', 'score', 'and', 'seven', '']", "cyclomatic_complexity": 2, "code_length": 6, "category": "Super Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Non-Empty List", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty List", "len(value) > 0": "Non-Empty List"}}
{"index": 303, "idx": 32, "code": "def normalize_url(url):\n    \n    if url.endswith('.json'):\n        url = url[:-5]\n    if url.endswith('/'):\n        url = url[:-1]\n    return url", "input": "'https://www.reddit.com/r/CollegeBasketball/comments/31owr1.json'", "output": "'https://www.reddit.com/r/CollegeBasketball/comments/31owr1'", "cyclomatic_complexity": 3, "code_length": 6, "category": "Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 328, "idx": 33, "code": "def _prepare_references_in_schema(schema: Dict[str, Any]) -> Dict[str, Any]:\n    \n    \n    \n    schema = copy.deepcopy(schema)\n\n    def _prepare_refs(d: Dict[str, Any]) -> Dict[str, Any]:\n        \n        for key, value in d.items():\n            if key == \"$ref\":\n                d[key] = _VEGA_LITE_ROOT_URI + d[key]\n            else:\n                \n                \n                \n                \n                if isinstance(value, dict):\n                    d[key] = _prepare_refs(value)\n                elif isinstance(value, list):\n                    prepared_values = []\n                    for v in value:\n                        if isinstance(v, dict):\n                            v = _prepare_refs(v)\n                        prepared_values.append(v)\n                    d[key] = prepared_values\n        return d\n\n    schema = _prepare_refs(schema)\n    return schema", "input": "{'$ref': '#/definitions/ExprRef'}", "output": "{'$ref': 'urn:vega-lite-schema#/definitions/ExprRef'}", "cyclomatic_complexity": 8, "code_length": 19, "category": "Hard", "quantized_value_input": "Non-Empty dictionary", "quantized_value_output": "Non-Empty dictionary", "input_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}, "output_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}}
{"index": 329, "idx": 34, "code": "def _group_errors_by_validator(errors: ValidationErrorList) -> GroupedValidationErrors:\n    \n    errors_by_validator: DefaultDict[\n        str, ValidationErrorList\n    ] = collections.defaultdict(list)\n    for err in errors:\n        \n        \n        \n        errors_by_validator[err.validator].append(err)  \n    return dict(errors_by_validator)", "input": "[<ValidationError: \"4 is not of type 'string'\">]", "output": "{'type': [<ValidationError: \"4 is not of type 'string'\">]}", "cyclomatic_complexity": 2, "code_length": 7, "category": "Super Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 331, "idx": 35, "code": "def eval_block(code, namespace=None, filename=\"<string>\"):\n    \n    tree = ast.parse(code, filename=\"<ast>\", mode=\"exec\")\n    if namespace is None:\n        namespace = {}\n    catch_display = _CatchDisplay()\n\n    if isinstance(tree.body[-1], ast.Expr):\n        to_exec, to_eval = tree.body[:-1], tree.body[-1:]\n    else:\n        to_exec, to_eval = tree.body, []\n\n    for node in to_exec:\n        compiled = compile(ast.Module([node], []), filename=filename, mode=\"exec\")\n        exec(compiled, namespace)\n\n    with catch_display:\n        for node in to_eval:\n            compiled = compile(\n                ast.Interactive([node]), filename=filename, mode=\"single\"\n            )\n            exec(compiled, namespace)\n\n    return catch_display.output", "input": "b'\"\"\"\\nHorizontal Bar Chart\\n--------------------\\nThis example is a bar chart drawn horizontally by putting the quantitative value on the x axis.\\n\"\"\"\\n# category: bar charts\\nimport altair as alt\\nfrom vega_datasets import data\\n\\nsource = data.wheat()\\n\\nalt.Chart(source).mark_bar().encode(\\n    x=\\'wheat:Q\\',\\n    y=\"year:O\"\\n).properties(height=700)\\n', None, '<string>'", "output": "alt.Chart(...)", "cyclomatic_complexity": 5, "code_length": 19, "category": "Medium", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 339, "idx": 36, "code": "def infer_encoding_types(args: Sequence, kwargs: MutableMapping, channels: ModuleType):\n    \n    \n    \n    channel_objs = (getattr(channels, name) for name in dir(channels))\n    channel_objs = (\n        c for c in channel_objs if isinstance(c, type) and issubclass(c, SchemaBase)\n    )\n    channel_to_name: Dict[Type[SchemaBase], str] = {\n        c: c._encoding_name for c in channel_objs\n    }\n    name_to_channel: Dict[str, Dict[str, Type[SchemaBase]]] = {}\n    for chan, name in channel_to_name.items():\n        chans = name_to_channel.setdefault(name, {})\n        if chan.__name__.endswith(\"Datum\"):\n            key = \"datum\"\n        elif chan.__name__.endswith(\"Value\"):\n            key = \"value\"\n        else:\n            key = \"field\"\n        chans[key] = chan\n\n    \n    for arg in args:\n        if isinstance(arg, (list, tuple)) and len(arg) > 0:\n            type_ = type(arg[0])\n        else:\n            type_ = type(arg)\n\n        encoding = channel_to_name.get(type_, None)\n        if encoding is None:\n            raise NotImplementedError(\"positional of type {}\" \"\".format(type_))\n        if encoding in kwargs:\n            raise ValueError(\"encoding {} specified twice.\".format(encoding))\n        kwargs[encoding] = arg\n\n    def _wrap_in_channel_class(obj, encoding):\n        if isinstance(obj, SchemaBase):\n            return obj\n\n        if isinstance(obj, str):\n            obj = {\"shorthand\": obj}\n\n        if isinstance(obj, (list, tuple)):\n            return [_wrap_in_channel_class(subobj, encoding) for subobj in obj]\n\n        if encoding not in name_to_channel:\n            warnings.warn(\n                \"Unrecognized encoding channel '{}'\".format(encoding), stacklevel=1\n            )\n            return obj\n\n        classes = name_to_channel[encoding]\n        cls = classes[\"value\"] if \"value\" in obj else classes[\"field\"]\n\n        try:\n            \n            \n            return cls.from_dict(obj, validate=False)\n        except jsonschema.ValidationError:\n            \n            return obj\n\n    return {\n        encoding: _wrap_in_channel_class(obj, encoding)\n        for encoding, obj in kwargs.items()\n    }", "input": "(), {'latitude': 'latitude:Q', 'longitude': 'longitude:Q', 'latitude2': 'lat2:Q', 'longitude2': 'lon2:Q'}, <module 'altair.vegalite.v5.schema.channels' from '/local/rcs/XXX/code/pytrace-collector/logs/self_collected/tried/altair-viz+altair/altair-viz+altair/altair/vegalite/v5/schema/channels.py'>", "output": "{'latitude': Latitude({  shorthand: 'latitude:Q'}), 'longitude': Longitude({  shorthand: 'longitude:Q'}), 'latitude2': Latitude2({  shorthand: 'lat2:Q'}), 'longitude2': Longitude2({  shorthand: 'lon2:Q'})}", "cyclomatic_complexity": 15, "code_length": 51, "category": "Hard", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 342, "idx": 37, "code": "def _get(self, attr, default=Undefined):\n        \n        attr = self._kwds.get(attr, Undefined)\n        if attr is Undefined:\n            attr = default\n        return attr", "input": "alt.LayerChart(...), 'layer', Undefined, (), {'layer': [alt.Chart(...), alt.Chart(...)], 'autosize': Undefined, 'background': Undefined, 'config': Undefined, 'data': Undefined, 'datasets': Undefined, 'description': Undefined, 'encoding': Undefined, 'height': 500, 'name': Undefined, 'padding': Undefined, 'params': Undefined, 'projection': Undefined, 'resolve': Undefined, 'title': Undefined, 'transform': Undefined, 'usermeta': Undefined, 'view': Undefined, 'width': 750}", "output": "[alt.Chart(...), alt.Chart(...)]", "cyclomatic_complexity": 2, "code_length": 5, "category": "Super Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 344, "idx": 38, "code": "def _consolidate_data(data, context):\n    \n    values = Undefined\n    kwds = {}\n\n    if isinstance(data, core.InlineData):\n        if data.name is Undefined and data.values is not Undefined:\n            if isinstance(data.values, core.InlineDataset):\n                values = data.to_dict()[\"values\"]\n            else:\n                values = data.values\n            kwds = {\"format\": data.format}\n\n    elif isinstance(data, dict):\n        if \"name\" not in data and \"values\" in data:\n            values = data[\"values\"]\n            kwds = {k: v for k, v in data.items() if k != \"values\"}\n\n    if values is not Undefined:\n        name = _dataset_name(values)\n        data = core.NamedData(name=name, **kwds)\n        context.setdefault(\"datasets\", {})[name] = values\n\n    return data", "input": "UrlData({  url: 'https://cdn.jsdelivr.net/npm/vega-datasets@v1.29.0/data/airports.csv'}), {}", "output": "UrlData({  url: 'https://cdn.jsdelivr.net/npm/vega-datasets@v1.29.0/data/airports.csv'})", "cyclomatic_complexity": 7, "code_length": 19, "category": "Hard", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 346, "idx": 39, "code": "def _remove_layer_props(chart, subcharts, layer_props):\n    def remove_prop(subchart, prop):\n        \n        try:\n            if subchart[prop] is not Undefined:\n                subchart = subchart.copy()\n                subchart[prop] = Undefined\n        except KeyError:\n            pass\n        return subchart\n\n    output_dict = {}\n\n    if not subcharts:\n        \n        return output_dict, subcharts\n\n    for prop in layer_props:\n        if chart[prop] is Undefined:\n            \n            \n            values = []\n            for c in subcharts:\n                \n                try:\n                    val = c[prop]\n                    if val is not Undefined:\n                        values.append(val)\n                except KeyError:\n                    pass\n            if len(values) == 0:\n                pass\n            elif all(v == values[0] for v in values[1:]):\n                output_dict[prop] = values[0]\n            else:\n                raise ValueError(f\"There are inconsistent values {values} for {prop}\")\n        else:\n            \n            \n            if all(\n                getattr(c, prop, Undefined) is Undefined or c[prop] == chart[prop]\n                for c in subcharts\n            ):\n                output_dict[prop] = chart[prop]\n            else:\n                raise ValueError(f\"There are inconsistent values {values} for {prop}\")\n        subcharts = [remove_prop(c, prop) for c in subcharts]\n\n    return output_dict, subcharts", "input": "alt.LayerChart(...), [alt.Chart(...), alt.Chart(...)], ('height', 'width', 'view')", "output": "({'height': 500, 'width': 750}, [alt.Chart(...), alt.Chart(...)])", "cyclomatic_complexity": 15, "code_length": 38, "category": "Hard", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 347, "idx": 40, "code": "def to_values(data: DataType) -> ToValuesReturnType:\n    \n    check_data_type(data)\n    if hasattr(data, \"__geo_interface__\"):\n        if isinstance(data, pd.DataFrame):\n            data = sanitize_dataframe(data)\n        \n        \n        data_sanitized = sanitize_geo_interface(data.__geo_interface__)  \n        return {\"values\": data_sanitized}\n    elif isinstance(data, pd.DataFrame):\n        data = sanitize_dataframe(data)\n        return {\"values\": data.to_dict(orient=\"records\")}\n    elif isinstance(data, dict):\n        if \"values\" not in data:\n            raise KeyError(\"values expected in data dict, but not present.\")\n        return data\n    elif hasattr(data, \"__dataframe__\"):\n        \n        pi = import_pyarrow_interchange()\n        pa_table = sanitize_arrow_table(pi.from_dataframe(data))\n        return {\"values\": pa_table.to_pylist()}\n    else:\n        \n        raise ValueError(\"Unrecognized data type: {}\".format(type(data)))", "input": "   threshold0         90", "output": "{'values': [{'threshold': 90}]}", "cyclomatic_complexity": 7, "code_length": 20, "category": "Hard", "quantized_value_input": "Mixed String", "quantized_value_output": "Non-Empty dictionary", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}}
{"index": 348, "idx": 41, "code": "def sanitize_dataframe(df: pd.DataFrame) -> pd.DataFrame:  \n    \n    df = df.copy()\n\n    if isinstance(df.columns, pd.RangeIndex):\n        df.columns = df.columns.astype(str)\n\n    for col_name in df.columns:\n        if not isinstance(col_name, str):\n            raise ValueError(\n                \"Dataframe contains invalid column name: {0!r}. \"\n                \"Column names must be strings\".format(col_name)\n            )\n\n    if isinstance(df.index, pd.MultiIndex):\n        raise ValueError(\"Hierarchical indices not supported\")\n    if isinstance(df.columns, pd.MultiIndex):\n        raise ValueError(\"Hierarchical indices not supported\")\n\n    def to_list_if_array(val):\n        if isinstance(val, np.ndarray):\n            return val.tolist()\n        else:\n            return val\n\n    for dtype_item in df.dtypes.items():\n        \n        \n        \n        col_name = cast(str, dtype_item[0])\n        dtype = dtype_item[1]\n        dtype_name = str(dtype)\n        if dtype_name == \"category\":\n            \n            \n            \n            col = df[col_name].astype(object)\n            df[col_name] = col.where(col.notnull(), None)\n        elif dtype_name == \"string\":\n            \n            \n            col = df[col_name].astype(object)\n            df[col_name] = col.where(col.notnull(), None)\n        elif dtype_name == \"bool\":\n            \n            df[col_name] = df[col_name].astype(object)\n        elif dtype_name == \"boolean\":\n            \n            \n            col = df[col_name].astype(object)\n            df[col_name] = col.where(col.notnull(), None)\n        elif dtype_name.startswith(\"datetime\") or dtype_name.startswith(\"timestamp\"):\n            \n            \n            \n            \n            \n            \n            df[col_name] = (\n                df[col_name].apply(lambda x: x.isoformat()).replace(\"NaT\", \"\")\n            )\n        elif dtype_name.startswith(\"timedelta\"):\n            raise ValueError(\n                'Field \"{col_name}\" has type \"{dtype}\" which is '\n                \"not supported by Altair. Please convert to \"\n                \"either a timestamp or a numerical value.\"\n                \"\".format(col_name=col_name, dtype=dtype)\n            )\n        elif dtype_name.startswith(\"geometry\"):\n            \n            \n            continue\n        elif (\n            dtype_name\n            in {\n                \"Int8\",\n                \"Int16\",\n                \"Int32\",\n                \"Int64\",\n                \"UInt8\",\n                \"UInt16\",\n                \"UInt32\",\n                \"UInt64\",\n                \"Float32\",\n                \"Float64\",\n            }\n        ):  \n            \n            col = df[col_name].astype(object)\n            df[col_name] = col.where(col.notnull(), None)\n        elif numpy_is_subtype(dtype, np.integer):\n            \n            df[col_name] = df[col_name].astype(object)\n        elif numpy_is_subtype(dtype, np.floating):\n            \n            \n            col = df[col_name]\n            bad_values = col.isnull() | np.isinf(col)\n            df[col_name] = col.astype(object).where(~bad_values, None)\n        elif dtype == object:\n            \n            \n            col = df[col_name].astype(object).apply(to_list_if_array)\n            df[col_name] = col.where(col.notnull(), None)\n    return df", "input": "    symbol       date   price0     MSFT 2000-01-01   39.811     MSFT 2000-02-01   36.352     MSFT 2000-03-01   43.223     MSFT 2000-04-01   28.374     MSFT 2000-05-01   25.45..     ...        ...     ...555   AAPL 2009-11-01  199.91556   AAPL 2009-12-01  210.73557   AAPL 2010-01-01  192.06558   AAPL 2010-02-01  204.62559   AAPL 2010-03-01  223.02[560 rows x 3 columns]", "output": "    symbol                 date   price0     MSFT  2000-01-01T00:00:00   39.811     MSFT  2000-02-01T00:00:00   36.352     MSFT  2000-03-01T00:00:00   43.223     MSFT  2000-04-01T00:00:00   28.374     MSFT  2000-05-01T00:00:00   25.45..     ...                  ...     ...555   AAPL  2009-11-01T00:00:00  199.91556   AAPL  2009-12-01T00:00:00  210.73557   AAPL  2010-01-01T00:00:00  192.06558   AAPL  2010-02-01T00:00:00  204.62559   AAPL  2010-03-01T00:00:00  223.02[560 rows x 3 columns]", "cyclomatic_complexity": 20, "code_length": 74, "category": "Hard", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 357, "idx": 42, "code": "def lineAfterContext(line, prefix):\n    if line.startswith(prefix):\n        line = line[len(prefix):]\n\n    toks = line.split(' in ', 1)\n    if len(toks) == 2:\n        rest = toks[1].split(' ')\n        line = ' '.join(rest[1:])\n\n    return line", "input": "'ic| eins: zwei', 'ic| '", "output": "'eins: zwei'", "cyclomatic_complexity": 3, "code_length": 8, "category": "Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 358, "idx": 43, "code": "def argumentToString(obj):\n    s = DEFAULT_ARG_TO_STRING_FUNCTION(obj)\n    s = s.replace('\\\\n', '\\n')  \n    return s", "input": "1", "output": "'1'", "cyclomatic_complexity": 1, "code_length": 4, "category": "Super Easy", "quantized_value_input": "Positive Regular", "quantized_value_output": "Numeric String", "input_mapping_info": {"value == 0": "zero", "0 < value <= 10": "Positive Regular", "value > 10": "Positive Large", "-10 <= value < 0": "Negative Regular", "value < -10": "Negative Large"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 359, "idx": 44, "code": "def lineIsContextAndTime(line):\n    line = stripPrefix(line)  \n    context, time = line.split(' at ')\n\n    return (\n        lineIsContext(context) and\n        len(time.split(':')) == 3 and\n        len(time.split('.')) == 2)", "input": "'ic| test_icecream.py:229 in testAsArgument() at 01:15:24.779'", "output": "True", "cyclomatic_complexity": 1, "code_length": 7, "category": "Super Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Positive Regular", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"value == 0": "zero", "0 < value <= 10": "Positive Regular", "value > 10": "Positive Large", "-10 <= value < 0": "Negative Regular", "value < -10": "Negative Large"}}
{"index": 360, "idx": 45, "code": "def stripPrefix(line):\n    if line.startswith(ic.prefix):\n        line = line.strip()[len(ic.prefix):]\n    return line", "input": "'ic| test_icecream.py:229 in testAsArgument() at 01:15:24.779'", "output": "'test_icecream.py:229 in testAsArgument() at 01:15:24.779'", "cyclomatic_complexity": 2, "code_length": 4, "category": "Super Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 361, "idx": 46, "code": "def lineIsContext(line):\n    line = stripPrefix(line)  \n    sourceLocation, function = line.split(' in ')  \n    filename, lineNumber = sourceLocation.split(':')  \n    name, ext = splitext(filename)\n\n    return (\n        int(lineNumber) > 0 and\n        ext in ['.py', '.pyc', '.pyo'] and\n        name == splitext(MY_FILENAME)[0] and\n        (function == '<module>' or function.endswith('()')))", "input": "'test_icecream.py:229 in testAsArgument()'", "output": "True", "cyclomatic_complexity": 1, "code_length": 10, "category": "Super Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Positive Regular", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"value == 0": "zero", "0 < value <= 10": "Positive Regular", "value > 10": "Positive Large", "-10 <= value < 0": "Negative Regular", "value < -10": "Negative Large"}}
{"index": 362, "idx": 47, "code": "def format_pair(prefix, arg, value):\n    if arg is _arg_source_missing:\n        arg_lines = []\n        value_prefix = prefix\n    else:\n        arg_lines = indented_lines(prefix, arg)\n        value_prefix = arg_lines[-1] + ': '\n\n    looksLikeAString = value[0] + value[-1] in [\"''\", '\"\"']\n    if looksLikeAString:  \n        value = prefixLinesAfterFirst(' ', value)\n\n    value_lines = indented_lines(value_prefix, value)\n    lines = arg_lines[:-1] + value_lines\n    return '\\n'.join(lines)", "input": "'    ', 'multilineStr', \"'line1\\nline2'\"", "output": "\"    multilineStr: 'line1\\n                   line2'\"", "cyclomatic_complexity": 3, "code_length": 13, "category": "Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 363, "idx": 48, "code": "def prefixLinesAfterFirst(prefix, s):\n    lines = s.splitlines(True)\n\n    for i in range(1, len(lines)):\n        lines[i] = prefix + lines[i]\n\n    return ''.join(lines)", "input": "' ', \"'line1\\nline2'\"", "output": "\"'line1\\n line2'\"", "cyclomatic_complexity": 2, "code_length": 5, "category": "Super Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 380, "idx": 49, "code": "def strip_blank_lines(l):\n    \"Remove leading and trailing blank lines from a list of lines\"\n    while l and not l[0].strip():\n        del l[0]\n    while l and not l[-1].strip():\n        del l[-1]\n    return l", "input": "['Aggregate statistic to compute in each bin.', '', '- `count`: show the number of observations in each bin', '- `frequency`: show the number of observations divided by the bin width', '- `probability` or `proportion`: normalize such that bar heights sum to 1', '- `percent`: normalize such that bar heights sum to 100', '- `density`: normalize such that the total area of the histogram equals 1', '']", "output": "['Aggregate statistic to compute in each bin.', '', '- `count`: show the number of observations in each bin', '- `frequency`: show the number of observations divided by the bin width', '- `probability` or `proportion`: normalize such that bar heights sum to 1', '- `percent`: normalize such that bar heights sum to 100', '- `density`: normalize such that the total area of the histogram equals 1']", "cyclomatic_complexity": 3, "code_length": 7, "category": "Easy", "quantized_value_input": "Non-Empty List", "quantized_value_output": "Non-Empty List", "input_mapping_info": {"len(value) == 0": "Empty List", "len(value) > 0": "Non-Empty List"}, "output_mapping_info": {"len(value) == 0": "Empty List", "len(value) > 0": "Non-Empty List"}}
{"index": 400, "idx": 50, "code": "def _is_scope_subset(needle_scope, haystack_scope):\n        needle_scope = set(needle_scope.split()) if needle_scope else set()\n        haystack_scope = (\n            set(haystack_scope.split()) if haystack_scope else set()\n        )\n        return needle_scope <= haystack_scope", "input": "'playlist-modify-private', 'playlist-modify-public'", "output": "False", "cyclomatic_complexity": 1, "code_length": 6, "category": "Super Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Zero", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"value == 0": "zero", "0 < value <= 10": "Positive Regular", "value > 10": "Positive Large", "-10 <= value < 0": "Negative Regular", "value < -10": "Negative Large"}}
{"index": 409, "idx": 51, "code": "def hmac_digest(secret, message, encoding=\"utf-8\"):\n    \n    if isinstance(secret, str):\n        secret = secret.encode(encoding)\n    return hmac.new(secret, message.encode(encoding), hashlib.sha256).hexdigest()", "input": "'secret_hmac_for_userids', 'mat:secret', 'utf-8'", "output": "'a93d8634eee921a11354f428a42e47b74ac2f249bc852896ea267c70d593ef9c'", "cyclomatic_complexity": 2, "code_length": 4, "category": "Super Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 413, "idx": 52, "code": "def find_csv_separators(csv):\n    \n    lines = csv.strip().split('\\n')\n    \n    column_separator_candidates = {',', ';', '\\t', '|'}\n    for line in lines:\n        if not numeric_start.match(line):  \n            continue\n        remove_candidates = []\n        for column_separator in column_separator_candidates:\n            if column_separator not in line:\n                \n                remove_candidates.append(column_separator)\n        for remove_candidate in remove_candidates:\n            column_separator_candidates.remove(remove_candidate)\n\n    if len(column_separator_candidates) == 0:\n        raise CsvParseError('Could not find column and decimal separators')\n\n    if column_separator_candidates == {','}:\n        \n        return [',', '.']\n\n    if ',' in column_separator_candidates:\n        \n        decimal_separator = ','\n        column_separator_candidates.remove(',')\n    else:\n        decimal_separator = '.'\n\n    if len(column_separator_candidates) > 1:\n        raise CsvParseError(f'Found multiple potential column separators: {column_separator_candidates}')\n\n    return list(column_separator_candidates)[0], decimal_separator", "input": "'frequency,raw\\n20,0\\n1000,3\\n20000,0\\n'", "output": "[',', '.']", "cyclomatic_complexity": 10, "code_length": 24, "category": "Hard", "quantized_value_input": "Mixed String", "quantized_value_output": "Non-Empty List", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty List", "len(value) > 0": "Non-Empty List"}}
{"index": 414, "idx": 53, "code": "def parse_csv(csv):\n    lines = csv.strip().split('\\n')\n    lines = [line for line in lines if line.strip()]\n    csv = '\\n'.join(lines)\n    if autoeq_pattern.match(csv):  \n        columns = lines[0].split(',')\n        return {column: [float(line.split(',')[i]) for line in lines[1:]] for i, column in enumerate(columns)}\n\n    if rew_pattern.match(csv) or crinacle_pattern.match(csv):\n        \n        csv = '\\n'.join([re.sub(r'(?:, ?| |\\t)', '\\t', line) for line in lines if numeric_start.match(line) and '?' not in line])\n        lines = csv.split('\\n')\n\n    column_separator, decimal_separator = find_csv_separators(csv)\n    columns = find_csv_columns(csv, column_separator)\n\n    \n    if columns is None:\n        \n        ixs = {'frequency': 0, 'raw': 1}\n    else:\n        ixs = {'frequency': None, 'raw': None}\n        for i, column in enumerate(columns):\n            if re.match(r'^freq', column, flags=re.IGNORECASE):\n                ixs['frequency'] = i\n            if re.match(r'^(?:spl|gain|ampl|raw)', column, flags=re.IGNORECASE):\n                ixs['raw'] = i\n        if ixs['frequency'] is None:\n            if len(columns) == 2:  \n                ixs = {'frequency': 0, 'raw': 1}\n            else:\n                raise CsvParseError('Failed to find frequency column')\n        if ixs['raw'] is None:\n            raise CsvParseError('Failed to find SPL column')\n\n    \n    data_line_pattern = re.compile(rf'^-?\\d+(?:{column_separator}\\d+)?')\n    data = {'frequency': [], 'raw': []}\n    for line in lines:\n        if not data_line_pattern.match(line):\n            continue\n        cells = line.split(column_separator)\n        if decimal_separator == ',':\n            cells = [float(cell.replace(',', '.')) for cell in cells]\n        else:\n            cells = [float(cell) for cell in cells]\n        for column, ix in ixs.items():\n            data[column].append(cells[ix])\n    return data", "input": "'frequency,raw\\n20,0\\n1000,3\\n20000,0\\n'", "output": "{'frequency': [20.0, 1000.0, 20000.0], 'raw': [0.0, 3.0, 0.0]}", "cyclomatic_complexity": 14, "code_length": 41, "category": "Hard", "quantized_value_input": "Mixed String", "quantized_value_output": "Non-Empty dictionary", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}}
{"index": 415, "idx": 54, "code": "def find_csv_columns(csv, column_separator):\n    lines = csv.strip().split('\\n')\n    numeric_lines = [line for line in lines if column_separator in line and numeric_start.search(line)]\n    n_columns = list(set([len(line.split(column_separator)) for line in numeric_lines]))\n    if len(n_columns) != 1:\n        raise CsvParseError('Numeric lines have different number of columns')\n    n_columns = n_columns[0]\n    for line in lines:\n        if not numeric_start.search(line) and len(line.split(column_separator)) == n_columns:\n            return [cell.strip() for cell in line.split(column_separator)]", "input": "'freq\\tspl\\n20.0\\t0.0\\n1000.0\\t3.0\\n20000.0\\t0.0', '\\t'", "output": "['freq', 'spl']", "cyclomatic_complexity": 4, "code_length": 10, "category": "Medium", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Non-Empty List", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty List", "len(value) > 0": "Non-Empty List"}}
{"index": 418, "idx": 55, "code": "def is_sorted(a):\n    if len(a) <= 1:\n        return True\n    for i in range(1, len(a)):\n        if less(a[i], a[i - 1]):\n            return False\n    return True", "input": "[1, 2, 13, 22, 123]", "output": "True", "cyclomatic_complexity": 4, "code_length": 7, "category": "Medium", "quantized_value_input": "Non-Empty List", "quantized_value_output": "Positive Regular", "input_mapping_info": {"len(value) == 0": "Empty List", "len(value) > 0": "Non-Empty List"}, "output_mapping_info": {"value == 0": "zero", "0 < value <= 10": "Positive Regular", "value > 10": "Positive Large", "-10 <= value < 0": "Negative Regular", "value < -10": "Negative Large"}}
{"index": 423, "idx": 56, "code": "def partition(a, lo, hi):\n        i = lo\n        j = hi\n\n        while True:\n            while not util.less(a[lo], a[i]):\n                i += 1\n                if i >= hi:\n                    break\n\n            while util.less(a[lo], a[j]):\n                j -= 1\n                if j <= lo:\n                    break\n\n            if i >= j:\n                break\n\n            util.exchange(a, i, j)\n\n        util.exchange(a, lo, j)\n        return j", "input": "[4, 2, 1, 23, 4, 5, 6, 7, 8, 9, 20, 11, 13, 34, 66], 0, 14", "output": "3", "cyclomatic_complexity": 7, "code_length": 17, "category": "Hard", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Positive Regular", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"value == 0": "zero", "0 < value <= 10": "Positive Regular", "value > 10": "Positive Large", "-10 <= value < 0": "Negative Regular", "value < -10": "Negative Large"}}
{"index": 443, "idx": 57, "code": "def can_file_be_synced_on_current_platform(path):\n    \n    can_be_synced = True\n\n    \n    fullpath = os.path.join(os.environ[\"HOME\"], path)\n\n    \n    \n    \n    library_path = os.path.join(os.environ[\"HOME\"], \"Library/\")\n\n    if platform.system() == constants.PLATFORM_LINUX:\n        if fullpath.startswith(library_path):\n            can_be_synced = False\n\n    return can_be_synced", "input": "'some/file'", "output": "True", "cyclomatic_complexity": 3, "code_length": 8, "category": "Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Positive Regular", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"value == 0": "zero", "0 < value <= 10": "Positive Regular", "value > 10": "Positive Large", "-10 <= value < 0": "Negative Regular", "value < -10": "Negative Large"}}
{"index": 445, "idx": 58, "code": "def is_process_running(process_name):\n    \n    is_running = False\n\n    \n    if os.path.isfile(\"/usr/bin/pgrep\"):\n        dev_null = open(os.devnull, \"wb\")\n        returncode = subprocess.call([\"/usr/bin/pgrep\", process_name], stdout=dev_null)\n        is_running = bool(returncode == 0)\n\n    return is_running", "input": "'a*'", "output": "True", "cyclomatic_complexity": 2, "code_length": 7, "category": "Super Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Positive Regular", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"value == 0": "zero", "0 < value <= 10": "Positive Regular", "value > 10": "Positive Large", "-10 <= value < 0": "Negative Regular", "value < -10": "Negative Large"}}
{"index": 489, "idx": 59, "code": "def version_compare(self, other):\n        \"Compares version of the form [epoch:]upstream-version[-debian-revision]\" \\\n        + \" according to Debian package version number format.\"\n\n        \n        diff = self.epoch - other.epoch\n        if diff != 0:\n            return diff\n\n        \n        for slf, othr in (self.upstream_version, other.upstream_version), (self.revision, other.revision):\n            i = 0\n            while len(slf) > 0 or len(othr) > 0:\n                decimal = (i % 2 == 1) \n                slf_part, slf = self._get_part(slf, decimal=decimal)\n                othr_part, othr = self._get_part(othr, decimal=decimal)\n                diff = self._compare_parts(slf_part, othr_part, decimal=decimal)\n                if diff != 0:\n                    return diff\n                i += 1\n\n        \n        return 0", "input": "2.2.0~rc5, 2.2.0~rc5, 0, '0', ('.', '+', '~'), '2.2.0~rc5', ('.', '+', '~', '-', ':'), '2.2.0~rc5'", "output": "0", "cyclomatic_complexity": 5, "code_length": 17, "category": "Medium", "quantized_value_input": "Mixed String", "quantized_value_output": "Zero", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"value == 0": "zero", "0 < value <= 10": "Positive Regular", "value > 10": "Positive Large", "-10 <= value < 0": "Negative Regular", "value < -10": "Negative Large"}}
{"index": 490, "idx": 60, "code": "def _get_part(self, s, decimal):\n        \"Strips first part of string containing either non-decimal or decimal characters.\" \\\n        + \" Returns tuple (part, remider).\"\n        div = 0\n        for c in s:\n            if decimal and not c.isdecimal():\n                break\n            elif not decimal and c.isdecimal():\n                break\n            else:\n                div += 1\n\n        return (s[:div], s[div:])", "input": "2.2.0~rc5, '2.2.0~rc5', False, 0, '0', ('.', '+', '~'), '2.2.0~rc5', ('.', '+', '~', '-', ':'), '2.2.0~rc5'", "output": "('', '2.2.0~rc5')", "cyclomatic_complexity": 4, "code_length": 12, "category": "Medium", "quantized_value_input": "Mixed String", "quantized_value_output": "Non-Empty tuple", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}}
{"index": 491, "idx": 61, "code": "def _compare_parts(self, a, b, decimal):\n        if decimal:\n            if a == \"\": a = \"0\"\n            if b == \"\": b = \"0\"\n            return int(a) - int(b)\n        else:\n            i = 0\n            while i < (min(len(a), len(b)) + 1):\n                res = self._order(self._get_empty_str_on_index_error(a, i)) \\\n                        - self._order(self._get_empty_str_on_index_error(b, i))\n                if res != 0:\n                    return res\n                i += 1\n            else:\n                return 0", "input": "2.2.0~rc5, '', '', False, 0, '0', ('.', '+', '~'), '2.2.0~rc5', ('.', '+', '~', '-', ':'), '2.2.0~rc5'", "output": "0", "cyclomatic_complexity": 6, "code_length": 15, "category": "Hard", "quantized_value_input": "Mixed String", "quantized_value_output": "Zero", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"value == 0": "zero", "0 < value <= 10": "Positive Regular", "value > 10": "Positive Large", "-10 <= value < 0": "Negative Regular", "value < -10": "Negative Large"}}
{"index": 497, "idx": 62, "code": "def getorcreatesubcontext(self, path):\n        for name in path:\n            that = self.resolvables.get(name)\n            if that is None:\n                self.resolvables[name] = that = Context(self)\n            self = that\n        return self", "input": "Context(SuperContext(), False), ('woo',), False, SuperContext(), OrderedDict()", "output": "Context(Context(SuperContext(), False), False)", "cyclomatic_complexity": 3, "code_length": 7, "category": "Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 504, "idx": 63, "code": "def indent(self):\n        indent = []\n        for r in self.resolvables:\n            if not r.ignorable or r.boundary:\n                break\n            indent.append(r)\n        return Concat.unlesssingleton(indent).resolve(None).cat()", "input": "Entry([Text('woo'), Blank(' '), Text('+='), Blank(' '), Text('yay')]), [Text('woo'), Blank(' '), Text('+='), Blank(' '), Text('yay')]", "output": "''", "cyclomatic_complexity": 3, "code_length": 7, "category": "Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Empty String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 507, "idx": 64, "code": "def __eq__(self, that):\n        if type(self) != type(that):\n            return False\n        if self.__dict__.keys() != that.__dict__.keys():\n            return False\n        for k, v in self.__dict__.items():\n            if v != that.__dict__[k]:\n                return False\n        return True", "input": "Text('*'), Text('woo'), '*'", "output": "False", "cyclomatic_complexity": 5, "code_length": 9, "category": "Medium", "quantized_value_input": "Mixed String", "quantized_value_output": "Zero", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"value == 0": "zero", "0 < value <= 10": "Positive Regular", "value > 10": "Positive Large", "-10 <= value < 0": "Negative Regular", "value < -10": "Negative Large"}}
{"index": 508, "idx": 65, "code": "def resolve(self, context):\n        c = Context(self.parent, self.islist)\n        for name, r in self.resolvables.items():\n            if name is not None:\n                c.resolvables[name] = r\n        defaults = self.resolvables.get(None)\n        if defaults is not None:\n            for item in c.resolvables:\n                for dn, dr in defaults.resolvables.items():\n                    if dn not in item.resolvables.keys():\n                        item.resolvables[dn] = dr\n        return c", "input": "Context(Context(SuperContext(), False), False), Context(SuperContext(), False), False, Context(SuperContext(), False), OrderedDict([('yay', Text('yay')), ('$(houpla  )', Call('', [Text('houpla'), Blank('  ')], '()'))])", "output": "Context(Context(SuperContext(), False), False)", "cyclomatic_complexity": 7, "code_length": 12, "category": "Hard", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 514, "idx": 66, "code": "def temporarily(self, name, resolvable, block): \n        oldornone = self.resolvables.get(name)\n        self.resolvables[name] = resolvable\n        try:\n            return block()\n        finally:\n            if oldornone is None:\n                del self.resolvables[name]\n            else:\n                self.resolvables[name] = oldornone", "input": "Context(SuperContext(), False), ('v', 'one', '1'), {}, 0, False, SuperContext(), OrderedDict([('v', Context(Context(SuperContext(), False), False))])", "output": "Context(Context(Context(Context(SuperContext(), False), False), False), False)", "cyclomatic_complexity": 2, "code_length": 10, "category": "Super Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 518, "idx": 67, "code": "def map(context, objs, *args):\n        if 1 == len(args):\n            expr, = args\n            def g():\n                for k, v in objs.resolve(context).resolvables.items():\n                    c = v.createchild()\n                    c.label = Text(k)\n                    yield expr.resolve(c)\n            return List(list(g()))\n        elif 2 == len(args):\n            name, expr = args\n            name = name.resolve(context).cat()\n            def g():\n                for obj in objs.resolve(context):\n                    c = context.createchild()\n                    c[name,] = obj\n                    yield expr.resolve(c)\n            return List(list(g()))\n        else:\n            kname, vname, expr = args\n            kname = kname.resolve(context).cat()\n            vname = vname.resolve(context).cat()\n            def g():\n                for k, v in objs.resolve(context).resolvables.items():\n                    c = context.createchild()\n                    c[kname,] = Text(k)\n                    c[vname,] = v\n                    yield expr.resolve(c)\n            return List(list(g()))", "input": "Context(SuperContext(), False), Call('', [Text('items')], '()'), (Call('', [Text('value')], '()'),)", "output": "List([Text('woo')])", "cyclomatic_complexity": 9, "code_length": 29, "category": "Hard", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 519, "idx": 68, "code": "def resolve(self, context):\n        raise NotImplementedError", "input": "Call('list', [Text('a'), Blank(' '), Text('bb'), Blank(' '), Text('ccc')], '()'), Context(SuperContext(), False), False, [Text('a'), Blank(' '), Text('bb'), Blank(' '), Text('ccc')], '()', 'list'", "output": "Context(Context(SuperContext(), False), True)", "cyclomatic_complexity": 1, "code_length": 2, "category": "Super Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 520, "idx": 69, "code": "def merge_dict(source, overrides):\n    merged = source.copy()\n    merged.update(overrides)\n    return merged", "input": "{}, {}", "output": "{}", "cyclomatic_complexity": 1, "code_length": 4, "category": "Super Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Empty dictionary", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}}
{"index": 540, "idx": 70, "code": "def static_bool_env(varname: str, default: bool) -> bool:\n  \n  val = os.getenv(varname, str(default))\n  val = val.lower()\n  if val in ('y', 'yes', 't', 'true', 'on', '1'):\n    return True\n  elif val in ('n', 'no', 'f', 'false', 'off', '0'):\n    return False\n  else:\n    raise ValueError(\n      'invalid truth value {!r} for environment {!r}'.format(val, varname)\n    )", "input": "'FLAX_LAZY_RNG', True", "output": "True", "cyclomatic_complexity": 3, "code_length": 11, "category": "Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Positive Regular", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"value == 0": "zero", "0 < value <= 10": "Positive Regular", "value > 10": "Positive Large", "-10 <= value < 0": "Negative Regular", "value < -10": "Negative Large"}}
{"index": 544, "idx": 71, "code": "def splitdrive(path):\n    \n    relative = get_instance(path).relpath(path)\n    drive = path.rsplit(relative, 1)[0]\n    if drive and not drive[-2:] == '//':\n        \n        relative = '/' + relative\n        drive = drive.rstrip('/')\n    return drive, relative", "input": "'dummy://dir1/dir2/dir3'", "output": "('dummy://', 'dir1/dir2/dir3')", "cyclomatic_complexity": 2, "code_length": 7, "category": "Super Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Non-Empty tuple", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}}
{"index": 551, "idx": 72, "code": "def copy(src, dst):\n    \n    \n    src, src_is_storage = format_and_is_storage(src)\n    dst, dst_is_storage = format_and_is_storage(dst)\n\n    \n    if not src_is_storage and not dst_is_storage:\n        return shutil_copy(src, dst)\n\n    \n    if not hasattr(dst, 'read'):\n        \n        if isdir(dst):\n            dst = join(dst, basename(src))\n\n        \n        elif not isdir(dirname(dst)):\n            raise IOError(\"No such file or directory: '%s'\" % dst)\n\n    \n    _copy(src, dst, src_is_storage, dst_is_storage)", "input": "'/tmp/pytest-of-XXX/pytest-198/test_cos_open0/file.txt', '/tmp/pytest-of-XXX/pytest-198/test_cos_open0/file_dst.txt'", "output": "'/tmp/pytest-of-XXX/pytest-198/test_cos_open0/file_dst.txt'", "cyclomatic_complexity": 5, "code_length": 11, "category": "Medium", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 553, "idx": 73, "code": "def _handle_http_errors(response):\n    \n    code = response.status_code\n    if 200 <= code < 400:\n        return response\n    elif code in (403, 404):\n        raise {403: ObjectPermissionError,\n               404: ObjectNotFoundError}[code](response.reason)\n    response.raise_for_status()", "input": "{}", "output": "{}", "cyclomatic_complexity": 3, "code_length": 8, "category": "Easy", "quantized_value_input": "Empty dictionary", "quantized_value_output": "Empty dictionary", "input_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}, "output_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}}
{"index": 563, "idx": 74, "code": "def _getmtime_from_header(header):\n        \n        \n        for key in ('Last-Modified', 'last-modified'):\n            try:\n                return mktime(parsedate(header.pop(key)))\n            except KeyError:\n                continue\n        else:\n            raise UnsupportedOperation('getmtime')", "input": "{'Accept-Ranges': 'bytes', 'Content-Length': '100', 'Last-Modified': 'Wed, 03 Apr 2024 20:18:10 GMT'}", "output": "1712189890.0", "cyclomatic_complexity": 4, "code_length": 8, "category": "Medium", "quantized_value_input": "Non-Empty dictionary", "quantized_value_output": "Positive Large", "input_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}, "output_mapping_info": {"value == 0.0": "zero", "0.0 < value <= 1.0": "Positive Small", "1.0 < value <= 10.0": "Positive Regular", "value > 10.0": "Positive Large", "-1.0 <= value < 0.0": "Negative Small", "-10.0 <= value < -1.0": "Negative Regular", "value < -10.0": "Negative Large"}}
{"index": 565, "idx": 75, "code": "def _getsize_from_header(header):\n        \n        \n        for key in ('Content-Length', 'content-length'):\n            try:\n                return int(header.pop(key))\n            except KeyError:\n                continue\n        else:\n            raise UnsupportedOperation('getsize')", "input": "{'Accept-Ranges': 'bytes', 'Content-Length': '100'}", "output": "100", "cyclomatic_complexity": 4, "code_length": 8, "category": "Medium", "quantized_value_input": "Non-Empty dictionary", "quantized_value_output": "Positive Large", "input_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}, "output_mapping_info": {"value == 0": "zero", "0 < value <= 10": "Positive Regular", "value > 10": "Positive Large", "-10 <= value < 0": "Negative Regular", "value < -10": "Negative Large"}}
{"index": 568, "idx": 76, "code": "def parse_range(header):\n    \n\n    data_range = (header or dict()).get('Range')\n    if data_range is None:\n        \n        content = BYTE * SIZE\n\n    else:\n        \n        data_range = data_range.split('=')[1]\n        start, end = data_range.split('-')\n        start = int(start)\n        try:\n            end = int(end) + 1\n        except ValueError:\n            end = SIZE\n\n        if start >= SIZE:\n            \n            raise ValueError\n\n        if end > SIZE:\n            end = SIZE\n        content = BYTE * (end - start)\n\n    return content", "input": "{'Range': 'bytes=10-'}", "output": "b'000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'", "cyclomatic_complexity": 6, "code_length": 18, "category": "Hard", "quantized_value_input": "Non-Empty dictionary", "quantized_value_output": "Unknown Type", "input_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}, "output_mapping_info": {"Unknown Type": "No mapping available"}}
{"index": 603, "idx": 77, "code": "def run_command(commands, args, cwd=None, verbose=False, hide_stderr=False):\n    assert isinstance(commands, list)\n    p = None\n    for c in commands:\n        try:\n            dispcmd = str([c] + args)\n            \n            p = subprocess.Popen([c] + args, cwd=cwd, stdout=subprocess.PIPE,\n                                 stderr=(subprocess.PIPE if hide_stderr\n                                         else None))\n            break\n        except EnvironmentError:\n            e = sys.exc_info()[1]\n            if e.errno == errno.ENOENT:\n                continue\n            if verbose:\n                print(\"unable to run %s\" % dispcmd)\n                print(e)\n            return None\n    else:\n        if verbose:\n            print(\"unable to find command, tried %s\" % (commands,))\n        return None\n    stdout = p.communicate()[0].strip()\n    if sys.version_info[0] >= 3:\n        stdout = stdout.decode()\n    if p.returncode != 0:\n        if verbose:\n            print(\"unable to run %s (error)\" % dispcmd)\n        return None\n    return stdout", "input": "['git'], ['describe', '--tags', '--dirty', '--always', '--long'], '/local/rcs/XXX/code/pytrace-collector/logs/pypibugs/tried/danielfrg+datasciencebox/danielfrg+datasciencebox', False, False", "output": "'v0.3-35-g74ca80e'", "cyclomatic_complexity": 10, "code_length": 30, "category": "Hard", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 718, "idx": 78, "code": "def _makeNPIndex(indexList):\n        newinds = []\n        for i, item in enumerate(indexList):\n            if isinstance(item, list):\n                newinds.append(item)\n            elif isinstance(item,int):\n                newinds.append([item])\n\n        numpyInd = list(np.ix_(*newinds))\n        newinds=[]\n        for item in indexList:\n            if not item is None:\n                newinds.append(numpyInd.pop(0))\n            else:\n                newinds.append(None)\n\n        return tuple(newinds)", "input": "[[0, 1], [0, 1]]", "output": "(array([[0],       [1]]), array([[0, 1]]))", "cyclomatic_complexity": 6, "code_length": 15, "category": "Hard", "quantized_value_input": "Non-Empty List", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty List", "len(value) > 0": "Non-Empty List"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 734, "idx": 79, "code": "def get_bound(pts: Iterable[Point]) -> Rect:\n    \n    limit: Rect = (INF, INF, -INF, -INF)\n    (x0, y0, x1, y1) = limit\n    for (x, y) in pts:\n        x0 = min(x0, x)\n        y0 = min(y0, y)\n        x1 = max(x1, x)\n        y1 = max(y1, y)\n    return x0, y0, x1, y1", "input": "[(6, 7), (7, 7)]", "output": "(6, 7, 7, 7)", "cyclomatic_complexity": 2, "code_length": 9, "category": "Super Easy", "quantized_value_input": "Non-Empty List", "quantized_value_output": "Non-Empty tuple", "input_mapping_info": {"len(value) == 0": "Empty List", "len(value) > 0": "Non-Empty List"}, "output_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}}
{"index": 816, "idx": 80, "code": "def make_input_stream(input, charset):\n    \n    if hasattr(input, 'read'):\n        if PY2:\n            return input\n        rv = _find_binary_reader(input)\n        if rv is not None:\n            return rv\n        raise TypeError('Could not find binary reader for input stream.')\n\n    if input is None:\n        input = b''\n    elif not isinstance(input, bytes):\n        input = input.encode(charset)\n    if PY2:\n        return StringIO(input)\n    return io.BytesIO(input)", "input": "None, 'utf-8'", "output": "{}", "cyclomatic_complexity": 7, "code_length": 15, "category": "Hard", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Empty dictionary", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}}
{"index": 831, "idx": 81, "code": "def _unpack_args(args, nargs_spec):\n    \n    args = deque(args)\n    nargs_spec = deque(nargs_spec)\n    rv = []\n    spos = None\n\n    def _fetch(c):\n        try:\n            if spos is None:\n                return c.popleft()\n            else:\n                return c.pop()\n        except IndexError:\n            return None\n\n    while nargs_spec:\n        nargs = _fetch(nargs_spec)\n        if nargs == 1:\n            rv.append(_fetch(args))\n        elif nargs > 1:\n            x = [_fetch(args) for _ in range(nargs)]\n            \n            \n            if spos is not None:\n                x.reverse()\n            rv.append(tuple(x))\n        elif nargs < 0:\n            if spos is not None:\n                raise TypeError('Cannot have two nargs < 0')\n            spos = len(rv)\n            rv.append(None)\n\n    \n    \n    if spos is not None:\n        rv[spos] = tuple(args)\n        args = []\n        rv[spos + 1:] = reversed(rv[spos + 1:])\n\n    return tuple(rv), list(args)", "input": "['foo.txt', 'bar.txt', 'dir'], [-1, 1]", "output": "((('foo.txt', 'bar.txt'), 'dir'), [])", "cyclomatic_complexity": 12, "code_length": 32, "category": "Hard", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Non-Empty tuple", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}}
{"index": 832, "idx": 82, "code": "def _fetch(c):\n        try:\n            if spos is None:\n                return c.popleft()\n            else:\n                return c.pop()\n        except IndexError:\n            return None", "input": "deque([-1, 1]), None", "output": "-1", "cyclomatic_complexity": 4, "code_length": 8, "category": "Medium", "quantized_value_input": "Mixed String", "quantized_value_output": "Negative Regular", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"value == 0": "zero", "0 < value <= 10": "Positive Regular", "value > 10": "Positive Large", "-10 <= value < 0": "Negative Regular", "value < -10": "Negative Large"}}
{"index": 870, "idx": 83, "code": "def make_default_short_help(help, max_length=45):\n    words = help.split()\n    total_length = 0\n    result = []\n    done = False\n\n    for word in words:\n        if word[-1:] == '.':\n            done = True\n        new_length = result and 1 + len(word) or len(word)\n        if total_length + new_length > max_length:\n            result.append('...')\n            done = True\n        else:\n            if result:\n                result.append(' ')\n            result.append(word)\n        if done:\n            break\n        total_length += new_length\n\n    return ''.join(result)", "input": "'Hello World!', 45", "output": "'Hello World!'", "cyclomatic_complexity": 6, "code_length": 20, "category": "Hard", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 878, "idx": 84, "code": "def join_options(options):\n    \n    rv = []\n    any_prefix_is_slash = False\n    for opt in options:\n        prefix = split_opt(opt)[0]\n        if prefix == '/':\n            any_prefix_is_slash = True\n        rv.append((len(prefix), opt))\n\n    rv.sort(key=lambda x: x[0])\n\n    rv = ', '.join(x[1] for x in rv)\n    return rv, any_prefix_is_slash", "input": "['--help']", "output": "('--help', False)", "cyclomatic_complexity": 3, "code_length": 11, "category": "Easy", "quantized_value_input": "Non-Empty List", "quantized_value_output": "Non-Empty tuple", "input_mapping_info": {"len(value) == 0": "Empty List", "len(value) > 0": "Non-Empty List"}, "output_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}}
{"index": 881, "idx": 85, "code": "def measure_table(rows):\n    widths = {}\n    for row in rows:\n        for idx, col in enumerate(row):\n            widths[idx] = max(widths.get(idx, 0), term_len(col))\n    return tuple(y for x, y in sorted(widths.items()))", "input": "[('--help', 'Show this message and exit.')]", "output": "(6, 27)", "cyclomatic_complexity": 3, "code_length": 6, "category": "Easy", "quantized_value_input": "Non-Empty List", "quantized_value_output": "Non-Empty tuple", "input_mapping_info": {"len(value) == 0": "Empty List", "len(value) > 0": "Non-Empty List"}, "output_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}}
{"index": 887, "idx": 86, "code": "def filename_to_ui(value):\n        if isinstance(value, bytes):\n            value = value.decode(get_filesystem_encoding(), 'replace')\n        return value", "input": "b'foo.txt'", "output": "'foo.txt'", "cyclomatic_complexity": 2, "code_length": 4, "category": "Super Easy", "quantized_value_input": "Unknown Type", "quantized_value_output": "Mixed String", "input_mapping_info": {"Unknown Type": "No mapping available"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 907, "idx": 87, "code": "def _build_prompt(text, suffix, show_default=False, default=None):\n    prompt = text\n    if default is not None and show_default:\n        prompt = '%s [%s]' % (prompt, default)\n    return prompt + suffix", "input": "'Foo', ': ', True, None", "output": "'Foo: '", "cyclomatic_complexity": 2, "code_length": 5, "category": "Super Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 908, "idx": 88, "code": "def format_filename(filename, shorten=False):\n    \n    if shorten:\n        filename = os.path.basename(filename)\n    return filename_to_ui(filename)", "input": "'/x/foo.txt', True", "output": "'foo.txt'", "cyclomatic_complexity": 2, "code_length": 4, "category": "Super Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 913, "idx": 89, "code": "def encode_request(*args):\n    \n    result = [\"*\" + str(len(args)) + CRLF]\n    \n    for arg in args:\n        if arg is None:\n            result.append('$-1' + CRLF)\n        else:\n            s = str(arg)\n            result.append('$' + str(len(s)) + CRLF + s + CRLF)\n\n    return \"\".join(result)", "input": "('ping',)", "output": "'*1\\r\\n$4\\r\\nping\\r\\n'", "cyclomatic_complexity": 3, "code_length": 9, "category": "Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 914, "idx": 90, "code": "def parse_array(data, start=0):\n    endcnt = data.find(CRLF, start + 1)\n\n    if endcnt == -1:\n        raise ParseError(\"Unterminated array element count after pos {}.\".format(start + 1))\n\n    try:\n        count = int(data[start + 1:endcnt])\n    except (ValueError, TypeError):\n        raise ParseError(\"Invalid array element count at pos {} - {}.\".format(start + 1, endcnt))\n\n    start = endcnt + CRLFLEN\n\n    if count == -1:\n        return None, endcnt\n\n    result = []\n    \n    for i in range(count):\n        if start + 4 < len(data):\n            obj, start = _decode(data, start)\n            result.append(obj)\n        else:\n            raise ParseError(\"Unterminated array element at pos {}\".format(start))\n    \n    return result, start", "input": "'*3\\r\\n$3\\r\\nSET\\r\\n$15\\r\\nmemtier-8232902\\r\\n$2\\r\\nxx\\r\\n*3\\r\\n$3\\r\\nSET\\r\\n$15\\r\\nmemtier-8232902\\r\\n$2\\r\\nxx\\r\\n*3\\r\\n$3\\r\\nSET\\r\\n$15\\r\\nmemtier-7630684\\r\\n$3\\r\\nAAA\\r\\n', 0", "output": "(['SET', 'memtier-8232902', 'xx'], 43)", "cyclomatic_complexity": 7, "code_length": 19, "category": "Hard", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Non-Empty tuple", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}}
{"index": 938, "idx": 91, "code": "def fill_style(complete, filling):  \n                    odd = bool(complete % 2)\n                    fill = (None,) if odd != bool(filling) else ()  \n                    fill += (chars[-1], None) * int(complete / 2)  \n                    if filling and odd:\n                        fill += mark_graphemes((chars[filling - 1],))\n                    return fill", "input": "0, 0, ('=',)", "output": "()", "cyclomatic_complexity": 2, "code_length": 7, "category": "Super Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Empty tuple", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}}
{"index": 951, "idx": 92, "code": "def _input(x):\n        return name_lookup(x) or func_lookup(x) or default", "input": "0, 0, 86400", "output": "0.0", "cyclomatic_complexity": 1, "code_length": 2, "category": "Super Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "zero", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"value == 0.0": "zero", "0.0 < value <= 1.0": "Positive Small", "1.0 < value <= 10.0": "Positive Regular", "value > 10.0": "Positive Large", "-1.0 <= value < 0.0": "Negative Small", "-10.0 <= value < -1.0": "Negative Regular", "value < -10.0": "Negative Large"}}
{"index": 963, "idx": 93, "code": "def elapsed_text(seconds, precise, prefix=''):\n    seconds = round(seconds, 1 if precise else 0)\n    if seconds < 60.:\n        return '{}{:{}f}s'.format(prefix, seconds, .1 if precise else .0)\n\n    minutes, seconds = divmod(seconds, 60.)\n    if minutes < 60.:\n        return '{}{:.0f}:{:0{}f}'.format(prefix, minutes, seconds, 4.1 if precise else 2.0)\n\n    hours, minutes = divmod(minutes, 60.)\n    return '{}{:.0f}:{:02.0f}:{:0{}f}'.format(prefix, hours, minutes, seconds,\n                                              4.1 if precise else 2.0)", "input": "1.23, True, ''", "output": "'1.2s'", "cyclomatic_complexity": 3, "code_length": 10, "category": "Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 975, "idx": 94, "code": "def block():\n            nonlocal r\n            r += 1\n            return getblock(text, r, r, '\\xb6')", "input": "10, 10", "output": "'class with\\n  block after blank\\n  \\tand its own indented block\\n  and back again after a wrong blank\\n'", "cyclomatic_complexity": 1, "code_length": 4, "category": "Super Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 978, "idx": 95, "code": "def strip(tokens):\n        output = \"\"\n        for type_, value in tokens:\n            if type_ == TokenType.TEXT:\n                output += value\n        return output", "input": "[(1, ''), (1, '{message}'), (1, '\\n'), (1, '{exception}')]", "output": "'{message}\\n{exception}'", "cyclomatic_complexity": 3, "code_length": 6, "category": "Easy", "quantized_value_input": "Non-Empty List", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty List", "len(value) > 0": "Non-Empty List"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 979, "idx": 96, "code": "def parse(text, *, strip=False, strict=True):\n    parser = loguru._colorizer.AnsiParser()\n    parser.feed(text)\n    tokens = parser.done(strict=strict)\n\n    if strip:\n        return parser.strip(tokens)\n    return parser.colorize(tokens, \"\")", "input": "'<red>Foo</red>\\n', False, True", "output": "'\\x1b[31mFoo\\x1b[0m\\n'", "cyclomatic_complexity": 2, "code_length": 7, "category": "Super Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 986, "idx": 97, "code": "def _parse_without_formatting(string, *, recursion_depth=2, recursive=False):\n        if recursion_depth < 0:\n            raise ValueError(\"Max string recursion exceeded\")\n\n        formatter = Formatter()\n        parser = AnsiParser()\n\n        messages_color_tokens = []\n\n        for literal_text, field_name, format_spec, conversion in formatter.parse(string):\n            if literal_text and literal_text[-1] in \"{}\":\n                literal_text += literal_text[-1]\n\n            parser.feed(literal_text, raw=recursive)\n\n            if field_name is not None:\n                if field_name == \"message\":\n                    if recursive:\n                        messages_color_tokens.append(None)\n                    else:\n                        color_tokens = parser.current_color_tokens()\n                        messages_color_tokens.append(color_tokens)\n                field = \"{%s\" % field_name\n                if conversion:\n                    field += \"!%s\" % conversion\n                if format_spec:\n                    field += \":%s\" % format_spec\n                field += \"}\"\n                parser.feed(field, raw=True)\n\n                _, color_tokens = Colorizer._parse_without_formatting(\n                    format_spec, recursion_depth=recursion_depth - 1, recursive=True\n                )\n                messages_color_tokens.extend(color_tokens)\n\n        return parser.done(), messages_color_tokens", "input": "'', 1, True", "output": "([], [])", "cyclomatic_complexity": 9, "code_length": 29, "category": "Hard", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Non-Empty tuple", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}}
{"index": 997, "idx": 98, "code": "def random_port():\n        port = helper.random_port()\n        while port in generated_ports:\n            port = helper.random_port()\n        generated_ports.add(port)\n        return port", "input": "set()", "output": "56663", "cyclomatic_complexity": 2, "code_length": 6, "category": "Super Easy", "quantized_value_input": "Empty set", "quantized_value_output": "Positive Large", "input_mapping_info": {"len(value) == 0": "Empty set", "len(value) > 0": "Non-Empty set"}, "output_mapping_info": {"value == 0": "zero", "0 < value <= 10": "Positive Regular", "value > 10": "Positive Large", "-10 <= value < 0": "Negative Regular", "value < -10": "Negative Large"}}
{"index": 1031, "idx": 99, "code": "def strtobool(val):\n    \n    val = val.lower()\n    if val in ('y', 'yes', 't', 'true', 'on', '1'):\n        return 1\n    if val in ('n', 'no', 'f', 'false', 'off', '0'):\n        return 0\n    raise ValueError(f\"invalid truth value {val!r}\")", "input": "'False'", "output": "0", "cyclomatic_complexity": 3, "code_length": 7, "category": "Easy", "quantized_value_input": "Alphabetic String", "quantized_value_output": "Zero", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"value == 0": "zero", "0 < value <= 10": "Positive Regular", "value > 10": "Positive Large", "-10 <= value < 0": "Negative Regular", "value < -10": "Negative Large"}}
{"index": 1042, "idx": 100, "code": "def parse_search_terms(raw_search_value):\n    search_regexp = r'(?:[^\\s,\"]|\"(?:\\\\.|[^\"])*\")+'  \n    if not raw_search_value:\n        return {}\n    parsed_search = {}\n    for query_part in re.findall(search_regexp, raw_search_value):\n        if not query_part:\n            continue\n        if query_part.startswith('result:'):\n            parsed_search['result'] = preprocess_search_value(query_part[len('result:'):])\n        elif query_part.startswith('args:'):\n            if 'args' not in parsed_search:\n                parsed_search['args'] = []\n            parsed_search['args'].append(preprocess_search_value(query_part[len('args:'):]))\n        elif query_part.startswith('kwargs:'):\n            if 'kwargs'not in parsed_search:\n                parsed_search['kwargs'] = {}\n            try:\n                key, value = [p.strip() for p in query_part[len('kwargs:'):].split('=')]\n            except ValueError:\n                continue\n            parsed_search['kwargs'][key] = preprocess_search_value(value)\n        elif query_part.startswith('state'):\n            if 'state' not in parsed_search:\n                parsed_search['state'] = []\n            parsed_search['state'].append(preprocess_search_value(query_part[len('state:'):]))\n        else:\n            parsed_search['any'] = preprocess_search_value(query_part)\n    return parsed_search", "input": "{}", "output": "{}", "cyclomatic_complexity": 13, "code_length": 29, "category": "Hard", "quantized_value_input": "Empty dictionary", "quantized_value_output": "Empty dictionary", "input_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}, "output_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}}
{"index": 1050, "idx": 101, "code": "def stringified_dict_contains_value(key, value, str_dict):\n    \n    if not str_dict:\n        return False\n    value = str(value)\n    try:\n        \n        key_index = str_dict.index(key) + len(key) + 3\n    except ValueError:\n        return False\n    try:\n        comma_index = str_dict.index(',', key_index)\n    except ValueError:\n        \n        comma_index = str_dict.index('}', key_index)\n    return str(value) == str_dict[key_index:comma_index].strip('\"\\'')", "input": "'test', 5, \"{'test': 5}\"", "output": "True", "cyclomatic_complexity": 6, "code_length": 13, "category": "Hard", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Positive Regular", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"value == 0": "zero", "0 < value <= 10": "Positive Regular", "value > 10": "Positive Large", "-10 <= value < 0": "Negative Regular", "value < -10": "Negative Large"}}
{"index": 1051, "idx": 102, "code": "def humanize(obj, type=None, length=None):\n    if obj is None:\n        obj = ''\n    elif type and type.startswith('time'):\n        tz = type[len('time'):].lstrip('-')\n        tz = timezone(tz) if tz else getattr(current_app, 'timezone', '') or utc\n        obj = format_time(float(obj), tz) if obj else ''\n    elif type and type.startswith('natural-time'):\n        tz = type[len('natural-time'):].lstrip('-')\n        tz = timezone(tz) if tz else getattr(current_app, 'timezone', '') or utc\n        delta = datetime.now(tz) - datetime.fromtimestamp(float(obj), tz)\n        if delta < timedelta(days=1):\n            obj = naturaltime(delta)\n        else:\n            obj = format_time(float(obj), tz) if obj else ''\n    elif isinstance(obj, str) and not re.match(UUID_REGEX, obj):\n        obj = obj.replace('-', ' ').replace('_', ' ')\n        obj = re.sub('|'.join(KEYWORDS_UP),\n                     lambda m: m.group(0).upper(), obj)\n        if obj and obj not in KEYWORDS_DOWN:\n            obj = obj[0].upper() + obj[1:]\n    elif isinstance(obj, list):\n        if all(isinstance(x, (int, float, str)) for x in obj):\n            obj = ', '.join(map(str, obj))\n    if length is not None and len(obj) > length:\n        obj = obj[:length - 4] + ' ...'\n    return obj", "input": "'ssl', None, None", "output": "'SSL'", "cyclomatic_complexity": 10, "code_length": 27, "category": "Hard", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Alphabetic String", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1053, "idx": 103, "code": "def abs_path(path):\n    path = os.path.expanduser(path)\n    if not os.path.isabs(path):\n        cwd = os.environ.get('PWD') or os.getcwd()\n        path = os.path.join(cwd, path)\n    return path", "input": "'~/file.txt'", "output": "'/home/XXX/file.txt'", "cyclomatic_complexity": 2, "code_length": 6, "category": "Super Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1070, "idx": 104, "code": "def to_tuple(param, low=None, bias=None):\n    \n    if low is not None and bias is not None:\n        raise ValueError(\"Arguments low and bias are mutually exclusive\")\n\n    if param is None:\n        return param\n\n    if isinstance(param, (int, float)):\n        if low is None:\n            param = -param, +param\n        else:\n            param = (low, param) if low < param else (param, low)\n    elif isinstance(param, Sequence):\n        if len(param) != 2:\n            raise ValueError(\"to_tuple expects 1 or 2 values\")\n        param = tuple(param)\n    else:\n        raise ValueError(\"Argument param must be either scalar (int, float) or tuple\")\n\n    if bias is not None:\n        return tuple(bias + x for x in param)\n\n    return tuple(param)", "input": "7, 3, None", "output": "(3, 7)", "cyclomatic_complexity": 8, "code_length": 19, "category": "Hard", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Non-Empty tuple", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}}
{"index": 1078, "idx": 105, "code": "def _position_of_committer_with_initials(all_committers: List[str], initials: str) -> int:\n    for index, committer in enumerate(all_committers):\n        if committer.startswith(initials):\n            return index\n    return _COMMITTER_NOT_PRESENT", "input": "['initials1,name1,email1\\n', 'initials2,name2,email2\\n'], 'initials3'", "output": "-1", "cyclomatic_complexity": 3, "code_length": 5, "category": "Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Negative Regular", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"value == 0": "zero", "0 < value <= 10": "Positive Regular", "value > 10": "Positive Large", "-10 <= value < 0": "Negative Regular", "value < -10": "Negative Large"}}
{"index": 1096, "idx": 106, "code": "def all_valid_hooks(hooks: List[Hook]) -> bool:\n    hook_names = [_name(hook) for hook in _normal_hooks(hooks)]\n    valid_names = GUET_HOOKS == hook_names\n    valid_content = all([hook.is_guet_hook() for hook in _normal_hooks(hooks)])\n    if not (valid_names and valid_content):\n        hook_names = [_name(hook).replace('-guet', '') for hook in _dash_guet_normal_hooks(hooks)]\n        valid_names = GUET_HOOKS == hook_names\n        valid_content = all([hook.is_guet_hook() for hook in _dash_guet_normal_hooks(hooks)])\n        return valid_names and valid_content\n    return True", "input": "[<Mock id='140465523545424'>, <Mock id='140465523545520'>, <Mock id='140465523546288'>]", "output": "False", "cyclomatic_complexity": 2, "code_length": 10, "category": "Super Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Zero", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"value == 0": "zero", "0 < value <= 10": "Positive Regular", "value > 10": "Positive Large", "-10 <= value < 0": "Negative Regular", "value < -10": "Negative Large"}}
{"index": 1097, "idx": 107, "code": "def _dash_guet_normal_hooks(hooks: List[Hook]) -> List[Hook]:\n    final = []\n    for hook in hooks:\n        name = _name(hook)\n        if name.endswith('-guet') and name.replace('-guet', '') in GUET_HOOKS:\n            final.append(hook)\n    return final", "input": "[<Mock id='140465523545424'>, <Mock id='140465523545520'>, <Mock id='140465523546288'>]", "output": "[]", "cyclomatic_complexity": 3, "code_length": 7, "category": "Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Empty List", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty List", "len(value) > 0": "Non-Empty List"}}
{"index": 1103, "idx": 108, "code": "def _parse_file_content(create, path_to_hook):\n        _content = Hook._get_file_content(path_to_hook, create)\n        if _content != GUET_HOOK_FILE:\n            _content = Hook._handle_mismatched_content(_content, create)\n        return _content", "input": "True, '/path/to/.git/hooks/name'", "output": "['#! /usr/bin/env python3', 'from guet.hooks import manage', 'import sys', 'manage(sys.argv[0])']", "cyclomatic_complexity": 2, "code_length": 5, "category": "Super Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Non-Empty List", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty List", "len(value) > 0": "Non-Empty List"}}
{"index": 1104, "idx": 109, "code": "def _handle_mismatched_content(_content, create):\n        if create:\n            _content = GUET_HOOK_FILE\n        return _content", "input": "['Other', 'Content'], True", "output": "['#! /usr/bin/env python3', 'from guet.hooks import manage', 'import sys', 'manage(sys.argv[0])']", "cyclomatic_complexity": 2, "code_length": 4, "category": "Super Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Non-Empty List", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty List", "len(value) > 0": "Non-Empty List"}}
{"index": 1125, "idx": 110, "code": "def which(exe=None):\n    \n\n    if not exe:\n        log.error(\"No executable was passed to be searched by salt.utils.path.which()\")\n        return None\n\n    \n    def is_executable_common(path):\n        \n        return os.path.isfile(path) and os.access(path, os.X_OK)\n\n    def resolve(path):\n        \n        while os.path.islink(path):\n            res = readlink(path)\n\n            \n            \n            if not os.path.isabs(res):\n                directory, _ = os.path.split(path)\n                res = join(directory, res)\n            path = res\n        return path\n\n    \n    def has_executable_ext(path, ext_membership):\n        \n        p, ext = os.path.splitext(path)\n        return ext.lower() in ext_membership\n\n    \n    res = salt.utils.stringutils.to_unicode(os.environ.get(\"PATH\", \"\"))\n    system_path = res.split(os.pathsep)\n\n    \n    if not salt.utils.platform.is_windows():\n        res = set(system_path)\n        extended_path = [\n            \"/sbin\",\n            \"/bin\",\n            \"/usr/sbin\",\n            \"/usr/bin\",\n            \"/usr/local/sbin\",\n            \"/usr/local/bin\",\n        ]\n        system_path.extend([p for p in extended_path if p not in res])\n\n    \n    if salt.utils.platform.is_windows():\n        \n        res = salt.utils.stringutils.to_str(os.environ.get(\"PATHEXT\", \".EXE\"))\n\n        \n        \n        \n        \n        pathext = res.split(os.pathsep)\n        res = {ext.lower() for ext in pathext}\n\n        \n        _, ext = os.path.splitext(exe)\n        if ext.lower() in res:\n            pathext = [\"\"]\n\n            is_executable = is_executable_common\n\n        \n        \n        else:\n            is_executable = lambda path, membership=res: is_executable_common(\n                path\n            ) and has_executable_ext(path, membership)\n\n    else:\n        \n        pathext = [\"\"]\n\n        \n        is_executable = is_executable_common\n\n    \n\n    \n    \n    if is_executable(exe):\n        return exe\n\n    \n    for path in system_path:\n        p = join(path, exe)\n\n        \n        for ext in pathext:\n            pext = p + ext\n            rp = resolve(pext)\n            if is_executable(rp):\n                return p + ext\n            continue\n        continue\n\n    \n    log.trace(\n        \"'%s' could not be found in the following search path: '%s'\", exe, system_path\n    )\n    return None", "input": "'true'", "output": "'/usr/bin/true'", "cyclomatic_complexity": 14, "code_length": 60, "category": "Hard", "quantized_value_input": "Alphabetic String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1126, "idx": 111, "code": "def join(*parts, **kwargs):\n    \n    parts = [salt.utils.stringutils.to_str(part) for part in parts]\n\n    kwargs = salt.utils.args.clean_kwargs(**kwargs)\n    use_posixpath = kwargs.pop(\"use_posixpath\", False)\n    if kwargs:\n        salt.utils.args.invalid_kwargs(kwargs)\n\n    pathlib = posixpath if use_posixpath else os.path\n\n    \n    parts = [pathlib.normpath(p) for p in parts]\n\n    try:\n        root = parts.pop(0)\n    except IndexError:\n        \n        return \"\"\n\n    root = salt.utils.stringutils.to_unicode(root)\n    if not parts:\n        ret = root\n    else:\n        stripped = [p.lstrip(os.sep) for p in parts]\n        ret = pathlib.join(root, *salt.utils.data.decode(stripped))\n    return pathlib.normpath(ret)", "input": "('/home/XXX/.gdrive-downloader', 'true'), {}", "output": "'/home/XXX/.gdrive-downloader/true'", "cyclomatic_complexity": 5, "code_length": 19, "category": "Medium", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1127, "idx": 112, "code": "def to_str(s, encoding=None, errors=\"strict\", normalize=False):\n    \n\n    def _normalize(s):\n        try:\n            return unicodedata.normalize(\"NFC\", s) if normalize else s\n        except TypeError:\n            return s\n\n    if encoding is None:\n        \n        encoding = (\"utf-8\", __salt_system_encoding__)\n    if not isinstance(encoding, (tuple, list)):\n        encoding = (encoding,)\n\n    if not encoding:\n        raise ValueError(\"encoding cannot be empty\")\n\n    if isinstance(s, str):\n        return _normalize(s)\n\n    exc = None\n    if isinstance(s, (bytes, bytearray)):\n        for enc in encoding:\n            try:\n                return _normalize(s.decode(enc, errors))\n            except UnicodeDecodeError as err:\n                exc = err\n                continue\n        \n        \n        \n        raise exc  \n    raise TypeError(f\"expected str, bytes, or bytearray not {type(s)}\")", "input": "'/home/XXX/.gdrive-downloader', None, 'strict', False", "output": "'/home/XXX/.gdrive-downloader'", "cyclomatic_complexity": 12, "code_length": 24, "category": "Hard", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1128, "idx": 113, "code": "def _remove_circular_refs(ob, _seen=None):\n    \n    if _seen is None:\n        _seen = set()\n    if id(ob) in _seen:\n        \n        \n        log.exception(\n            \"Caught a circular reference in data structure below.\"\n            \"Cleaning and continuing execution.\\n%r\\n\",\n            ob,\n        )\n        return None\n    _seen.add(id(ob))\n    res = ob\n    if isinstance(ob, dict):\n        res = {\n            _remove_circular_refs(k, _seen): _remove_circular_refs(v, _seen)\n            for k, v in ob.items()\n        }\n    elif isinstance(ob, (list, tuple, set, frozenset)):\n        res = type(ob)(_remove_circular_refs(v, _seen) for v in ob)\n    \n    _seen.remove(id(ob))\n    return res", "input": "['true'], None, 'strict', False, False, False, False, False", "output": "['true']", "cyclomatic_complexity": 5, "code_length": 21, "category": "Medium", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Non-Empty List", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty List", "len(value) > 0": "Non-Empty List"}}
{"index": 1134, "idx": 114, "code": "def file(input_file, light=False):\n    \n    util.create_dir(os.path.join(CONF_DIR, \"colorschemes/light/\"))\n    util.create_dir(os.path.join(CONF_DIR, \"colorschemes/dark/\"))\n\n    theme_name = \".\".join((input_file, \"json\"))\n    bri = \"light\" if light else \"dark\"\n\n    user_theme_file = os.path.join(CONF_DIR, \"colorschemes\", bri, theme_name)\n    theme_file = os.path.join(MODULE_DIR, \"colorschemes\", bri, theme_name)\n\n    \n    if input_file in (\"random\", \"random_dark\"):\n        theme_file = get_random_theme()\n\n    elif input_file == \"random_light\":\n        theme_file = get_random_theme(light)\n\n    elif input_file == \"random_user\":\n        theme_file = get_random_theme_user()\n\n    elif os.path.isfile(user_theme_file):\n        theme_file = user_theme_file\n\n    elif os.path.isfile(input_file):\n        theme_file = input_file\n\n    \n    if os.path.isfile(theme_file):\n        logging.info(\"Set theme to \\033[1;37m%s\\033[0m.\",\n                     os.path.basename(theme_file))\n        util.save_file(os.path.basename(theme_file),\n                       os.path.join(CACHE_DIR, \"last_used_theme\"))\n        return parse(theme_file)\n\n    logging.error(\"No %s colorscheme file found.\", bri)\n    logging.error(\"Try adding   '-l' to set light themes.\")\n    logging.error(\"Try removing '-l' to set dark themes.\")\n    sys.exit(1)", "input": "'tests/test_files/test_file.json', False", "output": "{'wallpaper': '5.png', 'alpha': '100', 'special': {'background': '#1F211E', 'foreground': '#F5F1F4', 'cursor': '#F5F1F4'}, 'colors': {'color0': '#1F211E', 'color1': '#4B7A85', 'color2': '#CC6A93', 'color3': '#5C9894', 'color4': '#A0A89B', 'color5': '#D1B9A9', 'color6': '#E3D6D8', 'color7': '#F5F1F4', 'color8': '#666666', 'color9': '#4B7A85', 'color10': '#CC6A93', 'color11': '#5C9894', 'color12': '#A0A89B', 'color13': '#D1B9A9', 'color14': '#E3D6D8', 'color15': '#F5F1F4'}}", "cyclomatic_complexity": 7, "code_length": 27, "category": "Hard", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Non-Empty dictionary", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}}
{"index": 1135, "idx": 115, "code": "def parse(theme_file):\n    \n    data = util.read_file_json(theme_file)\n\n    if \"wallpaper\" not in data:\n        data[\"wallpaper\"] = \"None\"\n\n    if \"alpha\" not in data:\n        data[\"alpha\"] = util.Color.alpha_num\n\n    \n    if \"color\" in data:\n        data = terminal_sexy_to_wal(data)\n\n    return data", "input": "'tests/test_files/test_file.json'", "output": "{'wallpaper': '5.png', 'alpha': '100', 'special': {'background': '#1F211E', 'foreground': '#F5F1F4', 'cursor': '#F5F1F4'}, 'colors': {'color0': '#1F211E', 'color1': '#4B7A85', 'color2': '#CC6A93', 'color3': '#5C9894', 'color4': '#A0A89B', 'color5': '#D1B9A9', 'color6': '#E3D6D8', 'color7': '#F5F1F4', 'color8': '#666666', 'color9': '#4B7A85', 'color10': '#CC6A93', 'color11': '#5C9894', 'color12': '#A0A89B', 'color13': '#D1B9A9', 'color14': '#E3D6D8', 'color15': '#F5F1F4'}}", "cyclomatic_complexity": 4, "code_length": 9, "category": "Medium", "quantized_value_input": "Mixed String", "quantized_value_output": "Non-Empty dictionary", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}}
{"index": 1137, "idx": 116, "code": "def get(img, cache_dir=CACHE_DIR, iterative=False, recursive=False):\n    \n    if os.path.isfile(img):\n        wal_img = img\n\n    elif os.path.isdir(img):\n        if iterative:\n            wal_img = get_next_image(img, recursive)\n\n        else:\n            wal_img = get_random_image(img, recursive)\n\n    else:\n        logging.error(\"No valid image file found.\")\n        sys.exit(1)\n\n    wal_img = os.path.abspath(wal_img)\n\n    \n    util.save_file(wal_img, os.path.join(cache_dir, \"wal\"))\n\n    logging.info(\"Using image \\033[1;37m%s\\033[0m.\", os.path.basename(wal_img))\n    return wal_img", "input": "'tests/test_files/test.jpg', '/home/XXX/.cache/wal', False, False", "output": "'/local/rcs/XXX/code/pytrace-collector/logs/self_collected/tried/dylanaraps+pywal/dylanaraps+pywal/tests/test_files/test.jpg'", "cyclomatic_complexity": 4, "code_length": 15, "category": "Medium", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1138, "idx": 117, "code": "def get_random_image(img_dir, recursive):\n    \n    if recursive:\n        images, current_wall = get_image_dir_recursive(img_dir)\n    else:\n        images, current_wall = get_image_dir(img_dir)\n\n    if len(images) > 2 and current_wall in images:\n        images.remove(current_wall)\n\n    elif not images:\n        logging.error(\"No images found in directory.\")\n        sys.exit(1)\n\n    random.shuffle(images)\n    return os.path.join(img_dir if not recursive else \"\", images[0])", "input": "'tests/test_files', False", "output": "'tests/test_files/test.png'", "cyclomatic_complexity": 4, "code_length": 12, "category": "Medium", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1139, "idx": 118, "code": "def get_image_dir(img_dir):\n    \n    current_wall = wallpaper.get()\n    current_wall = os.path.basename(current_wall)\n\n    file_types = (\".png\", \".jpg\", \".jpeg\", \".jpe\", \".gif\")\n\n    return [img.name for img in os.scandir(img_dir)\n            if img.name.lower().endswith(file_types)], current_wall", "input": "'tests/test_files'", "output": "(['test2.jpg', 'test.jpg', 'test.png'], 'test.jpg')", "cyclomatic_complexity": 1, "code_length": 6, "category": "Super Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Non-Empty tuple", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}}
{"index": 1140, "idx": 119, "code": "def check_impl_detail(**guards):\n    \n    guards, default = _parse_guards(guards)\n    return guards.get(sys.implementation.name, default)", "input": "{}", "output": "True", "cyclomatic_complexity": 1, "code_length": 3, "category": "Super Easy", "quantized_value_input": "Empty dictionary", "quantized_value_output": "Positive Regular", "input_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}, "output_mapping_info": {"value == 0": "zero", "0 < value <= 10": "Positive Regular", "value > 10": "Positive Large", "-10 <= value < 0": "Negative Regular", "value < -10": "Negative Large"}}
{"index": 1142, "idx": 120, "code": "def _find_and_replace_patterns(content, patterns_and_insertions):\n  r\n  for pattern_and_insertion in patterns_and_insertions:\n    pattern = pattern_and_insertion['pattern']\n    insertion = pattern_and_insertion['insertion']\n    description = pattern_and_insertion['description']\n    logging.info('Processing pattern: %s.', description)\n    p = regex.compile(pattern)\n    m = p.search(content)\n    while m is not None:\n      local_insertion = insertion.format(**m.groupdict())\n      if pattern_and_insertion.get('strip_whitespace', True):\n        local_insertion = strip_whitespace(local_insertion)\n      logging.info(f'Found {content[m.start():m.end()]:<70}')\n      logging.info(f'Replacing with {local_insertion:<30}')\n      content = content[: m.start()] + local_insertion + content[m.end() :]\n      m = p.search(content)\n    logging.info('Finished pattern: %s.', description)\n  return content", "input": "'& \\\\figcompfigures{\\n\\timage1.jpg\\n}{\\n\\t\\\\ww\\n}{\\n\\t1.0\\n\\t}\\n& \\\\figcompfigures{image2.jpg}{\\\\ww}{1.0}', [{'pattern': '(?:\\\\\\\\figcompfigures{\\\\s*)(?P<first>.*?)\\\\s*}\\\\s*{\\\\s*(?P<second>.*?)\\\\s*}\\\\s*{\\\\s*(?P<third>.*?)\\\\s*}', 'insertion': '\\\\parbox[c]{{\\n            {second}\\\\linewidth\\n        }}{{\\n            \\\\includegraphics[\\n                width={third}\\\\linewidth\\n            ]{{\\n                figures/{first}\\n            }}\\n        }} ', 'description': 'Replace figcompfigures'}]", "output": "'& \\\\parbox[c]{\\\\ww\\\\linewidth}{\\\\includegraphics[width=1.0\\\\linewidth]{figures/image1.jpg}}\\n& \\\\parbox[c]{\\\\ww\\\\linewidth}{\\\\includegraphics[width=1.0\\\\linewidth]{figures/image2.jpg}}'", "cyclomatic_complexity": 4, "code_length": 19, "category": "Medium", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1143, "idx": 121, "code": "def strip_whitespace(text):\n  \n  pattern = regex.compile(r'\\s+')\n  text = regex.sub(pattern, '', text)\n  return text", "input": "'\\\\parbox[c]{\\n            \\\\ww\\\\linewidth\\n        }{\\n            \\\\includegraphics[\\n                width=1.0\\\\linewidth\\n            ]{\\n                figures/image1.jpg\\n            }\\n        } '", "output": "'\\\\parbox[c]{\\\\ww\\\\linewidth}{\\\\includegraphics[width=1.0\\\\linewidth]{figures/image1.jpg}}'", "cyclomatic_complexity": 1, "code_length": 4, "category": "Super Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1144, "idx": 122, "code": "def _keep_pattern(haystack, patterns_to_keep):\n  \n  out = []\n  for item in haystack:\n    if any((regex.findall(rem, item) for rem in patterns_to_keep)):\n      out.append(item)\n  return out", "input": "['abc', 'bca'], ['a']", "output": "['abc', 'bca']", "cyclomatic_complexity": 3, "code_length": 6, "category": "Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Non-Empty List", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty List", "len(value) > 0": "Non-Empty List"}}
{"index": 1145, "idx": 123, "code": "def merge_args_into_config(args, config_params):\n  final_args = copy.deepcopy(config_params)\n  config_keys = config_params.keys()\n  for key, value in args.items():\n    if key in config_keys:\n      if any([isinstance(value, t) for t in [str, bool, float, int]]):\n        \n        final_args[key] = value\n      elif isinstance(value, list):\n        \n        final_args[key] = value + config_params[key]\n      elif isinstance(value, dict):\n        \n        final_args[key].update(**value)\n    else:\n      final_args[key] = value\n  return final_args", "input": "{'input_folder': 'foo/bar', 'resize_images': False, 'im_size': 500, 'compress_pdf': False, 'pdf_im_resolution': 500, 'images_allowlist': {'path1/': 1000}, 'commands_to_delete': ['\\\\todo1'], 'use_external_tikz': 'foo/bar/tikz'}, {'input_folder': 'foo_/bar_', 'resize_images': True, 'im_size': 1000, 'compress_pdf': True, 'pdf_im_resolution': 1000, 'images_allowlist': {'path2/': 1000}, 'commands_to_delete': ['\\\\todo2'], 'use_external_tikz': 'foo_/bar_/tikz_'}", "output": "{'input_folder': 'foo/bar', 'resize_images': False, 'im_size': 500, 'compress_pdf': False, 'pdf_im_resolution': 500, 'images_allowlist': {'path2/': 1000, 'path1/': 1000}, 'commands_to_delete': ['\\\\todo1', '\\\\todo2'], 'use_external_tikz': 'foo/bar/tikz'}", "cyclomatic_complexity": 6, "code_length": 14, "category": "Hard", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Non-Empty dictionary", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}}
{"index": 1146, "idx": 124, "code": "def _remove_command(text, command, keep_text=False):\n  \n  base_pattern = r'\\\\' + command + r'\\{((?:[^{}]+|\\{(?1)\\})*)\\}'\n  \n  \n  while True:\n    all_substitutions = []\n    has_match = False\n    for match in regex.finditer(base_pattern, text):\n      \n      \n      has_match = True\n      new_substring = (\n          ''\n          if not keep_text\n          else text[match.span()[0] + len(command) + 2 : match.span()[1] - 1]\n      )\n      if match.span()[1] < len(text):\n        next_newline = text[match.span()[1] :].find('\\n')\n        if next_newline != -1:\n          text_until_newline = text[\n              match.span()[1] : match.span()[1] + next_newline\n          ]\n          if (\n              not text_until_newline or text_until_newline.isspace()\n          ) and not keep_text:\n            new_substring = '%'\n      all_substitutions.append(\n          (match.span()[0], match.span()[1], new_substring)\n      )\n\n    for start, end, new_substring in reversed(all_substitutions):\n      text = text[:start] + new_substring + text[end:]\n\n    if not keep_text or not has_match:\n      break\n\n  return text", "input": "'A\\\\todo{B\\nC}D\\nE\\n\\\\end{document}', 'todo', False", "output": "'AD\\nE\\n\\\\end{document}'", "cyclomatic_complexity": 8, "code_length": 30, "category": "Hard", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1147, "idx": 125, "code": "def _remove_comments_inline(text):\n  \n  if 'auto-ignore' in text:\n    return text\n  if text.lstrip(' ').lstrip('\\t').startswith('%'):\n    return ''\n\n  url_pattern = r'\\\\url\\{(?>[^{}]|(?R))*\\}'\n\n  def remove_comments(segment):\n    \n    if segment.lstrip().startswith('%'):\n      return ''\n    match = regex.search(r'(?<!\\\\)%', segment)\n    if match:\n      return segment[: match.end()] + '\\n'\n    else:\n      return segment\n\n  \n  segments = regex.split(f'({url_pattern})', text)\n\n  for i in range(len(segments)):\n    \n    if not regex.match(url_pattern, segments[i]):\n      segments[i] = remove_comments(segments[i])\n\n  final_text = ''.join(segments)\n  return (\n      final_text\n      if final_text.endswith('\\n') or final_text.endswith('\\\\n')\n      else final_text + '\\n'\n  )", "input": "'Foo %Comment\\n'", "output": "'Foo %\\n'", "cyclomatic_complexity": 8, "code_length": 24, "category": "Hard", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1148, "idx": 126, "code": "def _remove_iffalse_block(text):\n  \n  p = regex.compile(r'\\\\if\\s*(\\w+)|\\\\fi(?!\\w)')\n  level = -1\n  positions_to_delete = []\n  start, end = 0, 0\n  for m in p.finditer(text):\n    if (\n        m.group().replace(' ', '') == r'\\iffalse'\n        or m.group().replace(' ', '') == r'\\if0'\n    ) and level == -1:\n      level += 1\n      start = m.start()\n    elif m.group().startswith(r'\\if') and level >= 0:\n      level += 1\n    elif m.group() == r'\\fi' and level >= 0:\n      if level == 0:\n        end = m.end()\n        positions_to_delete.append((start, end))\n      level -= 1\n    else:\n      pass\n\n  for start, end in reversed(positions_to_delete):\n    if end < len(text) and text[end].isspace():\n      end_to_del = end + 1\n    else:\n      end_to_del = end\n    text = text[:start] + text[end_to_del:]\n\n  return text", "input": "'\\\\newcommand\\\\figref[1]{Figure~\\\\ref{fig:\\\\#1}}'", "output": "'\\\\newcommand\\\\figref[1]{Figure~\\\\ref{fig:\\\\#1}}'", "cyclomatic_complexity": 8, "code_length": 28, "category": "Hard", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1149, "idx": 127, "code": "def _replace_includesvg(content, svg_inkscape_files):\n  def repl_svg(matchobj):\n    svg_path = matchobj.group(2)\n    svg_filename = os.path.basename(svg_path)\n    \n    matching_pdf_tex_files = _keep_pattern(\n        svg_inkscape_files, ['/' + svg_filename + '-tex.pdf_tex']\n    )\n    if len(matching_pdf_tex_files) == 1:\n      options = '' if matchobj.group(1) is None else matchobj.group(1)\n      return f'\\\\includeinkscape{options}{{{matching_pdf_tex_files[0]}}}'\n    else:\n      return matchobj.group(0)\n\n  content = regex.sub(r'\\\\includesvg(\\[.*?\\])?{(.*?)}', repl_svg, content)\n\n  return content", "input": "'Foo\\\\includesvg{test2}\\nFoo', ['ext_svg/test1-tex.pdf_tex', 'ext_svg/test2-tex.pdf_tex']", "output": "'Foo\\\\includeinkscape{ext_svg/test2-tex.pdf_tex}\\nFoo'", "cyclomatic_complexity": 3, "code_length": 14, "category": "Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1150, "idx": 128, "code": "def _replace_tikzpictures(content, figures):\n  \n\n  def get_figure(matchobj):\n    found_tikz_filename = regex.search(\n        r'\\\\tikzsetnextfilename{(.*?)}', matchobj.group(0)\n    ).group(1)\n    \n    matching_tikz_filenames = _keep_pattern(\n        figures, ['/' + found_tikz_filename + '.pdf']\n    )\n    if len(matching_tikz_filenames) == 1:\n      return '\\\\includegraphics{' + matching_tikz_filenames[0] + '}'\n    else:\n      return matchobj.group(0)\n\n  content = regex.sub(\n      r'\\\\tikzsetnextfilename{[\\s\\S]*?\\\\end{tikzpicture}', get_figure, content\n  )\n\n  return content", "input": "'Foo\\n', ['ext_tikz/test1.pdf', 'ext_tikz/test2.pdf']", "output": "'Foo\\n'", "cyclomatic_complexity": 3, "code_length": 16, "category": "Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1156, "idx": 129, "code": "def _list_all_files(in_folder, ignore_dirs=None):\n  if ignore_dirs is None:\n    ignore_dirs = []\n  to_consider = [\n      os.path.join(os.path.relpath(path, in_folder), name)\n      if path != in_folder\n      else name\n      for path, _, files in os.walk(in_folder)\n      for name in files\n  ]\n  return _remove_pattern(to_consider, ignore_dirs)", "input": "'tex_arXiv', None", "output": "['main.bbl', 'main.tex', 'ext_tikz/test2.pdf', 'ext_tikz/test1.pdf', 'figures/figure_included.tikz', 'figures/figure_included.tex', 'figures/data_included.txt', 'images/im4_included.png', 'images/im3_included.png', 'images/im2_included.jpg', 'images/im5_included.jpg', 'images/im1_included.png', 'images/include/images/im3_included.png']", "cyclomatic_complexity": 2, "code_length": 11, "category": "Super Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Non-Empty List", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty List", "len(value) > 0": "Non-Empty List"}}
{"index": 1158, "idx": 130, "code": "def _read_file_content(filename):\n  with open(filename, 'r', encoding='utf-8') as fp:\n    lines = fp.readlines()\n    lines = _strip_tex_contents(lines, '\\\\end{document}')\n    return lines", "input": "'tex/figures/figure_not_included.tex'", "output": "['\\\\addplot{figures/data_not_included.txt}\\n', '\\\\input{figures/figure_not_included_2.tex}\\n']", "cyclomatic_complexity": 1, "code_length": 5, "category": "Super Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Non-Empty List", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty List", "len(value) > 0": "Non-Empty List"}}
{"index": 1159, "idx": 131, "code": "def _strip_tex_contents(lines, end_str):\n  \n  for i in range(len(lines)):\n    if end_str in lines[i]:\n      if '%' not in lines[i]:\n        return lines[: i + 1]\n      elif lines[i].index('%') > lines[i].index(end_str):\n        return lines[: i + 1]\n  return lines", "input": "['\\\\addplot{figures/data_not_included.txt}\\n', '\\\\input{figures/figure_not_included_2.tex}\\n'], '\\\\end{document}'", "output": "['\\\\addplot{figures/data_not_included.txt}\\n', '\\\\input{figures/figure_not_included_2.tex}\\n']", "cyclomatic_complexity": 5, "code_length": 8, "category": "Medium", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Non-Empty List", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty List", "len(value) > 0": "Non-Empty List"}}
{"index": 1193, "idx": 132, "code": "def remove_python_path_suffix(path):\n    for suffix in all_suffixes() + ['.pyi']:\n        if path.suffix == suffix:\n            path = path.with_name(path.stem)\n            break\n    return path", "input": "PosixPath('/local/rcs/XXX/code/pytrace-collector/logs/self_collected/tried/davidhalter+jedi/davidhalter+jedi/example.py')", "output": "PosixPath('/local/rcs/XXX/code/pytrace-collector/logs/self_collected/tried/davidhalter+jedi/davidhalter+jedi/example')", "cyclomatic_complexity": 3, "code_length": 6, "category": "Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1197, "idx": 133, "code": "def complete_dict(module_context, code_lines, leaf, position, string, fuzzy):\n    bracket_leaf = leaf\n    if bracket_leaf != '[':\n        bracket_leaf = leaf.get_previous_leaf()\n\n    cut_end_quote = ''\n    if string:\n        cut_end_quote = get_quote_ending(string, code_lines, position, invert_result=True)\n\n    if bracket_leaf == '[':\n        if string is None and leaf is not bracket_leaf:\n            string = cut_value_at_position(leaf, position)\n\n        context = module_context.create_context(bracket_leaf)\n\n        before_node = before_bracket_leaf = bracket_leaf.get_previous_leaf()\n        if before_node in (')', ']', '}'):\n            before_node = before_node.parent\n        if before_node.type in ('atom', 'trailer', 'name'):\n            values = infer_call_of_leaf(context, before_bracket_leaf)\n            return list(_completions_for_dicts(\n                module_context.inference_state,\n                values,\n                '' if string is None else string,\n                cut_end_quote,\n                fuzzy=fuzzy,\n            ))\n    return []", "input": "ModuleContext(<ModuleValue: example@2-3 is_stub=False>), ['\\n', 'import json\\n', 'json.lo'], <Name: lo@3,5>, (3, 7), None, False", "output": "[]", "cyclomatic_complexity": 7, "code_length": 24, "category": "Hard", "quantized_value_input": "Mixed String", "quantized_value_output": "Empty List", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty List", "len(value) > 0": "Non-Empty List"}}
{"index": 1199, "idx": 134, "code": "def _get_code_for_stack(code_lines, leaf, position):\n    \n    \n    if leaf.start_pos >= position:\n        \n        leaf = leaf.get_previous_leaf()\n        if leaf is None:\n            return ''  \n\n    is_after_newline = leaf.type == 'newline'\n    while leaf.type == 'newline':\n        leaf = leaf.get_previous_leaf()\n        if leaf is None:\n            return ''\n\n    if leaf.type == 'error_leaf' or leaf.type == 'string':\n        if leaf.start_pos[0] < position[0]:\n            \n            return ''\n\n        \n        \n        raise OnErrorLeaf(leaf)\n    else:\n        user_stmt = leaf\n        while True:\n            if user_stmt.parent.type in ('file_input', 'suite', 'simple_stmt'):\n                break\n            user_stmt = user_stmt.parent\n\n        if is_after_newline:\n            if user_stmt.start_pos[1] > position[1]:\n                \n                \n                return ''\n\n        \n        return _get_code(code_lines, user_stmt.get_start_pos_of_prefix(), position)", "input": "['\\n', 'import json\\n', 'json.lo'], <Name: lo@3,5>, (3, 5)", "output": "'json.'", "cyclomatic_complexity": 11, "code_length": 24, "category": "Hard", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1200, "idx": 135, "code": "def _get_code(code_lines, start_pos, end_pos):\n    \n    lines = code_lines[start_pos[0] - 1:end_pos[0]]\n    \n    lines[-1] = lines[-1][:end_pos[1]]\n    \n    lines[0] = lines[0][start_pos[1]:]\n    return ''.join(lines)", "input": "['\\n', 'import json\\n', 'json.lo'], (3, 0), (3, 5)", "output": "'json.'", "cyclomatic_complexity": 1, "code_length": 5, "category": "Super Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1222, "idx": 136, "code": "def _get_definition_names(parso_cache_node, used_names, name_key):\n    if parso_cache_node is None:\n        names = used_names.get(name_key, ())\n        return tuple(name for name in names if name.is_definition(include_setitem=True))\n\n    try:\n        for_module = _definition_name_cache[parso_cache_node]\n    except KeyError:\n        for_module = _definition_name_cache[parso_cache_node] = {}\n\n    try:\n        return for_module[name_key]\n    except KeyError:\n        names = used_names.get(name_key, ())\n        result = for_module[name_key] = tuple(\n            name for name in names if name.is_definition(include_setitem=True)\n        )\n        return result", "input": "{node=<Module: @1-3>, lines=['def f(a, b=1):\\n', '    \"Document for function f.\"\\n', ''], change_time=1712197932.5185623, last_used=1712197932.5185623}, {_dict={'f': [<Name: f@1,4>], 'a': [<Name: a@1,6>], 'b': [<Name: b@1,9>]}}, 'f'", "output": "(<Name: f@1,4>,)", "cyclomatic_complexity": 6, "code_length": 16, "category": "Hard", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1238, "idx": 137, "code": "def _search_param_in_docstr(docstr, param_str):\n    \n    \n    patterns = [re.compile(p % re.escape(param_str))\n                for p in DOCSTRING_PARAM_PATTERNS]\n    for pattern in patterns:\n        match = pattern.search(docstr)\n        if match:\n            return [_strip_rst_role(match.group(1))]\n\n    return _search_param_in_numpydocstr(docstr, param_str)", "input": "':type param: int', 'param'", "output": "['int']", "cyclomatic_complexity": 3, "code_length": 8, "category": "Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Non-Empty List", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty List", "len(value) > 0": "Non-Empty List"}}
{"index": 1254, "idx": 138, "code": "def _underscore(word: str) -> str:\n    \n    word = re.sub(r\"([A-Z]+)([A-Z][a-z])\", r'\\1_\\2', word)\n    word = re.sub(r\"([a-z\\d])([A-Z])\", r'\\1_\\2', word)\n    word = word.replace(\"-\", \"_\")\n    return word.lower()", "input": "'TestKlass'", "output": "'test_klass'", "cyclomatic_complexity": 1, "code_length": 5, "category": "Super Easy", "quantized_value_input": "Alphabetic String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1266, "idx": 139, "code": "def to_json_line(self):\n        raise NotImplementedError", "input": "AsciiCastV2Header(version=2, width=212, height=53, theme=None, idle_time_limit=None), 2, 212, 53, None, None", "output": "'{\"version\": 2, \"width\": 212, \"height\": 53}'", "cyclomatic_complexity": 1, "code_length": 2, "category": "Super Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1268, "idx": 140, "code": "def integral_duration_validation(duration):\n    if duration.lower().endswith('ms'):\n        duration = duration[:-len('ms')]\n\n    if duration.isdigit() and int(duration) >= 1:\n        return int(duration)\n    raise ValueError('duration must be an integer greater than 0')", "input": "'100ms'", "output": "100", "cyclomatic_complexity": 3, "code_length": 6, "category": "Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Positive Large", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"value == 0": "zero", "0 < value <= 10": "Positive Regular", "value > 10": "Positive Large", "-10 <= value < 0": "Negative Regular", "value < -10": "Negative Large"}}
{"index": 1271, "idx": 141, "code": "def __get_command_output(command, cwd=None):\n    \n\n    p = subprocess.Popen(command, stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE, cwd=cwd)\n    p.wait()\n    return p.returncode, p.stdout.read(), p.stderr.read()", "input": "['git', 'rev-parse'], '/local/rcs/XXX/code/pytrace-collector/logs/pypibugs/tried/ASPP+pelita/ASPP+pelita/pelita'", "output": "(0, b'', b'')", "cyclomatic_complexity": 1, "code_length": 5, "category": "Super Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Non-Empty tuple", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}}
{"index": 1276, "idx": 142, "code": "def initial_positions(walls):\n    \n    width = max(walls)[0] + 1\n    height = max(walls)[1] + 1\n\n    left_start = (1, height - 2)\n    left = []\n    right_start = (width - 2, 1)\n    right = []\n\n    dist = 0\n    while len(left) < 2:\n        \n        for x_dist in range(dist + 1):\n            y_dist = dist - x_dist\n            pos = (left_start[0] + x_dist, left_start[1] - y_dist)\n            \n            if not (0 <= pos[0] < width) and not (0 <= pos[1] < height):\n                raise ValueError(\"Not enough free initial positions.\")\n            \n            if not (0 <= pos[0] < width) or not (0 <= pos[1] < height):\n                continue\n            \n            if pos not in walls:\n                left.append(pos)\n\n            if len(left) == 2:\n                break\n\n        dist += 1\n\n    dist = 0\n    while len(right) < 2:\n        \n        for x_dist in range(dist + 1):\n            y_dist = dist - x_dist\n            pos = (right_start[0] - x_dist, right_start[1] + y_dist)\n            \n            if not (0 <= pos[0] < width) and not (0 <= pos[1] < height):\n                raise ValueError(\"Not enough free initial positions.\")\n            \n            if not (0 <= pos[0] < width) or not (0 <= pos[1] < height):\n                continue\n            \n            if pos not in walls:\n                right.append(pos)\n\n            if len(right) == 2:\n                break\n\n        dist += 1\n\n    \n    left.reverse()\n    right.reverse()\n    return [left[0], right[0], left[1], right[1]]", "input": "[(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 3), (2, 0), (2, 1), (2, 3), (3, 0), (3, 1), (3, 3), (4, 0), (4, 1), (4, 3), (5, 0), (5, 3), (6, 0), (6, 3), (7, 0), (7, 1), (7, 2), (7, 3)]", "output": "[(1, 1), (6, 2), (1, 2), (6, 1)]", "cyclomatic_complexity": 13, "code_length": 38, "category": "Hard", "quantized_value_input": "Non-Empty List", "quantized_value_output": "Non-Empty List", "input_mapping_info": {"len(value) == 0": "Empty List", "len(value) > 0": "Non-Empty List"}, "output_mapping_info": {"len(value) == 0": "Empty List", "len(value) > 0": "Non-Empty List"}}
{"index": 1280, "idx": 143, "code": "def deep_extend(*args):\n        \n        def clone_obj(item):\n            if isinstance(item, dict):\n                return dict(**item)\n            if isinstance(item, (list, tuple)):\n                return list(item)\n            return None\n\n        def iterator(item, i, iterable):\n            obj = clone_obj(item)\n            if obj is None:\n                iterable[i] = item\n            else:\n                if isinstance(obj, dict):\n                    iterable[i] = deep_extend({}, obj)\n                elif isinstance(obj, (list, tuple)):\n                    FuncFlow.each(obj, iterator)\n                    iterable[i] = obj\n                else:\n                    raise TypeError(\"deep_copy cannot handle this type: {}\".format(type(obj)))\n            \n        args = list(args)\n        dest = args.pop(0)\n\n        for source in args:\n            if source:\n                for k, v in source.items():\n                    obj = clone_obj(v)\n                    if obj is None:\n                        dest[k] = v\n                    else:\n                        FuncFlow.each(obj, iterator)\n                        dest[k] = obj\n        return dest", "input": "(2,)", "output": "2", "cyclomatic_complexity": 12, "code_length": 31, "category": "Hard", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Positive Regular", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"value == 0": "zero", "0 < value <= 10": "Positive Regular", "value > 10": "Positive Large", "-10 <= value < 0": "Negative Regular", "value < -10": "Negative Large"}}
{"index": 1284, "idx": 144, "code": "def get_nested(d, path, delimiter=\"/\"):\n    \n    def item_by_tag(d, tags):\n        \n        t = tags[-1]\n        if len(tags) == 1:\n            return d[t]\n        return item_by_tag(d[t], tags[:-1])\n\n    tags = path.split(delimiter)\n    tags.reverse()\n    \n    return item_by_tag(d, tags)", "input": "{'nested': {'data': 'should be unchanged', 'event': None}}, 'nested', '/'", "output": "{'data': 'should be unchanged', 'event': None}", "cyclomatic_complexity": 3, "code_length": 9, "category": "Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Non-Empty dictionary", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}}
{"index": 1287, "idx": 145, "code": "def extend(*args):\n        args = list(args)\n        dest = args.pop(0)\n        for source in args:\n            if source:\n                dest.update(source)\n        return dest", "input": "({}, {})", "output": "{}", "cyclomatic_complexity": 3, "code_length": 7, "category": "Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Empty dictionary", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}}
{"index": 1301, "idx": 146, "code": "def dict_factory(cursor, row):\n    d = {}\n    for idx, col in enumerate(cursor.description):\n        d[col[0]] = row[idx]\n    return d", "input": "REPR FAILED, ('My Way',)", "output": "{'name': 'My Way'}", "cyclomatic_complexity": 2, "code_length": 5, "category": "Super Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Non-Empty dictionary", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}}
{"index": 1307, "idx": 147, "code": "def digit_version(version_str: str, length: int = 4):\n    \n    assert 'parrots' not in version_str\n    version = parse(version_str)\n    assert version.release, f'failed to parse version {version_str}'\n    release = list(version.release)\n    release = release[:length]\n    if len(release) < length:\n        release = release + [0] * (length - len(release))\n    if version.is_prerelease:\n        mapping = {'a': -3, 'b': -2, 'rc': -1}\n        val = -4\n        \n        if version.pre:\n            if version.pre[0] not in mapping:\n                warnings.warn(f'unknown prerelease version {version.pre[0]}, '\n                              'version checking may go wrong')\n            else:\n                val = mapping[version.pre[0]]\n            release.extend([val, version.pre[-1]])\n        else:\n            release.extend([val, 0])\n\n    elif version.is_postrelease:\n        release.extend([1, version.post])\n    else:\n        release.extend([0, 0])\n    return tuple(release)", "input": "'2.2.2+cu121', 4", "output": "(2, 2, 2, 0, 0, 0)", "cyclomatic_complexity": 6, "code_length": 25, "category": "Hard", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Non-Empty tuple", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}}
{"index": 1317, "idx": 148, "code": "def __ne__(self, other: object) -> bool:\n        return not self == other", "input": "{'Properties': {'callcorrect': False}}", "output": "{'Properties': {'callcorrect': False}}", "cyclomatic_complexity": 1, "code_length": 2, "category": "Super Easy", "quantized_value_input": "Non-Empty dictionary", "quantized_value_output": "Non-Empty dictionary", "input_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}, "output_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}}
{"index": 1318, "idx": 149, "code": "def get_or_add_parameter(self, parameter: Parameter) -> Parameter:\n        if parameter.title in self.parameters:\n            return self.parameters[parameter.title]\n        else:\n            self.add_parameter(parameter)\n        return parameter", "input": "{'Value': 'myvalue'}", "output": "{'Value': 'myvalue'}", "cyclomatic_complexity": 2, "code_length": 6, "category": "Super Easy", "quantized_value_input": "Non-Empty dictionary", "quantized_value_output": "Non-Empty dictionary", "input_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}, "output_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}}
{"index": 1350, "idx": 150, "code": "def notification_event(events):\n    \n\n    valid_events = [\"All\", \"InProgress\", \"Success\", \"TimedOut\", \"Cancelled\", \"Failed\"]\n    for event in events:\n        if event not in valid_events:\n            raise ValueError(\n                'NotificationEvents must be at least one of: \"%s\"'\n                % (\", \".join(valid_events))\n            )\n    return events", "input": "['All', 'InProgress', 'Success', 'TimedOut', 'Cancelled', 'Failed']", "output": "['All', 'InProgress', 'Success', 'TimedOut', 'Cancelled', 'Failed']", "cyclomatic_complexity": 3, "code_length": 9, "category": "Easy", "quantized_value_input": "Non-Empty List", "quantized_value_output": "Non-Empty List", "input_mapping_info": {"len(value) == 0": "Empty List", "len(value) > 0": "Non-Empty List"}, "output_mapping_info": {"len(value) == 0": "Empty List", "len(value) > 0": "Non-Empty List"}}
{"index": 1351, "idx": 151, "code": "def get_air_quality(city):\n    \n\n    if not city or not city.strip():\n        return\n    print(' {} ...'.format(city))\n    try:\n\n        url = 'http://api.waqi.info/feed/{city}/?token={token}'.format(city=city, token=AQICN_TOKEN)\n        resp = requests.get(url)\n        if resp.status_code == 200:\n            \n            content_dict = resp.json()\n            if content_dict.get('status') == 'ok':\n                data_dict = content_dict['data']\n                aqi = data_dict['aqi']\n                air_status = ''\n                for key in sorted(AIR_STATUS_DICT):\n                    if key >= aqi:\n                        air_status = AIR_STATUS_DICT[key]\n                        break\n                aqi_info = '{city} PM2.5{aqi} {air_status}'.format(city=city, aqi=aqi, air_status=air_status)\n                \n                return aqi_info\n            else:\n                print(':{}'.format(content_dict['data']))\n                return None\n        print('')\n    except Exception as exception:\n        print(str(exception))\n    return None", "input": "''", "output": "' PM2.550 '", "cyclomatic_complexity": 8, "code_length": 26, "category": "Hard", "quantized_value_input": "Alphabetic String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1366, "idx": 152, "code": "def _LiteralEval(value):\n  \n  root = ast.parse(value, mode='eval')\n  if isinstance(root.body, ast.BinOp):\n    raise ValueError(value)\n\n  for node in ast.walk(root):\n    for field, child in ast.iter_fields(node):\n      if isinstance(child, list):\n        for index, subchild in enumerate(child):\n          if isinstance(subchild, ast.Name):\n            child[index] = _Replacement(subchild)\n\n      elif isinstance(child, ast.Name):\n        replacement = _Replacement(child)\n        node.__setattr__(field, replacement)\n\n  \n  \n  \n  return ast.literal_eval(root)", "input": "'[one, 2, \"3\"]'", "output": "['one', 2, '3']", "cyclomatic_complexity": 8, "code_length": 14, "category": "Hard", "quantized_value_input": "Mixed String", "quantized_value_output": "Non-Empty List", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty List", "len(value) > 0": "Non-Empty List"}}
{"index": 1367, "idx": 153, "code": "def SeparateFlagArgs(args: list):\n  \n  if len(args) > 0 and (args[-1] == '-h' or args[-1] == '--help') and '--' not in args:\n    args.pop()\n    args.append('--')\n    args.append('-h')\n\n  if '--' in args:\n    separator_index = len(args) - 1 - args[::-1].index('--')  \n    flag_args = args[separator_index + 1:]\n    args = args[:separator_index]\n    return args, flag_args\n\n  return args, []", "input": "['a', 'b', '--']", "output": "(['a', 'b'], [])", "cyclomatic_complexity": 3, "code_length": 11, "category": "Easy", "quantized_value_input": "Non-Empty List", "quantized_value_output": "Non-Empty tuple", "input_mapping_info": {"len(value) == 0": "Empty List", "len(value) > 0": "Non-Empty List"}, "output_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}}
{"index": 1371, "idx": 154, "code": "def prepare_docstring_help(N):\n    \n    \n\n    args = []\n    if hasattr(N, '__annotations__'):\n        for attr_name, cls in N.__annotations__.items():\n\n            filtered = filter_params(N)\n            parsed = parse_source_for_params(filtered)\n            attr = attr_map(parsed).get(attr_name)\n            if attr is None:\n                continue\n\n            args.append(argument_help(attr_name, attr))\n\n    return '\\n'.join(args)", "input": "{}", "output": "'    --bar (int):  (Default is 0)'", "cyclomatic_complexity": 4, "code_length": 11, "category": "Medium", "quantized_value_input": "Empty dictionary", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1372, "idx": 155, "code": "def filter_params(N):\n    \n    filtered_source = []\n    for line in inspect.getsourcelines(N.__class__)[0][1:]:\n        \n        if line.strip().startswith('def '):\n            break\n        filtered_source.append(line)\n    return filtered_source", "input": "{}", "output": "['            bar: int = 0\\n']", "cyclomatic_complexity": 3, "code_length": 7, "category": "Easy", "quantized_value_input": "Empty dictionary", "quantized_value_output": "Non-Empty List", "input_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}, "output_mapping_info": {"len(value) == 0": "Empty List", "len(value) > 0": "Non-Empty List"}}
{"index": 1378, "idx": 156, "code": "def _ParseFn(args):\n    \n    kwargs, remaining_kwargs, remaining_args = _ParseKeywordArgs(\n        args, all_args, fn_spec.varkw)\n\n    \n    parsed_args, kwargs, remaining_args, capacity = _ParseArgs(\n        fn_spec.args, fn_spec.defaults, num_required_args, kwargs,\n        remaining_args, metadata)\n\n    if fn_spec.varargs or fn_spec.varkw:\n      \n      capacity = True\n\n    extra_kw = set(kwargs) - set(fn_spec.kwonlyargs)\n    if fn_spec.varkw is None and extra_kw:\n      raise FireError('Unexpected kwargs present:', extra_kw)\n\n    missing_kwonly = set(required_kwonly) - set(kwargs)\n    if missing_kwonly:\n      raise FireError('Missing required flags:', missing_kwonly)\n\n    \n    if fn_spec.varargs is not None:\n      varargs, remaining_args = remaining_args, []\n    else:\n      varargs = []\n\n    for index, value in enumerate(varargs):\n      varargs[index] = _ParseValue(value, None, None, metadata)\n\n    varargs = parsed_args + varargs\n    remaining_args += remaining_kwargs\n\n    consumed_args = args[:len(args) - len(remaining_args)]\n    return (varargs, kwargs), consumed_args, remaining_args, capacity", "input": "['x'], [], {args=[], varargs=None, varkw='cli_args', defaults=(), kwonlyargs=[], kwonlydefaults={}, annotations={}}, {'ACCEPTS_POSITIONAL_ARGS': False}, 0, set()", "output": "(([], {}), [], ['x'], True)", "cyclomatic_complexity": 6, "code_length": 24, "category": "Hard", "quantized_value_input": "Mixed String", "quantized_value_output": "Non-Empty tuple", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}}
{"index": 1380, "idx": 157, "code": "def config_dict(configuration_tuple):\n    config_dict = {}\n\n    config_file = configuration_tuple._asdict().get('CFG')\n    if config_file is None:\n        config_file = configfile.get_config_path(configuration_tuple)\n\n    if config_file is not None:\n        config_dict = utils.filter_fields(configfile.read_config(config_file), configuration_tuple)\n        config_dict = utils.type_correct_with(config_dict, configuration_tuple)\n\n    return config_dict", "input": "{}", "output": "{'bar': 42}", "cyclomatic_complexity": 3, "code_length": 9, "category": "Easy", "quantized_value_input": "Empty dictionary", "quantized_value_output": "Non-Empty dictionary", "input_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}, "output_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}}
{"index": 1381, "idx": 158, "code": "def read_config(_filepath='test.cfg') -> dict:\n    filepath = Path(_filepath)\n    if not filepath.exists():\n        return {}\n\n    file_config = configparser.ConfigParser()\n    file_config.read(filepath)\n    if 'Default' in file_config:\n        return dict(file_config['Default'])\n    else:\n        print('warning: config file found at {}, but it was missing section named [Default]'.format(str(filepath)))\n        return {}", "input": "PosixPath('/local/rcs/XXX/code/pytrace-collector/logs/pypibugs/tried/d3rp+clima/d3rp+clima/tests/test_configfile.py')", "output": "PosixPath('/local/rcs/XXX/code/pytrace-collector/logs/pypibugs/tried/d3rp+clima/d3rp+clima/foo.cfg')", "cyclomatic_complexity": 3, "code_length": 11, "category": "Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1382, "idx": 159, "code": "def filter_fields(d: dict, nt):\n    \n    res = {}\n    for k, v in d.items():\n        if k in nt._fields:\n            res.update({k: v})\n\n    return res", "input": "{'bar': '42'}, {}", "output": "{'bar': '42'}", "cyclomatic_complexity": 3, "code_length": 6, "category": "Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Non-Empty dictionary", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}}
{"index": 1383, "idx": 160, "code": "def type_correct_with(cdict, cfg_tuple):\n    \n    \n    \n    res = {}\n    for k, v in cdict.items():\n        typename = getattr(cfg_tuple, k)\n        res.update({k: type(typename)(v)})\n    return res", "input": "{'bar': '42'}, {}", "output": "{'bar': 42}", "cyclomatic_complexity": 2, "code_length": 6, "category": "Super Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Non-Empty dictionary", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}}
{"index": 1428, "idx": 161, "code": "def safe_abs_path(res):\n    \"Gives an abs path, which safely returns a full (not 8.3) windows path\"\n    res = Path(res).resolve()\n    return str(res)", "input": "'/tmp/tmpbbwa2p3f'", "output": "'/tmp/tmpbbwa2p3f'", "cyclomatic_complexity": 1, "code_length": 4, "category": "Super Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1442, "idx": 162, "code": "def is_image_file(file_name):\n    \n    file_name = str(file_name)  \n    return any(file_name.endswith(ext) for ext in IMAGE_EXTENSIONS)", "input": "PosixPath('/tmp/tmpcr1f5en7/.gitignore')", "output": "False", "cyclomatic_complexity": 1, "code_length": 3, "category": "Super Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Zero", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"value == 0": "zero", "0 < value <= 10": "Positive Regular", "value > 10": "Positive Large", "-10 <= value < 0": "Negative Regular", "value < -10": "Negative Large"}}
{"index": 1458, "idx": 163, "code": "def mock_get_commit_message(diffs, context):\n                self.assertNotIn(\"one\", diffs)\n                self.assertNotIn(\"ONE\", diffs)\n                return \"commit message\"", "input": "'diff --git a/file.txt b/file.txt\\nindex 5626abf..f719efd 100644\\n--- a/file.txt\\n+++ b/file.txt\\n@@ -1 +1 @@\\n-one\\n+two', None, []", "output": "'commit message'", "cyclomatic_complexity": 1, "code_length": 4, "category": "Super Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1459, "idx": 164, "code": "def do_replace(fname, content, before_text, after_text, fence=None):\n    before_text = strip_quoted_wrapping(before_text, fname, fence)\n    after_text = strip_quoted_wrapping(after_text, fname, fence)\n    fname = Path(fname)\n\n    \n    if not fname.exists() and not before_text.strip():\n        fname.touch()\n        content = \"\"\n\n    if content is None:\n        return\n\n    if not before_text.strip():\n        \n        new_content = content + after_text\n    else:\n        new_content = replace_most_similar_chunk(content, before_text, after_text)\n\n    return new_content", "input": "'/tmp/tmp7g7a2csg/file.txt', 'two\\n', 'two\\n', 'three\\n', ('```', '```')", "output": "'three\\n'", "cyclomatic_complexity": 4, "code_length": 14, "category": "Medium", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1460, "idx": 165, "code": "def strip_quoted_wrapping(res, fname=None, fence=DEFAULT_FENCE):\n    \n    if not res:\n        return res\n\n    res = res.splitlines()\n\n    if fname and res[0].strip().endswith(Path(fname).name):\n        res = res[1:]\n\n    if res[0].startswith(fence[0]) and res[-1].startswith(fence[1]):\n        res = res[1:-1]\n\n    res = \"\\n\".join(res)\n    if res and res[-1] != \"\\n\":\n        res += \"\\n\"\n\n    return res", "input": "'two\\n', '/tmp/tmp7g7a2csg/file.txt', ('```', '```')", "output": "'two\\n'", "cyclomatic_complexity": 5, "code_length": 12, "category": "Medium", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1461, "idx": 166, "code": "def replace_most_similar_chunk(whole, part, replace):\n    \n\n    whole, whole_lines = prep(whole)\n    part, part_lines = prep(part)\n    replace, replace_lines = prep(replace)\n\n    res = perfect_or_whitespace(whole_lines, part_lines, replace_lines)\n    if res:\n        return res\n\n    \n    if len(part_lines) > 2 and not part_lines[0].strip():\n        skip_blank_line_part_lines = part_lines[1:]\n        res = perfect_or_whitespace(whole_lines, skip_blank_line_part_lines, replace_lines)\n        if res:\n            return res\n\n    \n    try:\n        res = try_dotdotdots(whole, part, replace)\n        if res:\n            return res\n    except ValueError:\n        pass\n\n    return\n    \n    res = replace_closest_edit_distance(whole_lines, part, part_lines, replace_lines)\n    if res:\n        return res", "input": "'two\\n', 'two\\n', 'three\\n'", "output": "'three\\n'", "cyclomatic_complexity": 8, "code_length": 22, "category": "Hard", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1462, "idx": 167, "code": "def perfect_or_whitespace(whole_lines, part_lines, replace_lines):\n    \n    res = perfect_replace(whole_lines, part_lines, replace_lines)\n    if res:\n        return res\n\n    \n    res = replace_part_with_missing_leading_whitespace(whole_lines, part_lines, replace_lines)\n    if res:\n        return res", "input": "['two\\n'], ['two\\n'], ['three\\n']", "output": "'three\\n'", "cyclomatic_complexity": 3, "code_length": 7, "category": "Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1463, "idx": 168, "code": "def perfect_replace(whole_lines, part_lines, replace_lines):\n    part_tup = tuple(part_lines)\n    part_len = len(part_lines)\n\n    for i in range(len(whole_lines) - part_len + 1):\n        whole_tup = tuple(whole_lines[i : i + part_len])\n        if part_tup == whole_tup:\n            res = whole_lines[:i] + replace_lines + whole_lines[i + part_len :]\n            return \"\".join(res)", "input": "['two\\n'], ['two\\n'], ['three\\n']", "output": "'three\\n'", "cyclomatic_complexity": 3, "code_length": 8, "category": "Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1469, "idx": 169, "code": "def parse_quoted_filenames(args):\n    filenames = re.findall(r\"\\\"(.+?)\\\"|(\\S+)\", args)\n    filenames = [name for sublist in filenames for name in sublist if name]\n    return filenames", "input": "'foo.txt bar.txt'", "output": "['foo.txt', 'bar.txt']", "cyclomatic_complexity": 1, "code_length": 4, "category": "Super Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Non-Empty List", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty List", "len(value) > 0": "Non-Empty List"}}
{"index": 1473, "idx": 170, "code": "def replace_part_with_missing_leading_whitespace(whole_lines, part_lines, replace_lines):\n    \n    \n    \n\n    \n    leading = [len(p) - len(p.lstrip()) for p in part_lines if p.strip()] + [\n        len(p) - len(p.lstrip()) for p in replace_lines if p.strip()\n    ]\n\n    if leading and min(leading):\n        num_leading = min(leading)\n        part_lines = [p[num_leading:] if p.strip() else p for p in part_lines]\n        replace_lines = [p[num_leading:] if p.strip() else p for p in replace_lines]\n\n    \n    num_part_lines = len(part_lines)\n\n    for i in range(len(whole_lines) - num_part_lines + 1):\n        add_leading = match_but_for_leading_whitespace(\n            whole_lines[i : i + num_part_lines], part_lines\n        )\n\n        if add_leading is None:\n            continue\n\n        replace_lines = [add_leading + rline if rline.strip() else rline for rline in replace_lines]\n        whole_lines = whole_lines[:i] + replace_lines + whole_lines[i + num_part_lines :]\n        return \"\".join(whole_lines)\n\n    return None", "input": "['    line1\\n', '    line2\\n', '    line3\\n'], [' line1\\n', ' line2\\n'], [' new_line1\\n', '     new_line2\\n']", "output": "'    new_line1\\n        new_line2\\n    line3\\n'", "cyclomatic_complexity": 4, "code_length": 19, "category": "Medium", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1474, "idx": 171, "code": "def match_but_for_leading_whitespace(whole_lines, part_lines):\n    num = len(whole_lines)\n\n    \n    if not all(whole_lines[i].lstrip() == part_lines[i].lstrip() for i in range(num)):\n        return\n\n    \n    add = set(\n        whole_lines[i][: len(whole_lines[i]) - len(part_lines[i])]\n        for i in range(num)\n        if whole_lines[i].strip()\n    )\n\n    if len(add) != 1:\n        return\n\n    return add.pop()", "input": "['    line1\\n', '    line2\\n'], ['line1\\n', 'line2\\n']", "output": "'    '", "cyclomatic_complexity": 3, "code_length": 12, "category": "Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1481, "idx": 172, "code": "def find_diffs(content):\n    \n    \n\n    if not content.endswith(\"\\n\"):\n        content = content + \"\\n\"\n\n    lines = content.splitlines(keepends=True)\n    line_num = 0\n    edits = []\n    while line_num < len(lines):\n        while line_num < len(lines):\n            line = lines[line_num]\n            if line.startswith(\"```diff\"):\n                line_num, these_edits = process_fenced_block(lines, line_num + 1)\n                edits += these_edits\n                break\n            line_num += 1\n\n    \n    \n\n    return edits", "input": "'\\nSome text...\\n\\n```diff\\n--- /dev/null\\n+++ file.txt\\n@@ ... @@\\n-Original\\n+Modified\\n```\\n'", "output": "[('file.txt', ['-Original\\n', '+Modified\\n'])]", "cyclomatic_complexity": 5, "code_length": 15, "category": "Medium", "quantized_value_input": "Mixed String", "quantized_value_output": "Non-Empty List", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty List", "len(value) > 0": "Non-Empty List"}}
{"index": 1482, "idx": 173, "code": "def process_fenced_block(lines, start_line_num):\n    for line_num in range(start_line_num, len(lines)):\n        line = lines[line_num]\n        if line.startswith(\"```\"):\n            break\n\n    block = lines[start_line_num:line_num]\n    block.append(\"@@ @@\")\n\n    if block[0].startswith(\"--- \") and block[1].startswith(\"+++ \"):\n        \n        fname = block[1][4:].strip()\n        block = block[2:]\n    else:\n        fname = None\n\n    edits = []\n\n    keeper = False\n    hunk = []\n    op = \" \"\n    for line in block:\n        hunk.append(line)\n        if len(line) < 2:\n            continue\n\n        if line.startswith(\"+++ \") and hunk[-2].startswith(\"--- \"):\n            if hunk[-3] == \"\\n\":\n                hunk = hunk[:-3]\n            else:\n                hunk = hunk[:-2]\n\n            edits.append((fname, hunk))\n            hunk = []\n            keeper = False\n\n            fname = line[4:].strip()\n            continue\n\n        op = line[0]\n        if op in \"-+\":\n            keeper = True\n            continue\n        if op != \"@\":\n            continue\n        if not keeper:\n            hunk = []\n            continue\n\n        hunk = hunk[:-1]\n        edits.append((fname, hunk))\n        hunk = []\n        keeper = False\n\n    return line_num + 1, edits", "input": "['\\n', 'Some text...\\n', '\\n', '```diff\\n', '--- /dev/null\\n', '+++ file.txt\\n', '@@ ... @@\\n', '-Original\\n', '+Modified\\n', '```\\n'], 4", "output": "(10, [('file.txt', ['-Original\\n', '+Modified\\n'])])", "cyclomatic_complexity": 11, "code_length": 44, "category": "Hard", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Non-Empty tuple", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}}
{"index": 1525, "idx": 174, "code": "def _addpoints(sol, distances, prec):\n    \n    res = []\n\n    posfound = False\n\n    \n    pleft = []\n    for n, m in enumerate(sol):\n        if np.ndim(m) == 0:\n            pleft.append(n)\n\n    \n    for i in pleft:\n        ires, state = _addpoint(sol, i, distances, prec)\n\n        \n        if state == 0:\n            posfound = True\n            for j in ires:\n                res.append(dcopy(j))\n        \n        elif state == 2:\n            return [], 2\n\n    \n    if posfound:\n        return res, 0\n\n    return res, 1", "input": "[array([0., 0.]), array([3., 0.]), 0, 0], array([[ 0.,  3.,  4.,  1.],       [ 3.,  0.,  2.,  3.],       [ 4.,  2.,  0., -1.],       [ 1.,  3., -1.,  0.]]), 0.1", "output": "([[array([0., 0.]), array([3., 0.]), array([3.5       , 1.93649167]), 0], [array([0., 0.]), array([3., 0.]), array([ 3.5       , -1.93649167]), 0], [array([0., 0.]), array([3., 0.]), 0, array([0.16666667, 0.9860133 ])], [array([0., 0.]), array([3., 0.]), 0, array([ 0.16666667, -0.9860133 ])]], 0)", "cyclomatic_complexity": 8, "code_length": 18, "category": "Hard", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1526, "idx": 175, "code": "def _addpoint(sol, i, distances, prec):\n    \n    res = []\n\n    \n    if np.ndim(sol[i]) != 0:\n        return [sol], 0\n\n    \n    solpnts = []\n    for n, m in enumerate(sol):\n        if np.ndim(m) != 0:\n            solpnts.append(n)\n\n    \n    pntscount = len(solpnts)\n\n    \n    for n in range(pntscount - 1):\n        for m in range(n + 1, pntscount):\n            tmppnt, state = _pntcoord(\n                sol, i, solpnts[n], solpnts[m], distances, prec\n            )\n\n            \n            if state == 0:\n                for pnt in tmppnt:\n                    res.append(dcopy(sol))\n                    res[-1][i] = pnt\n\n            \n            if state != 1:\n                return res, state\n\n    \n    return res, state", "input": "[array([0., 0.]), array([3., 0.]), 0, 0], 2, array([[ 0.,  3.,  4.,  1.],       [ 3.,  0.,  2.,  3.],       [ 4.,  2.,  0., -1.],       [ 1.,  3., -1.,  0.]]), 0.1", "output": "([[array([0., 0.]), array([3., 0.]), array([3.5       , 1.93649167]), 0], [array([0., 0.]), array([3., 0.]), array([ 3.5       , -1.93649167]), 0]], 0)", "cyclomatic_complexity": 9, "code_length": 21, "category": "Hard", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1527, "idx": 176, "code": "def _pntcoord(sol, i, n, m, distances, prec):\n    \n    tmppnt = []\n\n    state = 1\n\n    pntscount = len(sol)\n\n    \n    if distances[i, n] < -0.5 or distances[i, m] < -0.5:\n        return tmppnt, state\n\n    \n    if distances[i, n] + distances[i, m] < _dist(sol[n], sol[m]):\n        state = 2\n        return tmppnt, state\n\n    \n    g = _affinef(*_invtranmat(*_tranmat(sol[n], sol[m])))\n\n    \n    x = _xvalue(distances[i, n], distances[i, m], _dist(sol[n], sol[m]))\n    y1, y2 = _yvalue(distances[i, n], distances[i, m], _dist(sol[n], sol[m]))\n\n    \n    pos1 = g(np.array([x, y1]))\n    pos2 = g(np.array([x, y2]))\n\n    valid1 = True\n    valid2 = True\n\n    \n    for k in range(pntscount):\n        if np.ndim(sol[k]) != 0 and distances[i, k] > -0.5:\n            valid1 &= abs(_dist(sol[k], pos1) - distances[i, k]) < prec\n            valid2 &= abs(_dist(sol[k], pos2) - distances[i, k]) < prec\n\n    \n    if valid1 or valid2:\n        state = 0\n        same = abs(y1 - y2) < prec / 4.0\n        if valid1:\n            tmppnt.append(dcopy(pos1))\n        if valid2 and not same:\n            tmppnt.append(dcopy(pos2))\n    \n    else:\n        state = 2\n\n    return tmppnt, state", "input": "[array([0., 0.]), array([3., 0.]), 0, 0], 2, 0, 1, array([[ 0.,  3.,  4.,  1.],       [ 3.,  0.,  2.,  3.],       [ 4.,  2.,  0., -1.],       [ 1.,  3., -1.,  0.]]), 0.1", "output": "([array([3.5       , 1.93649167]), array([ 3.5       , -1.93649167])], 0)", "cyclomatic_complexity": 8, "code_length": 30, "category": "Hard", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1528, "idx": 177, "code": "def _tranmat(a, b):\n    \n    A = np.zeros((2, 2))\n    A[0, 0] = b[0] - a[0]\n    A[1, 1] = b[0] - a[0]\n    A[1, 0] = -(b[1] - a[1])\n    A[0, 1] = +(b[1] - a[1])\n    A /= _dist(a, b)\n    s = -np.dot(A, a)\n    return A, s", "input": "array([0., 0.]), array([3., 0.])", "output": "(array([[ 1.,  0.],       [-0.,  1.]]), array([-0., -0.]))", "cyclomatic_complexity": 1, "code_length": 9, "category": "Super Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1529, "idx": 178, "code": "def _yvalue(b, a, c):\n    \n    \n    if a + b <= c or a + c <= b or b + c <= a:\n        return 0.0, -0.0\n\n    res = 2 * ((a * b) ** 2 + (a * c) ** 2 + (b * c) ** 2)\n    res -= a ** 4 + b ** 4 + c ** 4\n    \n    res = max(res, 0.0)\n    res = np.sqrt(res)\n    res /= 2 * c\n    return res, -res", "input": "4.0, 2.0, 3.0", "output": "(1.9364916731037083, -1.9364916731037083)", "cyclomatic_complexity": 2, "code_length": 9, "category": "Super Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Non-Empty tuple", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}}
{"index": 1530, "idx": 179, "code": "def _solequal(sol1, sol2, prec):\n    \n    res = True\n\n    for sol_1, sol_2 in zip(sol1, sol2):\n        if np.ndim(sol_1) != 0 and np.ndim(sol_2) != 0:\n            res &= _dist(sol_1, sol_2) < prec\n        elif np.ndim(sol_1) != 0 and np.ndim(sol_2) == 0:\n            return False\n        elif np.ndim(sol_1) == 0 and np.ndim(sol_2) != 0:\n            return False\n\n    return res", "input": "[array([0., 0.]), array([3., 0.]), array([3.5       , 1.93649167]), array([ 0.16666667, -0.9860133 ])], [array([0., 0.]), array([3., 0.]), array([3.5       , 1.93649167]), array([0.16666667, 0.9860133 ])], 0.1", "output": "False", "cyclomatic_complexity": 5, "code_length": 10, "category": "Medium", "quantized_value_input": "Mixed String", "quantized_value_output": "Zero", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"value == 0": "zero", "0 < value <= 10": "Positive Regular", "value > 10": "Positive Large", "-10 <= value < 0": "Negative Regular", "value < -10": "Negative Large"}}
{"index": 1535, "idx": 180, "code": "def _process_namespace(name, namespaces, ns_sep=':', attr_prefix='@'):\n    if not namespaces:\n        return name\n    try:\n        ns, name = name.rsplit(ns_sep, 1)\n    except ValueError:\n        pass\n    else:\n        ns_res = namespaces.get(ns.strip(attr_prefix))\n        name = '{}{}{}{}'.format(\n            attr_prefix if ns.startswith(attr_prefix) else '',\n            ns_res, ns_sep, name) if ns_res else name\n    return name", "input": "'http://defaultns.com/:root', {'http://defaultns.com/': '', 'http://a.com/': 'a', 'http://b.com/': 'b'}, ':', '@'", "output": "'root'", "cyclomatic_complexity": 4, "code_length": 13, "category": "Medium", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Alphabetic String", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1545, "idx": 181, "code": "def check_data(a, b):\n    if not isinstance(a, np.ndarray):\n        a = np.array(a)\n\n    if not isinstance(b, np.ndarray):\n        b = np.array(b)\n\n    if type(a) != type(b):\n        raise ValueError(\"Type mismatch: %s and %s\" % (type(a), type(b)))\n\n    if a.size != b.size:\n        raise ValueError(\"Arrays must be equal in length.\")\n    return a, b", "input": "[1, 2, 3], [3, 2, 1]", "output": "(array([1, 2, 3]), array([3, 2, 1]))", "cyclomatic_complexity": 5, "code_length": 10, "category": "Medium", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1548, "idx": 182, "code": "def logloss(actual, predicted):\n    predicted = np.clip(predicted, EPS, 1 - EPS)\n    loss = -np.sum(actual * np.log(predicted))\n    return loss / float(actual.shape[0])", "input": "array([1]), array([1])", "output": "9.992007221626415e-16", "cyclomatic_complexity": 1, "code_length": 4, "category": "Super Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Positive Small", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"value == 0.0": "zero", "0.0 < value <= 1.0": "Positive Small", "1.0 < value <= 10.0": "Positive Regular", "value > 10.0": "Positive Large", "-1.0 <= value < 0.0": "Negative Small", "-10.0 <= value < -1.0": "Negative Regular", "value < -10.0": "Negative Large"}}
{"index": 1549, "idx": 183, "code": "def clasifier(optimizer):\n    X, y = make_classification(\n        n_samples=1000, n_features=100, n_informative=75, random_state=1111, n_classes=2, class_sep=2.5\n    )\n    y = one_hot(y)\n\n    X -= np.mean(X, axis=0)\n    X /= np.std(X, axis=0)\n    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.15, random_state=1111)\n\n    model = NeuralNet(\n        layers=[\n            Dense(128, Parameters(init=\"uniform\")),\n            Activation(\"relu\"),\n            Dropout(0.5),\n            Dense(64, Parameters(init=\"normal\")),\n            Activation(\"relu\"),\n            Dense(2),\n            Activation(\"softmax\"),\n        ],\n        loss=\"categorical_crossentropy\",\n        optimizer=optimizer,\n        metric=\"accuracy\",\n        batch_size=64,\n        max_epochs=10,\n    )\n    model.fit(X_train, y_train)\n    predictions = model.predict(X_test)\n    return roc_auc_score(y_test[:, 0], predictions[:, 0])", "input": "{rho=0.95, eps=1e-08, lr=1.0}", "output": "0.92549786628734", "cyclomatic_complexity": 1, "code_length": 27, "category": "Super Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Positive Small", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"value == 0.0": "zero", "0.0 < value <= 1.0": "Positive Small", "1.0 < value <= 10.0": "Positive Regular", "value > 10.0": "Positive Large", "-1.0 <= value < 0.0": "Negative Small", "-10.0 <= value < -1.0": "Negative Regular", "value < -10.0": "Negative Large"}}
{"index": 1567, "idx": 184, "code": "def str2datetime(string):\n    \n\n    if string == \"0000-00-00T24:60:60Z\":\n        return None\n\n    ms = string[20:-1]\n    ms += \"000000\"[:6 - len(ms)]\n    return datetime.datetime(\n        int(string[:4]),\n        int(string[5:7]),\n        int(string[8:10]),\n        int(string[11:13]),\n        int(string[14:16]),\n        int(string[17:19]),\n        int(ms))", "input": "'1970-01-01T00:00:00.0Z'", "output": "datetime.datetime(1970, 1, 1, 0, 0)", "cyclomatic_complexity": 2, "code_length": 13, "category": "Super Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1568, "idx": 185, "code": "def flatten(d, parent_key=\"\", sep=\"/\") -> Dict[str, Any]:\n    \n    items: List[Tuple[str, List[str]]] = []\n    for k, v in d.items():\n        new_key = parent_key + sep + k if parent_key else k\n        if isinstance(v, MutableMapping):\n            items.extend(flatten(v, new_key, sep=sep).items())\n        else:\n            items.append((new_key, v))\n    return dict(items)", "input": "{'aprtoapy': [], 'il': []}, 'crypto/tools', '/'", "output": "{'crypto/tools/aprtoapy': [], 'crypto/tools/il': []}", "cyclomatic_complexity": 3, "code_length": 9, "category": "Easy", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Non-Empty dictionary", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}}
{"index": 1578, "idx": 186, "code": "def load_json_dict(filename, *args):\n    \n    data = {}\n    if os.path.exists(filename):\n        lock.acquire()\n        with open(filename, \"r\") as f:\n            try:\n                data = _json.load(f)\n                if not isinstance(data, dict):\n                    data = {}\n            except:\n                data = {}  \n        lock.release()\n        if args:\n            return {key: data[key] for key in args if key in data}\n    return data", "input": "'/home/XXX/.plotly/.config', ()", "output": "{'plotly_domain': 'https://plot.ly', 'plotly_streaming_domain': 'stream.plot.ly', 'plotly_api_domain': 'https://api.plot.ly', 'plotly_ssl_verification': True, 'plotly_proxy_authorization': False, 'world_readable': True, 'sharing': 'public', 'auto_open': True}", "cyclomatic_complexity": 6, "code_length": 15, "category": "Hard", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Non-Empty dictionary", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}}
{"index": 1598, "idx": 187, "code": "def export_data(self) -> typing.Dict[str, dict]:\n        \n\n        nested_ip_objects = dict()\n\n        if self.__children_ip_object and None in self.__children_ip_object:\n            children_per_version = dict()\n            for child in self.__children_ip_object[None]:\n                version_set = children_per_version.setdefault(\n                    child.version, set()\n                )\n                version_set.add(child)\n\n            for version in children_per_version:\n                version_nest = nested_ip_objects.setdefault(version, dict())\n                for child in children_per_version[version]:\n                    version_nest[child] = self.__gather_nested_children(child)\n\n        return dict({\n            \"description\": dict(self.__description),\n            \"nested_ip_objects\": nested_ip_objects,\n        })", "input": "AddressSpace(_AddressSpace__strict=True, _AddressSpace__description={}, _AddressSpace__networks={}, _AddressSpace__addresses={}, _AddressSpace__parent_supernet={}, _AddressSpace__children_ip_object={None: set()}), {}, {None: set()}, {}, {}, {}, True", "output": "{'description': {}, 'nested_ip_objects': {}}", "cyclomatic_complexity": 5, "code_length": 17, "category": "Medium", "quantized_value_input": "Mixed String", "quantized_value_output": "Non-Empty dictionary", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}}
{"index": 1605, "idx": 188, "code": "def get_idx(ndim, axis=None, axis_idx=None):\n    s = [midx] * ndim\n    if axis is not None:\n        if hasattr(axis, \"__iter__\"):\n            for ax, axidx in zip(axis, axis_idx):\n                s[ax] = axidx\n        else:\n            s[axis] = axis_idx\n    return tuple(s)", "input": "1, 0, slice(None, -2, None)", "output": "(slice(None, -2, None),)", "cyclomatic_complexity": 4, "code_length": 9, "category": "Medium", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1607, "idx": 189, "code": "def det_hess(u):\n    \n    ndim = np.ndim(u)\n    inshape = np.asarray(u.shape)\n    outshape = list(inshape - 2)\n\n    \n    hess_unarranged = np.zeros([ndim, ndim] + outshape)\n    for i in range(ndim):\n        for j in range(i,ndim):\n            grad2_val = grad2(u, (i,j))\n            hess_unarranged[i,j] = grad2_val\n            hess_unarranged[j,i] = grad2_val\n\n    \n    perm_idx = list(range(2,ndim+2)) + list(range(2))\n    hess = np.transpose(hess_unarranged, perm_idx)\n\n    \n    return np.linalg.det(hess)", "input": "array([  0.,   1.,   4.,   9.,  16.,  25.,  36.,  49.,  64.,  81., 100.,       121., 144., 169., 196., 225., 256., 289., 324., 361., 400., 441.,       484., 529., 576., 625., 676., 729., 784., 841., 900., 961.])", "output": "array([2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2.,       2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2.])", "cyclomatic_complexity": 3, "code_length": 13, "category": "Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1609, "idx": 190, "code": "def _get_default_expanded_coordinate(shape, ndim):\n    x_coords = []\n    for i in range(ndim):\n        idx = [None] * ndim\n        idx[i] = slice(None, None, None)\n        x_coords.append(np.arange(shape[i])[tuple(idx)])\n    return x_coords", "input": "array([92]), 1", "output": "[array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,       17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33,       34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,       51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67,       68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84,       85, 86, 87, 88, 89, 90, 91])]", "cyclomatic_complexity": 2, "code_length": 7, "category": "Super Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1610, "idx": 191, "code": "def _pad_conserve_grads(phi):\n    \n    ndim = np.ndim(phi)\n    pw = [1, 1]\n    pp = np.pad(phi, [tuple(pw)]*ndim, mode=\"constant\")\n    for dim in range(ndim):\n        \n        idx_pad0_l = _get_idx(ndim, dim, slice(pw[0], pw[0]+1, None))\n        idx_pad0_r = _get_idx(ndim, dim, slice(pw[0]+1, pw[0]+2, None))\n        idx_pad0 = _get_idx(ndim, dim, slice(pw[0], pw[0]+1, None))\n        idx_pad0_fill = _get_idx(ndim, dim, slice(None, pw[0], None))\n        idx_pad1_l = _get_idx(ndim, dim, slice(-pw[1]-2, -pw[1]-1, None))\n        idx_pad1_r = _get_idx(ndim, dim, slice(-pw[1]-1, -pw[1], None))\n        idx_pad1 = _get_idx(ndim, dim, slice(-pw[1]-1, -pw[1], None))\n        idx_pad1_fill = _get_idx(ndim, dim, slice(-pw[1], None, None))\n\n        \n        grad0 = pp[idx_pad0_r] - pp[idx_pad0_l] \n        grad1 = pp[idx_pad1_r] - pp[idx_pad1_l]\n        pad_arange0 = np.arange(-pw[0],0) \n        pad_arange1 = np.arange(1,pw[0]+1)\n        pad0 = pad_arange0 * grad0 + pp[idx_pad0] \n        pad1 = pad_arange1 * grad1 + pp[idx_pad1]\n        pp[idx_pad0_fill] = pad0\n        pp[idx_pad1_fill] = pad1\n\n    return pp", "input": "array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])", "output": "array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])", "cyclomatic_complexity": 2, "code_length": 22, "category": "Super Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1611, "idx": 192, "code": "def _get_idx(ndim, dim, s, defidx=None):\n    defidx = slice(None, None, None) if defidx is None else defidx\n    idx = [defidx] * ndim\n    idx[dim] = s\n    return tuple(idx)", "input": "1, 0, slice(1, 2, None), None", "output": "(slice(1, 2, None),)", "cyclomatic_complexity": 1, "code_length": 5, "category": "Super Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1619, "idx": 193, "code": "def _makeComplementTable(complementData):\n        \n        table = list(range(256))\n        for _from, to in complementData.items():\n            table[ord(_from[0].lower())] = ord(to[0].lower())\n            table[ord(_from[0].upper())] = ord(to[0].upper())\n        return ''.join(map(chr, table))", "input": "{'A': 'T', 'C': 'G', 'G': 'C', 'T': 'A', 'M': 'K', 'R': 'Y', 'W': 'W', 'S': 'S', 'Y': 'R', 'K': 'M', 'V': 'B', 'H': 'D', 'D': 'H', 'B': 'V', 'X': 'X', 'N': 'N'}", "output": "'\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\t\\n\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f !\"#$%&\\'()*+,-./0123456789:;<=>?@TVGHEFCDIJMLKNOPQYSAUBWXRZ[\\\\]^_`tvghefcdijmlknopqysaubwxrz{|}~\\x7f\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\\xad'", "cyclomatic_complexity": 2, "code_length": 6, "category": "Super Easy", "quantized_value_input": "Non-Empty dictionary", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty dictionary", "len(value) > 0": "Non-Empty dictionary"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1664, "idx": 194, "code": "def find_extension(codec):\n    \n    if codec in extensions_dict:\n        \n        return codec\n\n    for ext, infos in extensions_dict.items():\n        if codec in infos.get(\"codec\", []):\n            return ext\n    raise ValueError(\n        \"The audio_codec you chose is unknown by MoviePy. \"\n        \"You should report this. In the meantime, you can \"\n        \"specify a temp_audiofile with the right extension \"\n        \"in write_videofile.\"\n    )", "input": "'libmp3lame'", "output": "'mp3'", "cyclomatic_complexity": 4, "code_length": 12, "category": "Medium", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1683, "idx": 195, "code": "def version_compare(v1, v2):\n    \n\n    arr1 = v1.split(\".\")\n    arr2 = v2.split(\".\")\n    n = len(arr1)\n    m = len(arr2)\n\n    \n    arr1 = [int(i) for i in arr1]\n    arr2 = [int(i) for i in arr2]\n\n    \n    \n    if n > m:\n        for i in range(m, n):\n            arr2.append(0)\n    elif m > n:\n        for i in range(n, m):\n            arr1.append(0)\n\n    \n    \n    for i in range(len(arr1)):\n        if arr1[i] > arr2[i]:\n            return 1\n        elif arr2[i] > arr1[i]:\n            return -1\n    return 0", "input": "'3.8.18', '3.8.27'", "output": "-1", "cyclomatic_complexity": 8, "code_length": 19, "category": "Hard", "quantized_value_input": "Non-Empty tuple", "quantized_value_output": "Negative Regular", "input_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}, "output_mapping_info": {"value == 0": "zero", "0 < value <= 10": "Positive Regular", "value > 10": "Positive Large", "-10 <= value < 0": "Negative Regular", "value < -10": "Negative Large"}}
{"index": 1684, "idx": 196, "code": "def parse_access_method(access_method: str):\n    num_workers = 0\n    scheduler = \"threaded\"\n    download = access_method.startswith(\"download\")\n    local = access_method.startswith(\"local\")\n    if download or local:\n        split = access_method.split(\":\")\n        if len(split) == 1:\n            split.extend((\"threaded\", \"0\"))\n        elif len(split) == 2:\n            split.append(\"threaded\" if split[1].isnumeric() else \"0\")\n        elif len(split) >= 3:\n            num_integers = sum(1 for i in split if i.isnumeric())\n            if num_integers != 1 or len(split) > 3:\n                raise ValueError(\n                    \"Invalid access_method format. Expected format is one of the following: {download, download:scheduler, download:num_workers, download:scheduler:num_workers, download:num_workers:scheduler}\"\n                )\n\n        access_method = \"download\" if download else \"local\"\n        num_worker_index = 1 if split[1].isnumeric() else 2\n        scheduler_index = 3 - num_worker_index\n        num_workers = int(split[num_worker_index])\n        scheduler = split[scheduler_index]\n    return access_method, num_workers, scheduler", "input": "'download'", "output": "('download', 0, 'threaded')", "cyclomatic_complexity": 6, "code_length": 23, "category": "Hard", "quantized_value_input": "Alphabetic String", "quantized_value_output": "Non-Empty tuple", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty tuple", "len(value) > 0": "Non-Empty tuple"}}
{"index": 1711, "idx": 197, "code": "def write_shape_info(shape_info, buffer, offset) -> int:\n    \n    if shape_info.ndim == 1:\n        offset += 8\n    else:\n        buffer[offset : offset + 8] = struct.pack(\"<ii\", *shape_info.shape)\n        offset += 8\n\n        buffer[offset : offset + shape_info.nbytes] = shape_info.tobytes()\n        offset += shape_info.nbytes\n    return offset", "input": "array([[2, 3]], dtype=uint32), bytearray(b'\\x063.8.18\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'), 7", "output": "23", "cyclomatic_complexity": 2, "code_length": 9, "category": "Super Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Positive Large", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"value == 0": "zero", "0 < value <= 10": "Positive Regular", "value > 10": "Positive Large", "-10 <= value < 0": "Negative Regular", "value < -10": "Negative Large"}}
{"index": 1715, "idx": 198, "code": "def _get_new_player_rack_list(self, num_players):\n        player_rack_list = []\n\n        for _ in range(num_players):\n            this_rack = []\n            for _ in range(config.PLAYER_RACK_SIZE):\n                this_tile = self._draw_random_tile()\n                this_rack.append(this_tile)\n\n            player_rack_list.append(this_rack)\n\n        return player_rack_list", "input": "REPR FAILED, 4, [*, *, A, A, A, A, A, A, A, A, A, B, B, C, C, D, D, D, D, E, E, E, E, E, E, E, E, E, E, E, E, F, F, G, G, G, H, H, I, I, I, I, I, I, I, I, I, J, K, L, L, L, L, M, M, N, N, N, N, N, N, O, O, O, O, O, O, O, O, P, P, Q, R, R, R, R, R, R, S, S, S, S, T, T, T, T, T, T, U, U, U, U, V, V, W, W, X, Y, Y, Z]", "output": "[[U, A, E, F, K, H, V], [U, N, E, I, N, C, I], [B, H, T, Q, O, D, T], [A, R, B, O, O, N, I]]", "cyclomatic_complexity": 3, "code_length": 9, "category": "Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Mixed String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
{"index": 1716, "idx": 199, "code": "def _draw_random_tile(self):\n        random_index = random.randrange(0, len(self.tile_bag))\n        selected_tile = self.tile_bag.pop(random_index)\n\n        return selected_tile", "input": "REPR FAILED, [*, *, A, A, A, A, A, A, A, A, A, B, B, C, C, D, D, D, D, E, E, E, E, E, E, E, E, E, E, E, E, F, F, G, G, G, H, H, I, I, I, I, I, I, I, I, I, J, K, L, L, L, L, M, M, N, N, N, N, N, N, O, O, O, O, O, O, O, O, P, P, Q, R, R, R, R, R, R, S, S, S, S, T, T, T, T, T, T, U, U, U, U, V, V, W, W, X, Y, Y, Z]", "output": "U", "cyclomatic_complexity": 1, "code_length": 4, "category": "Super Easy", "quantized_value_input": "Mixed String", "quantized_value_output": "Alphabetic String", "input_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}, "output_mapping_info": {"len(value) == 0": "Empty String", "len(value) > 0 and value.isalpha()": "Alphabetic String", "len(value) > 0 and value.isdigit()": "Numeric String", "len(value) > 0 and not (value.isalpha() or value.isdigit())": "Mixed String"}}
